<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Rust】Rustup 介绍</title>
    <url>/2022/06/30/%E3%80%90Rust%E3%80%91Rustup%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>学习 <code>rust</code> 的第一步当然是安装，在 <code>rust</code> 中，工具链的安装，升级版本切换都是由 <code>rustup</code> 来完成的。<code>rust</code> 的工具链分布在三个不同的 <code>channel</code> ：<code>stable</code>，<code>beta</code> 和 <code>nightly</code>。</p>
<p>可以将 <code>rustup</code> 看做 <code>rust</code> 的版本管理器，方便我们在不同的 <code>channel</code> 之间进行切换。 在国内 <code>rust</code> 的相关网站是没有被 <code>GFW</code> 屏蔽的，但是访问速度还是很慢。好在国内有很多镜像源，例如，我这里使用的是中国科学技术大学的镜像，配置的话只需要添加两个环境变量：</p>
<ul>
<li><code>export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</code></li>
<li><code>export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</code></li>
</ul>
<p><code>rustup</code> 的安装我们依然使用官方的方式：</p>
<blockquote>
<p>curl –proto ‘&#x3D;https’ –tlsv1.2 -sSf <a href="https://sh.rustup.rs/">https://sh.rustup.rs</a> | sh</p>
</blockquote>
<p>执行结束之后，应该能看到下面这样的信息，而且会默认安装 <code>nightly</code>（每日构建）版本：</p>
<img data-src="/2022/06/30/%E3%80%90Rust%E3%80%91Rustup%20%E4%BB%8B%E7%BB%8D/install-success.png" class="">

<p>我们可以顺手配置以下 <code>cargo</code> 的镜像地址，参考自 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates/">中科大 <code>Rust Crates</code> 镜像使用帮助</a></p>
<figure class="highlight yaml"><figcaption><span>~/.cargo/config</span></figcaption><table><tr><td class="code"><pre><span class="line">[<span class="string">source.crates-io</span>]</span><br><span class="line"><span class="string">registry</span> <span class="string">=</span> <span class="string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span></span><br><span class="line"><span class="string">replace-with</span> <span class="string">=</span> <span class="string">&#x27;ustc&#x27;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">source.ustc</span>]</span><br><span class="line"><span class="string">registry</span> <span class="string">=</span> <span class="string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span></span><br></pre></td></tr></table></figure>

<p>也推荐的字节跳动的 <code>Rustup</code> 镜像和 <code>crates.io</code> 镜像，具体请看 <a href="https://rsproxy.cn/"><code>https://rsproxy.cn/</code></a>。</p>
<span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>rustup</code> 就是 <code>rust</code> 的包管理器，安装和管理 rust 的工具链，安装目录是：<code>~/.cargo/bin</code>。安装在 <code>~/.cargo/bin</code> 中的 <code>rustc</code> 和 <code>cargo</code> 可执行文件其实是真实文件的代理，真正的文件在 <code>~/.rustup/toolchains/</code> 目录下，<code>rustup</code> 提供了在各个不同 <code>channel</code> 之间切换的能力。</p>
<p>关于 <code>rustup</code> 有很多术语，<code>channel</code>，<code>toolchain</code>，<code>target</code>，<code>component</code> 和 <code>profile</code>，它们的关系可以用下面的图表示：</p>
<img data-src="/2022/06/30/%E3%80%90Rust%E3%80%91Rustup%20%E4%BB%8B%E7%BB%8D/rust.png" class="">

<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p><code>rust</code> 有三个不同的 <code>channel</code> 来发布版本：<code>stable</code>，<code>beta</code> 和 <code>nightly</code>。<code>stable</code> 和 <code>beta</code> 每六周发布一次， <code>beta</code> 就是下一个稳定版本，<code>nightly</code> 就是日版本。<code>rustup</code> 用于保持版本最新，并在它们之间轻松切换，当前版本信息请看 <a href="https://forge.rust-lang.org/">Rust Forge</a>，发布模型请看 <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#stability-without-stagnation">Appendix G - How Rust is Made and “Nightly Rust”</a>。</p>
<p>我们经常使用 <code>stable</code> 作为我们的开发版本，但是 <code>nightly</code> 提供了提供了很多<a href="https://doc.rust-lang.org/unstable-book/">实验性的功能</a>。切换 <code>nightly</code> 非常方便：</p>
<ul>
<li>安装：<code>rustup toolchain install nightly</code></li>
<li>测试：<code>rustup run nightly rustc --version</code></li>
<li>默认：<code>rustup default nightly</code></li>
<li>更新：<code> rustup update</code></li>
</ul>
<h4 id="Toolchain"><a href="#Toolchain" class="headerlink" title="Toolchain"></a>Toolchain</h4><p><code>rustup</code> 能够安装和处理不同的工具链，官方发布渠道最基本的跟踪：<code>stable</code>、<code>beta</code> 和 <code>nightly</code>；但是 <code>rustup</code> 也可以从官方存档、备用主机平台和本地构建中安装工具链。标准发布通道工具链名称具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;channel&gt;[-&lt;date&gt;][-&lt;host&gt;]</span><br><span class="line"></span><br><span class="line">&lt;channel&gt;       = stable|beta|nightly|&lt;major.minor&gt;|&lt;major.minor.patch&gt;</span><br><span class="line">&lt;date&gt;          = YYYY-MM-DD</span><br><span class="line">&lt;host&gt;          = &lt;target-triple&gt;</span><br></pre></td></tr></table></figure>

<p><code>channel</code> 是发布通道的名称，可以在后年跟上主次版本号，例如 <code>1.42</code> 或者 <code>1.42.0</code>，紧接着在后面可以跟一个发布日期，例如：<code>nightly-2014-12-18</code>。最后的是最主要的，需要填写安装目标机器的相关信息，例如：<code>stable-x86_64-pc-windows-msvc</code>。</p>
<blockquote>
<p>rustup toolchain install stable-x86_64-pc-windows-msvc</p>
</blockquote>
<p>出去方便考虑，某些编译信息可省略：</p>
<blockquote>
<p>rustup toolchain install stable-msvc</p>
</blockquote>
<p>对于开发者或者发烧友，可能会自己为 <code>rust</code> 增加新功能编译，那么可以编译自定义工具链，例如，克隆 <code>rust-lang/rust</code> 代码到 <code>~/rust</code>，然后构建:</p>
<blockquote>
<p>rustup toolchain link myrust ~&#x2F;rust&#x2F;build&#x2F;x86_64-unknown-linux-gnu&#x2F;stage2&#x2F;<br>rustup default myrust</p>
</blockquote>
<p><code>rust-lang/rust</code> 项目中没有包含 <code>cargo</code>，从自定义的工具链中调用 <code>cargo</code> 是行不通的，<code>rustup</code> 会依次尝试 <code>nightly</code>，<code>beta</code> 或者 <code>stable</code> 中的 <code>cargo</code>。</p>
<h4 id="component"><a href="#component" class="headerlink" title="component"></a>component</h4><p>每个工具链都有一些 <code>component</code>，一些事必要的，例如 <code>rustc</code>，一些是可选的， 例如 <a href="https://github.com/rust-lang/rust-clippy"><code>clippy</code></a>。<code>rust componnet</code> 被用于去管理 <code>component</code>。</p>
<p><code>component</code> 可以随工具链一起安装，使用 <code>--component</code>，例如：</p>
<blockquote>
<p>rustup toolchain install nightly –component rust-docs</p>
</blockquote>
<p>也可以通过 <code>rust component</code> 命令添加到已安装的工具链中:</p>
<blockquote>
<p>rustup component add rust-docs</p>
</blockquote>
<p>可用的组件会随着版本变化，下面是一些可用的组件：</p>
<ul>
<li><code>rustc</code> — Rust 编译器</li>
<li><a href="https://doc.rust-lang.org/cargo/"><code>cargo</code></a> — 包管理器和构建工具；</li>
<li><a href="https://github.com/rust-lang/rustfmt"><code>rustfmt</code></a> — 代码格式化工具；</li>
<li><a href="https://doc.rust-lang.org/std/"><code>rust-std</code></a> — Rust 标准库，Rust 为许多平台都发布了二进制版本的标准库，有些平台还有完整的编译器；</li>
<li><code>rust-docs</code> — <a href="https://doc.rust-lang.org/"><code>Rust 文档</code></a> 的本地副本，可以通过 <code>rustup doc</code> 在浏览器中打开；</li>
<li><a href="https://github.com/rust-lang/rls"><code>rls</code></a> — 用于IDE提供语言分析的后端能力；</li>
<li><a href="https://github.com/rust-lang/rust-clippy"><code>clippy</code></a> — 代码lint工具；</li>
<li><a href="https://github.com/rust-lang/miri/"><code>miri</code></a> — 实验性的 Rust 解释器，可用于检查未定义的行为；</li>
<li><code>rust-src</code> — Rust 标准库有代码的本地副本。可以被 <code>RLS</code>，<code>Miri</code> 或者 Cargo 的实验性 <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>build-std</code></a> 功能使用。</li>
<li><code>rust-analysis</code> — 被 <code>RLS</code> 使用构建标准库的元数据信息；</li>
<li><code>rust-mingw</code> — 包含了用于构建 <code>x86_64-pc-windows-gnu</code> 平台的 <code>linker</code> 和库；</li>
<li><code>llvm-tools-preview</code> — 实验性组件，包含了一些列的 <a href="https://llvm.org/"><code>LLVM</code></a> 工具；</li>
<li><code>rustc-dev</code> — 该组件包含作为库的编译器。大多数用户不需要这个；它仅用于开发链接到编译器的工具，例如对 <code>Clippy</code> 进行修改。</li>
</ul>
<p>并非所有的组件在所有的工具链中都可用，关于组件的可用状态可以在 <a href="https://rust-lang.github.io/rustup-components-history/">Rust 组件历史</a> 这里找到。</p>
<p>对于 <code>nightly</code> 版本，当我们尝试更新的时候，可能有些组件没有一起发布，如果这个组件是必要的，<code>rustup</code> 会自动寻找一个历史版本，可以通过下面的方式改变这些行为：</p>
<ul>
<li>使用 <code>--flag</code> 强制 <code>rustup toolchain install</code> 安装最新的组件版本，即使没有；</li>
<li>使用 <code>--profile</code> 要求 <code>rustup toolchain install</code> 用不包含丢失组件的 <code>profile</code>。例如，<code>--profile=minimal</code> 应该总是可以的工作的；</li>
<li>安装一个包含需要组件的具体日版本，例如：<code>rustup toolchain install nightly-2020-07-27</code>。</li>
</ul>
<h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><p><code>profile</code> 就是一组 <code>component</code>，目前可取的值有：<code>minimal</code>，<code>default</code> 和 <code>complete</code>。</p>
<ul>
<li><p><code>minimal</code>：包含最少的组件，但是可以让编译器正常公共，例如：<code>rustc</code>，<code>rust-std</code> 和 <code>cargo</code>。如果不适用本地文档，在windows上推荐使用这个；</p>
</li>
<li><p><code>default</code>：除了包含 <code>minimal</code> 的组件之外，还包含：<code>rust-docs</code>，<code>rustfmt</code>，<code>clippy</code>。<code>rustup</code> 的默认行为；</p>
</li>
<li><p><code>complete</code>：包含了所有可用的组件，这永远不应该使用，因为它包含了元数据中曾经包含的所有组件。如果你需要某个额外的组件可以进行独立安装，例如 <code>rls</code> 和 <code>miri</code>。</p>
</li>
</ul>
<p>可以使用 <code>rustup set profile</code> 命令更高 <code>rustup</code> 的默认行为，例如 <code>rustup set profile minimal</code>。</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p><code>rustup</code> 包装了通用的 <code>rust</code> 工具， 它们被称为 <code>Proxies</code> 代表的命令由各种各样的 <code>Component</code> 提供。</p>
<p>The list of proxies is currently static in <code>rustup</code> and is as follows:</p>
<ul>
<li><p><code>rustc</code> is the compiler for the Rust programming language, provided by the project itself and comes from the <code>rustc</code> component.</p>
</li>
<li><p><code>rustdoc</code> is a tool distributed in the <code>rustc</code> component which helps you to generate documentation for Rust projects.</p>
</li>
<li><p><code>cargo</code> is the Rust package manager which downloads your Rust package’s dependencies, compiles your packages, makes distributable packages, and uploads them to crates.io (the Rust community’s package registry). It comes from the cargo component.</p>
</li>
<li><p><code>rust-lldb</code> and <code>rust-gdb</code> are simple wrappers around the <code>lldb</code> and <code>gdb</code> debuggers respectively. The wrappers enable some pretty-printing of Rust values and add some convenience features to the debuggers by means of their scripting interfaces.</p>
</li>
<li><p><code>rls</code> is part of the Rust IDE integration tooling. It implements the language-server protocol to permit IDEs and editors such as Visual Studio Code, ViM, or Emacs, access to the semantics of the Rust code you are editing. It comes from the <code>rls</code> component.</p>
</li>
<li><p><code>cargo-clippy</code> and <code>clippy-driver</code> are related to the <code>clippy</code> linting tool which provides extra checks for common mistakes and stylistic choices and it comes from the <code>clippy</code> component.</p>
</li>
<li><p><code>cargo-miri</code> is an experimental interpreter for Rust’s mid-level intermediate representation (MIR) and it comes from the miri component.</p>
</li>
</ul>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ol>
<li><p>如果要更新 <code>rust</code> 或者 <code>rustup</code> 可以使用下面的命令：</p>
<blockquote>
<p>$ rustup self update<br>info: checking for self-updates<br>info: downloading self-updates</p>
</blockquote>
<p> 或者更新 <code>rust</code>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rustup update</span><br><span class="line">info: syncing channel updates for &#x27;stable&#x27;</span><br><span class="line">info: downloading component &#x27;rustc&#x27;</span><br><span class="line">info: downloading component &#x27;rust-std&#x27;</span><br><span class="line">info: downloading component &#x27;rust-docs&#x27;</span><br><span class="line">info: downloading component &#x27;cargo&#x27;</span><br><span class="line">info: installing component &#x27;rustc&#x27;</span><br><span class="line">info: installing component &#x27;rust-std&#x27;</span><br><span class="line">info: installing component &#x27;rust-docs&#x27;</span><br><span class="line">info: installing component &#x27;cargo&#x27;</span><br><span class="line">info: checking for self-updates</span><br><span class="line">info: downloading self-updates</span><br><span class="line"></span><br><span class="line">  stable updated: rustc 1.7.0 (a5d1e7a59 2016-02-29)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们快速测试不同的 <code>rust</code> 版本，可以将 <code>rustc</code> 或者 <code>cargo</code> 的第一个参数指定为 <code>+beta</code> 的形式进行测试，例如:</p>
<blockquote>
<p>cargo +beta run</p>
</blockquote>
</li>
<li><p>如果要为目录指定 <code>rust</code> 版本，可以在目录下执行 <code>rustup override set</code> 命令，例如:</p>
<blockquote>
<p>rustup override set beta</p>
</blockquote>
<p> 这会在配置文件 <code>~/.rustup/settings.toml</code>，为目录指定 <code>rust</code> 版本:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/helloworld ⌚ 11:15:14</span><br><span class="line">$ cat ~/.rustup/settings.toml</span><br><span class="line">default_host_triple = &quot;aarch64-apple-darwin&quot;</span><br><span class="line">default_toolchain = &quot;nightly-aarch64-apple-darwin&quot;</span><br><span class="line">profile = &quot;default&quot;</span><br><span class="line">version = &quot;12&quot;</span><br><span class="line"></span><br><span class="line">[overrides]</span><br><span class="line">&quot;/Users/fudenglong/WORKDIR/rust/helloworld&quot; = &quot;beta-aarch64-apple-darwin&quot;</span><br></pre></td></tr></table></figure>

<p> 如果要为项目固定 <code>rust</code> 版本，可以在目录中放一个 <code>rust-toolchain.toml</code>，里面指定 <code>rust</code> 版本，例如:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[toolchain]</span><br><span class="line">channel = &quot;nightly-2020-07-10&quot;</span><br><span class="line">components = [ &quot;rustfmt&quot;, &quot;rustc-dev&quot; ]</span><br><span class="line">targets = [ &quot;wasm32-unknown-unknown&quot;, &quot;thumbv2-none-eabi&quot; ]</span><br><span class="line">profile = &quot;minimal&quot;</span><br></pre></td></tr></table></figure>

<p> 更多请看：<a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file</a></p>
</li>
</ol>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p><code>Rust</code> 本身支持大量平台，对于很多平台 <code>Rust</code> 发布了标准库的二进制版本，一些平台还发布了全部的编译构建工具。当我们安装一个工具链的时候，<code>rustup</code> 仅仅会安装本平台下的标准库。为了编译到其他平台，我们必须安装特定平台的标准库，例如，对于 Android：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rustup target add arm-linux-androideabi</span><br><span class="line">info: downloading component &#x27;rust-std&#x27; for &#x27;arm-linux-androideabi&#x27;</span><br><span class="line">info: installing component &#x27;rust-std&#x27; for &#x27;arm-linux-androideabi&#x27;</span><br></pre></td></tr></table></figure>

<p>然后我们可以使用 <code>cargo build --target=arm-linux-androideabi</code> 构建安卓平台的发布件。但是我们除了安装标准库之外，还需要交叉编译所需的其他工具，尤其是链接器。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><code>RUSTUP_HOME</code>：<code>rustup</code> 根目录，默认是 <code>~/.rustup</code> 或者 <code>%USERPROFILE%/.rustup</code>；</li>
<li><code>RUSTUP_TOOLCHAIN</code>：默认：<code>none</code>。设置之后，会影响到所有的 <code>rust</code> 工具调用； </li>
<li><code>RUSTUP_DIST_SERVER</code>：默认：<code>https://static.rust-lang.org</code>，下载 <code>rust</code> 相关静态资源，可以更改为镜像站点；</li>
<li><code>RUSTUP_UPDATE_ROOT</code>：默认：<code>https://static.rust-lang.org/rustup</code>，<code>rustup</code> 自更新的站点，可以更新为镜像站点；</li>
<li><code>RUSTUP_NO_BACKTRACE</code>：即使设置了 <code>RUST_BACKTRACE</code>，也禁用非紧急错误的调用栈。</li>
</ul>
<p>其他不常用的请看 <a href="https://rust-lang.github.io/rustup/environment-variables.html">https://rust-lang.github.io/rustup/environment-variables.html</a>。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>如果因网络问题不能下载或者下载较慢，可以设置代理，大多情况下设置 <code>https_proxy</code> 就够了。</p>
<ul>
<li><p>linix:</p>
<blockquote>
<p>export https_proxy&#x3D;socks5:&#x2F;&#x2F;proxy.example.com:1080</p>
</blockquote>
</li>
<li><p><code>windows cmd</code>：</p>
<blockquote>
<p>set https_proxy&#x3D;socks5:&#x2F;&#x2F;proxy.example.com:1080</p>
</blockquote>
</li>
<li><p><code>windows powershell</code>：</p>
<blockquote>
<p>$env:https_proxy&#x3D;”socks5:&#x2F;&#x2F;proxy.example.com:1080”</p>
</blockquote>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>rustup default nightly</code></td>
<td>Set the <code>default toolchain</code> to the latest nightly</td>
</tr>
<tr>
<td><code>rustup set profile minimal</code></td>
<td>Set the default <code>profile</code></td>
</tr>
<tr>
<td><code>rustup target list</code></td>
<td>List all available <code>targets</code> for the active toolchain</td>
</tr>
<tr>
<td><code>rustup target add arm-linux-androideabi</code></td>
<td>Install the Android target</td>
</tr>
<tr>
<td><code>rustup target remove arm-linux-androideabi</code></td>
<td>Remove the Android target</td>
</tr>
<tr>
<td><code>rustup run nightly rustc foo.rs</code></td>
<td>Run the nightly regardless of the active toolchain</td>
</tr>
<tr>
<td><code>rustc +nightly foo.rs</code></td>
<td><code>Shorthand</code> way to run a nightly compiler</td>
</tr>
<tr>
<td><code>rustup run nightly bash</code></td>
<td>Run a shell configured for the nightly compiler</td>
</tr>
<tr>
<td><code>rustup default stable-msvc</code></td>
<td>On Windows, use the MSVC toolchain instead of GNU</td>
</tr>
<tr>
<td><code>rustup override set nightly-2015-04-01</code></td>
<td>For the current directory, use a nightly from a specific date</td>
</tr>
<tr>
<td><code>rustup toolchain link my-toolchain &quot;C:\RustInstallation&quot;</code></td>
<td>Install a custom toolchain by symlinking an existing installation</td>
</tr>
<tr>
<td><code>rustup show</code></td>
<td>Show which toolchain will be used in the current directory</td>
</tr>
<tr>
<td><code>rustup toolchain uninstall nightly</code></td>
<td>Uninstall a given toolchain</td>
</tr>
<tr>
<td><code>rustup toolchain help</code></td>
<td>Show the <code>help</code> page for a subcommand (like <code>toolchain</code>)</td>
</tr>
<tr>
<td><code>rustup man cargo</code></td>
<td>(<em>Unix only</em>) View the man page for a given command (like <code>cargo</code>)</td>
</tr>
</tbody></table>
<h3 id="Cargo-插件"><a href="#Cargo-插件" class="headerlink" title="Cargo 插件"></a><code>Cargo</code> 插件</h3><ol>
<li><a href="https://rust-lang.github.io/rust-clippy/master/"><code>cargo-clippy</code></a>：代码 <code>Lint</code> 工具；</li>
<li><a href="https://mozilla.github.io/cargo-vet/"><code>cargo-vet</code></a>：<code>crate</code> 供应链检查；</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://john-millikin.com/notes-on-cross-compiling-rust">Notes on cross-compiling Rust</a></li>
</ol>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rustup</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】Crate 和 Module</title>
    <url>/2022/06/23/%E3%80%90Rust%E3%80%91Crate-%E5%92%8C-Module/</url>
    <content><![CDATA[<h3 id="Crates"><a href="#Crates" class="headerlink" title="Crates"></a><code>Crates</code></h3><p><code>Rust</code> 程序是由 <code>crate</code> 组成的，每个 <code>crate</code> 都是一个完整的的单元：单个库或可执行文件的所有源代码，以及任何相关的测试、示例、工具、配置和其他东西。可以使用 <code>cargo build --verbose</code> 查看项目中使用了哪些 <code>crates</code>。</p>
<p>通常项目的依赖都是配置在 <code>Cargo.toml</code> 文件中，例如：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">num</span> = <span class="string">&quot;0.4&quot;</span></span><br><span class="line"><span class="attr">image</span> = <span class="string">&quot;0.13&quot;</span></span><br><span class="line"><span class="attr">crossbeam</span> = <span class="string">&quot;0.8&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以通过 <code>cargo build</code>，<code>cargo install</code> 或者 <code>cargo add</code> 下载依赖代码。一旦有了源代码，<code>Cargo</code> 就会编译所有的 <code>crate</code>。它为项目依赖图中的每个 <code>crate</code> 运行一次 <code>rustc</code>（<code>Rust</code> 编译器）。编译库时，<code>Cargo</code> 使用 <code>--crate-type lib</code> 选项。这告诉 <code>rustc</code> 不要寻找 <code>main()</code> 函数，而是生成一个 <code>.rlib</code> 文件，其中包含可用于创建二进制文件和其他 <code>.rlib</code> 文件的编译代码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustc --crate-name num --edition=2018 /Users/fudenglong/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/num-0.4.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C split-debuginfo=unpacked -C debuginfo=2 --cfg &#x27;feature=&quot;default&quot;&#x27; --cfg &#x27;feature=&quot;num-bigint&quot;&#x27; --cfg &#x27;feature=&quot;std&quot;&#x27; -C metadata=b84820de50dc7f78 -C extra-filename=-b84820de50dc7f78 --out-dir /Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps -L dependency=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps --extern num_bigint=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps/libnum_bigint-bd772250e89d4bb9.rmeta --extern num_complex=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps/libnum_complex-d3fd80f953e1ac52.rmeta --extern num_integer=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps/libnum_integer-7ff0466209086397.rmeta --extern num_iter=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps/libnum_iter-2b149e71dbad2afc.rmeta --extern num_rational=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps/libnum_rational-1686ad6eb82c18d4.rmeta --extern num_traits=/Users/fudenglong/WORKDIR/rust/mandelbrot/target/debug/deps/libnum_traits-deaceb32c41a04f1.rmeta --cap-lints allow</span><br></pre></td></tr></table></figure>

<p>对于每个 <code>rustc</code> 命令，<code>Cargo</code> 都会传递 <code>--extern</code> 选项，给出 <code>crate</code> 将使用的每个库的文件名。这样，当 <code>rustc</code> 看到像 <code>use num::bigint::BigInt;</code> 这样的代码行时，它可以确定 <code>num</code> 是另一个 <code>crate</code> 的名称，并且通过 <code>Cargo</code>，可以在磁盘上找到已编译的 <code>crate</code>。<code>Rust</code> 编译器需要访问这些 <code>.rlib</code> 文件，因为它们包含库的编译代码， <code>Rust</code> 会将该代码静态链接到最终的可执行文件中。 <code>.rlib</code> 还包含类型信息，因此 <code>Rust</code> 可以检查我们在代码中使用的库功能是否确实存在，以及我们是否正确使用它们，它还包含 <code>crate</code> 的公共内联函数、泛型和宏的副本等。</p>
<p>如果编译程序时，<code>Cargo</code> 使用 <code>--crate-type bin</code>，结果将会生成目标平台的二进制可执行文件。</p>
<span id="more"></span>

<h3 id="Edition"><a href="#Edition" class="headerlink" title="Edition"></a><code>Edition</code></h3><p><code>Rust</code> 具有极强的兼容性保证，在 <code>Rust 1.0</code> 上编译的任何代码都必须在 <code>Rust 1.50</code> 上编译。但有时社区会遇到令人信服的扩展语言的提议，这会导致旧代码不再编译。例如，经过多次讨论，<code>Rust</code> 确定了一种支持异步编程的语法，将标识符 <code>async</code> 和 <code>await</code> 重新用作关键字。但是这种语言更改会破坏任何使用 <code>async</code> 或 <code>await</code> 作为变量名称的现有代码。</p>
<p>为了在不破坏现有代码的情况下发展，<code>Rust</code> 使用 <code>Edition</code>。<code>Rust 2015</code> 版与 <code>Rust 1.0</code> 兼容。<code>2018</code> 将 <code>async</code> 和 <code>await</code> 更改为关键字，简化了模块系统，并引入了与 <code>2015</code> 不兼容的各种其他语言更改。打开 <code>Cargo.toml</code> 我们会看到如下的 <code>Edition</code> 声明，默认是 <code>2021</code>：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;mandelbrot&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 的编译器承诺始终接受该语言的所有现存版本，并且程序可以自由地混合使用不同版本编写的 <code>crate</code>，例如，<code>2015</code> 的 <code>crate</code> 依赖于 <code>2018</code> 的 <code>crate</code> 甚至可以，换句话说，一个 <code>crate</code> 的版本只影响其源代码的解释方式，代码编译完成之后，就没有所谓的 <code>Edition</code> 区分了，在学要使用语言的新功能时，我们只需要修改 <code>Edition</code>即可。</p>
<p>版本不会每年都发布，只有在 <code>Rust</code> 项目决定需要时才会发布，例如，没有 <code>2020</code> 版，将版本设置为 <code>2020</code> 会导致错误。<code>Rust</code> <a href="https://doc.rust-lang.org/stable/edition-guide/">版本指南</a> 涵盖了每个版本中引入的更改，并提供了版本系统的良好背景，对于新代码，建议总是使用最新的版本，<code>cargo new</code> 默认在最新版本上创建新项目。如果有一个用旧版 <code>Rust</code> 编写的 <code>crate</code>，<code>cargo fix</code> 命令会帮助你自动将代码升级到新版本。</p>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a><code>Profile</code></h3><p>配置文件提供了一种更改编译器设置的方法，影响优化和调试符号等内容。<code>Cargo</code> 有 <code>4</code> 个内置配置文件：<code>dev</code>、<code>release</code>、<code>test</code> 和 <code>bench</code>。如果未在命令行上指定配置文件，则会根据正在运行的命令自动选择配置文件。除了内置配置文件外，还可以指定自定义的用户定义配置文件。</p>
<p>可以使用 <code>[profile]</code> 在 <code>Cargo.toml</code> 中更改配置文件设置，在每个命名配置文件中，可以使用如下键&#x2F;值对更改各个设置：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span>               <span class="comment"># Use slightly better optimizations.</span></span><br><span class="line"><span class="attr">overflow-checks</span> = <span class="literal">false</span>     <span class="comment"># Disable integer overflow checks.</span></span><br></pre></td></tr></table></figure>

<p><code>cargo build</code> 会使用 <code>[profile.dev]</code> 的配置，<code>cargo build --release</code> 会使用 <code>[profile.release]</code> 的配置，<code>cargo test</code> 使用 <code>[profile.test]</code> 中的配置。</p>
<p>更多详细的内容请看 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo Profiles</a>。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a><code>Module</code></h3><p><code>crate</code> 就是第三方模块，用于项目之间的代码共享，而 <code>Module</code> 是项目内的代码组织。它们充当 <code>Rust</code> 的命名空间、构成 <code>Rust</code> 程序或库的函数、类型、常量等的容器。一个模块如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> spores &#123;</span><br><span class="line">  <span class="keyword">use</span> cells::&#123;Cell, Gene&#125;;</span><br><span class="line">  <span class="comment">/// A cell made by an adult fern. It disperses on the wind as part of</span></span><br><span class="line">  <span class="comment">/// the fern life cycle. A spore grows into a prothallus -- a whole</span></span><br><span class="line">  <span class="comment">/// separate organism, up to 5mm across -- which produces the zygote</span></span><br><span class="line">  <span class="comment">/// that grows into a new fern. (Plant sex is complicated.)</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Spore</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// Simulate the production of a spore by meiosis.</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">produce_spore</span>(factory: &amp;<span class="keyword">mut</span> Sporangium) <span class="punctuation">-&gt;</span> Spore &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// Extract the genes in a particular spore.</span></span><br><span class="line">  <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">genes</span>(spore: &amp;Spore) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Gene&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// Mix genes to prepare for meiosis (part of interphase).</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">recombine</span>(parent: &amp;<span class="keyword">mut</span> Cell) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中，模块是 <code>Spore</code> 结构和两个函数的集合。<code>pub</code> 关键字使得标记的项公开，因此可以从模块外部访问它。</p>
<p>一个函数被标记为 <code>pub(crate)</code>，这意味着它在这个 <code>crate</code> 内的任何地方都可用，但不作为外部接口的一部分公开。它不能被其他 <code>crate</code> 使用，也不会出现在这个 <code>crate</code> 的文档中。被标记为 <code>pub</code> 的项目通常称为<strong>导出</strong>该项目，任何未标记为 <code>pub</code> 的内容都是私有的，只能在定义它的同一模块或任何子模块中使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = spores::<span class="title function_ invoke__">produce_spore</span>(&amp;<span class="keyword">mut</span> factory); <span class="comment">// ok</span></span><br><span class="line">spores::<span class="title function_ invoke__">recombine</span>(&amp;<span class="keyword">mut</span> cell); <span class="comment">// error: `recombine` is private</span></span><br></pre></td></tr></table></figure>

<h3 id="模块嵌套"><a href="#模块嵌套" class="headerlink" title="模块嵌套"></a>模块嵌套</h3><p>模块可以嵌套，一个模块可能仅仅是子模块的集合：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> plant_structures &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">mod</span> roots &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">mod</span> stems &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">mod</span> leaves &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望嵌套模块中的项目对其他 <code>crate</code> 可见，必须将到达这个项的所有模块都标记为 <code>pub</code>。也可以指定 <code>pub(super)</code>，使项目仅对父模块可见，以及 <code>pub(in &lt;path&gt;)</code>，使其在特定父模块及其后代中可见。这对于深度嵌套的模块特别有用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> plant_structures &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">mod</span> roots &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> products &#123;</span><br><span class="line">      <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::plant_structures::roots) <span class="keyword">struct</span> <span class="title class_">Cytokinin</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">use</span> products::Cytokinin; <span class="comment">// ok: in `roots` module</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">use</span> roots::products::Cytokinin; <span class="comment">// error: `Cytokinin` is private</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: `Cytokinin` is private</span></span><br><span class="line"><span class="keyword">use</span> plant_structures::roots::products::Cytokinin;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们可以编写一个完整的程序，包含大量代码和整个模块层次结构，以我们想要的任何方式组织起来，而所有这些都在一个源文件中。</p>
<h3 id="模块和文件系统"><a href="#模块和文件系统" class="headerlink" title="模块和文件系统"></a>模块和文件系统</h3><p>如果将模块以单个文件形式组织，这种方式工作很痛苦，大型项目中往往需要拆分，将不同的功能的代码以不同的文件区分，使得代码在逻辑上，物理组织上都能很清晰。</p>
<h4 id="单文件模块"><a href="#单文件模块" class="headerlink" title="单文件模块"></a>单文件模块</h4><p>之前我们是在 <code>spores</code> 模块中使用括号将模块的内容包裹起来的，现在可以在单个源码文件中开发模块。我们在 <code>main.rs</code> 中声明如下模块：</p>
<figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> spores;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>spores.rs</code> 开发该模块的代码：</p>
<figure class="highlight rust"><figcaption><span>spores.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A cell made by an adult fern...</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Spore</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Simulate the production of a spore by meiosis.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">produce_spore</span>(factory: &amp;<span class="keyword">mut</span> Sporangium) <span class="punctuation">-&gt;</span> Spore &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract the genes in a particular spore.</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">genes</span>(spore: &amp;Spore) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Gene&gt; &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Mix genes to prepare for meiosis (part of interphase).</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">recombine</span>(parent: &amp;<span class="keyword">mut</span> Cell) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公开和私有的原则和之前讲的是相同的，<code>Rust</code> 从不单独编译模块，即使它们在单独的文件中：当你构建一个 <code>crate</code> 时，会重新编译它的所有模块。当 <code>Rust</code> 看到一个模块时，例如上面的 <code>mod spores;</code> 时，它会检查 <code>spores.rs</code> 和 <code>spores/mod.rs</code> 是否存在，如果都存在或者都不存在，就会报错。</p>
<h4 id="模块目录（一）"><a href="#模块目录（一）" class="headerlink" title="模块目录（一）"></a>模块目录（一）</h4><p>但是当我们的模块中包含子模块时，就不能像 <code>spores.rs</code> 那样单独处理了，就像之前的 <code>plant_structures</code> 模块。如果，我们有下面这样的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fern_sim/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src/</span><br><span class="line">  ├── main.rs</span><br><span class="line">  ├── spores.rs</span><br><span class="line">  └── plant_structures/</span><br><span class="line">    ├── mod.rs</span><br><span class="line">    ├── leaves.rs</span><br><span class="line">    ├── roots.rs</span><br><span class="line">    └── stems.rs</span><br></pre></td></tr></table></figure>

<p>在 <code>main.rs</code>，我们声明 <code>plant_structures</code> 模块，这会让 <code>Rust</code> 加载 <code>plant_structures/mod.rs</code>：</p>
<figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> plant_structures;</span><br></pre></td></tr></table></figure>

<p>然后，我们再声明子模块：</p>
<figure class="highlight rust"><figcaption><span>plant_structures/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> roots;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> stems;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> leaves;</span><br></pre></td></tr></table></figure>

<p>这三个模块的内容存储在名为 <code>leaves.rs</code>、<code>roots.rs</code> 和 <code>stems.rs</code> 的单独文件中，和 <code>plant_structures/mod.rs</code> 同级。</p>
<h4 id="模块目录（二）"><a href="#模块目录（二）" class="headerlink" title="模块目录（二）"></a>模块目录（二）</h4><p>我们也可以使用文件和目录一起组成模块，如果之前的 <code>stems</code> 需要包含 <code>xylem</code> 和 <code>phloem</code>，我们选择保留 <code>plant_structures/stems.rs</code>，然后再添加一个 <code>stems</code> 目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fern_sim/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src/</span><br><span class="line">  ├── main.rs</span><br><span class="line">  ├── spores.rs</span><br><span class="line">  └── plant_structures/</span><br><span class="line">    ├── mod.rs</span><br><span class="line">    ├── leaves.rs</span><br><span class="line">    ├── roots.rs</span><br><span class="line">    ├── stems/</span><br><span class="line">    │ ├── phloem.rs</span><br><span class="line">    │ └── xylem.rs</span><br><span class="line">    └── stems.rs</span><br></pre></td></tr></table></figure>

<p>然后，我们可以在 <code>stems.rs</code> 中声明两个新模块：</p>
<figure class="highlight rust"><figcaption><span>plant_structures/stems.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> xylem;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> phloem;</span><br></pre></td></tr></table></figure>

<p>所以这里有三种模块组织方式：</p>
<ul>
<li>模块在他们自己的文件中；</li>
<li>模块在他们自己的目录中，带有 <code>mod.rs</code>；</li>
<li>模块在他们自己的文件中，带有包含子模块的补充目录；</li>
</ul>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p><code>::</code> 操作符被用于访问其他模块的功能。我们可以直接使用其他模块中的功能而不实现导入，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> s1, &amp;<span class="keyword">mut</span> s2);</span><br></pre></td></tr></table></figure>

<p><code>std</code> 指向标准库的顶层模块，<code>mem</code> 是其中的一个子模块，<code>std::mem::swap</code> 只是其中的一个导出函数。上面的这种使用访问方式有点冗长，另一种方式是将要使用的功能导入当前的模块，使用 <code>use</code> 将 <code>std::mem</code> 引入到当前模块，并且定义新的别 <code>mem</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"><span class="keyword">if</span> s1 &gt; s2 &#123;</span><br><span class="line">  mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> s1, &amp;<span class="keyword">mut</span> s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以写 <code>use std::mem::swap;</code> 导入 <code>swap</code> 函数本身而不是 <code>mem</code> 模块。但最好的方式是：导入类型、<code>trait</code>和模块（如 <code>std::mem</code>），然后使用相对路径访问其中的函数、常量和其他成员。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;; <span class="comment">// 同时导入</span></span><br><span class="line"><span class="keyword">use</span> std::fs::&#123;<span class="keyword">self</span>, File&#125;; <span class="comment">// 导入 `std::fs` 和 `std::fs::File`.</span></span><br><span class="line"><span class="keyword">use</span> std::io::prelude::*;  <span class="comment">// import everything</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <code>as</code> 对导入的名称进行重命名：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IOResult;</span><br><span class="line"><span class="comment">// This return type is just another way to write `std::io::Result&lt;()&gt;`:</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">save_spore</span>(spore: &amp;Spore) <span class="punctuation">-&gt;</span> IOResult&lt;()&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>子模块不会自动导入父模块的内容，假设我们的 <code>proteins/mod.rs</code> 中内容是这样子的：</p>
<figure class="highlight rust"><figcaption><span>proteins/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">AminoAcid</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> synthesis;</span><br></pre></td></tr></table></figure>

<p>那么模块 <code>proteins/synthesis.rs</code> 中如果不导入 <code>AminoAcid</code> 是不能直接使用的：</p>
<div class="note danger"><figure class="highlight rust"><figcaption><span>proteins/synthesis.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">synthesize</span>(seq: &amp;[AminoAcid]) <span class="comment">// error: can&#x27;t find type `AminoAcid`</span></span><br></pre></td></tr></table></figure></div>

<p>而是，每个模块都是以一个空的状态开始的，必须手动导入它使用的任何内容（也不完全是空的，有预导入）：</p>
<div class="note success"><figure class="highlight rust"><figcaption><span>proteins/synthesis.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::AminoAcid; <span class="comment">// explicitly import from parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">synthesize</span>(seq: &amp;[AminoAcid]) <span class="comment">// error: can&#x27;t find type `AminoAcid`</span></span><br></pre></td></tr></table></figure></div>

<p>默认情况下，是从当前模块开始导入：</p>
<figure class="highlight rust"><figcaption><span>proteins/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> synthesis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">AminoAcid</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> synthesis::synthesize;  <span class="comment">// 从 synthesis 子模块导入</span></span><br></pre></td></tr></table></figure>

<p><code>self</code> 是当模块的昵称，因此在 <code>proteins/mod.rs</code> 中可以这样写：</p>
<figure class="highlight rust"><figcaption><span>proteins/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这样可以直接用 Lys 而不是 `AminoAcid::Lys`</span></span><br><span class="line"><span class="keyword">use</span> self::AminoAcid::*;</span><br></pre></td></tr></table></figure>

<p>也可以简化为：</p>
<figure class="highlight rust"><figcaption><span>proteins/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> AminoAcid::*;</span><br></pre></td></tr></table></figure>

<p>除了从顶层模块导入，从 <code>self</code> 当前模块导入或者从当前的子模块导入之外，还可以通过 <code>super</code> 或者 <code>crate</code> 关键字进行导入，其中 <code>super</code> 表示父模块，而 <code>crate</code> 表示当前模块的 <code>crate</code>。</p>
<p>使用相对于 <code>crate</code> 根目录的导入而不是相对于当前路径的导入，有助于在项目中移动代码。因为如果当前模块的路径发生更改，所有导入都不会中断。例如：</p>
<figure class="highlight rust"><figcaption><span>proteins/synthesis.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::proteins::AminoAcid; <span class="comment">// 显示从 crate 的根导入</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">synthesize</span>(seq: &amp;[AminoAcid]) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>之前看了从父模块导入子模块，但是如果从子模块导入父模块的内容，可以使用 <code>super::</code>。</p>
<p>如果你有一个和正在使用的 <code>crate</code> 同名的模块，在导入的时候就要注意了，否则会引起错误，例如，如果引用了 <a href="https://crates.io/crates/image"><code>image</code></a>，自己也有个 <code>image</code> 模块：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> image &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sampler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：引入 image crate 还是 image 模块</span></span><br><span class="line"><span class="keyword">use</span> image::Pixels;</span><br></pre></td></tr></table></figure></div>

<p>解决这个问题的方法是使用绝对导入，导入以 <code>::</code> 开始，例如，如果要导入第三方 <code>image</code>，可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ::image::Pixels; <span class="comment">// the `image` crate&#x27;s `Pixels`</span></span><br></pre></td></tr></table></figure>

<p>引入内部的 <code>image module</code> 可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> self::image::Sampler; <span class="comment">// the `image` module&#x27;s `Sampler`</span></span><br></pre></td></tr></table></figure>

<h3 id="预导入"><a href="#预导入" class="headerlink" title="预导入"></a>预导入</h3><p>之前说每个模块都以空的状态开始，但其实也不完全是空的，因为 <code>Rust</code> 有很多常用的类型，为了简化编程，<code>Rust</code> 会帮我们导入，不用我们显示导入。例如：<code>Vec</code> 和 <code>Result</code>。 </p>
<p>自动导入的内容可以看这里，<a href="https://doc.rust-lang.org/std/prelude/index.html">std::prelude</a>。</p>
<h3 id="别名导出"><a href="#别名导出" class="headerlink" title="别名导出"></a>别名导出</h3><p><code>use</code> 只是将我们使用的内容从其他模块或者 <code>crate</code>导入并且在本模块起了个没别名，但是它也可以将导入的内容重新导出。例如：</p>
<figure class="highlight rust"><figcaption><span>plant_structures/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::leaves::Leaf;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::roots::Root;</span><br></pre></td></tr></table></figure>

<p>这意味着 <code>Leaf</code> 和 <code>Root</code> 是 <code>plant_structures</code> 模块中的公共内容，它们也仍然是 <code>self::leaves::Leaf</code> 和 <code>self::roots::Root</code> 的别名。</p>
<h3 id="结构体导出"><a href="#结构体导出" class="headerlink" title="结构体导出"></a>结构体导出</h3><p><code>module</code> 可以包含用户定义的结构体类型，使用 <code>struct</code> 关键字引入，它和它的字段也可以由 <code>pub</code> 声明是否导出。一个简单的结构如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Fern</span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> roots: RootSet,</span><br><span class="line">  <span class="keyword">pub</span> stems: StemSet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的所有字段，甚至私有字段，都可以在声明结构体的模块及其子模块中访问，在模块之外，只能访问导出字段。</p>
<h3 id="静态变量和常量"><a href="#静态变量和常量" class="headerlink" title="静态变量和常量"></a>静态变量和常量</h3><p><code>const</code> 关键字引入了一个常量。 语法和 <code>let</code> 一样，只是它可能被标记为 <code>pub</code>，并且类型是必需的。此外，大写名称对于常量来说是常规的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> ROOM_TEMPERATURE: <span class="type">f64</span> = <span class="number">20.0</span>; <span class="comment">// degrees Celsius</span></span><br></pre></td></tr></table></figure>

<p><code>static</code> 关键字引入了一个静态项，和 <code>const</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> ROOM_TEMPERATURE: <span class="type">f64</span> = <span class="number">68.0</span>; <span class="comment">// degrees Fahrenheit</span></span><br></pre></td></tr></table></figure>

<p>常量有点像 <code>C</code> 中的 <code>#define</code>，值会被编译到使用的地方。静态变量是在程序开始运行之前设置并持续到退出的变量。在代码中使用常量作为 <code>magic number</code> 和字符串，对大量数据或任何需要借用常量值的引用的时候使用静态。</p>
<p>没有 <code>mut</code> 类型常量，静态变量可以标记为 <code>mut</code>，<code>Rust</code> 无法强制执行其关于对 <code>mut</code> 静态变量的独占访问的规则。因此，它们本质上是非线程安全的，安全代码根本不能使用它们，<code>Rust</code> 不鼓励全局可变状态：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> PACKETS_SERVED: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; served&quot;</span>, PACKETS_SERVED); <span class="comment">// error: use of mutable static</span></span><br></pre></td></tr></table></figure></div>

<h3 id="开发-library-项目"><a href="#开发-library-项目" class="headerlink" title="开发 library 项目"></a>开发 library 项目</h3><p>如果想要将项目编译成一个 <code>lib</code> 而不是一个可执行文件，我们只需要三步：</p>
<ul>
<li><p>将 <code>src/main.rs</code> 重命名成 <code>src/lib.js</code>；</p>
</li>
<li><p>添加 <code>pub</code> 关键字给 <code>src/lib.js</code> 中的导出内容；</p>
</li>
<li><p>移除 <code>src/main.rs</code> 中的 <code>main</code> 函数；</p>
</li>
</ul>
<p>我们不需要更改 <code>Cargo.toml</code> 中的任何内容 默认情况下，<code>cargo build</code> 查看源目录中的文件并确定要构建的内容。当它看到文件 <code>src/lib.rs</code> 时，就知道需要去构建一个 <code>lib</code>。<code>src/lib.rs</code> 中的代码构成了库的根模块，使用我们的其他 <code>crate</code> 只能访问此根模块的公共项目。</p>
<h4 id="src-bin-目录"><a href="#src-bin-目录" class="headerlink" title="src/bin 目录"></a><code>src/bin</code> 目录</h4><p>我们可以让一个项目是 <code>lib</code>，也可以让它同时编译成一个可执行程序，只是需要将 <code>main</code> 函数移到目录 <code>sr/bin</code> 中，而且可以有多个 <code>main</code> 函数，例如我的项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/mandelbrot 20:15:24</span><br><span class="line">$ tree --help -l 4</span><br><span class="line">▁</span><br><span class="line">/Users/fudenglong/WORKDIR/rust/mandelbrot</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line">   ├── bin</span><br><span class="line">   |  ├── mandelbrot.rs</span><br><span class="line">   |  └── mandelbrot_v2</span><br><span class="line">   |     └── main.rs</span><br><span class="line">   └── lib.rs</span><br><span class="line">~/WORKDIR/rust/mandelbrot 20:15:28</span><br></pre></td></tr></table></figure>

<p>各个文件的内容如下：</p>
<div class="tabs" id="rust项目结构"><ul class="nav-tabs"><li class="tab active"><a href="#rust项目结构-1">src/lib.rs</a></li><li class="tab"><a href="#rust项目结构-2">src/bin/mandelbrot.js</a></li><li class="tab"><a href="#rust项目结构-3">src/bin/mandelbrot_v2/mandelbrot.js</a></li><li class="tab"><a href="#rust项目结构-4">Cargo.toml</a></li></ul><div class="tab-content"><div class="tab-pane active" id="rust项目结构-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::bigint::BigInt;</span><br><span class="line"><span class="keyword">use</span> num::rational::&#123;BigRational, Ratio&#125;;</span><br><span class="line"><span class="keyword">use</span> num::FromPrimitive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">approx_sqrt</span>(number: <span class="type">u64</span>, iterations: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> BigRational &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span>: Ratio&lt;BigInt&gt; = Ratio::<span class="title function_ invoke__">from_integer</span>(FromPrimitive::<span class="title function_ invoke__">from_u64</span>(number).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">approx</span> = start.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..iterations &#123;</span><br><span class="line">        approx = (&amp;approx + (&amp;start / &amp;approx))</span><br><span class="line">            / Ratio::<span class="title function_ invoke__">from_integer</span>(FromPrimitive::<span class="title function_ invoke__">from_u64</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    approx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="rust项目结构-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mandelbrot::approx_sqrt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">approx_sqrt</span>(<span class="number">10</span>, <span class="number">4</span>)); <span class="comment">// prints 4057691201/1283082416</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="rust项目结构-3"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mandelbrot::approx_sqrt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">approx_sqrt</span>(<span class="number">10</span>, <span class="number">4</span>)); <span class="comment">// prints 4057691201/1283082416</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="rust项目结构-4"><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;mandelbrot&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">num</span> = <span class="string">&quot;0.4&quot;</span></span><br></pre></td></tr></table></figure></div></div></div>

<p>我们可以指定运行不同的 <code>main</code> 函数：</p>
<pre><code>~/WORKDIR/rust/mandelbrot 20:25:13
$ cargo run --bin mandelbrot
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/mandelbrot`
4057691201/1283082416

~/WORKDIR/rust/mandelbrot 20:25:15
$ cargo run --bin mandelbrot_v2
  Compiling mandelbrot v0.1.0 (/Users/fudenglong/WORKDIR/rust/mandelbrot)
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
    Running `target/debug/mandelbrot_v2`
4057691201/1283082416
</code></pre>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>Rust</code> 程序中的任何项目都可以用属性进行修饰。属性是 <code>Rust</code> 用于向编译器编写杂项指令和建议的语法。例如，假设您收到以下警告：</p>
<pre><code>libgit2.rs: warning: type `git_revspec` should have a camel case name
such as `GitRevspec`, #[warn(non_camel_case_types)] on by default
</code></pre>
<p>但是你选择这个名字是有原因的，你希望屏蔽这个告警，可以通过在类型上添加 <code>#[allow]</code> 完成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_revspec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件编译是使用属性编写的另一个功能，即 <code>#[cfg]</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有在编译安卓平台的项目时包含这个模块</span></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;android&quot;</span>)]</span></span><br><span class="line"><span class="keyword">mod</span> mobile;</span><br></pre></td></tr></table></figure>

<p><code>#[cfg]</code> 常用的属性可以看 <a href="https://www.rustwiki.org.cn/zh-CN/reference/conditional-compilation.html">条件编译</a>。</p>
<p>给函数添加 <code>#[inline]</code> 属性可以建议编译器根据情况决定是否内联函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_osmosis</span>(c1: &amp;<span class="keyword">mut</span> Cell, c2: &amp;<span class="keyword">mut</span> Cell) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <code>crate</code> 中定义的函数或方法在另一个 <code>crate</code> 中被调用时，<code>Rust</code> 不会内联它，除非它是泛型的或显式标记为 <code>#[inline]</code>。<code>Rust</code> 还支持更直接的 <code>#[inline(always)]</code>，要求在每个调用点内联扩展函数，并支持 <code>#[inline(never)]</code>，要求永远不要内联函数。</p>
<p>一些属性，如 <code>#[cfg]</code> 和<code>#[allow]</code>，可以附加到整个模块并应用于其中的所有内容。其他的，如<code> #[test]</code> 和<code>#[inline]</code>，必须附加到单个项目，每个属性都是可以指定参数进行定制，这里看<a href="https://www.rustwiki.org.cn/zh-CN/reference/items.html">完整的属性列表</a>。</p>
<p>要将属性附加到整个 <code>crate</code>，请将其添加到 <code>main.rs</code> 或 <code>lib.rs</code> 文件的顶部，在任何内容之前，然后写 <code>#!</code> 而不是<code>#</code>，像这样：</p>
<figure class="highlight rust"><figcaption><span>libgit2_sys/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(non_camel_case_types)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_revspec</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_error</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#!</code> 通常只用于文件的开头，用于将属性附加到整个模块或 <code>crate</code>。某些属性总是使用 <code>#!</code> 语法，因为它们只能应用于整个 <code>crate</code>。 例如，<code>#![feature]</code> 属性用于打开 <code>Rust</code> 语言和库的不稳定特性，这些特性是实验性的，因此可能存在错误，或者将来可能会被更改或删除。</p>
<p>例如，<code>Rust</code> 为跟踪宏的扩展提供了实验性支持，比如 <code>assert!</code>，但是由于这种支持是实验性的，你只能通过 </p>
<ul>
<li>(1) 安装 <code>nightly</code> 版本的 <code>Rust</code>；</li>
<li>(2) 来使用<code>#![feature(trace_macros)]</code> 明确使用 <code>trace_macros</code>；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(trace_macros)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// I wonder what actual Rust code this use of assert_eq!</span></span><br><span class="line">  <span class="comment">// gets replaced with!</span></span><br><span class="line">  trace_macros!(<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">10</span>*<span class="number">10</span>*<span class="number">10</span> + <span class="number">9</span>*<span class="number">9</span>*<span class="number">9</span>, <span class="number">12</span>*<span class="number">12</span>*<span class="number">12</span> + <span class="number">1</span>*<span class="number">1</span>*<span class="number">1</span>);</span><br><span class="line">  trace_macros!(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><code>Rust</code> 内置了一个单元测试框架，任何由 <code>#[test]</code> 标记的普通函数是测试函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">math_works</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">assert!</span>(x.<span class="title function_ invoke__">is_positive</span>());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cargo test</code> 用于运行项目中的所有测试函数：</p>
<pre><code>$ cargo test
Compiling math_test v0.1.0 (file:///.../math_test)
Running target/release/math_test-e31ed91ae51ebf22
running 1 test
test math_works ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>可以通过 <code>cargo test TESTNAME</code> 指定要运行的测试函数需要包含的关键字，以运行某些测试。</p>
<p>通常使用 <code>asset!</code> 和 <code>asset_eq!</code> 在测试中对结果进行断言，如果断言失败，程序就会 <code>panic</code>。<code>asset!</code> 和 <code>asset_eq!</code> 没有包含在 <code>release</code> 版本中，如果仅仅是构建 <code>debug</code> 版本，可以使用 <code>debug_assert!</code> 和 <code>debug_assert_eq!</code>。</p>
<p>为了测试错误情况，可以添加 <code>#[should_panic]</code> 给测试函数，这个例子中我们也使用了 <code>#allow</code> 允许我们无条件 <code>panic</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// This test passes only if division by zero causes a panic,</span></span><br><span class="line"><span class="comment">/// as we claimed in the previous chapter.</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[allow(unconditional_panic, unused_must_use)]</span></span><br><span class="line"><span class="meta">#[should_panic(expected=<span class="string">&quot;divide by zero&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_divide_by_zero_error</span>() &#123;</span><br><span class="line">  <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// should panic!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以从测试中返回 <code>Result&lt;(), E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// if 1024 是有效的数字，这个测试会通过</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::num::ParseIntError&gt; &#123;</span><br><span class="line">    <span class="type">i32</span>::<span class="title function_ invoke__">from_str_radix</span>(<span class="string">&quot;x1024xx&quot;</span>, <span class="number">10</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标有<code>#[test]</code> 的函数是会条件编译的。普通的 <code>cargo build</code> 或 <code>cargo build --release</code> 会跳过测试代码。但运行 <code>cargo test</code> 时，<code>Cargo</code> 会构建程序两次：一次以普通方式，一次来运行测试。这意味着单元测试可以与他们测试的代码一起使用，如果需要，可以访问内部实现细节，而且没有运行时成本。但是，它可能会导致一些警告。 例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">roughly_equal</span>(a: <span class="type">f64</span>, b: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">  (a - b).<span class="title function_ invoke__">abs</span>() &lt; <span class="number">1e-6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">trig_works</span>() &#123;</span><br><span class="line">  <span class="keyword">use</span> std::<span class="type">f64</span>::consts::PI;</span><br><span class="line">  <span class="built_in">assert!</span>(<span class="title function_ invoke__">roughly_equal</span>(PI.<span class="title function_ invoke__">sin</span>(), <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在省略了测试代码的构建中，<code>roughly_equal</code> 似乎没有被使用，<code>Rust</code> 会报错：</p>
<pre><code>$ cargo build
Compiling math_test v0.1.0 (file:///.../math_test)
warning: function is never used: `roughly_equal`
--&gt; src/crates_unused_testing_function.rs:7:1
|
7 | / fn roughly_equal(a: f64, b: f64) -&gt; bool &#123;
8 | | (a - b).abs() &lt; 1e-6
9 | | &#125;
| |_^
|
= note: #[warn(dead_code)] on by default
</code></pre>
<p>按照约定，当测试代码需要一些代码支持时，需要放进 <code>tests</code> 模块，并且使用 <code>#[cfg(test)]</code> 标记整个模块：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span> <span class="comment">// include this module only when testing</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">roughly_equal</span>(a: <span class="type">f64</span>, b: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    (a - b).<span class="title function_ invoke__">abs</span>() &lt; <span class="number">1e-6</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">trig_works</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">f64</span>::consts::PI;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">roughly_equal</span>(PI.<span class="title function_ invoke__">sin</span>(), <span class="number">0.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>我们可以在 <code>src</code> 目录同级创建一个 <code>tests</code> 目录，用于放我们的集成测试代码，集成测试将我们的库代码当做外部 <code>crate</code> 链接然后进行测试，因此集成测试也只能测试公共 <code>API</code>：</p>
<figure class="highlight rust"><figcaption><span>tests/unfurl.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> fern_sim::Terrarium;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_fiddlehead_unfurling</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">world</span> = Terrarium::<span class="title function_ invoke__">load</span>(<span class="string">&quot;tests/unfurl_files/fiddlehead.tm&quot;</span>);</span><br><span class="line">  <span class="built_in">assert!</span>(world.<span class="title function_ invoke__">fern</span>(<span class="number">0</span>).<span class="title function_ invoke__">is_furled</span>());</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">one_hour</span> = Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">  world.<span class="title function_ invoke__">apply_sunlight</span>(one_hour);</span><br><span class="line">  <span class="built_in">assert!</span>(world.<span class="title function_ invoke__">fern</span>(<span class="number">0</span>).<span class="title function_ invoke__">is_fully_unfurled</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cargo test</code> 命令会同时运行集成测试和单元测试，如果只想运行 <code>tests/unfurl.rs</code> 中的集成测试代码，可以使用 <code>cargo test --test unfurl</code>。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><code>cargo doc</code> 命令可以生成 <code>crate</code> 的文档，文档中会包含库中 <code>pub</code> 内容的文档，文档就是添加到它们上面的注释。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Simulate the production of a spore by meiosis.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">produce_spore</span>(factory: &amp;<span class="keyword">mut</span> Sporangium) <span class="punctuation">-&gt;</span> Spore &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>Rust</code> 看到三个斜线开头的注释时，就相当于使用 <code>#[doc]</code>，上面的例子等价于：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[doc = <span class="string">&quot;Simulate the production of a spore by meiosis.&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">produce_spore</span>(factory: &amp;<span class="keyword">mut</span> Sporangium) <span class="punctuation">-&gt;</span> Spore &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>///</code> 样式的注释之外，还有 <code>//!</code>，被当做 <code>#![doc]</code>，经常用于模块或者 <code>crate</code>，例如 <code>src/lib.rs</code> 可能像下面这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Simulate the growth of ferns, from the level of</span></span><br><span class="line"><span class="comment">//! individual cells on up.</span></span><br></pre></td></tr></table></figure>

<p>注释的内容会被当做 <code>Markdown</code> 格式，还可以包含 <code>Html</code> 标记。注释有个特色功能就是可以用 <code>Rust</code> 的模块组织路径去引用 <code>Rust</code> 定义的函数，结构体等。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Create and return a [`VascularPath`] which represents the path of</span></span><br><span class="line"><span class="comment">/// nutrients from the given [`Root`][r] to the given [`Leaf`](leaves::Leaf).</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// [r]: roots::Root</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trace_path</span>(leaf: &amp;leaves::Leaf, root: &amp;roots::Root) <span class="punctuation">-&gt;</span> VascularPath &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以添加搜索别名，以便使用内置搜索功能更轻松地查找内容。在这个 <code>crate</code> 的文档中搜索 <code>path</code> 或 <code>route</code> 都能找到 <code>VascularPath</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[doc(alias = <span class="string">&quot;route&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">VascularPath</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>backticks</code> 在运行文本的中间设置一些代码，在输出中，这些片段将被格式化为固定宽度的字体。可以通过缩进<code>4</code>个空格来添加更大的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A block of code in a doc comment:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     if samples::everything().works() &#123;</span></span><br><span class="line"><span class="comment">///         println!(&quot;ok&quot;);</span></span><br><span class="line"><span class="comment">///     &#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>Markdown</code> 格式的代码风格，有同样效果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Another snippet, the same code, but written differently:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// if samples::everything().works() &#123;</span></span><br><span class="line"><span class="comment">///   println!(&quot;ok&quot;);</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure>

<p>还有很多注释类型，可以参考这里 <a href="https://www.rustwiki.org.cn/zh-CN/reference/comments.html">注释</a>。</p>
<h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><p>当运行测试的时候，<code>Rust</code> 会检查所有出现在文档中的代码块，编译成一个独立的 <code>crate</code>，然后和我们的库链接并执行。下面是一个用 <code>cargo new --lib ranges</code> 创建的例子，把下面的代码的放入 <code>ranges/src/lib.rs</code> 中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return true if two ranges overlap.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     assert_eq!(ranges::overlap(0..7, 3..10), true);</span></span><br><span class="line"><span class="comment">///     assert_eq!(ranges::overlap(1..5, 101..105), false);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If either range is empty, they don&#x27;t count as overlapping.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     assert_eq!(ranges::overlap(0..0, 0..10), false);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">overlap</span>(r1: Range&lt;<span class="type">usize</span>&gt;, r2: Range&lt;<span class="type">usize</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    r1.start &lt; r1.end &amp;&amp; r2.start &lt; r2.end &amp;&amp; r1.start &lt; r2.end &amp;&amp; r2.start &lt; r1.end</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>cargo doc --no-deps --open</code> 应该能看到下面的文档：</p>
<img data-src="/2022/06/23/%E3%80%90Rust%E3%80%91Crate-%E5%92%8C-Module/cargo-doc.png" class="">

<p>如果运行 <code>cargo test</code> 会看到如下的信息：</p>
<pre><code>~/WORKDIR/rust/ranges ⌚ 9:57:08
$  cargo test               
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
    Running unittests src/lib.rs (target/debug/deps/ranges-13060b2daf473d43)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

  Doc-tests ranges

running 2 tests
test src/lib.rs - overlap (line 5) ... ok
test src/lib.rs - overlap (line 10) ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.63s
</code></pre>
<p>如果你将 <code>cargo test --verbose</code>，你会看到它使用 <code>rustdoc --test</code> 来运行这两个文档中的测试。<code>rustdoc</code> 将每个代码示例存储在一个单独的文件中，添加几行样例代码，以生成两个程序。 例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ranges;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(ranges::<span class="title function_ invoke__">overlap</span>(<span class="number">0</span>..<span class="number">7</span>, <span class="number">3</span>..<span class="number">10</span>), <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(ranges::<span class="title function_ invoke__">overlap</span>(<span class="number">1</span>..<span class="number">5</span>, <span class="number">101</span>..<span class="number">105</span>), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doc test</code> 背后的想法不是把所有的测试都放在文档中，而是确保文档中的代码能正常编译运行。一个代码示例将包含一些诸如导入类的东西，但是如果想在代码中隐藏，可以以 <code># </code>开头：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Let the sun shine in and run the simulation for a given</span></span><br><span class="line"><span class="comment">/// amount of time.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     # use fern_sim::Terrarium;</span></span><br><span class="line"><span class="comment">///     # use std::time::Duration;</span></span><br><span class="line"><span class="comment">///     # let mut tm = Terrarium::new();</span></span><br><span class="line"><span class="comment">///     tm.apply_sunlight(Duration::from_secs(60));</span></span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure>

<p>生成的文档如下图所示，省略了 <code># </code> 开头的导入：</p>
<img data-src="/2022/06/23/%E3%80%90Rust%E3%80%91Crate-%E5%92%8C-Module/cargo-doc-comment.png" class="">

<p>有时在文档中展示一个完整的示例程序会很有帮助，包括一个 <code>main</code> 函数。 <code>rustdoc</code> 将包含确切字符串 <code>fn main</code> 的任何代码块视为一个完整的程序，并且不会向其中添加任何内容。</p>
<p>如果我们想要实际编译代码块，但又不行让 <code>rust</code> 运行它，可以添加 <code>no_run</code> 标记：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Upload all local terrariums to the online gallery.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```no_run</span></span><br><span class="line"><span class="comment">/// let mut session = fern_sim::connect();</span></span><br><span class="line"><span class="comment">/// session.upload_all();</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">upload_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果也不想编译，那么使用 <code>ignore</code>，而不是 <code>no_run</code>。如果代码块根本不是 <code>Rust</code> 代码，请使用语言的名称，如 <code>c</code> 或 <code>sh</code>，或 <code>text</code>（表示纯文本），它将任何它无法识别的注释视为表明代码块不是 <code>Rust</code>，这会禁用代码高亮和文档测试。</p>
<h3 id="依赖声明"><a href="#依赖声明" class="headerlink" title="依赖声明"></a>依赖声明</h3><p>关于依赖声明，详细请看 <a href="https://www.rustwiki.org.cn/zh-CN/cargo/reference/specifying-dependencies.html"><code>cargo</code> 依赖声明</a>。</p>
<ul>
<li><p><code>image = &quot;0.6.1&quot;</code>：指定版本号，从 <code>crates.io</code> 下载依赖：</p>
</li>
<li><p><code>image = &#123; git = &quot;https://github.com/Piston/image.git&quot;, rev = &quot;528f19c&quot; &#125;</code>：指定版本号和原本下载路径；</p>
</li>
<li><p><code>image = &#123; path = &quot;vendor/image&quot; &#125;</code> 指定包含依赖源代码的相对目录；</p>
</li>
</ul>
<h4 id="依赖版本号"><a href="#依赖版本号" class="headerlink" title="依赖版本号"></a>依赖版本号</h4><p>当我们在 <code>Cargo.toml</code> 文件中写入类似 <code>image = &quot;0.13.0&quot;</code> 的内容时，<code>Cargo</code> 对此的解释相当松散，它使用被认为与 <code>0.13.0</code> 版本兼容的最新版本的 <code>image</code>。兼容性规格改编自 <a href="https://semver.org/lang/zh-CN/">语义化版本 2.0.0</a>。</p>
<ul>
<li><p>以 <code>0.0</code> 开头的版本号非常原始，以至于 <code>Cargo</code> 从不认为它与任何其他版本兼容；</p>
</li>
<li><p>以 <code>0.x</code> 开头的版本号（其中 <code>x</code> 非零）被认为与 <code>0.x</code> 系列中的其他点版本兼容。 我们指定了 <code>image</code> 版本 <code>0.6.1</code>，但如果可用，<code>Cargo</code> 将使用 <code>0.6.3</code>；</p>
</li>
<li><p>一旦项目达到 <code>1.0</code>，由于新的主版本会破坏兼容性。因此，如果要求版本 <code>2.0.1</code>，<code>Cargo</code> 可能会使用 <code>2.17.99</code>，而不是 <code>3.0</code>；</p>
</li>
</ul>
<p>默认情况下，版本号是灵活的，否则使用哪个版本的问题很快就会变得过分约束。假设一个库 <code>libA</code> 使用 <code>num = &quot;0.1.31&quot;</code> 而另一个库 <code>libB</code> 使用 <code>num = &quot;0.1.29&quot;</code>。如果版本号需要完全匹配，则没有项目能够同时使用这两个库，允许 <code>Cargo</code> 使用任何兼容版本是一个更实用的默认设置。</p>
<p>尽管如此，不同的项目在依赖关系和版本控制方面有不同的需求。可以使用运算符指定确切的版本或版本范围：</p>
<table>
<thead>
<tr>
<th align="center"><code>Cargo.toml</code></th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>image = &quot;=0.10.0&quot;</code></td>
<td align="left">完全匹配 <code>0.10.0</code> 版本</td>
</tr>
<tr>
<td align="center"><code>image = &quot;&gt;=1.0.5&quot;</code></td>
<td align="left">使用 <code>1.0.5</code> 或者更高的版本，甚至 <code>2.9</code></td>
</tr>
<tr>
<td align="center"><code>image = &quot;&gt;1.0.5 &lt;1.1.9&quot;</code></td>
<td align="left">使用大于 <code>1.0.5</code> 但小于 <code>1.1.9</code> 的版本</td>
</tr>
<tr>
<td align="center"><code>image = &quot;&lt;=2.7.10&quot;</code></td>
<td align="left">小于 <code>2.7.10</code> 的任何版本</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="left">任何版本</td>
</tr>
</tbody></table>
<h4 id="Cargo-lock"><a href="#Cargo-lock" class="headerlink" title="Cargo.lock"></a><code>Cargo.lock</code></h4><p><code>Cargo.toml</code> 中的版本号很灵活，但我们不希望 <code>Cargo</code> 每次构建时都将我们升级到最新的库版本。因此，<code>Cargo</code> 有一个内置机制来防止这种情况。第一次构建项目时，<code>Cargo</code> 会输出一个 <code>Cargo.lock</code> 文件，该文件记录了它使用的每个 <code>crate</code> 的确切版本。以后的构建将参考这个文件并继续使用相同的版本。<code>Cargo</code> 仅在你告诉它时才升级到较新的版本，通过手动增加 <code>Cargo.toml</code> 文件中的版本号或运行 <code>cargo update</code>：</p>
<pre><code>$ cargo update
Updating registry `https://github.com/rust-lang/crates.io-index`
Updating libc v0.2.7 -&gt; v0.2.11
Updating png v0.4.2 -&gt; v0.4.3
</code></pre>
<p><code>cargo update</code> 仅升级到与在 <code>Cargo.toml</code> 中指定的内容兼容的最新版本。如果你指定了 <code>image = &quot;0.6.1&quot;</code>，并且你想升级到 <code>0.10.0</code> 版本，你必须在 <code>Cargo.toml</code> 中改变它。下次构建时，<code>Cargo</code> 会更新到新版本的镜像库，并将新版本号存储在 <code>Cargo.lock</code> 中。前面的示例显示 <code>Cargo</code> 更新了 <code>crates.io</code> 上托管的两个 <code>crate</code>，存储在 <code>Git</code> 中的依赖项也会发生类似的情况。假设我们的 <code>Cargo.toml</code> 文件包含以下内容：</p>
<pre><code>image = &#123; git = &quot;https://github.com/Piston/image.git&quot;, branch = &quot;master&quot; &#125;
</code></pre>
<p>如果 <code>cargo build</code> 发现我们有一个 <code>Cargo.lock</code> 文件，它不会从 <code>Git</code> 存储库中提取新的更改。而是读取 <code>Cargo.lock</code> 并使用与上次相同的版本。但是 <code>cargo update</code> 将从 <code>master</code> 中提取，以便我们的下一个构建使用最新版本。</p>
<p><code>Cargo.lock</code> 会自动生成，通常不会手动编辑它。如果项目是可执行文件，应该将 <code>Cargo.lock</code> 提交给版本控制。这样，每个人构建的项目都将始终获得相同的版本，<code>Cargo.lock</code> 文件的历史记录将记录你的依赖更新。</p>
<p>如果你的项目是一个普通的 <code>Rust</code> 库，不要提交 <code>Cargo.lock</code>。因为下游项目也拥有 <code>Cargo.lock</code> 文件，其中包含其整个依赖关系图的版本信息，他们会忽略依赖的库中的 <code>Cargo.lock</code> 文件。</p>
<p>在极少数情况下，项目如果是共享库（即输出是 <code>.dll</code>、<code>.dylib</code> 或 <code>.so</code> 文件），没有这样的下游项目，应该提交 <code>Cargo.lock</code>。</p>
<p><code>Cargo.toml</code> 灵活的版本说明符使我们可以轻松地解决依赖之间的兼容性。 <code>Cargo.lock</code> 保证了构建一致性。</p>
<h3 id="发布到-crates-io"><a href="#发布到-crates-io" class="headerlink" title="发布到 crates.io"></a>发布到 crates.io</h3><p>详情请看 <a href="https://www.rustwiki.org.cn/zh-CN/cargo/reference/publishing.html">发布到 crates.io</a>。</p>
<h3 id="工作区间"><a href="#工作区间" class="headerlink" title="工作区间"></a>工作区间</h3><p>详情请看 <a href="https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html">Cargo 工作空间</a>。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>Crate</tag>
        <tag>Module</tag>
        <tag>《Rust 程序设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】Trait和泛型</title>
    <url>/2022/06/20/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>编程中可能经常遇到要用相同的逻辑处理不同的类型，即使这个类型是还没出世的自定义类型。这种能力对于 <code>Rust</code> 来说并不新鲜，它被称为多态性，诞生于 <code>1970</code> 年代的编程语言技术，到现在为止仍然普遍。<code>Rust</code> 支持具有两个相关特性的多态性：<code>Trait</code> 和 泛型。</p>
<p><code>Trait</code> 是 <code>Rust</code> 对接口或抽象基类的对照实现，它们看起来就像 <code>Java</code> 或 <code>C#</code> 中的接口：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>File</code>，<code>TcpStream</code> 以及 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Write"><code>Vec&lt;u8&gt;</code></a> 都实现了 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>std::io::Write</code></a>，这<code>3</code>个类型都提供了 <code>.write()</code>，<code>.flush()</code> 等等方法，我们可以使用 <code>write</code> 方法而不用关心它的实际类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(out: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Write) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    out.<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;hello world\n&quot;</span>)?;</span><br><span class="line">    out.<span class="title function_ invoke__">flush</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;mut dyn Write</code> 的意思是任何实现了 <code>Write</code> 的可变引用，我们可以调用 <code>say_hello</code> 并且给他传递这样一个引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">local_file</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"><span class="title function_ invoke__">say_hello</span>(&amp;<span class="keyword">mut</span> local_file)?; <span class="comment">// works</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bytes</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="title function_ invoke__">say_hello</span>(&amp;<span class="keyword">mut</span> bytes)?; <span class="comment">// also works</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(bytes, <span class="string">b&quot;hello world\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>泛型函数就像 <code>C++</code> 中模板函数，一个泛型函数或者类型可以用于许多不同类型的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Given two values, pick whichever one is less.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>&lt;T: <span class="built_in">Ord</span>&gt;(value1: T, value2: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> value1 &lt;= value2 &#123;</span><br><span class="line">        value1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;T: Ord&gt;</code> 意思是 <code>T</code> 类型必须实现 <code>Ord</code>，这称为边界，因为它设置了 <code>T</code> 可能是哪些类型，编译器为实际使用的每种类型 <code>T</code> 生成自定义机器代码。</p>
<span id="more"></span>


<h3 id="使用-Trait"><a href="#使用-Trait" class="headerlink" title="使用 Trait"></a>使用 <code>Trait</code></h3><p><code>Trait</code> 代表了一种能力，这个类型能做哪些事情，例如：</p>
<ul>
<li><p>实现 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>std::io::Write</code></a> 意味着可以调用 <code>.write()</code> 方法写入字节等；</p>
</li>
<li><p>实现 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a> 可以产生一个序列值；</p>
</li>
<li><p>实现 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>std::clone::Clone</code></a> 可以在内存中 <code>clone</code> 自身；</p>
</li>
<li><p>实现 <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>std::fmt::Debug</code></a> 可以使用 <code>&#123;:?&#125;</code> 打印；</p>
</li>
</ul>
<p>这 <code>4</code> 个 <code>Trait</code> 只是标准库中的一部分，许多标准类型都实现了他们，例如：<code>std::fs::File</code> 实现 <code>Write</code>，<code>Range&lt;i32&gt;(0..10)</code> 实现了 <code>Iterator</code>，有很多类型都实现了 <code>Clone</code> 和 <code>Debug</code>。</p>
<p>关于 <code>Trait</code> 方法有一个不寻常的规则：<code>Trait</code> 本身必须在范围内。否则，它的所有方法都会被隐藏：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">buf.<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;hello&quot;</span>)?; <span class="comment">// error: no method named `write_all`</span></span><br></pre></td></tr></table></figure></div>

<p>正常情况下，编译器会提示我们需要导入 <code>std::io::Write</code>：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">buf.<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;hello&quot;</span>)?; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div>

<p>之所以要这样做，是因为了避免命名冲突，需要导入计划使用的 <code>Trait</code>，因为我们可能为类型实现了多种 <code>Trait</code>，它们都相同的方法名。但如果我们需要导入这两个名称冲突的方法，就需要使用<a href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%B0%83%E7%94%A8">完全限定方法调用</a>，而 <code>Clone</code> 和 <code>Iterator</code> 能正常使用的原因是它们是预导入的。</p>
<h3 id="Trait-对象"><a href="#Trait-对象" class="headerlink" title="Trait 对象"></a><code>Trait</code> 对象</h3><p>在 <code>Rust</code> 中，一个变量的大小必须在编译时就能确定，而 <code>Trait</code> 可以被任何类型实现，所以它们的大小无法确认，类似下面的代码会编译失败：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">writer</span>: <span class="keyword">dyn</span> Write = buf; <span class="comment">// error: `Write` does not have a constant size</span></span><br></pre></td></tr></table></figure></div>

<p>然而一个引用的大小时确定的，我们可以获取 <code>Trait</code> 的引用：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">writer</span>: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Write = &amp;<span class="keyword">mut</span> buf; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div>

<p><code>Trait</code> 类型的引用，如 <code>writer</code>，称为 <mark class="label ">Trait 对象</mark>。 <code>Trait</code> 对象指向某个值，它有生命周期，可以是可变引用或共享引用。<code>Trait</code> 对象的不同之处在于，它包含了一些关于所指对象类型的额外信息，当你调用 <code>writer.write(data)</code> 时，<code>Rust</code> 需要根据 <code>*writer</code> 的类型动态调用正确的 <code>write</code> 方法。<code>Rust</code> 不允许直接查询类型信息，也不支持从 <code>Trait</code> 对象向下转换，<code>&amp;mut dyn</code> 不能转换为 <code>Vec&lt;u8&gt; </code>这样的具体类型。</p>
<p>在内存中，<code>Trait</code> 对象是一个胖指针，由一个指向值的指针和一个指向拥有该值类型方法表的指针组成，因此，每个<code>Trait</code>对象占用两个机器字，下图所示：</p>
<img data-src="/2022/06/20/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/trait-obj-inmem.png" class="">

<p><code>C++</code> 也有这种运行时类型信息，它被称为虚拟表，<code>vtable</code> 是 <code>Rust</code> 的私有实现细节，这些是不可以直接访问的字段和数据结构。当调用<code>Trait</code>对象的方法时语言自动使用 <code>vtable</code> 去决定使用哪个类型。</p>
<p><code>Rust</code> 在需要时会自动将普通引用转换为 <code>Trait</code> 对象， 这就是为什么我们能够在这个例子中将 <code>&amp;mut local_file</code> 传递给 <code>say_hello</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">local_file</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"><span class="title function_ invoke__">say_hello</span>(&amp;<span class="keyword">mut</span> local_file)?;</span><br></pre></td></tr></table></figure>

<p><code>local_file</code> 的类型是 <code>&amp;mut File</code>，<code>say_hello</code> 函数的参数类型是 <code>&amp;mut dyn Write</code>，由于 <code>File</code> 实现了 <code>Write</code>，所以允许自动转换。同样，<code>Rust</code> 也可以将 <code>Box&lt;File&gt;</code> 转换为 <code>Box&lt;dyn Write&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">w</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Write&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(local_file);</span><br></pre></td></tr></table></figure>

<p><code>Box&lt;dyn Write&gt;</code> 和 <code>&amp;mut dyn Write</code> 一样，是一个胖指针：它包含 <code>writer</code> 本身和 <code>vtable</code> 的地址。其他指针类型也是如此，例如 <code>Rc&lt;dyn Write&gt;</code>。</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>首先来看一个普通函数和泛型函数的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(out: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Write) <span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>&lt;W: Write&gt;(out: &amp;<span class="keyword">mut</span> W) <span class="comment">// 泛型函数</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;W: Write&gt;</code> 预示着这个函数是泛型的，<code>W</code> 是一个类型参数，意味着在整个函数体中，类型 <code>W</code> 是实现了 <code>Write</code> 的类型。约定上，类型参数使用单个大写字母表示，而 <code>W</code> 实际代表哪种类型取决于泛型函数的使用方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">say_hello</span>(&amp;<span class="keyword">mut</span> local_file)?; <span class="comment">// calls say_hello::&lt;File&gt;</span></span><br><span class="line"><span class="title function_ invoke__">say_hello</span>(&amp;<span class="keyword">mut</span> bytes)?; <span class="comment">// calls say_hello::&lt;Vec&lt;u8&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们传递给 <code>say_hello</code> 函数 <code>&amp;mut local_file</code>，<code>Rust</code> 就会为 <code>say_hello::&lt;File&gt;()</code> 类型的机器代码，当使用 <code>&amp;mut bytes</code> 时，就会生成<code>say_hello::&lt;Vec&lt;u8&gt;&gt;()</code> 类型的代码。在这两种情况中，<code>W</code> 的类型都会由编译器自动推断，这叫做<mark class="label ">单态化（monomorphization）</mark>。</p>
<p>如果不嫌麻烦，可以显示写出 <code>W</code> 的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">say_hello::&lt;File&gt;(&amp;<span class="keyword">mut</span> local_file)?;</span><br></pre></td></tr></table></figure>

<p>但是，如果你调用的泛型函数没有提供任何可供编译器进行类型推断的信息，就需要显示提供：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calling a generic method collect&lt;C&gt;() that takes no arguments</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = (<span class="number">0</span> .. <span class="number">1000</span>).<span class="title function_ invoke__">collect</span>(); <span class="comment">// 无法进行类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span> = (<span class="number">0</span> .. <span class="number">1000</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v3</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">0</span>..<span class="number">1000</span>).<span class="title function_ invoke__">collect</span>();    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div>

<p>有时候，一个类型可能需要具备多种能力，也就是它得实现多个 <code>Trait</code>，这个时候我们可以使用 <code>+</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::hash::Hash;</span><br><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">top_ten</span>&lt;T: <span class="built_in">Debug</span> + Hash + <span class="built_in">Eq</span>&gt;(values: &amp;<span class="type">Vec</span>&lt;T&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2022/06/20/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/type-parameter-implement-multiple-trait.png" class="">

<p>泛型函数也是可以拥有多个类型参数的，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Run a query on a large, partitioned data set.</span></span><br><span class="line"><span class="comment">/// See &lt;http://research.google.com/archive/mapreduce.html&gt;.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run_query</span>&lt;M: Mapper + Serialize, R: Reducer + Serialize&gt;(</span><br><span class="line">    data: &amp;DataSet,</span><br><span class="line">    map: M,</span><br><span class="line">    reduce: R,</span><br><span class="line">) <span class="punctuation">-&gt;</span> Results &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写会让函数的签名变得很长，看起来不是很顺眼，所以可以使用 <code>where</code> 关键字达到同样的效果，只是将 <code>M</code> 和 <code>R</code> 的边界移动到了后边，让函数签名看起来更加清晰而已：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_query</span>&lt;M, R&gt;(data: &amp;DataSet, map: M, reduce: R) <span class="punctuation">-&gt;</span> Results</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    M: Mapper + Serialize,</span><br><span class="line">    R: Reducer + Serialize,</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型函数的参数有引用时，可能需要显示使用生命周期参数，这种情况需要把生命周期写在最前面：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Return a reference to the point in `candidates` that&#x27;s</span></span><br><span class="line"><span class="comment">/// closest to the `target` point.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">nearest</span>&lt;<span class="symbol">&#x27;t</span>, <span class="symbol">&#x27;c</span>, P&gt;(target: &amp;<span class="symbol">&#x27;t</span> P, candidates: &amp;<span class="symbol">&#x27;c</span> [P]) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> P</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: MeasureDistance,</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生命周期参数不会影响函数的机器代码生成，只有不同的类型 <code>P</code> 才会导致编译器生成不同的 <code>nearest</code> 版本。</p>
<p>即使结构体不是泛型，它的方法也可以是泛型的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PancakeStack</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>&lt;T: Topping&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, goop: T) <span class="punctuation">-&gt;</span> PancakeResult&lt;()&gt; &#123;</span><br><span class="line">        goop.<span class="title function_ invoke__">pour</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">absorb_topping</span>(goop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型别名也可以是泛型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PancakeResult</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, PancakeError&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="泛型-or-Trait"><a href="#泛型-or-Trait" class="headerlink" title="泛型 or Trait"></a>泛型 <code>or Trait</code></h3><p><code>Trait</code> 解决的问题是像什么，它能代表一类对象，这一类对象都有相同的行为；而泛型解决的问题是解决重复编码，更像是一个代码模板，泛型类型可以使用 <code>Trait</code> 作为边界。</p>
<p>对于代码体积来说，由于泛型更像是代码模板，所以在编译时更具会对不同类型生成真正的代码，代码体积会增大，但是运行速度会更快，而 <code>Trait</code> 对象只有在实际运行时才能确定其真正的类型。</p>
<h3 id="定义实现-Trait"><a href="#定义实现-Trait" class="headerlink" title="定义实现 Trait"></a>定义实现 <code>Trait</code></h3><p>定义 <code>Trait</code> 相对比较简单，有两个必须的信息，名称和方法签名列表：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A trait for characters, items, and scenery -</span></span><br><span class="line"><span class="comment">/// anything in the game world that&#x27;s visible on screen.</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Visible</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Render this object on the given canvas.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>, canvas: &amp;<span class="keyword">mut</span> Canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return true if clicking at (x, y) should</span></span><br><span class="line">    <span class="comment">/// select this object.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hit_test</span>(&amp;<span class="keyword">self</span>, x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要为类型实现 <code>Trait</code>，需要使用 <code>impl TraitName for Type</code> 的语法，这里只包含 <code>Type</code> 为 <code>TraitName</code> 实现的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Visible</span> <span class="keyword">for</span> <span class="title class_">Broom</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>, canvas: &amp;<span class="keyword">mut</span> Canvas) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">y</span> <span class="keyword">in</span> <span class="keyword">self</span>.y - <span class="keyword">self</span>.height - <span class="number">1</span>..<span class="keyword">self</span>.y &#123;</span><br><span class="line">            canvas.<span class="title function_ invoke__">write_at</span>(<span class="keyword">self</span>.x, y, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.<span class="title function_ invoke__">write_at</span>(<span class="keyword">self</span>.x, <span class="keyword">self</span>.y, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hit_test</span>(&amp;<span class="keyword">self</span>, x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x == x &amp;&amp; <span class="keyword">self</span>.y - <span class="keyword">self</span>.height - <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= <span class="keyword">self</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trait-默认方法"><a href="#Trait-默认方法" class="headerlink" title="Trait 默认方法"></a><code>Trait</code> 默认方法</h3><p><code>Trait</code> 中可以不止包含方法签名列表，也可以包含方法的实现，如果类型没有重新实现方法，在调用的时候，会选择 <code>Trait</code> 的默认实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bytes_written</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> bytes_written &lt; buf.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            bytes_written += <span class="keyword">self</span>.<span class="title function_ invoke__">write</span>(&amp;buf[bytes_written..])?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Write</code> 默认实现了 <code>write_all</code> 方法，在为自定义类型实现时，如果没有重新实现，就会选择这个 <code>write_all</code> 。</p>
<h3 id="Trait-实现限制"><a href="#Trait-实现限制" class="headerlink" title="Trait 实现限制"></a><code>Trait</code> 实现限制</h3><p>只要类型或者 <code>Trait</code> 是当前 <code>crate</code> 引入的，就可以：</p>
<ol>
<li><p>为其他任何类型实现当前 <code>crate</code> 中的 <code>Trait</code>；</p>
</li>
<li><p>或者为当前 <code>crate</code> 中的类型实现任何 <code>Trait</code>；</p>
</li>
</ol>
<p>例如，我们可以为标准库 <code>char</code> 类型实现我们自定义的 <code>IsEmoji</code>，只要 <code>IsEmoji</code> 在作用域之内就可以使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">IsEmoji</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_emoji</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Implement IsEmoji for the built-in character type.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IsEmoji</span> <span class="keyword">for</span> <span class="title class_">char</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_emoji</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法扩展"><a href="#方法扩展" class="headerlink" title="方法扩展"></a>方法扩展</h3><p>还可以对某类已存在类型一次性扩展多个方法，通过一个 <mark class="label ">泛型impl块</mark>，这里，为所有实现了 <code>Write</code> 的类型添加 <code>write_html</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Trait for values to which you can send HTML.</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">WriteHtml</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_html</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, html: &amp;HtmlDocument) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// You can write HTML to any std::io writer.</span></span><br><span class="line"><span class="keyword">impl</span>&lt;W: Write&gt; WriteHtml <span class="keyword">for</span> <span class="title class_">W</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_html</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, html: &amp;HtmlDocument) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，标准库中为所有实现了 <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code>From</code></a> 的类型自动实现了 <a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code>Into</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[rustc_const_unstable(feature = <span class="string">&quot;const_convert&quot;</span>, issue = <span class="string">&quot;88674&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; <span class="keyword">const</span> <span class="built_in">Into</span>&lt;U&gt; <span class="keyword">for</span> <span class="title class_">T</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    U: ~<span class="keyword">const</span> <span class="built_in">From</span>&lt;T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// Calls `U::from(self)`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// That is, this conversion is whatever the implementation of</span></span><br><span class="line">    <span class="comment">/// &lt;code&gt;[From]&amp;lt;T&amp;gt; for U&lt;/code&gt; chooses to do.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> U &#123;</span><br><span class="line">        U::<span class="title function_ invoke__">from</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，当实现一个 <code>Trait</code> 的时候，<code>Trait</code> 或者类型必须要有是当前 <code>crate</code> 中，这称之为<strong>孤儿原则</strong>，它确保 <code>Trait</code> 实现是唯一的，所以不能为 <code>u8</code> 实现 <code>Write</code>，因为它两都是标准库中的。</p>
<h3 id="Trait-中的-Self"><a href="#Trait-中的-Self" class="headerlink" title="Trait 中的 Self"></a><code>Trait</code> 中的 <code>Self</code></h3><p>在 <code>Trait</code> 的方法定义中可以使用 <code>Self</code> 关键字，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Spliceable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">splice</span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Spliceable</span> <span class="keyword">for</span> <span class="title class_">CherryTree</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">splice</span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Spliceable</span> <span class="keyword">for</span> <span class="title class_">Mammoth</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">splice</span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一个 <code>impl</code> 中，<code>Self</code> 表示 <code>CherryTree</code>，在第二个 <code>impl</code> 中，<code>Self</code> 表示 <code>Mammoth</code>，而且 <code>self</code> 和 <code>other</code> 的类型必须匹配。但是如果 <code>Trait</code> 中包含了 <code>Self</code>，就和 <code>Trait</code> 对象不兼容，因为在编译时，<code>Rust</code> 不能确定 <code>Trait</code> 对象背后的实际类型，所以下面的代码会编译失败，因为 <code>Rust</code> 不知道 <code>left</code> 和 <code>right</code> 是否是相同类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error: the trait `Spliceable` cannot be made into an object</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">splice_anything</span>(left: &amp;<span class="keyword">dyn</span> Spliceable, right: &amp;<span class="keyword">dyn</span> Spliceable) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">combo</span> = left.<span class="title function_ invoke__">splice</span>(right);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要 <code>splice</code> 函数能够处理兼容处理不同类型，我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">MegaSpliceable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">splice</span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">dyn</span> MegaSpliceable) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MegaSpliceable&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子Trait"><a href="#子Trait" class="headerlink" title="子Trait"></a>子<code>Trait</code></h3><p><code>Trait</code> 之间可以扩展，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Creature</span>: Visible &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">facing</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Direction;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每个想实现 <code>Creature</code> 的类型就必须实现 <code>Visible</code>，我们将 <code>Creature</code> 称作 <code>Visible</code> 的 **子 <code>Trait</code>**，或者将 <code>Visible</code> 称作 <code>Creature</code> 的 <strong>父<code>Trait</code><strong>，但是</strong>子 <code>Trait</code></strong> 不能继承 <strong>父<code>Trait</code></strong> 的关联项。另外如果想调用 <code>Trait</code> 的方法，依然需要每个 <code>Trait</code> 都在作用域内。</p>
<p>其实 <code>trait Creature: Visible</code> 只是下面的简写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Creature</span> <span class="keyword">where</span> <span class="keyword">Self</span>: Visible &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trait-的关联函数"><a href="#Trait-的关联函数" class="headerlink" title="Trait 的关联函数"></a><code>Trait</code> 的关联函数</h3><p>大多数面向对象语言中，接口是不可以包含静态方法或者构造函数的，但是 <code>Rust</code> 的 <code>Trait</code> 可以包含静态类型方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">StringSet</span> &#123;</span><br><span class="line">    <span class="comment">/// 返回空的set</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return a set that contains all the strings in `strings`.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_slice</span>(strings: &amp;[&amp;<span class="type">str</span>]) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Find out if this set contains a particular `value`.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, string: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Add a string to this set.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, string: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new</code> 和 <code>from_slice</code> 没有将 <code>self</code> 作为第一个参数，它们就像构造函数。每个实现 <code>StringSet</code> 的类型必须实现关联的静态方法。在非泛型代码中，这些函数可以使用 <code>::</code> 调用&#x3D;类型关联函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create sets of two hypothetical types that impl StringSet:</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">set1</span> = SortedStringSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">set2</span> = HashedStringSet::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>在泛型代码中也是一样的，有区别的是，类型通常是一个类型变量，例如，<code>S::new()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Return the set of words in `document` that aren&#x27;t in `wordlist`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">unknown_words</span>&lt;S: StringSet&gt;(document: &amp;[<span class="type">String</span>], wordlist: &amp;S) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">unknowns</span> = S::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> document &#123;</span><br><span class="line">        <span class="keyword">if</span> !wordlist.<span class="title function_ invoke__">contains</span>(word) &#123;</span><br><span class="line">            unknowns.<span class="title function_ invoke__">add</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unknowns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Trait</code> 对象不支持类型关联的函数，如果你想使用 <code>&amp;dyn StringSet</code>，即 <code>Trait</code> 对象，你必须改变 <code>Trait</code>，给那些没有将 <code>self</code> 作为参数的关联函数添加边界 <code>where Self: Sized</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">StringSet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_slice</span>(strings: &amp;[&amp;<span class="type">str</span>]) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, string: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, string: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个边界告诉<code>Rust</code>，<code>Trait</code> 对象可以不支持这个特定的关联函数。有了这些补充，虽然 <code>StringSet</code> 的 <code>Trait</code>对象仍然不支持<code>new</code>或<code>from_slice</code>，但可以创建它们并使用它们来调用<code>.contains()</code>和<code>.add()</code>。</p>
<h3 id="完全限定调用"><a href="#完全限定调用" class="headerlink" title="完全限定调用"></a>完全限定调用</h3><p>当调用 <code>&quot;hello&quot;.to_string()</code> 的时候，<code>Rust</code> 会根据方法查找算法进行方法查找，这里的 <code>to_string()</code> 实际上引用到了 <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> <code>Trait</code> 的方法。下面的四种方法是等价的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="type">str</span>::<span class="title function_ invoke__">to_string</span>(<span class="string">&quot;hello&quot;</span>);                <span class="comment">// 限定类型</span></span><br><span class="line"><span class="built_in">ToString</span>::<span class="title function_ invoke__">to_string</span>(<span class="string">&quot;hello&quot;</span>);           <span class="comment">// 限定Trait</span></span><br><span class="line">&lt;<span class="type">str</span> <span class="keyword">as</span> <span class="built_in">ToString</span>&gt;::<span class="title function_ invoke__">to_string</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 限定类型和Trait，完全限定</span></span><br></pre></td></tr></table></figure>

<p>其中最后一种称之为<strong>完全限定语法</strong>，通过这个语法，可以明确知道调用哪个方法，这在下面这些场景中非常有用：</p>
<ul>
<li><p>当两个方法有相同的名称时，调用就会有歧义，可以通过限定类型或者指定 <code>Trait</code> 来具体说明：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">outlaw.<span class="title function_ invoke__">draw</span>(); <span class="comment">// 不知道调用哪个？</span></span><br><span class="line"></span><br><span class="line">Visible::<span class="title function_ invoke__">draw</span>(&amp;outlaw); <span class="comment">// ok: draw on screen</span></span><br><span class="line">HasPistol::<span class="title function_ invoke__">draw</span>(&amp;outlaw); <span class="comment">// ok: corral</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当 <code>self</code> 参数类型不能推断时：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">zero</span> = <span class="number">0</span>; <span class="comment">// type unspecified; could be `i8`, `u8`, ...</span></span><br><span class="line">zero.<span class="title function_ invoke__">abs</span>(); <span class="comment">// error: can&#x27;t call method `abs`</span></span><br><span class="line"><span class="comment">// on ambiguous numeric type</span></span><br><span class="line"><span class="type">i64</span>::<span class="title function_ invoke__">abs</span>(zero); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用函数本身作为函数值时：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">words</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; =</span><br><span class="line">    line.<span class="title function_ invoke__">split_whitespace</span>() <span class="comment">// iterator produces &amp;str values</span></span><br><span class="line">        .<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string) <span class="comment">// ok</span></span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在宏中调用 <code>Trait</code> 方法时；</p>
</li>
</ul>
<h3 id="Trait-关联类型"><a href="#Trait-关联类型" class="headerlink" title="Trait 关联类型"></a><code>Trait</code> 关联类型</h3><p><code>Trait</code> 内部也可以定义类型，用于类型之间相互交互，例如 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">std::iter::Iterator</a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">std::ops::Mul</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Mul</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mul</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中的 <code>type Item;</code> 是一个关联类型，每个实现 <code>Iterator</code> 的类型必须声明 <code>Item</code> 的具体类型，<code>next</code> 的返回值用了 <code>Item</code> 关联类型，这里写作 <code>Self::Item</code> 表明他不是一个普通类型，而是和每个实现 <code>Iterator</code> 的类型相关。</p>
<p>我们可以看到 <a href="https://doc.rust-lang.org/std/env/struct.Args.html#impl-Iterator"><code>std::env::Args</code></a> 的实现，在这里的实现中，<code>Item</code> 的类型是 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">map</span>(|s| s.<span class="title function_ invoke__">into_string</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型代码也可以使用 <code>Trait</code> 的关联类型，在 <code>collect_into_vector</code> 的返回值中，我们必须使用 <code>Vec&lt;I::Item&gt;</code> 而不能是 <code> Vec&lt;I</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Loop over an iterator, storing the values in a new vector.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">collect_into_vector</span>&lt;I: <span class="built_in">Iterator</span>&gt;(iter: I) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;I::Item&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">value</span> <span class="keyword">in</span> iter &#123;</span><br><span class="line">        results.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以指定关联类型的边界，如果不指定，我们可能会遇到问题，我们想打印出 <code>Iterator</code> 的每个值，但是编译器会提示我们 <code>&lt;I as Iterator&gt;::Item</code> 没有实现 <code>Debug</code>：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print out all the values produced by an iterator</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dump</span>&lt;I&gt;(iter: I)</span><br><span class="line">    <span class="keyword">where</span> I: <span class="built_in">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (index, value) <span class="keyword">in</span> iter.<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, index, value);  <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>鉴于此错误，我们要么指定 <code>&lt;I as Iterator&gt;::Item</code> 的边界，要么指定它的具体类型：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print out all the values produced by an iterator</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dump</span>&lt;I&gt;(iter: I)</span><br><span class="line">    <span class="keyword">where</span> I: <span class="built_in">Iterator</span>, I::Item: <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (index, value) <span class="keyword">in</span> iter.<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, index, value);  <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print out all the values produced by an iterator</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dump</span>&lt;I&gt;(iter: I)</span><br><span class="line">    <span class="keyword">where</span> I: <span class="built_in">Iterator</span>&lt;Item=<span class="type">String</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (index, value) <span class="keyword">in</span> iter.<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, index, value);  <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>后面这个语法可用于任何 <code>Trait</code> 名称可以使用的地方被使用，包括 <code>Trait</code> 对象类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dump</span>(iter: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> <span class="built_in">Iterator</span>&lt;Item=<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (index, s) <span class="keyword">in</span> iter.<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, index, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型-Trait"><a href="#泛型-Trait" class="headerlink" title="泛型 Trait"></a>泛型 <code>Trait</code></h3><p><code>Trait</code> 也可以是泛型的，例如<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>std::ops::Mul</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Mul</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mul</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的类型参数和在结构体或函数上的意思是一样的：<code>Mul</code> 是泛型 <code>Trait</code>，它的实例 <code>Mul&lt;f64&gt;</code>、<code>Mul&lt;String&gt;</code>、<code>Mul&lt;Size&gt;</code> 等都是不同的 <code>Trait</code>。</p>
<p>之前说我们实现 <code>Trait</code> 时，<code>Trait</code> 或者类型必须要有一个是当前 <code>crate</code> 中的。假设我们有自己的结构体 <code>Number</code>，我们完全可以为 <code>f64</code> 实现 <code>Mul&lt;Number&gt;</code>，以支持 <code>f64 * Number</code>，即使 <code>Mul</code> 和 <code>f64</code> 不是我们 <code>crate</code> 的，但是 <code>Mul&lt;Number&gt;</code> 是我们自己定义的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Mul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    num: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Mul</span>&lt;Number&gt; <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">f64</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mul</span>(<span class="keyword">self</span>, rhs: Number) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span> * rhs.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">left</span> = <span class="number">0.5f64</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = Number &#123; num: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:&#125;&quot;</span>, left * number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="impl-Trait"><a href="#impl-Trait" class="headerlink" title="impl Trait"></a><code>impl Trait</code></h3><p>许多泛型类型的组合可能会使代码变得混乱，例如，使用标准库几个迭代器会使代码的返回类型变得异常复杂：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter;</span><br><span class="line"><span class="keyword">use</span> std::vec::IntoIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cyclical_zip</span>(v: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, u: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;<span class="type">u8</span>&gt;, IntoIter&lt;<span class="type">u8</span>&gt;&gt;&gt; &#123;</span><br><span class="line">    v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">chain</span>(u.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">cycle</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>Trait</code> 对象替换这个看起来很复杂的返回值类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">cyclical_zip</span>(v: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, u: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Iterator</span>&lt;Item=<span class="type">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">chain</span>(u.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">cycle</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个返回值每次都要在堆中重新申请内存，也是有代价的。因此，<code>Rust</code> 专门为这种情况提供了 <code>impl Trait</code> 这种语法，只指定它实现的一个或多个<code>Trait</code>，而无需动态调度或堆分配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">cyclical_zip</span>(v: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, u: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">u8</span>&gt; &#123;</span><br><span class="line">    v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">chain</span>(u.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">cycle</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们不能通过这个实现在运行时动态返回不同类型的函数，错误是很明显的，<code>Rust</code> 需要在编译的时候就知道返回值的大小，并且分配大小正确的空间，这里返回三个不同类型，<code>Rust</code> 就不知道怎么做了：</p>
<details class="note danger"><summary><p>查看错误示例</p>
</summary>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">0f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Triangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">0f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">0f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_shape</span>(shape: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> shape &#123;</span><br><span class="line">        <span class="string">&quot;triangle&quot;</span> =&gt; Triangle::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        <span class="string">&quot;shape&quot;</span> =&gt; Rectangle::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        _ =&gt; Circle::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>正确的修改方法是：</p>
<details class="note success"><summary><p>查看正确示例</p>
</summary>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">0f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Triangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">0f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="number">0f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_shape</span>(shape: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Shape&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> shape &#123;</span><br><span class="line">        <span class="string">&quot;triangle&quot;</span> =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Triangle::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        <span class="string">&quot;shape&quot;</span> =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Rectangle::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        _ =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Circle::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>更多可以查看 <a href="https://www.rustwiki.org.cn/zh-CN/rust-by-example/trait/dyn.html">使用 dyn 返回 trait</a>。</p>

</details>

<p>需要注意的是，<code>Rust</code> 不允许 <code>Trait</code> 方法使用 <code>impl Trait</code> 返回值，只有自由函数和与类型关联的函数才能使用 <code>impl Trait</code> 返回。<code>impl Trait</code> 也可以用在接受泛型参数的函数中。例如，下面两个函数的实现等价：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>&lt;T: Display&gt;(val: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(val: <span class="keyword">impl</span> <span class="title class_">Display</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个重要的例外，使用泛型函数允许函数调用者声明泛型参数类型，例如：<code>print::&lt;i32&gt;(42)</code>，但是当使用 <code>impl Trait</code> 是不允许的。</p>
<p>每个 <code>impl Trait</code> 参数都分配有自己的匿名类型参数，因此参数是 <code>impl Trait</code> 仅限于简单的泛型函数，类型和参数之间没有关系的。</p>
<h3 id="关联常量"><a href="#关联常量" class="headerlink" title="关联常量"></a>关联常量</h3><p>像结构体和枚举一样，<code>Trait</code> 也可以有关联的常量，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Greet</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> GREETING: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联的常量可以只声明而不用给值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Float</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ZERO: <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">const</span> ONE: <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在实现的时候再定义这些值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Float</span> <span class="keyword">for</span> <span class="title class_">f32</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ZERO: <span class="type">f32</span> = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">const</span> ONE: <span class="type">f32</span> = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Float</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ZERO: <span class="type">f64</span> = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">const</span> ONE: <span class="type">f64</span> = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这允许我们定义这样的泛型函数，以使用这些常量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>&lt;T: Float + Add&lt;Output=T&gt;&gt;(value: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    value + T::ONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，关联常量不能与 <code>Trait</code> 对象一起使用，因为编译器依赖于有关实现的类型信息以便在编译时选择正确的值。即使是一个根本没有行为的简单 <code>Trait</code>，比如 <code>Float</code>，也可以提供足够的关于类型的信息，结合一些运算符，来实现常见的数学函数，比如 <code>Fibonacci</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fib</span>&lt;T: Float + Add&lt;Output=T&gt;&gt;(n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; T::ZERO,</span><br><span class="line">        <span class="number">1</span> =&gt; T::ONE,</span><br><span class="line">        n =&gt; fib::&lt;T&gt;(n - <span class="number">1</span>) + fib::&lt;T&gt;(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="步步为营"><a href="#步步为营" class="headerlink" title="步步为营"></a>步步为营</h3><p>假设我们写了一个函数用于求和两个 <code>&amp;[i64]</code> 的和，代码可能看起来是这个样子的，代码也可以正常运行：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dot</span>(v1: &amp;[<span class="type">i64</span>], v2: &amp;[<span class="type">i64</span>]) <span class="punctuation">-&gt;</span> <span class="type">i64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span> .. v1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        total = total + v1[i] * v2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现在假设我们又想实现两个 <code>&amp;[f64]</code> 的和，我们可以第一步想到的是改成泛型函数：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dot</span>&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) <span class="punctuation">-&gt;</span> N &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span>: N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span> .. v1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        total = total + v1[i] * v2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但这肯定不定，类型 <code>N</code> 必须支持 <code>+</code> 和 <code>*</code> 运算。另外由于 <code>0</code> 是整数，不是浮点数，当 <code>N</code> 代表 <code>f64</code> 是依然不对，所以我们可以改成这个样子，对 <code>N</code> 进行边界限定：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::&#123;Add, Mul&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dot</span>&lt;N: Add&lt;Output = N&gt; + Mul&lt;Output = N&gt; + <span class="built_in">Default</span>&gt;(v1: &amp;[N], v2: &amp;[N]) <span class="punctuation">-&gt;</span> N &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = N::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..v1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        total = total + v1[i] * v2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于看起来很丑陋，所以我们对它进行美化，但还是编译不过：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::&#123;Add, Mul&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dot</span>&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) <span class="punctuation">-&gt;</span> N</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    N: Add&lt;Output = N&gt; + Mul&lt;Output = N&gt; + <span class="built_in">Default</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = N::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..v1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        total = total + v1[i] * v2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>&amp;v1[N]</code> 没有实现 <code>Copy</code>，<code>v1[i]</code> 会转移所有权：</p>
<pre><code>    error[E0508]: cannot move out of type `[N]`, a non-copy slice
    --&gt; src/main.rs:11:25
    |
    11 |         total = total + v1[i] * v2[i];
    |                         ^^^^^
    |                         |
    |                         cannot move out of here
    |                         move occurs because `v1[_]` has type `N`, which does not implement the `Copy` trait

    error[E0508]: cannot move out of type `[N]`, a non-copy slice
    --&gt; src/main.rs:11:33
    |
    11 |         total = total + v1[i] * v2[i];
    |                                 ^^^^^
    |                                 |
    |                                 cannot move out of here
    |                                 move occurs because `v2[_]` has type `N`, which does not implement the `Copy` trait
</code></pre>
</div>


<p>所以我们接着改，这次改对了：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::&#123;Add, Mul&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dot</span>&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) <span class="punctuation">-&gt;</span> N</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    N: Add&lt;Output = N&gt; + Mul&lt;Output = N&gt; + <span class="built_in">Default</span> + <span class="built_in">Copy</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = N::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..v1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        total = total + v1[i] * v2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">dot</span>(&amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], &amp;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">dot</span>(</span><br><span class="line">            &amp;[<span class="number">1.01f64</span>, <span class="number">2.02f64</span>, <span class="number">3f64</span>, <span class="number">4f64</span>],</span><br><span class="line">            &amp;[<span class="number">1.01f64</span>, <span class="number">2.02f64</span>, <span class="number">3f64</span>, <span class="number">4f64</span>]</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">30.1005f64</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>虽然结局看起来不错，但是我们是跟着编译器提示把 <code>N</code> 的边界给找出来。就这个问题而言，我们可以使用 <code>num</code> 这个 <code>crate</code>，看起来很简洁：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::Num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dot</span>&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) <span class="punctuation">-&gt;</span> N</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    N: Num + <span class="built_in">Copy</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = N::<span class="title function_ invoke__">zero</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..v1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        total = total + v1[i] * v2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>Rust</code> 目前还不支持在 <code>trait</code> 里使用 <code>impl trait</code> 做返回值：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">ImplTrait</span> &#123;</span><br><span class="line">    <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">impl_in_args</span>(s: <span class="keyword">impl</span> <span class="title class_">Into</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">impl_as_return</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Into</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>Trait</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】anyhow &amp; thiserror</title>
    <url>/2022/04/11/%E3%80%90Rust%E3%80%91anyhow-and-thiserror/</url>
    <content><![CDATA[<p><code>Rust</code> 中使用 <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>std::result::Result</code></a> 表示可能出错的操作，成功的时候是 <code>Ok(T)</code>，而出错的时候则是 <code>Err(E)</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>E</code> 是实现 <a href="https://doc.rust-lang.org/stable/std/error/trait.Error.html"><code>std::error::Error</code></a> 的错误类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Error</span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">source</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;(<span class="keyword">dyn</span> Error + <span class="symbol">&#x27;static</span>)&gt; &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">backtrace</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;Backtrace&gt; &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">dyn</span> Error&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通常也需要在自己的代码中自定义错误，并且为之手动实现 <code>std::error::Error</code>，这个工作很麻烦，所以就有了 <code>thiserror</code>，自动帮我们生成实现的 <code>std::error::Error</code> 的代码。</p>
<p>而借助于 <code>anyhow::Error</code>，和与之对应的 <code>Result&lt;T, anyhow::Error&gt;</code>，等价于 <code>anyhow::Result&lt;T&gt;</code>，我们可以使用 <code>?</code> 在可能失败的函数中传播任何实现了 <code>std::error::Error</code> 的错误。</p>
<span id="more"></span>

<h3 id="thiserror"><a href="#thiserror" class="headerlink" title="thiserror"></a><code>thiserror</code></h3><p>可以使用命令 <code>cargo add thiserror</code> 将它添加到自己的项目中，或者在 <code>Cargo.toml</code> 中添加如下的配置：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">thiserror</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>thiserror</code> 可以用于枚举或者结构体，例如，我们来看一个基本的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">DataStoreError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;data store disconnected&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Disconnect</span>(<span class="meta">#[from]</span> std::io::Error),</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;the data for key `&#123;0&#125;` is not available&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Redaction</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;invalid header (expected &#123;expected:?&#125;, found &#123;found:?&#125;)&quot;</span>)]</span></span><br><span class="line">    InvalidHeader &#123; expected: <span class="type">String</span>, found: <span class="type">String</span> &#125;,</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;unknown data store error&quot;</span>)]</span></span><br><span class="line">    Unknown,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="error"><a href="#error" class="headerlink" title="#[error]"></a><code>#[error]</code></h4><p>如果使用 <code>#[error(...)]</code> 为结构体或者枚举生成自定义错误消息，这将为它们实现 <code>Display</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="meta">#[error(<span class="string">&quot;something failed, msg is: &#123;msg&#125;&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    msg: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在错误中插入字段的简写，一共有四种形式：</p>
<ol>
<li><code>#[error(&quot;&#123;var&#125;&quot;)]   &lt;=&gt; write!(&quot;&#123;&#125;&quot;, self.var)</code></li>
<li><code>#[error(&quot;&#123;0&#125;&quot;)]     &lt;=&gt; write!(&quot;&#123;&#125;&quot;, self.0)</code></li>
<li><code>#[error(&quot;&#123;var:?&#125;&quot;)] &lt;=&gt; write!(&quot;&#123;:?&#125;&quot;, self.var)</code></li>
<li><code>#[error(&quot;&#123;0:?&#125;&quot;)]   &lt;=&gt; write!(&quot;&#123;:?&#125;&quot;, self.0)</code></li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">first_char</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s.<span class="title function_ invoke__">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Limits</span> &#123;</span><br><span class="line">    lo: <span class="type">i16</span>,</span><br><span class="line">    hi: <span class="type">i16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;invalid rdo_lookahead_frames &#123;0&#125; (expected &lt; &#123;&#125;)&quot;</span>, i32::MAX)]</span></span><br><span class="line">    <span class="title function_ invoke__">InvalidLookahead</span>(<span class="type">u32</span>),</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;first letter must be lowercase but was &#123;:?&#125;&quot;</span>, first_char(.0))]</span></span><br><span class="line">    <span class="title function_ invoke__">WrongCase</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;invalid index &#123;idx&#125;, expected at least &#123;&#125; and at most &#123;&#125;&quot;</span>, .limits.lo, .limits.hi)]</span></span><br><span class="line">    OutOfBounds &#123; idx: <span class="type">usize</span>, limits: Limits &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="from"><a href="#from" class="headerlink" title="#[from]"></a><code>#[from]</code></h4><p>可以使用 <code>#[from]</code> 注解为错误类型实现 <code>From</code>，可以从其他错误生成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="meta">#![feature(backtrace)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::backtrace;</span><br><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> _;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="meta">#[error(<span class="string">&quot;some io error happened, &#123;:?&#125;&quot;</span>, .source)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="meta">#[from]</span></span><br><span class="line">    source: io::Error,</span><br><span class="line">    backtrace: backtrace::Backtrace,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err</span> = MyError::<span class="title function_ invoke__">from</span>(io::Error::<span class="title function_ invoke__">from</span>(io::ErrorKind::TimedOut));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, err.<span class="title function_ invoke__">source</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="source"><a href="#source" class="headerlink" title="#[source]"></a><code>#[source]</code></h4><p>可以使用 <code>#[source]</code> 属性，或者将字段命名为 <code>source</code>，可为自定义错误实现 <code>source</code> 方法，返回底层的错误类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;some io error happened, &#123;:?&#125;&quot;</span>, .source)]</span></span><br><span class="line">    IO &#123; source: io::Error &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err</span> = MyError::IO &#123;</span><br><span class="line">        source: io::Error::<span class="title function_ invoke__">from</span>(io::ErrorKind::TimedOut),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, err.<span class="title function_ invoke__">source</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>#[source]</code> 属性标记非 <code>source</code> 的字段，例如：这里是 <code>err</code> 字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;some io error happened, &#123;:?&#125;&quot;</span>, .err)]</span></span><br><span class="line">    IO &#123;</span><br><span class="line">        <span class="meta">#[source]</span></span><br><span class="line">        err: io::Error,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err</span> = MyError::IO &#123;</span><br><span class="line">        err: io::Error::<span class="title function_ invoke__">from</span>(io::ErrorKind::TimedOut),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, err.<span class="title function_ invoke__">source</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#[from]</code> 和 <code>#[source]</code> 二选一即可，<code>#[from]</code> 也会为类型生成 <code>.source()</code> 方法，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="meta">#![feature(backtrace)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::backtrace;</span><br><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> _;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="meta">#[error(<span class="string">&quot;some io error happened, &#123;:?&#125;&quot;</span>, .source)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="meta">#[from]</span></span><br><span class="line">    source: io::Error,</span><br><span class="line">    backtrace: backtrace::Backtrace,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err</span> = MyError::<span class="title function_ invoke__">from</span>(io::Error::<span class="title function_ invoke__">from</span>(io::ErrorKind::TimedOut));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, err.<span class="title function_ invoke__">source</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="backtrace"><a href="#backtrace" class="headerlink" title="#[backtrace]"></a><code>#[backtrace]</code></h4><p>只要在我们的错误结构体里面放个类型为 <code>std::backtrace::Backtrace</code> 的字段，就会自动实现 <code>backtrace()</code> 方法，可以看 <a href="#from"><code>#[from]</code></a>。</p>
<p>另外，如果使用 <code>#[backtrace]</code> 标记 <code>source</code>（<code>source</code>字段，或者 <code>#[source]</code>，或者 <code>#[from]</code>），那么 <code>backtrace()</code> 方法会转发到 <code>source</code> 的 <code>backtrace</code>。</p>
<p>文档里面的例子（没理解，以后再来改）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    Io &#123;</span><br><span class="line">        <span class="meta">#[backtrace]</span></span><br><span class="line">        source: io::Error,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="error-transparent"><a href="#error-transparent" class="headerlink" title="#[error(transparent)]"></a><code>#[error(transparent)]</code></h4><p>可以通过 <code>#[error(transparent)]</code> 让 <code>source</code> 和 <code>Display</code> 直接使用底层的错误，这对于那些想处理任何的枚举来说是很有用的：</p>
<div class="tabs" id="error(transparent)"><ul class="nav-tabs"><li class="tab active"><a href="#error(transparent)-1">示例一</a></li><li class="tab"><a href="#error(transparent)-2">示例二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="error(transparent)-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> anyhow::anyhow;</span><br><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> _;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="meta">#[error(transparent)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="meta">#[from]</span></span><br><span class="line">    source: anyhow::Error,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err</span> = MyError::<span class="title function_ invoke__">from</span>(anyhow!(<span class="string">&quot;Missing attribute: &#123;&#125;&quot;</span>, <span class="string">&quot;field1&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="error(transparent)-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> anyhow::anyhow;</span><br><span class="line"><span class="keyword">use</span> std::error::&#123;<span class="keyword">self</span>, Error <span class="keyword">as</span> _&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;file not found&quot;</span>)]</span></span><br><span class="line">    FileNotFound,</span><br><span class="line">    <span class="meta">#[error(transparent)]</span></span><br><span class="line">    <span class="title function_ invoke__">Other</span>(<span class="meta">#[from]</span> anyhow::Error), <span class="comment">// source and Display delegate to anyhow::Error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err</span> = MyError::<span class="title function_ invoke__">from</span>(anyhow!(<span class="string">&quot;Missing attribute: &#123;&#125;&quot;</span>, <span class="string">&quot;field1&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="anyhow"><a href="#anyhow" class="headerlink" title="anyhow"></a><code>anyhow</code></h3><p><a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html"><code>anyhow::Error</code></a> 是这个 <code>crate</code> 中最重要的结构体，它是动态错误类型的包装器，能从所有实现了 <a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html#impl-From%3CE%3E"><code>std::error::Error + Send + Sync + &#39;static</code></a> 的错误转换而来，也能转换成 <a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html#impl-From%3CError%3E"><code>Box&lt;dyn std::error::Error + Send + Sync + &#39;static&gt;</code></a>，它有以下特点：</p>
<ol>
<li><code>anyhow::Error</code> 要求包裹的错误必须是 <code>Send + Sync + &#39;static</code>；</li>
<li><code>anyhow::Error</code> 保证 <code>backtrace</code> 是可用的，就是底层的错误类型没有提供；</li>
<li><code>anyhow::Error</code> 在内存中只占一个机器字而不是两个；</li>
</ol>
<p>如果我们要将 <code>anyhow::Error</code> 以文本形式展出来，可以有下面几种形式：</p>
<ol>
<li><p>可以使用 <code>&#123;&#125;</code> 或者 <code>.to_string()</code>，但是仅仅打印最外层错误或者上下文，而不是内层的错误；</p>
</li>
<li><p>可以使用 <code>&#123;:#&#125;</code> 打印外层和底层错误；</p>
</li>
<li><p>可以使用 <code>&#123;:?&#125;</code> 在调试模式打印错误以及调用栈；</p>
</li>
<li><p>可以使用 <code>&#123;:#?&#125;</code> 以结构体样式打印错误，例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error &#123;</span><br><span class="line">    context: &quot;Failed to read instrs from ./path/to/instrs.json&quot;,</span><br><span class="line">    source: Os &#123;</span><br><span class="line">        code: 2,</span><br><span class="line">        kind: NotFound,</span><br><span class="line">        message: &quot;No such file or directory&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>另外，既然 <code>anyhow::Error</code> 包装了底层的错误，那就得提供找到内层错误的方法，这里是 <code>downcast_ref</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> anyhow::&#123;anyhow, bail&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">DataStoreError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;the data for key `&#123;0&#125;` is not available&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Redaction</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用 ？运算符能将任何实现了 std::error::Error + Send + Sync + &#x27;static 的错误转换为 anyhow::Error</span></span><br><span class="line">    std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;config.json&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">foo</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(()) =&gt; (),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="keyword">ref</span> root_cause) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">err</span> = root_cause.downcast_ref::&lt;DataStoreError&gt;();</span><br><span class="line">            <span class="keyword">match</span> err &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(DataStoreError::<span class="title function_ invoke__">Redaction</span>(_)) =&gt; (),</span><br><span class="line">                <span class="literal">None</span> =&gt; (),</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, root_cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="anyhow-1"><a href="#anyhow-1" class="headerlink" title="anyhow!"></a><code>anyhow!</code></h4><p>使用 <a href="https://docs.rs/anyhow/1.0.57/anyhow/macro.anyhow.html"><code>anyhow!</code></a> 这个宏可以生成 <a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html"><code>anyhow::Error</code></a>类型的值，它可以接受字符串，格式化字符串作为参数，或者实现 <code>std::error:Error</code> 的错误作为参数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anyhow::&#123;anyhow, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">lookup</span>(key: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> key.<span class="title function_ invoke__">len</span>() != <span class="number">16</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(anyhow!(<span class="string">&quot;key length must be 16 characters, got &#123;:?&#125;&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者从实现了 <code>std::error::Error</code> 的错误转换而来：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anyhow::anyhow;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">DataStoreError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;the data for key `&#123;0&#125;` is not available&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Redaction</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> std::result::<span class="type">Result</span>&lt;(), DataStoreError&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(DataStoreError::<span class="title function_ invoke__">Redaction</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_owned</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo1</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">bar</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo2</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(anyhow::Error::<span class="title function_ invoke__">from</span>(DataStoreError::<span class="title function_ invoke__">Redaction</span>(</span><br><span class="line">        <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    )))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo3</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(anyhow!(DataStoreError::<span class="title function_ invoke__">Redaction</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_owned</span>())))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>又或者：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anyhow::anyhow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(anyhow!(<span class="string">&quot;missing &#123;&#125; field&quot;</span>, <span class="string">&quot;f1&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bail"><a href="#bail" class="headerlink" title="bail!"></a><code>bail!</code></h4><p><a href="https://docs.rs/anyhow/1.0.57/anyhow/macro.bail.html"><code>anyhow::bail</code></a> 宏用于提前错误返回，它等价于 <code>return Err(anyhow!($args...))</code>，包含这个宏的函数的返回值必须是 <code>Result&lt;_,anyhow::Error&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anyhow::&#123;anyhow, bail&#125;;</span><br><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">DataStoreError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;the data for key `&#123;0&#125;` is not available&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">Redaction</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(i: <span class="type">i16</span>) <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">        bail!(DataStoreError::<span class="title function_ invoke__">Redaction</span>(<span class="string">&quot;something wrong&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="anyhow-Context"><a href="#anyhow-Context" class="headerlink" title="anyhow::Context"></a><code>anyhow::Context</code></h4><p><a href="https://docs.rs/anyhow/1.0.57/anyhow/trait.Context.html"><code>anyhow::Context</code></a> 为 <code>anyhow::Result</code> 类型提供了 <code>context</code> 方法，能在错误发生时提供更多的上下文信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anyhow::&#123;anyhow, Context, <span class="type">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ImportantThing</span> &#123;</span><br><span class="line">    path: PathBuf,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ImportantThing</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">detach</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(anyhow!(<span class="string">&quot;detach faield&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">do_it</span>(<span class="keyword">mut</span> it: ImportantThing) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; &#123;</span><br><span class="line">    it.<span class="title function_ invoke__">detach</span>()</span><br><span class="line">        .<span class="title function_ invoke__">context</span>(<span class="string">&quot;Failed to detach the important thing&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = &amp;it.path;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> =</span><br><span class="line">        fs::<span class="title function_ invoke__">read</span>(path).<span class="title function_ invoke__">with_context</span>(|| <span class="built_in">format!</span>(<span class="string">&quot;Failed to read instrs from &#123;&#125;&quot;</span>, path.<span class="title function_ invoke__">display</span>()))?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">it</span> = ImportantThing &#123;</span><br><span class="line">        path: PathBuf::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">do_it</span>(it) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; (),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="keyword">ref</span> err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">cause</span> <span class="keyword">in</span> err.<span class="title function_ invoke__">chain</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将输出：</p>
<pre><code>Failed to detach the important thing
detach faield
</code></pre>
<p>对于下面的代码也是输出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">do_it</span>(it: &amp;<span class="keyword">mut</span> ImportantThing) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = &amp;it.path;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> =</span><br><span class="line">        fs::<span class="title function_ invoke__">read</span>(path).<span class="title function_ invoke__">with_context</span>(|| <span class="built_in">format!</span>(<span class="string">&quot;Failed to read instrs from &#123;&#125;&quot;</span>, path.<span class="title function_ invoke__">display</span>()))?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">it</span> = ImportantThing &#123;</span><br><span class="line">        path: PathBuf::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">do_it</span>(&amp;<span class="keyword">mut</span> it) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; (),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="keyword">ref</span> err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">cause</span> <span class="keyword">in</span> err.<span class="title function_ invoke__">chain</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将输出：</p>
<pre><code>Failed to read instrs from 
No such file or directory (os error 2)
</code></pre>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>anyhow</tag>
        <tag>thiserror</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】使用Cross进行跨平台编译</title>
    <url>/2023/07/21/%E3%80%90Rust%E3%80%91cross/</url>
    <content><![CDATA[<p><code>Rust</code> 的编译速度和跨平台编译相比 <code>Go</code> 语言就要难用很多，但这也是语言特点，当你从中受益时，必然要付出一些代价，本文主要介绍如何实现跨平台编译，使用 <a href="https://github.com/cross-rs/cross"><code>cross</code></a> 这个工具。</p>
<p>我的工作台是 <code>Mac M2</code>，想编译出 <code>Linux</code> 和 <code>Windows</code> 的可执行文件，使用的代码很简单，就是 <code>Hello World</code> 示例程序，这个不是重点。</p>
<p>使用 <code>cross</code> 首先当然是安装，按照官方的描述，可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo install cross --git https://github.com/cross-rs/cross</span><br></pre></td></tr></table></figure>

<p>然后是安装 <code>docker</code> 或者 <code>podman</code>，本文以 <code>docker</code> 为例，讲述使用过程中遇到的问题及其解决方案。<code>cross</code> 的使用很简单，例如，如果我要编译 <code>target</code> 为 <code>aarch64-unknown-linux-gnu</code>，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cross build  --target aarch64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="ghcr-io-镜像加速"><a href="#ghcr-io-镜像加速" class="headerlink" title="ghcr.io 镜像加速"></a><code>ghcr.io</code> 镜像加速</h3><p><code>cross</code> 的工作原理是创建一个容器来构建我们的目标平台软件，但是它的镜像不是在 <code>Dockerhub</code>，所以说传统的镜像加速方法不能对它起作用，另外还有下面这些镜像仓库都不可以：</p>
<ul>
<li><code>gcr.io、k8s.gcr.io</code>：谷歌镜像仓库；</li>
<li><code>quay.io</code> ：<code>Red Hat</code> 镜像仓库；</li>
<li><code>ghcr.io</code> ：<code>GitHub</code> 镜像仓库；</li>
</ul>
<p>例如，我要编译 <code>target</code> 为 <code>aarch64-unknown-linux-gnu</code> 以及 <code>x86_64-pc-windows-gnu</code>，就需要下载这两个镜像：</p>
<ol>
<li><code>ghcr.io/cross-rs/x86_64-pc-windows-gnu:edge</code>；</li>
<li><code>ghcr.io/cross-rs/aarch64-unknown-linux-gnu:main</code></li>
</ol>
<p>所有可用的 <code>target</code> 可以在<a href="https://github.com/cross-rs/cross/blob/main/docker/Dockerfile.x86_64-pc-windows-gnu">这里</a>找到。</p>
<p>加速这些镜像的方法就是我们把他下载下来然后传到 <code>Doclerhub</code>，然后我们通过国内的公共镜像加速服务器就可以快速下载。当然自己搞这些太麻烦了，已经有大神做好了自动化，只需要在这里创建个<code>issue</code>，就可自动帮我们完成，例如，这是我创建的两个：<a href="https://github.com/togettoyou/hub-mirror/issues/created_by/gamelife1314"><code>https://github.com/togettoyou/hub-mirror/issues</code></a>，执行完成之后，会在 <code>Dockerhub</code> 创建一个新的 <code>Repo</code>，例如：</p>
<img data-src="/2023/07/21/%E3%80%90Rust%E3%80%91cross/hub-mirror.png" class="">

<p>然后在 <code>Cargo.toml</code> 配置为我们新创建的镜像，例如：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.cross.target.aarch64-unknown-linux-gnu]</span></span><br><span class="line"><span class="attr">xargo</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">image</span> = <span class="string">&quot;togettoyou/ghcr.io.cross-rs.aarch64-unknown-linux-gnu:main&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="sh-1-cargo-not-found"><a href="#sh-1-cargo-not-found" class="headerlink" title="sh: 1: cargo: not found"></a><code>sh: 1: cargo: not found</code></h3><p>当我将镜像好不容易拉到本地之后，以为可以顺利的编出我想要的软件时，没想到又遇到了错误：</p>
<div class="note danger"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/examples100 ⌚ 21:23:17</span><br><span class="line">$ cross build  --target aarch64-unknown-linux-gnu</span><br><span class="line">[cross] warning: using newer rustc `1.69.0-nightly (34e6673a0 2023-02-25)` for the target. Current active rustc on the host is `rustc 1.69.0-nightly (585f3eef2 2023-02-11)`.</span><br><span class="line"> &gt; Update with `rustup update`</span><br><span class="line">sh: 1: cargo: not found</span><br></pre></td></tr></table></figure></div>

<p>在一番查找之后，在 <a href="https://github.com/cross-rs/cross/issues/260#issuecomment-1132237489"><code>Github</code></a> 中找到了解决方案：</p>
<img data-src="/2023/07/21/%E3%80%90Rust%E3%80%91cross/cargo-not-found.png" class="">

<p>其实这个问题应该与我将 <code>docker</code> 装在虚拟中有关，但是这个解决方案可以从本质上解决问题，镜像中没有安装 <code>rust</code> 工具链。所以我又构建了新的镜像：</p>
<figure class="highlight plaintext"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM togettoyou/ghcr.io.cross-rs.aarch64-unknown-linux-gnu:main</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y wget</span><br><span class="line">RUN mkdir -m777 /opt/rust /opt/cargo</span><br><span class="line">ENV RUSTUP_HOME=/opt/rust CARGO_HOME=/opt/cargo PATH=/opt/cargo/bin:$PATH</span><br><span class="line">ENV RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;</span><br><span class="line">ENV RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;</span><br><span class="line">RUN wget --https-only --secure-protocol=TLSv1_2 -O- https://sh.rustup.rs | sh /dev/stdin -y</span><br><span class="line">RUN rustup target add aarch64-unknown-linux-gnu</span><br><span class="line">RUN printf &#x27;#!/bin/sh\nexport CARGO_HOME=/opt/cargo\nexec /bin/sh &quot;$@&quot;\n&#x27; &gt;/usr/local/bin/sh</span><br><span class="line">RUN chmod +x /usr/local/bin/sh</span><br></pre></td></tr></table></figure>

<p>构建命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t gamelife1314/aarch64-unknown-linux-gnu .</span><br></pre></td></tr></table></figure>

<img data-src="/2023/07/21/%E3%80%90Rust%E3%80%91cross/docker-build-linux.png" class="">

<p>然后又重新更新 <code>Cargo.toml</code> 为我新建的镜像：</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.cross.target.aarch64-unknown-linux-gnu]</span></span><br><span class="line"><span class="attr">xargo</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">image</span> = <span class="string">&quot;gamelife1314/aarch64-unknown-linux-gnu&quot;</span></span><br></pre></td></tr></table></figure>

<p>再去执行编译命令，终于成功了：</p>
<img data-src="/2023/07/21/%E3%80%90Rust%E3%80%91cross/cross-linux-build.png" class="">

<h3 id="x86-64-pc-windows-gnu"><a href="#x86-64-pc-windows-gnu" class="headerlink" title="x86_64-pc-windows-gnu"></a><code>x86_64-pc-windows-gnu</code></h3><p>以同样的方式，我又编译出了 <code>windows</code> 上的可执行文件，下面是本地自建镜像的 <code>Dockerfile</code> 内容：</p>
<figure class="highlight dockerfile"><figcaption><span>Dockerfile.x86_64-pc-windows-gnu</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> togettoyou/ghcr.io.cross-rs.x86_64-pc-windows-gnu:edge</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -m777 /opt/rust /opt/cargo</span></span><br><span class="line"><span class="keyword">ENV</span> RUSTUP_HOME=/opt/rust CARGO_HOME=/opt/cargo PATH=/opt/cargo/bin:$PATH</span><br><span class="line"><span class="keyword">ENV</span> RUSTUP_DIST_SERVER=<span class="string">&quot;https://rsproxy.cn&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> RUSTUP_UPDATE_ROOT=<span class="string">&quot;https://rsproxy.cn/rustup&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget --https-only --secure-protocol=TLSv1_2 -O- https://sh.rustup.rs | sh /dev/stdin -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> rustup target add x86_64-pc-windows-gnu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">printf</span> <span class="string">&#x27;#!/bin/sh\nexport CARGO_HOME=/opt/cargo\nexec /bin/sh &quot;$@&quot;\n&#x27;</span> &gt;/usr/local/bin/sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/sh</span></span><br></pre></td></tr></table></figure>

<p>如果自定义了 <code>Dockerfile</code>文件名，需要使用 <code>-f</code> 指定，构建镜像的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t gamelife1314/x86_64-pc-windows-gnu -f Dockerfile.x86_64-pc-windows-gnu .</span><br></pre></td></tr></table></figure>

<p><code>Cargo.toml</code> 配置使用自定义镜像：</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.cross.target.x86_64-pc-windows-gnu]</span></span><br><span class="line"><span class="attr">xargo</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">image</span> = <span class="string">&quot;gamelife1314/x86_64-pc-windows-gnu&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>cross</code> 进行编译：</p>
<img data-src="/2023/07/21/%E3%80%90Rust%E3%80%91cross/cross-win-build.png" class="">

<h3 id="自建镜像"><a href="#自建镜像" class="headerlink" title="自建镜像"></a>自建镜像</h3><p>本文中涉及的 <code>target</code> 为 <code>aarch64-unknown-linux-gnu</code> 和 <code>x86_64-pc-windows-gnu</code> 的自建镜像已经上传到 <code>Dockerhub</code>，可以直接使用。</p>
<img data-src="/2023/07/21/%E3%80%90Rust%E3%80%91cross/custom-build-image.png" class="">
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>跨平台编译</tag>
        <tag>Cross</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】unsafe 代码</title>
    <url>/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>系统编程的秘密乐趣在于，在每一种安全语言和精心设计的抽象之下，都存在着极其 <code>unsafe</code> 的机器语言和小技巧，我们也可以用 <code>Rust</code> 来写。</p>
<p>到目前为止，我们介绍的语言可确保程序通过类型、生命周期、边界检查等完全自动地避免内存错误和数据竞争，但是这种自动推断有其局限性，有许多有价值的技术手段是无法被 <code>Rust</code> 认可的。             </p>
<p><code>unsafe</code> 代码告诉 <code>Rust</code>，程序选择使用它无法保证安全的特性。通过将代码块或函数标记为  <code>unsafe</code>，可以获得调用标准库中的 <code>unsafe</code> 函数、解引用 <code>unsafe</code> 指针以及调用用其他语言（如 <code>C</code> 和 <code>C++</code> ）编写的函数以及其他能力。 </p>
<p>这种跳出安全 <code>Rust</code> 边界的能力使得在 <code>Rust</code> 中实现许多 <code>Rust</code> 最基本的功能成为可能，就像 <code>C</code> 和 <code>C++</code> 用来实现自己的标准库一样。 <code>unsafe</code> 代码允许 <code>Vec</code> 有效地管理其缓冲区、 <code>std::io</code> 能直接和操作系统对话、以及提供并发原语的 <code>std::thread</code> 和 <code>std::sync</code>。</p>
<p>本节将 <code>unsafe</code> 功能的要点：</p>
<ul>
<li><p><code>Rust</code> 的 <code>unsafe</code> 块在安全的 <code>Rust</code> 代码和使用 <code>unsafe</code> 特性的代码之间建立了界限；</p>
</li>
<li><p>可以将函数标记为  <code>unsafe</code>，提醒调用者存他们必须遵守的额外规范以避免未定义的行为；</p>
</li>
<li><p>裸指针及其方法允许不受限制地访问内存，并允许构建 <code>Rust</code> 类型系统原本禁止的数据结构。尽管 <code>Rust</code> 的引用是安全但受约束的，但正如任何 <code>C</code> 或 <code>C++</code> 程序员所知道的，裸指针是一个强大而锋利的工具；</p>
</li>
<li><p>了解未定义行为将帮助理解为什么它会产生比仅仅得到错误结果更严重的后果；</p>
</li>
<li><p><code>unsafe</code> 的 <code>Trait</code>，类似于 <code>unsafe</code> 的函数，强加了每个实现必须遵循的规约；</p>
</li>
</ul>
<span id="more"></span>

<h3 id="unsafe-示例"><a href="#unsafe-示例" class="headerlink" title="unsafe 示例"></a><code>unsafe</code> 示例</h3><p>下面这段程序在原书中说是运行会崩溃，但是在我自己的电脑上并未发生，就当它崩溃了吧。（我的 <code>Rust</code> 版本是 <code>rustc 1.62.0-nightly</code> ）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = &amp;<span class="keyword">mut</span> a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ptr.<span class="title function_ invoke__">offset</span>(<span class="number">3</span>) = <span class="number">0x7000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序借用了对局部变量 <code>a</code> 的可变引用，将其转换为 <code>*mut usize</code> 类型的裸指针，然后使用 <code>offset</code> 方法在内存中生成一个指针，新指针等于 <code>ptr + 3 * size_of::&lt;uszie&gt;()</code>。按原书说这恰好是存储 <code>main</code> 的返回地址的地方（这其实得看 <code>Rust</code> 的调用规约了）。程序用一个常量覆盖了返回地址，这样从 <code>main</code> 中返回的行为就不确定了。导致这次崩溃的原因是程序对 <code>unsafe</code> 特性的错误使用，在这里就是滥用解引用裸指针的能力。</p>
<p>一个 <code>unsafe</code> 的特性是会有一个使用规约：但是 <code>Rust</code> 不能自动强制执行，所以必须遵循这些规约以避免未定义的行为。</p>
<p><code>unsafe</code> 代码能跳过常规的类型检查和生命周期检查，但增加了更多的使用规约。通常， <code>Rust</code> 本身根本不知道这些规约，它们只是在该功能的文档中进行了解释。例如，裸指针类型有一个规约，禁止解引用已超出其原来范围的指针，此示例中的表达式 <code>*ptr.offset(3) = ...</code> 违反了此约定。但是， <code>Rust</code> 依然编译了程序：它的安全检查没有检测到这种违规行为。当使用 <code>unsafe</code> 的功能时，作为程序员，有责任检查代码是否符合他们的规约。</p>
<p>许多功能都有正确使用它们应该遵循的规则，但这些规则不是我们在这里所说的意义上的规约，除非可能的后果包括未定义的行为。未定义的行为是 <code>Rust</code> 坚信你的代码永远不会出现的行为，例如， <code>Rust</code> 假设你不会用其他东西覆盖函数调用的返回地址。通过 <code>Rust</code> 的安全检查并遵守非安全功能规约的代码不可能做这样的事情。由于该程序违反了裸指针规约，它的行为是未定义的，所以出错了。</p>
<p>如果代码出现了未定义的行为， <code>Rust</code> 就无法保证代码会执行到哪里了，也无法保证结局，更无法保证安全。可能报告出一对不相关的错误消息然后崩溃，或者系统的控制权让出给其他程序，而且不同的 <code>Rust</code> 版本之间也不保证一致，也不会存在告警。</p>
<p>规定只能在 <code>unsafe</code> 代码块或函数中使用 <code>unsafe</code> 的功能；我们将在接下来的部分中解释这两个。通过强制编写一个 <code>unsafe</code> 代码块或函数，这会提醒开发者在使用 <code>unsafe</code> 功能时应该格外小心， <code>Rust</code> 确保开发者知道需要遵循额外的规约。</p>
<h3 id="unsafe-代码块"><a href="#unsafe-代码块" class="headerlink" title="unsafe 代码块"></a><code>unsafe</code> 代码块</h3><p><code>Rust</code> 的 <code>unsafe</code> 代码块和普通到的代码块看起来没什么两样，只是由一个 <code>unsafe</code> 关键字开始：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_unchecked</span>(ascii)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果块前面没有 <code>unsafe</code> 关键字， <code>Rust</code> 不让使用 <code>from_utf8_unchecked</code>，它是一个 <code>unsafe</code> 的函数。</p>
<p>与普通的 <code>Rust</code> 块一样， <code>unsafe</code> 代码块的值是其最终表达式的值，如果没有，则为 <code>()</code>。前面显示的对 <code>String::from_utf8_unchecked</code> 的调用提供了块的值。</p>
<p><code>unsafe</code> 代码块提供了 <code>5</code> 个编程能力：</p>
<ul>
<li><p>可以调用 <code>unsafe</code> 的函数，但是每个 <code>unsafe</code> 的函数都必须根据其用途指定自己的规约；</p>
</li>
<li><p>可以解引用裸指针，安全代码可以传递裸指针并且比较它们，并通过从引用（甚至从整数）转换来创建它们，但只有 <code>unsafe</code> 代码才能真正使用它们来访问内存；</p>
</li>
<li><p>可以访问联合体的字段，编译器无法确定它们是否包含代表它们类型的有效位模式；</p>
</li>
<li><p>可以访问可变静态变量， <code>Rust</code> 无法确定线程何时使用可变静态变量，因此它们的规约要求确保所有访问都是同步的；</p>
</li>
<li><p>可以访问通过 <code>Rust</code> 的外部函数接口声明的函数和变量。即使它们是不可变的，它们也被认为是 <code>unsafe</code> 的，因为它们对于用其他可能不遵守 <code>Rust</code> 安全规则的语言编写的代码是可见的；</p>
</li>
</ul>
<p>将 <code>unsafe</code> 的功能限制在 <code>unsafe</code> 代码块中并不能真正阻止我们要做的事情，这个限制的好处主要在于将开发者的注意力吸引到 <code>Rust</code> 无法保证安全的代码上：</p>
<ul>
<li><p>不会不小心使用了 <code>unsafe</code> 的特性，然后发现要为不知道的规约负责，肯定是开发者写的，出了事也要自己兜着，别怪 <code>Rust</code> ；</p>
</li>
<li><p>一个 <code>unsafe</code> 的代码块会引起 <code>commiter</code> 的更多关注。一些项目甚至具有自动化来确保这一点，标记为 <code>unsafe</code> 的代码块可以引起特别关注；</p>
</li>
<li><p>当考虑编写一个 <code>unsafe</code> 的块时，需要花点时间问问自己你的任务是否真的需要这样的措施。如果是为了性能，你是否有测量表明这实际上是一个瓶颈。也许有一个好方法可以在安全的 <code>Rust</code> 中完成同样的事情，不要为了那么一丁点的性能牺牲了整个程序的安全性。</p>
</li>
</ul>
<h3 id="高效的-ASCII"><a href="#高效的-ASCII" class="headerlink" title="高效的 ASCII"></a>高效的 <code>ASCII</code></h3><p>这里有一个 <code>Ascii</code> 类型，一个总是包含有效 <code>ASCII</code> 的 <code>string</code> 类型，使用了一个 <code>unsafe</code> 功能零成本转换成 <code>String</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_ascii &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// An ASCII-encoded string.</span></span><br><span class="line">    <span class="meta">#[derive(Debug, Eq, PartialEq)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Ascii</span>(</span><br><span class="line">        <span class="comment">// This must hold only well-formed ASCII text:</span></span><br><span class="line">        <span class="comment">// bytes from `0` to `0x7f` .</span></span><br><span class="line">        <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Ascii</span> &#123;</span><br><span class="line">        <span class="comment">/// Create an `Ascii` from the ASCII text in `bytes` . Return a</span></span><br><span class="line">        <span class="comment">/// `NotAsciiError` error if `bytes` contains any non-ASCII</span></span><br><span class="line">        <span class="comment">/// characters.</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_bytes</span>(bytes: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Ascii, NotAsciiError&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;byte| !byte.<span class="title function_ invoke__">is_ascii</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="title function_ invoke__">NotAsciiError</span>(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ascii</span>(bytes))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When conversion fails, we give back the vector we couldn&#x27;t convert.</span></span><br><span class="line">    <span class="comment">// This should implement `std::error::Error` ; omitted for brevity.</span></span><br><span class="line">    <span class="meta">#[derive(Debug, Eq, PartialEq)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NotAsciiError</span>(<span class="keyword">pub</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;);</span><br><span class="line">    <span class="comment">// Safe, efficient conversion, implemented using unsafe code.</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">From</span>&lt;Ascii&gt; <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">from</span>(ascii: Ascii) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">            <span class="comment">// If this module has no bugs, this is safe, because</span></span><br><span class="line">            <span class="comment">// well-formed ASCII text is also well-formed UTF-8.</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_unchecked</span>(ascii.<span class="number">0</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模块的关键是 <code>Ascii</code> 类型的定义，类型本身被标记为 <code>pub</code>，以使其在 <code>my_ascii</code> 模块之外可见。但是该类型的 <code>Vec&lt;u8&gt;</code> 元素不是公共的，所以只有 <code>my_ascii</code> 模块可以构造一个 <code>Ascii</code> 值或引用它的元素。事实上，公共构造函数 <code>Ascii::from_bytes</code> 在构造一个 <code>Ascii</code> 之前仔细检查了可能出现的错误，确保 <code>Ascii</code> 值始终包含正确的 <code>ASCII</code> 文本，就像 <code>String</code> 的方法确保其内容是有效的 <code>UTF-8</code> 一样。</p>
<p>这种保证让我们可以非常有效地为 <code>String</code> 实现 <code>From&lt;Ascii&gt;</code>。 <code>unsafe</code> 函数 <code>String::from_utf8_unchecked</code> 接受一个字节 <code>vector</code> 并从中构建一个字符串，而不检查其内容是否是有效的 <code>UTF-8</code> 文本，函数的规约是让调用者对此负责。幸运的是， <code>Ascii</code> 类型强制执行的规则正是我们需要满足 <code>from_utf8_unchecked</code> 的规约。因为任何 <code>ASCII</code> 文本块也是有效的 <code>UTF-8</code>，因此 <code>Ascii</code> 的底层 <code>Vec&lt;u8&gt;</code> 可以立即用作字符串的缓冲区。</p>
<p>有了这些定义，我们可以写出如下的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> my_ascii::Ascii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="string">b&quot;ASCII and ye shall receive&quot;</span>.<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line"><span class="comment">// This call entails no allocation or text copies, just a scan.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ascii</span>: Ascii = Ascii::<span class="title function_ invoke__">from_bytes</span>(bytes).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// We know these chosen bytes are ok.</span></span><br><span class="line">                                                        <span class="comment">// This call is zero-cost: no allocation, copies, or scans.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(ascii);</span><br><span class="line"><span class="built_in">assert_eq!</span>(string, <span class="string">&quot;ASCII and ye shall receive&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但使用 <code>Ascii</code> 不需要 <code>unsafe</code> 代码块，这里已经使用 <code>unsafe</code> 的操作实现了一个安全的接口，并且只根据模块自己的代码而不是用户的行为来安排满足他们的规约。</p>
<p><code>Ascii</code> 只不过是 <code>Vec&lt;u8&gt;</code> 的包装器，隐藏在一个模块中，该模块对其内容实施额外的规则。这种类型称为 <code>newtype</code>，是 <code>Rust</code> 中的一种常见模式。 <code>Rust</code> 的 <code>String</code> 类型的定义方式完全相同，只是它的内容被限制为 <code>UTF-8</code>，而不是 <code>ASCII</code>。下面是标准库中对 <code>String</code> 的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    vec: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在机器层面上，去掉 <code>Rust</code> 类型， <code>newtype</code> 和它原本的类型在内存中有相同的表示，所以构造一个 <code>newtype</code> 根本不需要任何机器指令。在 <code>Ascii::from_bytes</code> 中，表达式 <code>Ascii(bytes)</code> 简单地认为 <code>Vec&lt;u8&gt;</code> 的表示方法现在持有一个 <code>Ascii</code> 值。类似地， <code>String::from_utf8_unchecked</code> 在内联时可能不需要机器指令： <code>Vec&lt;u8&gt;</code> 现在被认为是一个字符串。</p>
<h3 id="unsafe-函数"><a href="#unsafe-函数" class="headerlink" title="unsafe 函数"></a><code>unsafe</code> 函数</h3><p>一个 <code>unsafe</code> 的函数定义看起来像一个普通的函数定义，前面有 <code>unsafe</code> 关键字。 <code>unsafe</code> 函数的主体自动被视为 <code>unsafe</code> 块。</p>
<p>只能在 <code>unsafe</code> 的块中调用 <code>unsafe</code> 的函数。这意味着将函数标记为 <code>unsafe</code> 会提醒调用者使用它们必须认真看文档以避免未定义的行为。</p>
<p>例如，这是我们之前介绍的 <code>Ascii</code> 类型的新构造函数，它从字节 <code>vector</code> 构建 <code>Ascii</code>，而不检查其内容是否为有效的 <code>ASCII</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This must be placed inside the `my_ascii` module.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Ascii</span> &#123;</span><br><span class="line">    <span class="comment">/// Construct an `Ascii` value from `bytes` , without checking</span></span><br><span class="line">    <span class="comment">/// whether `bytes` actually contains well-formed ASCII.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// This constructor is infallible, and returns an `Ascii` directly,</span></span><br><span class="line">    <span class="comment">/// rather than a `Result&lt;Ascii, NotAsciiError&gt;` as the `from_bytes` </span></span><br><span class="line">    <span class="comment">/// constructor does.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Safety</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The caller must ensure that `bytes` contains only ASCII</span></span><br><span class="line">    <span class="comment">/// characters: bytes no greater than 0x7f. Otherwise, the effect is</span></span><br><span class="line">    <span class="comment">/// undefined.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">from_bytes_unchecked</span>(bytes: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> Ascii &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ascii</span>(bytes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从使用场景来说，可能已经确定调用 <code>Ascii::from_bytes_unchecked</code> 的代码的 <code>vector</code> 仅包含 <code>ASCII</code> 字符，因此 <code>Ascii::from_bytes</code> 坚持执行的检查将是浪费时间。</p>
<p>但之前我们强调了 <code>Ascii</code> 的公共构造函数和方法的重要性，以确保 <code>Ascii</code> 值的格式正确，而 <code>from_bytes_unchecked</code> 制定规约将其传递给它的调用者来履行其义务。这个规约将函数标记为 <code>unsafe</code> 是完全正确的：尽管函数本身不执行 <code>unsafe</code> 的操作，但它的调用者必须遵循 <code>Rust</code> 无法自动强制执行的规约以避免未定义的行为。</p>
<p>我们可以不遵循 <code>Ascii::from_bytes_unchecked</code> 的规约，然后构造一个无效格式的 <code>UTF-8</code> 字符串：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Imagine that this vector is the result of some complicated process</span></span><br><span class="line"><span class="comment">// that we expected to produce ASCII. Something went wrong!</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = <span class="built_in">vec!</span>[<span class="number">0xf7</span>, <span class="number">0xbf</span>, <span class="number">0xbf</span>, <span class="number">0xbf</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ascii</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// This unsafe function&#x27;s contract is violated</span></span><br><span class="line">    <span class="comment">// when `bytes` holds non-ASCII bytes.</span></span><br><span class="line">    my_ascii::Ascii::<span class="title function_ invoke__">from_bytes_unchecked</span>(bytes)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bogus</span>: <span class="type">String</span> = ascii.<span class="title function_ invoke__">into</span>();</span><br><span class="line"><span class="comment">// `bogus` now holds ill-formed UTF-8. Parsing its first character produces</span></span><br><span class="line"><span class="comment">// a `char` that is not a valid Unicode code point. That&#x27;s undefined</span></span><br><span class="line"><span class="comment">// behavior, so the language doesn&#x27;t say how this assertion should behave.</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(bogus.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>() <span class="keyword">as</span> <span class="type">u32</span>, <span class="number">0x1fffff</span>);</span><br></pre></td></tr></table></figure>

<p>在某些版本的 <code>Rust</code> 中，在某些平台上，这个断言被观察到会失败 时，会出现以下有趣的错误信息（然而我自己测试并未出现）：</p>
<pre><code>thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)` 
left: `2097151` ,
right: `2097151` &#39;, src/main.rs:42:5
</code></pre>
</div>

<p>这两个数字在我们看来是相等的，但这不是 <code>Rust</code> 的错，而是之前 <code>unsafe</code> 代码的错。当我们说未定义行为会导致不可预测的结果时，这就是我们所指的那种情况。</p>
<p>从本质上讲， <code>Rust</code> 的类型检查器、借用检查器和其他静态检查是在检查程序，并试图证明程序中不存在未定义的行为。当 <code>Rust</code> 成功编译程序时，这意味着它成功地证明了代码是合理的。然而一个 <code>unsafe</code> 的块是这个证明中的一个缺口，这就相当于程序员对 <code>Rust</code> 口头说相信我的代码，不过口头承诺是否正确，可能取决于程序中影响 <code>unsafe</code> 块中发生的任何部分，而错误的后果可能出现在受 <code>unsafe</code> 块影响的任何地方。编写 <code>unsafe</code> 关键字相当于提醒你没有得到语言安全检查的全部保证。          </p>
<p>如果有选择的话，你应该自然而然地倾向于创建没有隐含规约的安全接口。这些接口更容易操作，因为用户可以依靠 <code>Rust</code> 的安全检查来确保他们的代码不存在未定义的行为。即使你的实现使用了 <code>unsafe</code> 的特性，最好还是使用 <code>Rust</code> 的类型、生命周期和模块系统来满足它们的规约。            </p>
<p>不幸的是，在很多地方遇到 <code>unsafe</code> 的函数是很正常的，这些函数的文档并没有对它们的规约进行解释。你应该根据你的经验和对代码行为的了解，自己推断出规则。</p>
<h3 id="unsafe-block-or-unsafe-fn"><a href="#unsafe-block-or-unsafe-fn" class="headerlink" title="unsafe block or unsafe fn"></a><code>unsafe block or unsafe fn</code></h3><p>使用 <code>unsafe</code> 代码块还是 <code>unsafe</code> 函数，需要考虑：   </p>
<ul>
<li><p>如果有可能以一种编译正常但仍导致未定义行为的方式滥用该函数，你必须将其标记为 <code>unsafe</code>。正确使用该函数的规则就是它的规约；规约的存在就是使该函数 <code>unsafe</code> 的原因；</p>
</li>
<li><p>否则，该函数是安全的：对它的良好类型的调用都不会导致未定义的行为，它不应该被标记为 <code>unsafe</code>。该函数是否在其主体中使用了 <code>unsafe</code> 的特性并不重要，重要的是规约的存在。之前，我们展示了一个没有使用 <code>unsafe</code> 特征的 <code>unsafe</code> 函数，以及一个使用了 <code>unsafe</code> 特性的安全函数。</p>
</li>
</ul>
<p>不要因为在一个安全函数的主体中使用了 <code>unsafe</code> 的特征，就把它标记为 <code>unsafe</code>，这将使函数更难使用，并使读者感到困惑，他们会（正常情况下）期望在某处找到规约的解释。</p>
<h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><p>在介绍中，我们说过，未定义的行为是指 <code>Rust</code> 坚决认为你的代码不可能出现的行为。这是一个很奇怪的说法，尤其是我们从其他语言的经验中知道，这些行为确实会经常意外发生。为什么这个概念对规定 <code>unsafe</code> 代码的义务有帮助？ </p>
<p>我们知道编译器是一种编程语言到另一种语言的翻译器。 <code>Rust</code> 编译器将一个 <code>Rust</code> 程序翻译成一个等效的机器语言程序。但是，如果说这种完全不同的语言的表示的程序是等价的，这意味着什么？ </p>
<p>意味着两个程序在执行时总是有相同的可见行为，它们进行相同的系统调用，以相同的方式与外部库交互，等等。这有点像程序的图灵测试：如果你无法分辨你是在与原版还是译版互动，那么它们就是等价的。 </p>
<p>现在考虑一下下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">10</span>;</span><br><span class="line"><span class="title function_ invoke__">very_trustworthy</span>(&amp;i);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i * <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>即使对 <code>very_trustworthy</code> 的定义一无所知，我们也可以看到它只接受对 <code>i</code> 的共享引用，所以这个调用不能改变 <code>i</code> 的值。由于传递给 <code>println!</code> 的值总是 <code>1000</code>， <code>Rust</code> 可以将这段代码翻译成机器语言，就像：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">very_trustworthy</span>(&amp;<span class="number">10</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这个转换后的版本具有与原版相同的行为，而且它的速度可能会快一点。但只有当我们同意这个版本与原始版本具有相同的意义时，考虑这个版本的性能才有意义。如果 <code>very_trustworthy</code> 被定义为以下情况呢？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">very_trustworthy</span>(shared: &amp;<span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// Turn the shared reference into a mutable pointer.</span></span><br><span class="line">        <span class="comment">// This is undefined behavior.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutable</span> = shared <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">        *mutable = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码打破了共享引用的规则：它将 <code>i</code> 的值改为 <code>20</code>，尽管它不应该被修改，因为 <code>i</code> 是借用来共享的。结果，我们对调用者所做的转换现在有一个非常明显的效果：如果 <code>Rust</code> 转换代码，程序会打印 <code>1000</code> ；如果它不理会代码并使用 <code>i</code> 的新值，它会打印 <code>2000</code>。在 <code>very_trustworthy</code> 中打破共享引用的规则意味着共享引用在其调用者中不会像预期的那样运行。                </p>
<p>这类问题几乎出现在 <code>Rust</code> 可能尝试的每一种转换中。即使是将一个函数内联到它的调用位置，也假定当被调用者完成时，控制流将返回到调用站点。但是我们在这一章的开头举了一个甚至违反了这个假设的不良代码的例子。               </p>
<p>对于 <code>Rust</code> 来说，除非它能相信语言的基本功能会按照设计的方式运行，否则基本上不可能评估对程序的转换是否保留了其意义。而他们是否能做到这一点，不仅取决于手头的代码，还取决于程序的其他可能遥远的部分。 为了对你的代码做任何事情，<code>Rust</code> 必须假设你的程序的其他部分是具有良好的行为。</p>
<p><code>Rust</code> 定义了具有好行为的程序：</p>
<ul>
<li><p>禁止读未初始化的内存；</p>
</li>
<li><p>程序不得创建无效的原始值：</p>
<ol>
<li>引用，<code>Box</code> 或者 <code>fn</code> 指针不能是 <code>Null</code> ；</li>
<li><code>bool</code> 值只能是 <code>0</code> 或者 <code>1</code> ；</li>
<li>枚举值只能使用有效的项；</li>
<li><code>char</code> 必须是有效的 <code>Unicode</code> 码点；</li>
<li><code>str</code> 必须是有效的 <code>UTF-8</code>；</li>
<li>胖指针必须具有有效的 <code>vtables</code> 或者 <code>slice</code> 长度；</li>
<li>不得使用 <a href="/2022/04/20/%E3%80%90Rust%E3%80%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B">特殊类型 !</a> 的任何值；</li>
</ol>
</li>
<li><p>必须遵守引用规则，任何引用都不能比其引用的值活得更久；共享访问是只读访问；可变访问是独占访问；</p>
</li>
<li><p>程序不得解引用空指针、不正确对齐的指针或悬空指针；</p>
</li>
<li><p>程序不得使用指针访问与指针关联的分配之外的内存；</p>
</li>
<li><p>程序必须没有数据争用，当两个线程在没有同步的情况下访问相同的内存位置时，如果至少其中一个访问是写入，就会发生数据竞争；</p>
</li>
<li><p>The program must not unwind across a call made from another language, via the foreign function interface.</p>
</li>
<li><p>程序必须遵守标准库函数的约定；</p>
</li>
</ul>
<p>由于我们还没有一个完整的 <code>Rust</code> <code>unsafe</code> 代码语义模型，这个列表可能会随着时间的推移而演变，但这些可能永远是被禁止的。</p>
<p>任何违反这些规则的行为都会构成未定义的行为，并使 <code>Rust</code> 优化程序并将其翻译成机器语言而变得不可信。</p>
<p>不使用 <code>unsafe</code> 特性的 <code>Rust</code> 代码保证在编译后遵循所有前面的规则。只有当使用 <code>unsafe</code> 功能时，这些规则才会成为必尽责任。</p>
<h3 id="unsafe-Trait"><a href="#unsafe-Trait" class="headerlink" title="unsafe Trait"></a><code>unsafe Trait</code></h3><p><code>unsafe trait</code> 是具有规约的 <code>trait</code>，<code>Rust</code> 无法检查或强制实现者必须满足以避免未定义的行为。要实现 <code>unsafe trait</code>，必须将实现标记为 <code>unsafe</code>。由开发者来理解 <code>trait</code> 的 <code>规约</code> 并确保你的类型满足它。</p>
<p>将其类型变量与 <code>unsafe trait</code> 绑定的函数通常是使用 <code>unsafe trait</code> 本身的函数，并且仅通过依赖于 <code>unsafe trait</code> 的规约来满足它们的规约, <code>trait</code> 的不正确实现可能会导致此类函数表现出未定义的行为。</p>
<p><code>std::marker::Send</code> 和 <code>std::marker::Sync</code> 是 <code>unsafe trait</code> 的经典示例。这些 <code>trait</code> 没有定义任何方法，因此对于任何类型都可以轻松实现。但是它们确实有规约：<code>Send</code> 要求实现者可以安全地移动到另一个线程，而 <code>Sync</code> 要求它们可以安全地通过共享引用在线程之间共享。例如，为不合适的类型实现 <code>Send</code> 将使 <code>std::sync::Mutex</code> 不能完全避免数据竞争。</p>
<p>举个简单的例子，<code>Rust</code> 标准库曾经包含一个 <code>unsafe trait</code> 的 <code>core::nonzero::Zeroable</code>，用于可以通过将所有字节设置为零来安全初始化的类型。显然，将 <code>usize</code> 归零很好，但是将 <code>&amp;T</code> 归零会返回一个空引用，如果解引用，这将导致崩溃。对于可归零的类型，可以进行一些优化：可以使用 <code>std::ptr::write_bytes</code> （ <code>Rust</code> 的 <code>memset</code> 等效项）快速初始化它们的数组，或者使用分配归零页面的操作系统调用。 （ <code>Zeroable</code> 是不稳定的，在 <code>Rust 1.26</code> 的 <code>num</code> 包中被转移到仅供内部使用，但它是一个很好的、简单的、真实的例子。） <code>Zeroable</code> 是一个典型的标记特征，没有方法或相关类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Zeroable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>合适类型的实现同样简单：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Zeroable</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Zeroable</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Zeroable</span> <span class="keyword">for</span> <span class="title class_">usize</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用这些定义，我们可以编写一个函数来快速分配一个给定长度的包含 <code>Zeroable</code> 类型的 <code>vector</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> core::nonzero::Zeroable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">zeroed_vector</span>&lt;T&gt;(len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Zeroable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(len);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        std::ptr::<span class="title function_ invoke__">write_bytes</span>(vec.<span class="title function_ invoke__">as_mut_ptr</span>(), <span class="number">0</span>, len);</span><br><span class="line">        vec.<span class="title function_ invoke__">set_len</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先创建一个具有所需容量的空 <code>Vec</code>，然后调用 <code>write_bytes</code> 以用零填充未占用的缓冲区。（ <code>write_bytes</code> 函数将 <code>len</code> 视为 <code>T</code> 元素的数量，而不是字节的数量，所以这个调用确实填满了整个缓冲区。） <code>vector</code> 的 <code>set_len</code> 方法改变它的长度而不对缓冲区做任何事情； 这是不安全的，因为必须确保 <code>vector</code> 的缓冲区空间实际上包含正确初始化的 <code>T</code> 类型值。但这正是 <code>T：Zeroable</code> 界限所建立的：零字节块表示有效的 <code>T</code> 值，我们使用 <code>set_len</code> 是安全的。</p>
<p>这里我们可以写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt; = <span class="title function_ invoke__">zeroed_vector</span>(<span class="number">100_000</span>);</span><br><span class="line"><span class="built_in">assert!</span>(v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">all</span>(|&amp;u| u == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>显然，<code>Zeroable</code> 必须是一个不 <code>unsafe trait</code>，因为不尊重其规约的实现可能会导致未定义的行为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HoldsRef</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Zeroable <span class="keyword">for</span> <span class="title class_">HoldsRef</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;HoldsRef&gt; = <span class="title function_ invoke__">zeroed_vector</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">*v[<span class="number">0</span>].<span class="number">0</span> = <span class="number">1</span>; <span class="comment">// crashes: dereferences null pointer</span></span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 不知道 <code>Zeroable</code> 是什么意思，也不知道什么类型会实现它。与任何其他 <code>unsafe</code> 特性一样，由开发者来理解和遵守 <code>unsafe trait</code> 的规约。</p>
<h3 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h3><p><code>Rust</code> 中的裸指针是不受约束的指针，可以使用裸指针来形成 <code>Rust</code> 指针类型无法形成的各种结构，例如双向链表或任意对象图。但是由于裸指针非常灵活，<code>Rust</code> 无法判断是否安全地使用它们，因此只能在不安全的块中解引用。裸指针本质上等同于 <code>C</code> 或 <code>C++</code> 指针，因此它们对于与用这些语言编写的代码进行交互也很有用。</p>
<p>这里有两种类型的裸指针：</p>
<ol>
<li><code>*mut T</code>，指向 <code>T</code> 类型，并且允许对它指向的内容进行修改；</li>
<li><code>*const T</code>，指向 <code>T</code> 类型，但是只允许读取它引用的内容；</li>
</ol>
<p>（记住，这里没有 <code>*T</code> 类型，必须总是声明 <code>const</code> 或者 <code>mut</code>。）</p>
<p>可以将一个普通引用转换成裸指针，并且使用 <code>*</code> 解引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr_x</span> = &amp;<span class="keyword">mut</span> x <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr_y</span> = &amp;*y <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ptr_x += *ptr_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不像 <code>box</code> 和 <code>Rust</code> 引用，裸指针可能是空，类似于 <code>C</code> 里面的 <code>NULL</code>，或者 <code>C++</code> 中的 <code>nullptr</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">option_to_raw</span>&lt;T&gt;(opt: <span class="type">Option</span>&lt;&amp;T&gt;) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> T &#123;</span><br><span class="line">    <span class="keyword">match</span> opt &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; std::ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(r) =&gt; r <span class="keyword">as</span> *<span class="keyword">const</span> T,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert!</span>(!<span class="title function_ invoke__">option_to_raw</span>(<span class="title function_ invoke__">Some</span>(&amp;(<span class="string">&quot;pea&quot;</span>, <span class="string">&quot;pod&quot;</span>))).<span class="title function_ invoke__">is_null</span>());</span><br><span class="line"><span class="built_in">assert_eq!</span>(option_to_raw::&lt;<span class="type">i32</span>&gt;(<span class="literal">None</span>), std::ptr::<span class="title function_ invoke__">null</span>());</span><br></pre></td></tr></table></figure>

<p>这个例子没有 <code>unsafe</code> 代码块，因为创建裸指针，传递、比较都是安全的，仅解引用裸指针是不安全的。</p>
<p>指向 <code>unsized</code> 类型的裸指针是胖指针，就像对应的引用或 <code>Box</code> 类型一样。<code>*const [u8]</code> 指针包括长度和地址，并且像 <code>*mut dyn std::io::Write</code> 指针这样的 <code>trait</code> 对象携带 <code>vtable</code>。</p>
<p>尽管 <code>Rust</code> 在各种情况下隐式解引用安全指针类型，但裸指针解引用必须是显式的：</p>
<ul>
<li><p><code>.</code> 运算符不会隐式解引用裸指针，必须写 <code>(*raw).field</code> 或者 <code>(*raw).method(...)</code> ；</p>
</li>
<li><p>裸指针不实现 <code>Deref</code>，因此 <code>deref</code> 不适用于它们；</p>
</li>
<li><p>诸如 <code>==</code> 和 <code>&lt;</code> 之类的运算符将裸指针作为地址进行比较：如果两个裸指针指向内存中的相同位置，则它们相等。类似地，对裸指针进行 <code>hash</code> 是以它们的地址为输入，而不是它们指向的内容；</p>
</li>
<li><p>格式化 <code>trait</code>，如 <code>std::fmt::Display</code> 根本不处理裸指针，例外是 <code>std::fmt::Debug</code> 和 <code>std::fmt::Pointer</code>，它们将裸指针显示为十六进制地址，而不解引用它们；</p>
</li>
</ul>
<p>与 <code>C</code> 和 <code>C++</code> 中的 <code>+</code> 运算符不同，<code>Rust</code> 的 <code>+</code> 不处理裸指针，但可以通过它们的 <code>offset</code> 和 <code>wrapping_offset</code> 方法，或者更方便的 <code>add</code> 、 <code>sub</code> 、 <code>wrapping_add</code> 和 <code>wrapping_sub</code> 方法来执行指针运算。 相反，<code>offset_from</code> 方法以字节为单位给出两个指针之间的偏移量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trucks</span> = <span class="built_in">vec!</span>[<span class="string">&quot;garbage truck&quot;</span>, <span class="string">&quot;dump truck&quot;</span>, <span class="string">&quot;moonstruck&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span>: *<span class="keyword">const</span> &amp;<span class="type">str</span> = &amp;trucks[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span>: *<span class="keyword">const</span> &amp;<span class="type">str</span> = &amp;trucks[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="keyword">unsafe</span> &#123; last.<span class="title function_ invoke__">offset_from</span>(first) &#125;, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="keyword">unsafe</span> &#123; first.<span class="title function_ invoke__">offset_from</span>(last) &#125;, -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>first</code> 和 <code>last</code> 不需要显式转换，只需指定类型就足够了。 <code>as</code> 运算符允许引用和裸指针，或者两种裸指针类型之间的几乎所有可能的转换。但是，可能需要将复杂的转换分解为一系列更简单的步骤。 例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&amp;<span class="built_in">vec!</span>[<span class="number">42_u8</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">String</span>; <span class="comment">// error: invalid conversion</span></span><br><span class="line">&amp;<span class="built_in">vec!</span>[<span class="number">42_u8</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">String</span>; <span class="comment">// permitted</span></span><br></pre></td></tr></table></figure>

<p>以这种方式生成的引用具有不受约束的生命周期，它的生命周期没有限制，因为裸指针没有给 <code>Rust</code> 提供参考依据。还有就是 <code>as</code> 不能将裸指针转换为 <code>Rust</code> 的引用，这样的转换将是不安全的。而且，必须在 <code>unsafe</code> 代码块中解引用裸指针，然后借用结果值。</p>
<p>许多类型都有 <code>as_ptr</code> 和 <code>as_mut_ptr</code> 方法，它们返回指向其内容的裸指针。例如，数组切片和字符串返回指向它们的第一个元素的指针，并且一些迭代器返回指向它们将产生的下一个元素的指针。拥有像 <code>Box</code>、 <code>Rc</code> 和 <code>Arc</code> 这样的指针类型有 <code>into_raw</code> 和 <code>from_raw</code> 函数，它们可以在裸指针之间进行转换。其中一些方法的规约提出了难以置信的要求，因此在使用它们之前检查它们的文档。</p>
<p>允许将整数转换成裸指针，但通常是先把指针转换成整数，进行运算，然后转换成裸指针。</p>
<p>与 <code>Rust</code> 的引用不同，裸指针没有实现 <code>Send</code> 也没有实现 <code>Sync</code>。因此，默认情况下，任何包含裸指针的类型都不会实现这些 <code>Trait</code>。在线程之间发送或共享裸指针本身并没有什么不安全的。毕竟，无论它们走到哪里，都需要一个 <code>unsafe</code> 代码块来解引用它们。但是考虑到裸指针通常扮演的角色，语言设计者认为这种行为是最好的的默认设置。</p>
<h4 id="安全解引用裸指针"><a href="#安全解引用裸指针" class="headerlink" title="安全解引用裸指针"></a>安全解引用裸指针</h4><p>以下是一些安全使用裸指针的常识性指南：</p>
<ul>
<li><p>解引用空指针或悬空指针是未定义的行为，就像引用未初始化的内存或超出范围的值一样；</p>
</li>
<li><p>解引用未针对其引用类型正确对齐的指针是未定义的行为；</p>
</li>
<li><p>You may borrow values out of a dereferenced raw pointer only if doing so obeys the rules for reference safety: no reference may outlive its referent, shared access is read-only access, and mutable access is exclusive access.  (This rule is easy to violate by accident, since raw pointers are often used to create data structures with nonstandard sharing or ownership.)</p>
</li>
<li><p>只有当裸指针是其类型有效值时，才可以使用它的引用。例如，必须确保取消引用 <code>*const char</code> 会产生正确的 <code>Unicode</code> 代码点；</p>
</li>
<li><p>可以对裸指针使用 <code>offset</code> 和 <code>wrapping_offset</code> 方法，仅指向裸指针所指的变量或堆内存块中的字节，或指向超出该区域的第一个字节。如果通过将指针转换为整数、对整数进行算术然后将其转换回指针来进行指针运算，则结果必须是 <code>offset</code> 方法允许生成的指针，也就是遵循 <code>offset</code> 的规约；</p>
</li>
<li><p>If you assign to a raw pointer’s referent, you must not violate the invariants of any type of which the referent is a part. For example, if you have a <code>*mut u8</code> pointing to a byte of a <code>String</code> , you may only store values in that <code>u8</code> that leave the String holding well-formed <code>UTF-8</code> .</p>
</li>
</ul>
<p>除了借用规则之外，这些规则与在 <code>C</code> 或 <code>C++</code> 中使用指针时必须遵循的规则基本相同。</p>
<p>The reason for not violating types’ invariants should be clear. Many of Rust’s standard  types use unsafe code in their implementation, but still provide safe interfaces on the  assumption that Rust’s safety checks, module system, and visibility rules will be respected. Using raw pointers to circumvent these protective measures can lead to  undefined behavior.  </p>
<p>裸指针的完整、准确的约定不容易说明，并且可能随着语言的发展而改变，但是这里概述的原则可以让代码保持较为安全的状态。</p>
<h4 id="示例：-RefWithFlag"><a href="#示例：-RefWithFlag" class="headerlink" title="示例： RefWithFlag"></a>示例： <code>RefWithFlag</code></h4><p>下面是一个示例，说明如何利用裸指针实现的经典的位级 <code>hack</code> 并将其包装为完全安全的 <code>Rust</code> 类型。该模块定义了一个类型， <code>RefWithFlag&lt;&#39;a, T&gt;</code>，它同时包含一个 <code>&amp;&#39;a T</code> 和一个布尔值，就像元组 <code>(&amp;&#39;a T, bool)</code> 一样，但仍然设法只占用一个机器字而不是两个，这种技术经常在垃圾收集器和虚拟机中使用，其中某些类型（例如，表示对象的类型）非常多，以至于在每个值中添加一个机器字都会大大增加内存使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> ref_with_flag &#123;</span><br><span class="line">    <span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line">    <span class="keyword">use</span> std::mem::align_of;</span><br><span class="line">    <span class="comment">/// A `&amp;T` and a `bool` , wrapped up in a single word.</span></span><br><span class="line">    <span class="comment">/// The type `T` must require at least two-byte alignment.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// If you&#x27;re the kind of programmer who&#x27;s never met a pointer whose</span></span><br><span class="line">    <span class="comment">/// 2⁰-bit you didn&#x27;t want to steal, well, now you can do it safely!</span></span><br><span class="line">    <span class="comment">/// (&quot;But it&#x27;s not nearly as exciting this way...&quot;)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RefWithFlag</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        ptr_and_bit: <span class="type">usize</span>,</span><br><span class="line">        behaves_like: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;, <span class="comment">// occupies no space</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; RefWithFlag&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ptr: &amp;<span class="symbol">&#x27;a</span> T, flag: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> RefWithFlag&lt;T&gt; &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(align_of::&lt;T&gt;() % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">            RefWithFlag &#123;</span><br><span class="line">                ptr_and_bit: ptr <span class="keyword">as</span> *<span class="keyword">const</span> T <span class="keyword">as</span> <span class="type">usize</span> | flag <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">                behaves_like: PhantomData,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_ref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> T &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">ptr</span> = (<span class="keyword">self</span>.ptr_and_bit &amp; !<span class="number">1</span>) <span class="keyword">as</span> *<span class="keyword">const</span> T;</span><br><span class="line">                &amp;*ptr</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_flag</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.ptr_and_bit &amp; <span class="number">1</span> != <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码利用了许多类型必须放在内存中的偶数地址这一事实：由于偶数地址的最低有效位始终为零，我们可以在那里存储其他内容，然后只需通过屏蔽底部位即可重建原始地址。并非所有类型都符合条件，例如，类型 <code>u8</code> 和 <code>(bool, [i8; 2])</code> 可以放在任何地址。但是我们可以在构造函数中检查类型的对齐方式拒绝那些不能使用的类型。</p>
<p>我们可以这样使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ref_with_flag::RefWithFlag;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">flagged</span> = RefWithFlag::<span class="title function_ invoke__">new</span>(&amp;vec, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(flagged.<span class="title function_ invoke__">get_ref</span>()[<span class="number">1</span>], <span class="number">20</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(flagged.<span class="title function_ invoke__">get_flag</span>(), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数 <code>RefWithFlag::new</code> 接受一个引用和一个 <code>bool</code> 值，断言引用的类型是合适的，然后将引用转换为裸指针和 <code>usize</code>。 <code>usize</code> 类型被定义为足够大，可以在我们编译的任何处理器上保存一个指针，因此将裸指针转换为 <code>usize</code> 并返回是明确定义的。一旦我们有了一个 <code>usize</code>，我们就知道它一定是偶数，我们也已将其转换为整数 <code>0</code> 或 <code>1</code>，所以我们可以使用 <code>|</code> 按位或运算符将其与 <code>bool</code> 运算。</p>
<p><code>get_flag</code> 方法提取 <code>RefWithFlag</code> 的 <code>bool</code> 组件。这很简单：只需屏蔽底部位并检查它是否为非零。</p>
<p><code>get_ref</code> 方法从 <code>RefWithFlag</code> 中提取引用。首先，它屏蔽了 <code>usize</code> 的底部位并将其转换为裸指针。<code>as</code> 运算符不会将裸指针转换为引用，但我们可以解引用裸指针并借用它。借用一个裸指针的引用对象会给你一个无限生命周期的引用：<code>Rust</code> 将给予引用任何生命周期会使其周围的代码检查的生命周期。但是，通常有一些特定的生命周期更准确，因此会发现更多错误。在这种情况下，由于 <code>get_ref</code> 的返回类型是 <code>&amp;&#39;a T</code>，<code>Rust</code> 看到引用的生命周期与 <code>RefWithFlag</code> 的生命周期参数 <code>&#39;a</code> 相同，这正是我们想要的：这就是我们开始引用的生命周期。</p>
<p>在内存中，<code>RefWithFlag</code> 看起来就像一个 <code>usize</code>：因为 <code>PhantomData</code> 是一个零大小的类型，<code>behaviours_like</code> 字段在结构中不占用空间。但是 <code>PhantomData</code> 是 <code>Rust</code> 知道如何处理使用 <code>RefWithFlag</code> 的代码中的生命周期所必需的。想象一下没有 <code>behaves_like</code> 字段的类型会是什么样子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This won&#x27;t compile.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RefWithFlag</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    ptr_and_bit: <span class="type">usize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的章节中，指出任何包含引用的结构体都不能超过它们借用的值，以免引用变成悬空指针。该结构必须遵守适用于其字段的限制，这当然适用于 <code>RefWithFlag</code>：在我们刚刚查看的示例代码中，<code>flagged </code> 不能超过 <code>vec</code>，因为 <code>flagged.get_ref()</code> 返回对它的引用。但是我们简化的 <code>RefWithFlag</code> 类型根本不包含任何引用，并且从不使用它的生命周期参数 <code>&#39;a</code>。 <code>Rust</code> 通过包含一个 <code>PhantomData&lt;&amp;&#39;a T&gt; </code> 字段告诉 <code>Rust </code> 将 <code>RefWithFlag&lt;&#39;a, T&gt;</code> 视为包含一个 <code>&amp;&#39;a T</code>，而不会实际影响结构体的表示。</p>
<p>如果你省略了 <code>behaves_like</code> 字段， <code>Rust</code> 会认为 <code>&#39;a</code> 和 <code>T</code> 没有使用，并建议使用 <code>PhantomData</code>。</p>
<p><code>RefWithFlag</code> 使用与我们之前介绍的 <code>Ascii</code> 类型相同的策略来避免其 <code>unsafe</code> 块中的未定义行为。类型本身是 <code>pub</code>，但它的字段不是，这意味着只有 <code>ref_with_flag</code> 模块中的代码才能创建或查看 <code>RefWithFlag</code> 值，因此可确信 <code>ptr_and_bit</code> 字段构造是有效的。</p>
<h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p><code>Rust</code> 中的 <code>null</code> 裸指针是零地址，就像在 <code>C</code> 和 <code>C++</code> 中一样。对于任何类型 <code>T</code>，<code>std::ptr::null&lt;T&gt;</code> 函数返回一个 <code>*const T</code> 空指针，而 <code>std::ptr::null_mut&lt;T&gt;</code> 返回一个 <code>*mut T</code> 空指针。</p>
<p>有几种方法可以检查裸指针是否为空，最简单的是 <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.is_null"><code>is_null</code></a> 方法，但是 <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref"><code>as_ref</code></a> 方法可能更方便：它接受一个 <code>*const T</code> 指针并返回一个 <code>Option&lt;&amp;&#39;a T&gt;</code>，将一个空指针变成一个 <code>None</code>。 同样，<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.as_mut"> <code>as_mut</code> </a> 方法将 <code>*mut T</code> 指针转换为 <code>Option&lt;&amp;&#39;a mut T&gt;</code> 值。</p>
<h4 id="类型大小和对齐"><a href="#类型大小和对齐" class="headerlink" title="类型大小和对齐"></a>类型大小和对齐</h4><p>任何 <code>Sized</code> 类型的值在内存中占用恒定数量的字节，并且进行内存对齐，按多少对齐由机器体系结构确定。例如，一个 <code>(i32, i32)</code> 元组占用 <code>8</code> 个字节，大多数处理器更喜欢将它放置在一个 <code>4</code> 的倍数的地址上。</p>
<p>调用 <code>std::mem::size_of::&lt;T&gt;()</code> 返回 <code>T</code> 类型值的大小，以字节为单位，而 <code>std::mem::align_of::&lt;T&gt;()</code> 返回其所需的对齐方式。 例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;<span class="type">i64</span>&gt;(), <span class="number">8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(std::mem::align_of::&lt;(<span class="type">i32</span>, <span class="type">i32</span>)&gt;(), <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>任何类型的对齐方式始终是 <code>2</code> 的幂，一个类型的大小总是四舍五入到它的对齐的倍数，即使它在技术上可以容纳更少的空间。例如，即使像 <code>(f32, u8)</code> 这样的元组只需要 <code>5</code> 个字节， <code>size_of::&lt;(f32, u8)&gt;()</code> 也是 <code>8</code>，因为 <code>align_of::&lt;(f32, u8)&gt;()</code> 是 <code>4</code>。这确保如果有一个数组，则元素类型的大小始终反映一个元素与下一个元素之间的间距。</p>
<p>对于 <code>unsize</code> 类型，大小和对齐方式取决于手头的值。给定一个 <code>unsize</code> 值的引用， <code>std::mem::size_of_val</code> 和 <code>std::mem::align_of_val</code> 函数返回值的大小和对齐方式。这些函数可以对 <code>Sized</code> 和 <code>unsized</code> 类型的引用进行操作：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Fat pointers to slices carry their referent&#x27;s length.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;[<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>, <span class="number">81</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(slice), <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span>: &amp;<span class="type">str</span> = <span class="string">&quot;alligator&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(text), <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Display;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unremarkable</span>: &amp;<span class="keyword">dyn</span> Display = &amp;<span class="number">193_u8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remarkable</span>: &amp;<span class="keyword">dyn</span> Display = &amp;<span class="number">0.0072973525664</span>;</span><br><span class="line">    <span class="comment">// These return the size/alignment of the value the</span></span><br><span class="line">    <span class="comment">// trait object points to, not those of the trait object</span></span><br><span class="line">    <span class="comment">// itself. This information comes from the vtable the</span></span><br><span class="line">    <span class="comment">// trait object refers to.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(unremarkable), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">align_of_val</span>(remarkable), <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p><code>Rust</code> 将数组、切片或 <code>vector</code> 的元素布置为单个连续的内存块，如下图所示。元素是规则间隔的，因此如果每个元素占用 <code>size</code> 个字节，则第 <code>i</code> 个元素以第 <code>i * sizeth</code> 个字节开始。</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/array-in-memory.png" class="">

<p>这样做的一个很好的结果是，如果你有两个指向数组元素的裸指针，比较指针会得到与比较元素索引相同的结果：如果 <code>i &lt; j</code>，那么指向第 <code>i</code> 个元素的裸指针小于指向第 <code>j</code> 的裸指针，这使得裸指针可用作数组遍历的边界。事实上，标准库对切片的简单迭代器最初是这样定义的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Iter</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    ptr: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ptr</code> 字段指向下一次迭代应该产生的元素，<code>end</code> 字段作为限制：当 <code>ptr == end</code> 时，迭代完成。数组这样布局的另一个好处是：如果 <code>element_ptr</code> 是指向某个数组的第 <code>i</code> 个元素的 <code>*const T</code> 或 <code>*mut Traw </code> 指针，则 <code>element_ptr.offset(o)</code> 是指向第 <code>(i + o)</code> 个元素的裸指针。它的定义等价于：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">offset</span>&lt;T&gt;(ptr: *<span class="keyword">const</span> T, count: <span class="type">isize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes_per_element</span> = std::mem::size_of::&lt;T&gt;() <span class="keyword">as</span> <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_offset</span> = count * bytes_per_element;</span><br><span class="line">    (ptr <span class="keyword">as</span> <span class="type">isize</span>).<span class="title function_ invoke__">checked_add</span>(byte_offset).<span class="title function_ invoke__">unwrap</span>() <span class="keyword">as</span> *<span class="keyword">const</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::mem::size_of::&lt;T&gt;</code> 函数以字节为单位返回类型 <code>T</code> 的大小。由于根据定义， <code>isize</code> 大到足以容纳地址，因此您可以将基指针转换为 <code>isize</code>，对该值进行算术运算，然后将结果转换回指针。</p>
<p>使用 <code>offset</code> 生成超出该点或在数组开始之前的指针是未定义的行为，即使从未解引用它。为了优化， <code>Rust</code> 想假设当 <code>i</code> 为正时 <code>ptr.offset(i) &gt; ptr</code>，当 <code>i</code> 为负时 p <code>tr.offset(i) &lt; ptr</code>。这个假设似乎是安全的，但如果 <code>offset</code> 中的算术溢出，它可能不成立。如果 <code>i</code> 被限制在与 <code>ptr</code> 相同的数组中，则不会发生溢出：毕竟，数组本身不会溢出地址空间的边界。</p>
<p>如果确实需要将指针偏移到与它们关联的数组的限制之外，可以使用 <code>wrapping_offset</code> 方法，这等效于偏移量，但 <code>Rust</code> 不对 <code>ptr.wrapping_offset(i)</code> 和 <code>ptr</code> 本身的相对顺序做任何假设。当然，仍然不能解引用这些指针，除非它们在数组中。</p>
<h4 id="移入移出内存"><a href="#移入移出内存" class="headerlink" title="移入移出内存"></a>移入移出内存</h4><p>如果正在实现一种管理自己内存的类型，将需要跟踪内存的哪些部分保存实时值以及哪些未初始化，就像 <code>Rust</code> 处理局部变量一样。考虑这段代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">pot</span> = <span class="string">&quot;pasta&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">plate</span> = pot;</span><br></pre></td></tr></table></figure>

<p>这段代码运行之后，这两个变量的内存结构看起来如下图所示：</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/move-string-from-atob.png" class="">

<p>赋值后， <code>pot</code> 未初始化， <code>plate</code> 是字符串的所有者。在机器级别，并没有指定 <code>move</code> 对源有什么作用，但实际上它通常什么都不做。赋值可能使 <code>pot</code> 仍然保留字符串的指针、容量和长度。但是将 <code>pot</code> 视为存在值将是灾难性的， <code>Rust</code> 确保不会这样做。</p>
<p>同样的注意事项也适用于管理自己内存的数据结构。假设运行以下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">noodles</span> = <span class="built_in">vec!</span>[<span class="string">&quot;udon&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">soba</span> = <span class="string">&quot;soba&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">last</span>;</span><br></pre></td></tr></table></figure>

<p>内存中，看起来的结构如下图所示：</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/vector-with-uninitialized.png" class="">

<p>该 <code>vector</code> 有多余的容量再容纳一个元素，但它的内容是垃圾，可能是之前保存的内存。假设您随后运行此代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">noodles.<span class="title function_ invoke__">push</span>(soba);</span><br></pre></td></tr></table></figure>

<p>将字符串推送到 <code>vector</code> 上会将未初始化的内存转换为新元素，如下图所示：</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/after-push-sobas-onto-vec.png" class="">

<p>该 <code>vector</code> 已初始化其空白空间以拥有该字符串并增加其长度以将其标记为新的活动元素。 <code>vector</code> 现在是字符串的所有者；可以引用它的第二个元素，删除 <code>vector</code> 会释放两个字符串， <code>soba</code> 现在未初始化。</p>
<p>最后，考虑当我们从 <code>vector</code> 中弹出一个值时会发生什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">last = noodles.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>现在，它的内存看起来如下图所示：</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/after-pop-sobas-onto-vec.png" class="">

<p>变量 <code>last</code> 获得了字符串的所有权，该 <code>vector</code> 已减少其长度以指示用于保存字符串的空间现在未初始化。</p>
<p>就像之前的 <code>pot</code> 和 <code>pasta</code> 一样， <code>soba</code> 、 <code>last</code> 和 <code>vector</code> 的空闲空间可能都持有相同的位模式。但只有 <code>last</code> 被认为拥有该值，将其他两个位置中的任何一个视为可用都是错误的。</p>
<p>初始化值的真正定义是一个变量被视为可用。写入一个值的字节通常是初始化的必要步骤，但也只是因为这样做才会将变量视为可用。<code>move</code> 和 <code>copy</code> 对内存的影响是一样的，两者的区别在于，在 <code>move</code> 之后，源不再被视为可用的，而在 <code>copy</code> 之后，源和目标都是可用的。</p>
<p>Rust 会在编译时跟踪哪些局部变量处于可用状态，并阻止使用其值已移动到其他地方的变量。<code>Vec</code>、<code>HashMap</code>、<code>Box</code> 等类型动态跟踪它们的缓冲区。如果你实现一个类型来管理它自己的内存，你需要做同样的事情。</p>
<p><code>Rust</code> 提供了两个基本操作来实现这些类型：</p>
<ol>
<li><p><code>std::ptr::read(src)</code> ：将值移出 <code>src</code> 指向的位置，将所有权转移给调用者。 <code>src</code> 参数应该是一个 <code>*const T</code> 裸指针，其中 <code>T</code> 是一个 <code>Sized</code> 类型。调用此函数后， <code>*src</code> 的内容不受影响，但除非 <code>T</code> 实现了 <code>Copy</code>，否则必须确保程序将它们视为未初始化的内存。</p>
<p> 这是 <code>Vec::pop</code> 背后的操作。弹出一个值调用 <code>read</code> 将值移出缓冲区，然后递减长度以将该空间标记为未初始化的容量。</p>
</li>
<li><p><code>std::ptr::write(dest, value)</code> ：将 <code>value</code> 移动到 <code>dest</code> 指向的位置，该位置在调用之前必须是未初始化的内存， <code>dest</code> 引用的变量现在拥有该 <code>value</code>。 在这里， <code>dest</code> 必须是一个 <code>*mutT</code> 裸指针并且 <code>value</code> 是一个实现了 <code>Sized</code> 的 <code>T</code> 类型。</p>
<p> 这是 <code>Vec::push</code> 背后的操作。 <code>push</code> 一个 <code>value</code> 调用 <code>write</code> 将值移动到下一个可用空间，然后增加长度以将该空间标记为有效元素。</p>
</li>
</ol>
<p>两者都是自由函数，而不是裸指针类型的方法。不过请注意，不能使用 <code>Rust</code> 的任何安全指针类型来做这些事情。它们都要求始终初始化它们的所指对象，因此将未初始化的内存转换为值，反之亦然，它们是无法实现的，但是裸指针符合要求。</p>
<p>标准库还提供了将值数组从一个内存块移动到另一个内存块的函数：</p>
<ul>
<li><p><code>std::ptr::copy(src, dst, count)</code> ：将内存中从 <code>src</code> 开始的有 <code>count</code> 个元素的数组移动到 <code>dst</code> 的内存，就像编写了一个读取和写入调用循环来一次移动一个一样。目标内存必须在调用之前未初始化，之后源内存保持未初始化。 <code>src</code> 和 <code>dest</code> 参数必须是 <code>*const T</code> 和 <code>*mut T</code> 裸指针，并且 <code>count</code> 必须是 <code>usize</code> ；</p>
</li>
<li><p><code>ptr.copy_to(dst, count)</code> ： <code>copy</code> 的简单易用版本，它将内存中从 <code>ptr</code> 开始的有 <code>count</code> 个元素的数组移动到 <code>dst</code> ；</p>
</li>
<li><p><code>std::ptr::copy_nonoverlapping(src, dst, count)</code> ：与相应的 <code>copy</code> 类似，只是它的规约进一步要求内存的源块和目标块不能重叠。这可能比调用 <code>copy</code> 稍微快一些；</p>
</li>
<li><p><code>ptr.copy_to_nonoverlapping(dst, count)</code> ：更方便的 <code>copy_nonoverlapping</code> 版本，例如 <code>copy_to</code> ；</p>
</li>
</ul>
<p>在 <code>std::ptr</code> 模块中还有另外两个读写函数系列：</p>
<ul>
<li><p><code>read_unaligned, write_unaligned</code> ：这些函数类似于 <code>read</code> 和 <code>write</code>，除了指针不需要按照引用类型的通常要求进行对齐。这些函数可能比普通的读写函数慢；</p>
</li>
<li><p><code>read_volatile, write_volatile</code> ：这些函数相当于 <code>C</code> 或 <code>C++</code> 中的 <code>volatile</code> 读写；</p>
</li>
</ul>
<h4 id="示例：-GapBuffer"><a href="#示例：-GapBuffer" class="headerlink" title="示例： GapBuffer"></a>示例： <code>GapBuffer</code></h4><p>这是一个使用刚刚描述的裸指针函数的示例。假设正在编写一个文本编辑器，并且正在寻找一种类型来表示文本。可以选择 <code>String</code> 并使用 <code>insert</code> 和 <code>remove</code> 方法在用户键入时插入和删除字符。但是如果他们在一个大文件的开头编辑文本，这些方法可能会很昂贵：插入一个新字符需要将整个字符串的其余部分移到内存中的右侧，而删除则将其全部移回左侧。</p>
<p><code>Emacs</code> 文本编辑器使用一种称为间隙缓冲区的简单数据结构，可以在恒定时间内插入和删除字符。 <code>String</code> 将其所有备用容量保留在文本的末尾，这使得 <code>push</code> 和 <code>pop</code> 比较轻量，而间隙缓冲区将其备用容量保留在文本中间，即进行编辑的位置，这种备用能力称为缺口。在间隙插入或删除元素很轻量：只需根据需要缩小或扩大间隙。可以通过将文本从间隙的一侧移动到另一侧来将间隙移动到喜欢的任何位置。当间隙为空时，将迁移到更大的缓冲区。</p>
<p>虽然间隙缓冲区中的插入和删除速度很快，但更改它们发生的位置需要将间隙移动到新位置，移动元素需要与移动距离成比例的时间。幸运的是，典型的编辑活动包括在缓冲区的一个邻域进行一系列更改，然后再开始在其他地方修改文本。</p>
<p>在本节中，我们将在 <code>Rust</code> 中实现一个间隙缓冲区。为了避免被 <code>UTF-8</code> 分散注意力，我们将让缓冲区直接存储 <code>char</code> 值，但如果我们以其他形式存储文本，操作原理将是相同的。</p>
<p>首先，我们将展示一个实际的间隙缓冲区。此代码创建一个 <code>GapBuffer</code>，在其中插入一些文本，然后将插入点移动到最后一个单词之前：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = GapBuffer::<span class="title function_ invoke__">new</span>();</span><br><span class="line">buf.<span class="title function_ invoke__">insert_iter</span>(<span class="string">&quot;Lord of the Rings&quot;</span>.<span class="title function_ invoke__">chars</span>());</span><br><span class="line">buf.<span class="title function_ invoke__">set_position</span>(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>运行代码之后，缓冲池可能如下如所示：</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/gap-buf-contain-some-text.png" class="">

<p>插入是用新文本填补空白的问题，这段代码加了一个词 <code>Onion</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">buf.<span class="title function_ invoke__">insert_iter</span>(<span class="string">&quot;Onion &quot;</span>.<span class="title function_ invoke__">chars</span>());</span><br></pre></td></tr></table></figure>

<p>插入之后如下图所示：</p>
<img data-src="/2022/04/18/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/gap-buf-contain-some-more-text.png" class="">

<p>这个就是我们的 <code>GapBuffer</code> 类型实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std;</span><br><span class="line"><span class="keyword">use</span> std::ops::Range;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GapBuffer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// Storage for elements. This has the capacity we need, but its length</span></span><br><span class="line">    <span class="comment">// always remains zero. GapBuffer puts its elements and the gap in this</span></span><br><span class="line">    <span class="comment">// `Vec` &#x27;s &quot;unused&quot; capacity.</span></span><br><span class="line">    storage: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">    <span class="comment">// Range of uninitialized elements in the middle of `storage` .</span></span><br><span class="line">    <span class="comment">// Elements before and after this range are always initialized.</span></span><br><span class="line">    gap: Range&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GapBuffer</code> 以一种奇怪的方式使用它的存储字段，它实际上从未在 <code>vector</code> 中存储任何元素或不完全存储。它只是调用 <code>Vec::with_capacity(n)</code> 来获得足够大的内存块来保存 <code>n</code> 个值，通过向量的 <code>as_ptr</code> 和 <code>as_mut_ptr</code> 方法获得指向该内存的裸指针，然后直接将缓冲区用于自己的目的，向量的长度始终保持为 <code>0</code>。 当 <code>Vec</code> 被丢弃时， <code>Vec</code> 不会尝试释放它的元素，因为它不知道它有任何元素，但它确实释放了内存块。 这就是 <code>GapBuffer</code> 想要的；它有自己的 <code>Drop</code> 实现，它知道活动元素的位置并正确删除它们。</p>
<p><code>GapBuffer</code> 最简单的几个方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; GapBuffer&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> GapBuffer&lt;T&gt; &#123;</span><br><span class="line">        GapBuffer &#123;</span><br><span class="line">            storage: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            gap: <span class="number">0</span>..<span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the number of elements this GapBuffer could hold without</span></span><br><span class="line">    <span class="comment">/// reallocation.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">capacity</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.storage.<span class="title function_ invoke__">capacity</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the number of elements this GapBuffer currently holds.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() - <span class="keyword">self</span>.gap.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the current insertion position.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gap.start</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续实现这个 <code>impl</code>，实现返回一个指向指定索引的只读裸指针和指向指定索引的可变裸指针：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Return a pointer to the `index` th element of the underlying storage,</span></span><br><span class="line"><span class="comment">/// regardless of the gap.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Safety: `index` must be a valid index into `self.storage` .</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">space</span>(&amp;<span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> T &#123;</span><br><span class="line">    <span class="keyword">self</span>.storage.<span class="title function_ invoke__">as_ptr</span>().<span class="title function_ invoke__">offset</span>(index <span class="keyword">as</span> <span class="type">isize</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Return a mutable pointer to the `index` th element of the underlying</span></span><br><span class="line"><span class="comment">/// storage, regardless of the gap.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Safety: `index` must be a valid index into `self.storage` .</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">space_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">mut</span> T &#123;</span><br><span class="line">    <span class="keyword">self</span>.storage.<span class="title function_ invoke__">as_mut_ptr</span>().<span class="title function_ invoke__">offset</span>(index <span class="keyword">as</span> <span class="type">isize</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要找到给定索引处的元素，必须考虑索引是落在间隙之前还是之后并适当调整：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Return the offset in the buffer of the `index` th element, taking</span></span><br><span class="line"><span class="comment">/// the gap into account. This does not check whether index is in range,</span></span><br><span class="line"><span class="comment">/// but it never returns an index in the gap.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index_to_raw</span>(&amp;<span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.gap.start &#123;</span><br><span class="line">        index</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index + <span class="keyword">self</span>.gap.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Return a reference to the `index` th element,</span></span><br><span class="line"><span class="comment">/// or `None` if `index` is out of bounds.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">index_to_raw</span>(index);</span><br><span class="line">    <span class="keyword">if</span> raw &lt; <span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// We just checked `raw` against self.capacity(),</span></span><br><span class="line">            <span class="comment">// and index_to_raw skips the gap, so this is safe.</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(&amp;*<span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(raw))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们开始在缓冲区的不同部分进行插入和删除时，我们需要将间隙移动到新位置。将间隙向右移动需要向左移动元素，反之亦然，就像水平仪中的气泡在流体流入另一个方向时向一个方向移动：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Set the current insertion position to `pos` .</span></span><br><span class="line"><span class="comment">/// If `pos` is out of bounds, panic.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_position</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pos: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> pos &gt; <span class="keyword">self</span>.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;index &#123;&#125; out of range for GapBuffer&quot;</span>, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">gap</span> = <span class="keyword">self</span>.gap.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">if</span> pos &gt; gap.start &#123;</span><br><span class="line">            <span class="comment">// `pos` falls after the gap. Move the gap right</span></span><br><span class="line">            <span class="comment">// by shifting elements after the gap to before it.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">distance</span> = pos - gap.start;</span><br><span class="line">            std::ptr::<span class="title function_ invoke__">copy</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(gap.end), <span class="keyword">self</span>.<span class="title function_ invoke__">space_mut</span>(gap.start), distance);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> pos &lt; gap.start &#123;</span><br><span class="line">            <span class="comment">// `pos` falls before the gap. Move the gap left</span></span><br><span class="line">            <span class="comment">// by shifting elements before the gap to after it.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">distance</span> = gap.start - pos;</span><br><span class="line">            std::ptr::<span class="title function_ invoke__">copy</span>(</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(pos),</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">space_mut</span>(gap.end - distance),</span><br><span class="line">                distance,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.gap = pos..pos + gap.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数使用 <code>std::ptr::copy</code> 方法移动元素； <code>copy</code> 要求目标未初始化，而源未初始化，源和目标范围可能重叠，但 <code>copy</code> 可以正确处理这种情况。由于间隙是调用前未初始化的内存，并且函数调整间隙的位置以覆盖副本腾出的空间，因此满足 <code>copy</code> 函数的规约。</p>
<p>元素插入和移除相对简单。插入从新元素的间隙中占据一个空间，而删除将一个值移出并扩大间隙以覆盖它曾经占用的空间：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Insert `elt` at the current insertion position,</span></span><br><span class="line"><span class="comment">/// and leave the insertion position after it.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elt: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.gap.<span class="title function_ invoke__">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">enlarge_gap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span> = <span class="keyword">self</span>.gap.start;</span><br><span class="line">        std::ptr::<span class="title function_ invoke__">write</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space_mut</span>(index), elt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.gap.start += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Insert the elements produced by `iter` at the current insertion</span></span><br><span class="line"><span class="comment">/// position, and leave the insertion position after them.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert_iter</span>&lt;I&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, iterable: I)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    I: <span class="built_in">IntoIterator</span>&lt;Item = T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> iterable &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">insert</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Remove the element just after the insertion position</span></span><br><span class="line"><span class="comment">/// and return it, or return `None` if the insertion position</span></span><br><span class="line"><span class="comment">/// is at the end of the GapBuffer.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.gap.end == <span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = <span class="keyword">unsafe</span> &#123; std::ptr::<span class="title function_ invoke__">read</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(<span class="keyword">self</span>.gap.end)) &#125;;</span><br><span class="line">    <span class="keyword">self</span>.gap.end += <span class="number">1</span>;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>Vec</code> 使用 <code>std::ptr::write</code> 进行 <code>push</code> 和 <code>std::ptr::read</code> 进行 <code>pop</code> 的方式类似， <code>GapBuffer</code> 使用 <code>write</code> 插入和 <code>read</code> 删除。 就像 <code>Vec</code> 必须调整它的长度以保持初始化元素和备用容量之间的边界一样， <code>GapBuffer</code> 也会调整它的间隙。</p>
<p>当间隙被填满时， <code>insert</code> 方法必须增大缓冲区以获取更多可用空间。 <code>expand_gap</code> 方法处理这个问题：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Double the capacity of `self.storage` .</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">enlarge_gap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_capacity</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> new_capacity == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// The existing vector is empty.</span></span><br><span class="line">        <span class="comment">// Choose a reasonable starting capacity.</span></span><br><span class="line">        new_capacity = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We have no idea what resizing a Vec does with its &quot;unused&quot;</span></span><br><span class="line">    <span class="comment">// capacity. So just create a new vector and move over the elements.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(new_capacity);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">after_gap</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() - <span class="keyword">self</span>.gap.end;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_gap</span> = <span class="keyword">self</span>.gap.start..new.<span class="title function_ invoke__">capacity</span>() - after_gap;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// Move the elements that fall before the gap.</span></span><br><span class="line">        std::ptr::<span class="title function_ invoke__">copy_nonoverlapping</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(<span class="number">0</span>), new.<span class="title function_ invoke__">as_mut_ptr</span>(), <span class="keyword">self</span>.gap.start);</span><br><span class="line">        <span class="comment">// Move the elements that fall after the gap.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_gap_end</span> = new.<span class="title function_ invoke__">as_mut_ptr</span>().<span class="title function_ invoke__">offset</span>(new_gap.end <span class="keyword">as</span> <span class="type">isize</span>);</span><br><span class="line">        std::ptr::<span class="title function_ invoke__">copy_nonoverlapping</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(<span class="keyword">self</span>.gap.end), new_gap_end, after_gap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This frees the old Vec, but drops no elements,</span></span><br><span class="line">    <span class="comment">// because the Vec&#x27;s length is zero.</span></span><br><span class="line">    <span class="keyword">self</span>.storage = new;</span><br><span class="line">    <span class="keyword">self</span>.gap = new_gap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set_position</code> 必须使用 <code>copy</code> 在间隙中来回移动元素，而 <code>enlarge_gap</code> 可以使用 <code>copy_nonoverlapping</code>，因为它将元素移动到全新的缓冲区。</p>
<p>将新 <code>vector</code> 移动到 <code>self.storage</code> 会删除旧 <code>vector</code>。由于它的长度为零，旧 <code>vector</code> 认为它没有元素可以丢弃并简单地释放它的缓冲区。 巧妙地， <code>copy_nonoverlapping</code> 让它的源未初始化，所以旧 <code>vector</code> 在这个信念上是正确的：所有元素现在都由新 <code>vector</code> 所有。</p>
<p>最后，我们需要确保删除 <code>GapBuffer</code> 会删除其所有元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">GapBuffer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.gap.start &#123;</span><br><span class="line">                std::ptr::<span class="title function_ invoke__">drop_in_place</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space_mut</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="keyword">self</span>.gap.end..<span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() &#123;</span><br><span class="line">                std::ptr::<span class="title function_ invoke__">drop_in_place</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space_mut</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元素位于间隙之前和之后，因此我们遍历每个区域并使用 <code>std::ptr::drop_in_place</code> 函数删除每个区域。 <code>drop_in_place</code> 函数是一个行为类似于 <code>drop(std::ptr::read(ptr))</code> 的实用程序，但不会将值移动到其调用者（因此适用于未调整大小的类型）。就像 <code>enlarge_gap</code> 一样，当向量 <code>self.storage</code> 被删除时，它的缓冲区实际上是未初始化的。</p>
<p>就像我们在本文中展示的其他类型一样， <code>GapBuffer</code> 确保它自己的不变量足以确保它使用的每个 <code>unsafe</code> 特性的规约都被遵循，因此它的任何公共方法都不需要标记为 <code>unsafe</code>， <code>GapBuffer</code> 实现了高效的接口但是这些没法使用安全代码做到。</p>
<p>完整的例子，请看 <a href="https://github.com/ProgrammingRust/examples/tree/master/gap-buffer">https://github.com/ProgrammingRust/examples/tree/master/gap-buffer</a>。</p>
<h4 id="unsafe-中的-Panic"><a href="#unsafe-中的-Panic" class="headerlink" title="unsafe 中的 Panic"></a><code>unsafe</code> 中的 <code>Panic</code></h4><p>在 <code>Rust</code> 中， <code>panic</code> 通常不会导致未定义的行为； <code>panic!</code> 不是 <code>unsafe</code> 功能。但是当你决定使用 <code>unsafe</code> 代码时， <code>panic</code> 安全需要关注了。考虑上一节中的 <code>GapBuffer::remove </code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Remove the element just after the insertion position</span></span><br><span class="line"><span class="comment">/// and return it, or return `None` if the insertion position</span></span><br><span class="line"><span class="comment">/// is at the end of the GapBuffer.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.gap.end == <span class="keyword">self</span>.<span class="title function_ invoke__">capacity</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = <span class="keyword">unsafe</span> &#123; std::ptr::<span class="title function_ invoke__">read</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">space</span>(<span class="keyword">self</span>.gap.end)) &#125;;</span><br><span class="line">    <span class="keyword">self</span>.gap.end += <span class="number">1</span>;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>read</code> 将紧随间隙的元素移出了缓冲区，留下了未初始化的空间。在这一点上， <code>GapBuffer</code> 处于不一致的状态：我们破坏了所有在间隙外的元素必须被初始化的不变性。幸运的是，下一条语句扩大了间隙以覆盖这个空间，所以当我们返回时，不变性再次成立。       </p>
<p>但是考虑一下，如果在调用 <code>read</code> 之后，但在调整为 <code>self.gap.end</code> 之前，这段代码试图使用一个可能会引起 <code>panic</code> 的功能–比如，对一个片断进行索引，那么会发生什么。下一次调用 <code>remove</code> 可能会尝试再次读取它；甚至简单地丢弃 <code>GapBuffer</code> 也会尝试放弃它。两者都是未定义的行为，因为它们访问了未初始化的内存。    </p>
<p>一个类型的方法在做工作的时候，暂时放松该类型的不变性，然后在返回之前将一切恢复原状，这几乎是不可避免的。方法中间的错误可能会缩短清理过程，使类型处于不一致的状态。     </p>
<p>如果类型只使用安全代码，那么这种不一致可能会使类型行为异常，但不会引入未定义的行为。但是使用 <code>unsafe</code> 特性的代码通常依靠其不变量来满足这些特性的规约，损坏的不变量会导致破坏规约，从而导致未定义的行为。在使用 <code>unsafe</code> 功能时，必须特别注意识别这些敏感的代码区域，其中不变量会暂时放松，并确保它们不做任何可能引起 <code>panic</code> 的事情。</p>
<h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a><code>Union</code></h3><p><code>Rust</code> 提供了许多有用的抽象，但最终编写的软件还是在处理字节。 <code>Union</code> 是 <code>Rust</code> 处理这些字节并选择如何解释它们的最强大的功能之一。 例如，任何 <code>32</code> 位（ <code>4</code> 个字节）的集合都可以被解释为整数或浮点数。任何一种解释都是有效的，尽管将数据解释为一个可能会导致无意义。</p>
<p>表示可以解释为整数或浮点数的字节集合的 <code>Union</code> 可以如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">FloatOrInt</span> &#123;</span><br><span class="line">    f: <span class="type">f32</span>,</span><br><span class="line">    i: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个具有两个字段 <code>f</code> 和 <code>i</code> 的 <code>union</code>，它们可以像结构体的字段一样被分配，但是在构造 <code>union</code> 时，与结构体不同，只可以选择其中一个。 结构体的字段指的是内存中的不同位置，而 <code>union</code> 的字段指的是同一位序列的不同解释。分配给不同的字段仅仅意味着根据适当的类型覆盖这些位中的一些或全部。这里， <code>one</code> 指的是单个 <code>32</code> 位内存跨度，它首先存储编码为简单整数的 <code>1</code>，然后存储 <code>1.0</code> 作为 <code>IEEE 754</code> 浮点数。一旦写入 <code>f</code>，之前写入 <code>FloatOrInt</code> 的值就会被覆盖：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">one</span> = FloatOrInt &#123; i: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="keyword">unsafe</span> &#123; one.i &#125;, <span class="number">0x00_00_00_01</span>);</span><br><span class="line">    one.f = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="keyword">unsafe</span> &#123; one.i &#125;, <span class="number">0x3F_80_00_00</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出于同样的原因， <code>union</code> 的大小由其最大的字段决定。例如，这个 <code>union</code> 的大小是 <code>64</code> 位，尽管 <code>SmallOrLarge::s</code> 只是一个布尔值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">SmallOrLarge</span> &#123;</span><br><span class="line">    s: <span class="type">bool</span>,</span><br><span class="line">    l: <span class="type">u64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然构造 <code>union</code> 或给它的字段赋值是完全安全的，但从 <code>union</code> 的任何字段中读取总是不安全的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">u</span> = SmallOrLarge &#123; l: <span class="number">1337</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123;u.l&#125;); <span class="comment">// prints 1337</span></span><br></pre></td></tr></table></figure>

<p>这是因为，与枚举不同， <code>union</code> 没有标签。编译器没有添加额外的位来区分变体。除非程序有一些额外的上下文，否则无法在运行时判断 <code>SmallOrLarge</code> 是要解释为 <code>u64</code> 还是 <code>bool</code>。</p>
<p>也没有内置保证给定字段的位模式有效。例如，写入 <code>SmallOrLarge</code> 值的 <code>l</code> 字段将覆盖其 <code>s</code> 字段，创建一个绝对没有任何用处的位模式，并且很可能不是有效的布尔值。因此，虽然写入 <code>union</code> 字段是安全的，但每个读取需要 <code>unsafe</code>。只有当 <code>s</code> 字段的位形成有效的布尔值时，才允许从 <code>u.s</code> 读取，否则，这是未定义的行为。</p>
<p>考虑到这些限制， <code>union</code> 可能是一种临时重新解释数据的有用方法，尤其是在对值的表示而不是值本身进行计算时。例如，前面提到的 <code>FloatOrInt</code> 类型可以很容易地用于打印出浮点数的各个位，尽管 <code>f32</code> 没有实现二进制格式化程序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = FloatOrInt &#123; f: <span class="number">31337.0</span> &#125;;</span><br><span class="line"><span class="comment">// prints 1000110111101001101001000000000</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:b&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; float.i &#125;);</span><br></pre></td></tr></table></figure>

<p>尽管这些简单的示例几乎可以肯定在任何版本的编译器上都能按预期工作，但不能保证任何字段都从特定位置开始，除非在联合定义中添加一个属性，告诉编译器如何在内存中布局数据。 添加属性 <code>#[repr(C)]</code> 保证所有字段都从偏移量 <code>0</code> 开始，而不是编译器喜欢的任何位置。有了该保证，覆盖行为可用于提取单个位，例如整数的符号位：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">SignExtractor</span> &#123;</span><br><span class="line">    value: <span class="type">i64</span>,</span><br><span class="line">    bytes: [<span class="type">u8</span>; <span class="number">8</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sign</span>(int: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">se</span> = SignExtractor &#123; value: int &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:b&#125; (&#123;:?&#125;)&quot;</span>, <span class="keyword">unsafe</span> &#123; se.value &#125;, <span class="keyword">unsafe</span> &#123; se.bytes &#125;);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; se.bytes[<span class="number">7</span>] &gt;= <span class="number">0b10000000</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">sign</span>(-<span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">sign</span>(<span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">sign</span>(<span class="type">i64</span>::MAX), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">sign</span>(<span class="type">i64</span>::MIN), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该程序输出：</p>
<pre><code>1111111111111111111111111111111111111111111111111111111111111111 ([255, 255, 255, 255, 255, 255, 255, 255])
1 ([1, 0, 0, 0, 0, 0, 0, 0])
111111111111111111111111111111111111111111111111111111111111111 ([255, 255, 255, 255, 255, 255, 255, 127])
1000000000000000000000000000000000000000000000000000000000000000 ([0, 0, 0, 0, 0, 0, 0, 128])
</code></pre>
<p>这里，符号位是最高有效字节的最高有效位。 因为 <code>x86</code> 处理器是 <code>little-endian</code>，所以这些字节的顺序是相反的；最重要的字节不是字节 <code>[0]</code>，而是字节 <code>[7]</code>。通常，这不是 <code>Rust</code> 代码必须处理的事情，但因为这段代码直接使用 <code>i64 </code> 的内存表示，所以这些低级细节变得很重要。</p>
<p>因为 <code>union</code> 不知道如何删除它们的内容，所以它们的所有字段都必须是 <code>Copy</code>。但是，如果只是必须将 <code>String</code> 存储在 <code>union </code> 中，则有一种解决方法，请查阅 <code>std::mem::ManuallyDrop</code> 的标准库文档。</p>
<h4 id="匹配-Union"><a href="#匹配-Union" class="headerlink" title="匹配 Union"></a>匹配 <code>Union</code></h4><p>在 <code>Rust</code> <code>union</code> 上进行匹配就像在结构上进行匹配，只是每个模式都必须准确地指定一个字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> u &#123;</span><br><span class="line">        SmallOrLarge &#123; s: <span class="literal">true</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;boolean true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SmallOrLarge &#123; l: <span class="number">2</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;integer 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配联合变体而不指定匹配的值将始终成功。 下面如果 <code>u</code> 的最后更新字段是 <code>u.i</code>，则以下代码将导致未定义的行为：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Undefined behavior!</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> u &#123;</span><br><span class="line">        FloatOrInt &#123; f &#125; =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;float &#123;&#125;&quot;</span>, f) &#125;,</span><br><span class="line">        <span class="comment">// warning: unreachable pattern</span></span><br><span class="line">        FloatOrInt &#123; i &#125; =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;int &#123;&#125;&quot;</span>, i) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="借用-Union"><a href="#借用-Union" class="headerlink" title="借用 Union"></a>借用 <code>Union</code></h4><p>借用 <code>union</code> 的一个字段会借用整个 <code>union</code>。这意味着，按照正常的借用规则，将一个字段借用为可变字段会排除对该字段或其他字段的任何额外借用，而将一个字段借用为不可变字段意味着在任何字段上都不能有可变借用。</p>
<p><code>Rust</code> 不仅可以为自己的 <code>unsafe</code> 代码构建安全接口，还可以为用其他语言编写的代码构建安全接口。顾名思义， <code>unsafe</code> 虽然令人望而生畏，但小心使用它可以构建高性能代码，并保留 <code>Rust</code> 程序员享有的保障。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>unsafe</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】Foreign Function</title>
    <url>/2022/04/17/%E3%80%90Rust%E3%80%91foreign-function/</url>
    <content><![CDATA[<p>世界上的每个程序并非都是用 <code>Rust</code> 编写的，我们希望能够在我们的 <code>Rust</code> 程序中使用许多用其他语言实现的关键库和接口。<code>Rust</code> 的外部函数接口 (<code>FFI</code>) 允许 <code>Rust</code> 代码调用用 <code>C</code> 编写的函数，也可以是 <code>C++</code>。由于大多数操作系统都提供 <code>C</code> 接口，<code>Rust</code> 的外部函数接口允许立即访问各种低级功能。</p>
<p>在本章中，我们将编写一个与 <code>libgit2</code> 链接的程序，<code>libgit2</code> 是一个用于与 <code>Git</code> 版本控制系统一起工作的 <code>C</code> 库。首先，我们使用前一章中展示的 <code>unsafe</code> 特性展示直接从 <code>Rust</code> 使用 <code>C</code> 函数的例子，然后，我们将展示如何构建 <code>libgit2</code> 的安全接口，灵感来自开源 <code>git2-rs</code>。本文假设你熟悉 <code>C</code> 以及编译和链接 <code>C</code> 程序的机制，还假设熟悉 <code>Git</code> 版本控制系统。</p>
<p>现实中确实存在用于与许多其他语言进行通信的 <code>Rust</code> 包，包括 <code>Python</code>、<code>JavaScript</code>、<code>Lua</code> 和 <code>Java</code>。这里没有篇幅介绍它们，但归根结底，所有这些接口都是使用 <code>C</code> 外来函数接口构建的。</p>
<span id="more"></span>

<h3 id="通用数据表示"><a href="#通用数据表示" class="headerlink" title="通用数据表示"></a>通用数据表示</h3><p><code>Rust</code> 和 <code>C</code> 的共同点是机器语言，所以为了预测 <code>Rust</code> 值在 <code>C</code> 代码中的样子，反之亦然，需要考虑它们的机器级表示。在该书中，强调了值是如何在内存中实际表示的，所以可能已经注意到 <code>C</code> 和 <code>Rust</code> 的数据世界有很多共同点：<code>Rust</code> 的 <code>usize</code> 和 <code>C</code> 的 <code>size_t</code> 是相同的，结构体在两种语言中基本上也是相同的。为了在 <code>Rust</code> 和 <code>C</code> 类型之间建立对应关系，我们将从基本类型开始，然后逐步发展到更复杂的类型。</p>
<p>鉴于其主要用作系统编程语言，<code>C</code> 对其类型的表示一直出人意料地松散，一个 <code>int</code> 通常为 <code>32</code> 位长，但可能更长，或短至 <code>16</code> 位。<code>C</code> <code>char</code> 可以有符号或无符号，等等。为了应对这种可变性，<code>Rust</code> 的 <code>std::os::raw</code> 模块定义了一组 <code>Rust</code> 类型，这些类型保证与某些 <code>C</code> 类型具有相同的表示形式，它们涵盖了原始整数和字符类型。如下图所示：</p>
<img data-src="/2022/04/17/%E3%80%90Rust%E3%80%91foreign-function/ctype-mapto-rust.png" class="">

<ul>
<li><p>除了 <code>c_void</code>，这里所有的 <code>Rust</code> 类型都是一些原始 <code>Rust</code> 类型的别名：例如，<code>c_char</code> 是 <code>i8</code> 或 <code>u8</code>；</p>
</li>
<li><p><code>Rust</code> 的 <code>bool</code> 等价于 <code>C/C++</code> 的布尔值；</p>
</li>
<li><p><code>Rust</code> 的 <code>32</code> 位 <code>char</code> 类型不是 <code>wchar_t</code> 的类似物，<code>wchar_t</code> 的宽度和编码因实现而异。<code>C</code> 的 <code>char32_t</code> 类型更接近，但它的编码仍然不能保证是 <code>Unicode</code>；</p>
</li>
<li><p><code>Rust</code> 的原始 <code>usize</code> 和 <code>isize</code> 类型与 <code>C</code> 的 <code>size_t</code> 和 <code>ptrdiff_t</code> 具有相同的表示；</p>
</li>
<li><p><code>C</code> 和 <code>C++</code> 指针和 <code>C++</code> 引用对应于 <code>Rust</code> 的原始指针类型 <code>*mut T</code> 和 <code>*const T</code>；</p>
</li>
<li><p>从技术上讲，<code>C</code> 标准允许实现使用 <code>Rust</code> 没有相应类型的表示：<code>36</code> 位整数、带符号值的符号和大小表示等。实际上，在 <code>Rust</code> 被移植到的每个平台上，每个常见的 <code>C</code> 整数类型在 <code>Rust</code> 中都有一个匹配项；</p>
</li>
</ul>
<p>要定义与 <code>C</code> 结构兼容的 <code>Rust</code> 结构类型，可以使用 <code>#[repr(C)]</code> 属性。将 <code>#[repr(C)]</code> 放在结构定义上方要求 <code>Rust</code> 在内存中排布结构体的字段，就像 <code>C </code>编译器排布 <code>C</code> 结构类型一样。例如，<code>libgit2</code> 的 <code>git2/errors.h</code> 头文件定义了以下 <code>C</code> 结构体，以提供有关先前报告的错误的详细信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *message;</span><br><span class="line">    <span class="type">int</span> klass;</span><br><span class="line">&#125; git_error;</span><br></pre></td></tr></table></figure>

<p>可以定义具有相同表示的 <code>Rust</code> 类型，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::os::raw::&#123;c_char, c_int&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_error</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> message: *<span class="keyword">const</span> c_char,</span><br><span class="line">    <span class="keyword">pub</span> klass: c_int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#[repr(C)]</code> 属性仅影响结构本身的布局，而不影响其各个字段的表示，因此要匹配 <code>C</code> 结构，每个字段也必须使用类 <code>C</code> 类型：<code>*const c_char</code> 对应于 <code>char *</code>，<code>c_int</code> 表示 <code>int</code>等等。</p>
<p>在这种特殊情况下，<code>#[repr(C)]</code> 属性可能不会改变 <code>git_error</code> 的布局。但是，尽管 <code>C</code> 和 <code>C++</code> 保证结构的成员按照声明的顺序出现在内存中，每个成员都位于不同的地址，但 <code>Rust</code> 对字段重新排序以最小化结构的整体大小，并且零大小的类型不占用空间。<code>#[repr(C)]</code> 属性告诉 <code>Rust</code> 遵循 <code>C</code> 对给定类型的规则。</p>
<p>还可以使用 <code>#[repr(C)]</code> 来控制 <code>C</code> 风格枚举的表示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">git_error_code</span> &#123;</span><br><span class="line">    GIT_OK = <span class="number">0</span>,</span><br><span class="line">    GIT_ERROR = -<span class="number">1</span>,</span><br><span class="line">    GIT_ENOTFOUND = -<span class="number">3</span>,</span><br><span class="line">    GIT_EEXISTS = -<span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>#[repr(C)]</code>，<code>Rust</code> 将使用单个字节来表示 <code>git_error_code</code> 枚举，使用<code>#[repr(C)]</code>，<code>Rust</code> 使用一个 <code>C</code> <code>int</code> 大小的值，就像 <code>C</code> 一样。</p>
<p>你也可以要求 <code>Rust</code> 给一个枚举与某个整数类型相同的表示。以 <code>#[repr(i16)]</code> 开始前面的定义会给你一个 <code>16</code> 位类型，它与以下 <code>C++</code> 枚举具有相同的表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">git_error_code</span>: <span class="type">int16_t</span> &#123;</span><br><span class="line">    GIT_OK = <span class="number">0</span>,</span><br><span class="line">    GIT_ERROR = <span class="number">-1</span>,</span><br><span class="line">    GIT_ENOTFOUND = <span class="number">-3</span>,</span><br><span class="line">    GIT_EEXISTS = <span class="number">-4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如前所述，<code>#[repr(C)]</code> 也适用于联合体，<code>#[repr(C)]</code> 联合体的字段总是从联合体内存的第一位开始——索引是 <code>0</code>。</p>
<p>假设你有一个 <code>C</code> 结构体，它使用一个 <code>union</code> 来保存一些数据和一个 <code>tag</code> 值来指示应该使用 <code>union</code> 的哪个字段，类似于 <code>Rust</code> 枚举。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">tag</span> &#123;</span><br><span class="line">    FLOAT = <span class="number">0</span>,</span><br><span class="line">    INT = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">number</span> &#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">short</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tagged_number</span> &#123;</span><br><span class="line">    tag t;</span><br><span class="line">    number n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 代码可以通过将 <code>#[repr(C)]</code> 应用于枚举、结构和 <code>union</code> 类型，并使用 <code>match</code> 语句根据<code>tag</code>在更大的结构中选择<code>union</code>字段来与此结构体互操作：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    Float = <span class="number">0</span>,</span><br><span class="line">    Int = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">FloatOrInt</span> &#123;</span><br><span class="line">    f: <span class="type">f32</span>,</span><br><span class="line">    i: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    tag: Tag,</span><br><span class="line">    union: FloatOrInt,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_zero</span>(v: Value) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">use</span> self::Tag::*;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> v &#123;</span><br><span class="line">            Value &#123;</span><br><span class="line">                tag: Int,</span><br><span class="line">                union: FloatOrInt &#123; i: <span class="number">0</span> &#125;,</span><br><span class="line">            &#125; =&gt; <span class="literal">true</span>,</span><br><span class="line">            Value &#123;</span><br><span class="line">                tag: Float,</span><br><span class="line">                union: FloatOrInt &#123; f: num &#125;,</span><br><span class="line">            &#125; =&gt; (num == <span class="number">0.0</span>),</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种技术，即使是复杂的结构体也可以轻松地跨 <code>FFI</code> 边界使用。</p>
<p>在 <code>Rust</code> 和 <code>C</code> 之间传递字符串有点困难，<code>C</code> 将字符串表示为指向字符数组的指针，并且以空字符终止。另一方面，<code>Rust</code> 将字符串的长度显式存储在字符串的字段或胖引用 <code>&amp;str</code> 的第二个机器字，<code>Rust</code> 字符串不是以 <code>null</code> 结尾的。事实上，它们可能在其内容中包含空字符，就像任何其他字符一样。</p>
<p>这意味着不能将 <code>Rust</code> 字符串作为 <code>C</code> 字符串借用：如果将 <code>C</code> 代码指针传递给 <code>Rust</code> 字符串，它可能会将嵌入的空字符误认为字符串的结尾，或者在结尾处寻找终止的空字符不在那里。换个方向，你可以借用一个 <code>C</code> 字符串作为 <code>Rust</code> 的 <code>&amp;str</code>，只要它的内容是有效的 <code>UTF-8</code>。</p>
<p>这种情况有效地迫使 <code>Rust</code> 将 <code>C</code> 字符串视为完全不同于 <code>String</code> 和 <code>&amp;str</code> 的类型。在 <code>std::ffi</code> 模块中，<code>CString</code> 和 <code>CStr</code> 类型表示拥有和借用的以空值结尾的字节数组。与 <code>String</code> 和 <code>str</code> 相比，<code>CString</code> 和 <code>CStr</code> 上的方法相当有限，仅限于构造和转换为其他类型。</p>
<h3 id="定义外部函数和变量"><a href="#定义外部函数和变量" class="headerlink" title="定义外部函数和变量"></a>定义外部函数和变量</h3><p><code>extern</code> 块声明了在其他库中定义的函数或变量，最终的 <code>Rust</code> 可执行文件将与之链接。例如，在大多数平台上，每个 <code>Rust</code> 程序都链接到标准 <code>C</code> 库，因此我们可以像这样告诉 <code>Rust</code> 库的 <code>strlen</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">strlen</span>(s: *<span class="keyword">const</span> c_char) <span class="punctuation">-&gt;</span> <span class="type">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这为 <code>Rust</code> 提供了函数的名称和类型，同时将定义留待稍后链接。</p>
<p><code>Rust</code> 假设在 <code>extern</code> 块中声明的函数使用 <code>C</code> 约定来传递参数和接受返回值，它们被定义为不安全的函数。这些是 <code>strlen</code> 的正确选择：它确实是一个 <code>C</code> 函数，并且它在 <code>C</code> 中的规范要求向它传递一个指向正确终止字符串的有效指针，这是 <code>Rust</code> 无法强制执行的规约。（几乎任何接受原始指针的函数都必须是 <code>unsafe</code>：安全的 <code>Rust</code> 可以从任意整数构造原始指针，而解引用这样的指针将是未定义的行为。）</p>
<p>使用这个 <code>extern</code> 块，我们可以像调用任何其他 <code>Rust</code> 函数一样调用 <code>strlen</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">strlen</span>(s: *<span class="keyword">const</span> c_char) <span class="punctuation">-&gt;</span> <span class="type">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::ffi::CString;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rust_str</span> = <span class="string">&quot;I&#x27;ll be back&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">null_terminated</span> = CString::<span class="title function_ invoke__">new</span>(rust_str).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">strlen</span>(null_terminated.<span class="title function_ invoke__">as_ptr</span>()), <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CString::new</code> 函数构建一个以 <code>null</code> 结尾的 <code>C</code> 字符串。它首先检查它的参数是否有嵌入的空字符，因为这些字符不能用 <code>C</code> 字符串表示，如果找到任何字符则返回一个错误。否则，它会在末尾添加一个空字节并返回一个拥有结果字符的 <code>CString</code>。</p>
<p><code>CString::new</code> 的成本取决于你传递给它的类型，它接受任何实现了<code>Into&lt;Vec&lt;u8&gt;</code>的东西。传递一个<code>&amp;str</code>需要一个分配和一个拷贝，因为转换为<code>Vec&lt;u8&gt;</code>会建立一个堆分配的字符串拷贝给<code>vector</code>来拥有。但是通过值传递一个字符串只是消耗了字符串并接管了它的缓冲区，所以除非附加空字符迫使缓冲区被调整大小，否则转换根本就不需要复制文本或分配。   </p>
<p><code>CString</code> 取消对 <code>CStr</code> 的引用，其 <code>as_ptr</code> 方法返回指向字符串开头的 <code>*const c_char</code>，这是 <code>strlen</code> 期望的类型。在这个例子中，<code>strlen</code> 遍历字符串，找到 <code>CString::new</code> 放置在那里的空字符，并返回长度，作为字节数。</p>
<p>还可以在外部块中声明全局变量，<code>POSIX</code> 系统有一个名为 <code>environ</code> 的全局变量，它保存进程的环境变量的值。在 <code>C </code>中，它被声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br></pre></td></tr></table></figure>

<p>在 <code>Rust</code> 中可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CStr;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> environ: *<span class="keyword">mut</span> *<span class="keyword">mut</span> c_char;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !environ.<span class="title function_ invoke__">is_null</span>() &amp;&amp; !(*environ).<span class="title function_ invoke__">is_null</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">var</span> = CStr::<span class="title function_ invoke__">from_ptr</span>(*environ);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;first environment variable: &#123;&#125;&quot;</span>, var.<span class="title function_ invoke__">to_string_lossy</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在确保 <code>environ</code> 有第一个元素之后，代码调用 <code>CStr::from_ptr</code> 来构建一个借用它的 <code>CStr</code>。<code>to_string_lossy</code> 方法返回一个 <code>Cow&lt;str&gt;</code>：如果 <code>C</code> 字符串包含有效的 <code>UTF-8</code>，则 <code>Cow</code> 将其内容作为 <code>&amp;str</code> 借用，不包括终止的空字节。否则，<code>to_string_lossy</code> 会复制堆中的文本，用官方的 <code>Unicode</code> 替换字符 <code>�</code> 替换格式错误的 <code>UTF-8</code> 序列，并以此构建拥有所有权的 <code>Cow</code>。无论哪种方式，结果都会实现 <code>Display</code>，因此可以使用 <code>&#123;&#125;</code> 格式参数打印它。</p>
<h3 id="使用库中的函数"><a href="#使用库中的函数" class="headerlink" title="使用库中的函数"></a>使用库中的函数</h3><p>要使用特定库提供的函数，可以在 <code>extern</code> 块顶部放置一个 <code>#[link]</code> 属性，该属性命名库 <code>Rust</code> 应该链接可执行文件。例如，这里有一个程序调用 <code>libgit2</code> 的初始化和 <code>shutdown</code> 方法，但没有其他的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::os::raw::c_int;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link(name = <span class="string">&quot;git2&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_libgit2_init</span>() <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_libgit2_shutdown</span>() <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">git_libgit2_init</span>();</span><br><span class="line">        <span class="title function_ invoke__">git_libgit2_shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>extern</code> 块像以前一样声明了 <code>extern</code> 函数。 <code>#[link(name =&quot;git2&quot;)]</code> 属性在 <code>crate</code> 中留下一个注释，大意是当 <code>Rust</code> 创建最终的可执行文件或共享库时，它应该链接到 <code>git2</code> 库。<code>Rust</code> 使用系统链接器来构建可执行文件，在 <code>Unix</code> 上，这会在链接器命令行上传递参数 <code>-lgit2</code>，在 <code>Windows</code> 上，它通过 <code>git2.LIB</code>。</p>
<p><code>#[link]</code> 属性也可以在库中使用，当你构建一个依赖于其他 <code>crate</code> 的程序时，<code>Cargo</code> 会从整个依赖图中收集链接注释，并将它们全部包含在最终链接中。</p>
<p>在此示例中，如果您想在自己的机器上进行操作，则需要自己构建 <code>libgit2</code>。 这里使用了 <code>libgit2</code> 版本 <code>0.25.1</code>。要编译 <code>libgit2</code>，需要安装 <code>CMake</code> 构建工具和 <code>Python</code> 语言，这里我们使用了 <code>CMake</code> 版本 <code>3.8.0</code> 和 <code>Python</code> 版本 <code>2.7.13</code>。</p>
<p>构建 <code>libgit2</code> 的完整说明可在其网站上找到，但它们非常简单，我们将在此处展示要点。在 <code>Linux</code> 上，假设已经将库的源代码解压缩到目录 <code>/home/jimb/libgit2-0.25.1</code> 中：</p>
<pre><code>$ cd /home/jimb/libgit2-0.25.1
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
</code></pre>
<p>在 <code>Linux</code> 上，这会生成一个共享库 <code>/home/jimb/libgit2-0.25.1/build/libgit2.so.0.25.1</code>，其中包含指向它的通常嵌套的符号链接，包括一个名为 <code>libgit2.so</code> 的文件。在 <code>macOS</code> 上，结果相似，但库名为 <code>libgit2.dylib</code>。</p>
<p>在 <code>Windows</code> 上，事情也很简单，假设已将源代码解压缩到目录 <code>C:\Users\JimB\libgit2-0.25.1</code>。 在 <code>Visual Studio</code> 命令提示符下：</p>
<pre><code>&gt; cd C:\Users\JimB\libgit2-0.25.1
&gt; mkdir build
&gt; cd build
&gt; cmake -A x64 ..
&gt; cmake --build .
</code></pre>
<p>这些命令与在 <code>Linux</code> 上使用的命令相同，不同之处在于在第一次运行 <code>CMake</code> 时必须请求 <code>64</code> 位构建以匹配 <code>Rust</code> 编译器。(如果你已经安装了 <code>32</code> 位 <code>Rust</code> 工具链，那么你应该在第一个 <code>cmake</code> 命令中省略 <code>-A x64</code> 标志。）这会在目录 <code>C:\Users\JimB\libgit2-0.25.1\build\Debug</code> 生成一个名为 <code>git2.LIB</code> 和 <code>git2.DLL</code> 的文件。（除了 <code>Windows</code> 有很大不同的地方，其余说明均针对 Unix。）</p>
<p>在单独的目录中创建 <code>Rust</code> 程序：</p>
<pre><code>$ cd /home/jimb
$ cargo new --bin git-toy
Created binary (application) `git-toy` package
</code></pre>
<p>将之前的代码放在 <code>src/main.rs</code> 中，然后尝试构建它，<code>Rust</code> 不知道去哪里找这个 <code>libgit2</code>，所以就会：</p>
<pre><code>$ cd git-toy
$ cargo run
Compiling git-toy v0.1.0 (/home/jimb/git-toy)
error: linking with `cc` failed: exit code: 1
|
= note: /usr/bin/ld: error: cannot find -lgit2
src/main.rs:11: error: undefined reference to &#39;git_libgit2_init&#39;
src/main.rs:12: error: undefined reference to &#39;git_libgit2_shutdown&#39;
collect2: error: ld returned 1 exit status
error: aborting due to previous error
error: could not compile `git-toy`.
To learn more, run the command again with --verbose.
</code></pre>
<p>可以通过编写构建脚本告诉 <code>Rust</code> 在哪里搜索库，<code>Rust</code> 代码在构建时编译并运行 <code>Cargo</code>。构建脚本可以做各种各样的事情：动态生成代码，编译 <code>C</code> 代码以包含在 <code>crate</code> 中等等。在这种情况下，只需要在可执行文件的链接命令中添加一个库搜索路径。当 <code>Cargo</code> 运行构建脚本时，它会解析构建脚本的输出以获取此类信息，因此构建脚本只需将链接的文件位置信息打印到它的标准输出。</p>
<p>要创建构建脚本，请在与 <code>Cargo.toml</code> 文件相同的目录中添加一个名为 <code>build.rs</code> 的文件，其内容如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">r&quot;cargo:rustc-link-search=native=/home/jimb/libgit2-0.25.1/build&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>Linux</code> 的正确路径，在 <code>Windows</code> 上，您可以将文本 <code>native=</code> 后面的路径更改为 <code>C:\Users\JimB\libgit2-0.25.1\build\Debug</code>。（为了让这个例子简单，我们偷工减料；在实际应用程序中，应该避免在构建脚本中使用绝对路径。我们在本节末尾引用了说明如何执行此操作的文档。）</p>
<p>现在几乎可以运行该程序了，在 <code>macOS</code> 上它可以立即工作，在 <code>Linux</code> 系统上，您可能会看到类似以下内容：</p>
<pre><code>$ cargo run
    Compiling git-toy v0.1.0 (/tmp/rustbook-transcript-tests/git-toy)
    Finished dev [unoptimized + debuginfo] target(s)
    Running `target/debug/git-toy`
target/debug/git-toy: error while loading shared libraries:
libgit2.so.25: cannot open shared object file: No such file or directory
</code></pre>
<p>这意味着，尽管 <code>Cargo</code> 成功地将可执行文件与库链接起来，但它不知道在运行时在哪里可以找到共享库。<code>Windows</code> 通过弹出一个对话框报告此故障。 在 <code>Linux</code> 上，必须设置 <code>LD_LIBRARY_PATH</code> 环境变量：</p>
<pre><code>$ export LD_LIBRARY_PATH=/home/jimb/libgit2-0.25.1/build:$LD_LIBRARY_PATH
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
    Running `target/debug/git-toy`
</code></pre>
<p>在 <code>MacOS</code> 上可能需要设置 <code> DYLD_LIBRARY_PATH</code>，在 <code>windows</code> 上需要设置 <code>PATH</code> 环境变量：</p>
<pre><code>&gt; set PATH=C:\Users\JimB\libgit2-0.25.1\build\Debug;%PATH%
&gt; cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
    Running `target/debug/git-toy`
&gt;
</code></pre>
<p>自然，在已部署的应用程序中，希望避免为了查找库的代码而必须设置环境变量，一种替代方法是将 <code>C</code> 库静态链接到 <code>crate</code> 中。这会将库的目标文件与 <code>crate</code> 的 <code>Rust</code> 代码的目标文件和元数据一起复制到 <code>crate</code> 的 <code>.rlib</code> 文件中。</p>
<p>根据 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#-sys-packages"><code>Cargo</code> 约定</a>，提供对 <code>C</code> 库的访问的 <code>crate</code> 应命名为 <code>LIB-sys</code>，其中 <code>LIB</code> 是 <code>C</code> 库的名称，例如 <a href="https://crates.io/crates/libsqlite3-sys"><code>libsqlite3-sys</code></a>。一个 <code>*-sys crate</code> 应该只包含静态链接的库，和包含<code>extern</code>块以及类型定义的 <code>Rust</code> 模块。更高级别的接口则属于依赖于 <code>*-sys</code> 的 <code>crate</code>。这允许多个上游 <code>crate</code> 依赖于同一个 <code>*-sys crate</code>，假设有一个版本的 <code>*-sys crate</code> 可以满足每个人的需求。</p>
<p>有关 <code>Cargo</code> 支持构建脚本和与系统库链接的完整详细信息，请参阅在线 <code>Cargo</code> 文档。它展示了如何避免构建脚本中的绝对路径、控制编译标志、使用 <code>pkg-config</code> 等工具。<a href="https://github.com/rust-lang/git2-rs/blob/master/libgit2-sys/build.rs"><code>git2-rs</code></a> 也提供了很好的例子。</p>
<h3 id="libgit2-的原生接口"><a href="#libgit2-的原生接口" class="headerlink" title="libgit2 的原生接口"></a><code>libgit2</code> 的原生接口</h3><p>弄清楚如何正确使用 <code>libgit2</code> 分为两个问题：</p>
<ul>
<li><p>在 <code>Rust</code> 中使用 <code>libgit2</code> 函数需要什么？</p>
</li>
<li><p>我们如何围绕它们构建一个安全的 <code>Rust</code> 接口？</p>
</li>
</ul>
<p>我们将一次一个地回答这些问题，在本节中，我们将编写一个程序，该程序本质上是一个巨大的不安全块，其中充满了非惯用的 <code>Rust</code> 代码，反映了混合语言中固有的类型系统和约定的冲突，我们将其称为原生接口，代码会很混乱，但它会让 <code>Rust</code> 代码使用 <code>libgit2</code> 必须执行的所有步骤变得清晰。</p>
<p>然后，在下一节中，我们将构建一个安全的 <code>libgit2</code> 接口，使用 <code>Rust</code> 的类型来执行 <code>libgit2</code> 强加给用户的规约。幸运的是，<code>libgit2</code> 是一个精心设计的 <code>C</code> 库，所以 <code>Rust</code> 的安全要求迫使我们提出的问题都有很好的答案，我们可以构建一个惯用的 <code>Rust</code> 接口，没有不安全的函数。</p>
<p>我们将编写的程序非常简单：它将路径作为命令行参数，在那里打开 <code>Git</code> 存储库，并打印出头部提交。对于原生接口，程序最终将需要比我们之前使用的更大的来自 <code>libgit2</code> 的函数和类型集合，因此将 <code>extern</code> 块移动到它自己的模块中是有意义的。我们将在 <code>git-toy/src</code> 中创建一个名为 <code>raw.rs</code> 的文件，其内容如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(non_camel_case_types)]</span></span><br><span class="line"><span class="keyword">use</span> std::os::raw::&#123;c_char, c_int, c_uchar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link(name = <span class="string">&quot;git2&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_libgit2_init</span>() <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_libgit2_shutdown</span>() <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">giterr_last</span>() <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> git_error;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_repository_open</span>(out: *<span class="keyword">mut</span> *<span class="keyword">mut</span> git_repository, path: *<span class="keyword">const</span> c_char) <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_repository_free</span>(repo: *<span class="keyword">mut</span> git_repository);</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_reference_name_to_id</span>(</span><br><span class="line">        out: *<span class="keyword">mut</span> git_oid,</span><br><span class="line">        repo: *<span class="keyword">mut</span> git_repository,</span><br><span class="line">        reference: *<span class="keyword">const</span> c_char,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_commit_lookup</span>(</span><br><span class="line">        out: *<span class="keyword">mut</span> *<span class="keyword">mut</span> git_commit,</span><br><span class="line">        repo: *<span class="keyword">mut</span> git_repository,</span><br><span class="line">        id: *<span class="keyword">const</span> git_oid,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_commit_author</span>(commit: *<span class="keyword">const</span> git_commit) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> git_signature;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_commit_message</span>(commit: *<span class="keyword">const</span> git_commit) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> c_char;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_commit_free</span>(commit: *<span class="keyword">mut</span> git_commit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_repository</span> &#123;</span><br><span class="line">    _private: [<span class="type">u8</span>; <span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_commit</span> &#123;</span><br><span class="line">    _private: [<span class="type">u8</span>; <span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_error</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> message: *<span class="keyword">const</span> c_char,</span><br><span class="line">    <span class="keyword">pub</span> klass: c_int,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> GIT_OID_RAWSZ: <span class="type">usize</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_oid</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> id: [c_uchar; GIT_OID_RAWSZ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">git_time_t</span> = <span class="type">i64</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_time</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> time: git_time_t,</span><br><span class="line">    <span class="keyword">pub</span> offset: c_int,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_signature</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: *<span class="keyword">const</span> c_char,</span><br><span class="line">    <span class="keyword">pub</span> email: *<span class="keyword">const</span> c_char,</span><br><span class="line">    <span class="keyword">pub</span> when: git_time,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的每个 <code>item</code> 都是根据 <code>libgit2</code> 自己的头文件中的声明。例如，<code>libgit2-0.25.1/include/git2/repository.h</code> 包含以下声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">git_repository_open</span><span class="params">(git_repository **out, <span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>此函数尝试在路径打开 <code>Git</code> 存储库。如果一切顺利，它会创建一个 <code>git_repository</code> 对象，并将指向它的指针存储在 <code>out</code> 指向的位置，等效的 <code>Rust</code> 声明如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">git_repository_open</span>(out: *<span class="keyword">mut</span> *<span class="keyword">mut</span> git_repository, path: *<span class="keyword">const</span> c_char) <span class="punctuation">-&gt;</span> c_int;</span><br></pre></td></tr></table></figure>

<p><code>libgit2</code> 公共头文件使用 <code>typedef</code> 定义了 <code>git_repository</code>，但它是不完整的结构体类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">git_repository</span> <span class="title">git_repository</span>;</span></span><br></pre></td></tr></table></figure>

<p>由于这种类型的详细信息对库来说是私有的，因此公共头文件永远不会定义 <code>struct git_repository</code>，从而确保库的用户永远不能自己构建这种类型的实例。 <code>Rust</code> 中不完整结构类型的一种可能类似物是：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span> <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">git_repository</span> &#123; _private: [<span class="type">u8</span>; <span class="number">0</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个结构体类型，包含一个没有元素的数组。 因为 <code>_private</code> 字段不是 <code>pub</code>，所以这种类型的值不能在这个模块之外构造，它完美地反映了只有 <code>libgit2</code> 应该构造的 <code>C</code> 类型，并且只能通过原始指针进行操作。</p>
<p>手工编写大的外部块可能是一件苦差事。如果您正在为复杂的 <code>C</code> 库创建 <code>Rust</code> 接口，可能想尝试使用 <a href="https://crates.io/crates/bindgen"><code>bindgen</code></a>，它具有可以从构建脚本中使用的函数来解析 <code>C</code> 头文件并自动生成相应的 <code>Rust</code> 声明。</p>
<p>接下来我们将完全重写 <code>main.rs</code>。 首先，我们需要声明<code>raw</code>模块：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> raw;</span><br></pre></td></tr></table></figure>

<p>根据 <code>libgit2</code> 的约定，易错函数返回一个整数代码，成功时为正数或者 <code>0</code>，失败时返回负数。如果发生错误，<code>giterr_last</code> 函数将返回一个指向 <code>git_error</code> 结构体的指针，该结构体提供有关出错的更多详细信息。<code>libgit2</code> 拥有这个结构，所以我们不需要自己释放它，但它可能会被我们进行的下一个库调用覆盖。适当的 <code>Rust</code> 接口将使用 <code>Result</code>，但在原始版本中，我们希望按原样使用 <code>libgit2</code> 函数，因此我们必须让自己的函数来处理错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CStr;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_int;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check</span>(activity: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>, status: c_int) <span class="punctuation">-&gt;</span> c_int &#123;</span><br><span class="line">    <span class="keyword">if</span> status &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">error</span> = &amp;*raw::<span class="title function_ invoke__">giterr_last</span>();</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;error while &#123;&#125;: &#123;&#125; (&#123;&#125;)&quot;</span>,</span><br><span class="line">                activity,</span><br><span class="line">                CStr::<span class="title function_ invoke__">from_ptr</span>(error.message).<span class="title function_ invoke__">to_string_lossy</span>(),</span><br><span class="line">                error.klass</span><br><span class="line">            );</span><br><span class="line">            std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    status</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们将用这个函数检查 <code>libgit2</code> 的调用结果，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">check</span>(<span class="string">&quot;initializing library&quot;</span>, raw::<span class="title function_ invoke__">git_libgit2_init</span>());</span><br></pre></td></tr></table></figure>

<p>这使用了之前使用的相同 <code>CStr</code> 方法：<code>from_ptr</code> 从 <code>C</code> 字符串构造 <code>CStr</code>，<code>to_string_lossy</code> 将其转换为 <code>Rust</code> 可以打印的东西。接下来，我们需要一个函数来打印<code>commit</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">show_commit</span>(commit: *<span class="keyword">const</span> raw::git_commit) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">author</span> = raw::<span class="title function_ invoke__">git_commit_author</span>(commit);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = CStr::<span class="title function_ invoke__">from_ptr</span>((*author).name).<span class="title function_ invoke__">to_string_lossy</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">email</span> = CStr::<span class="title function_ invoke__">from_ptr</span>((*author).email).<span class="title function_ invoke__">to_string_lossy</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &lt;&#123;&#125;&gt;\n&quot;</span>, name, email);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = raw::<span class="title function_ invoke__">git_commit_message</span>(commit);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, CStr::<span class="title function_ invoke__">from_ptr</span>(message).<span class="title function_ invoke__">to_string_lossy</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个指向 <code>git_commit</code> 的指针，<code>show_commit</code> 调用 <code>git_commit_author</code> 和 <code>git_commit_message</code> 来检索它需要的信息。这两个函数遵循 <code>libgit2</code> 文档解释如下的约定：</p>
<pre><code>If a function returns an object as a return value, that function is a getter and the object’s lifetime is tied to the parent object.
</code></pre>
<p>在 <code>Rust</code> 术语中，<code>author</code>和<code>message</code>是从<code>commit</code>中借用的：<code>show_commit</code> 不需要自己释放它们，但在释放<code>commit</code>后它不能保留它们。由于这个 <code>API</code> 使用原生指针，<code>Rust</code> 不会为我们检查它们的生命周期。</p>
<p>前面的代码假定这些字段包含 <code>UTF-8</code> 文本，这并不总是正确的，<code>Git</code> 也允许其他编码，为简洁起见，我们将在此处忽略这些问题。</p>
<p>我们程序的<code>main</code>函数如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"><span class="keyword">use</span> std::ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = std::env::<span class="title function_ invoke__">args</span>()</span><br><span class="line">        .<span class="title function_ invoke__">skip</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;usage: git-toy PATH&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = CString::<span class="title function_ invoke__">new</span>(path).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;path contains null characters&quot;</span>);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">check</span>(<span class="string">&quot;initializing library&quot;</span>, raw::<span class="title function_ invoke__">git_libgit2_init</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">repo</span> = ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line">        <span class="title function_ invoke__">check</span>(</span><br><span class="line">            <span class="string">&quot;opening repository&quot;</span>,</span><br><span class="line">            raw::<span class="title function_ invoke__">git_repository_open</span>(&amp;<span class="keyword">mut</span> repo, path.<span class="title function_ invoke__">as_ptr</span>()),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c_name</span> = <span class="string">b&quot;HEAD\0&quot;</span>.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> *<span class="keyword">const</span> c_char;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">oid</span> = &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">oid</span> = mem::MaybeUninit::<span class="title function_ invoke__">uninit</span>();</span><br><span class="line">            <span class="title function_ invoke__">check</span>(</span><br><span class="line">                <span class="string">&quot;looking up HEAD&quot;</span>,</span><br><span class="line">                raw::<span class="title function_ invoke__">git_reference_name_to_id</span>(oid.<span class="title function_ invoke__">as_mut_ptr</span>(), repo, c_name),</span><br><span class="line">            );</span><br><span class="line">            oid.<span class="title function_ invoke__">assume_init</span>()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">commit</span> = ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line">        <span class="title function_ invoke__">check</span>(</span><br><span class="line">            <span class="string">&quot;looking up commit&quot;</span>,</span><br><span class="line">            raw::<span class="title function_ invoke__">git_commit_lookup</span>(&amp;<span class="keyword">mut</span> commit, repo, &amp;oid),</span><br><span class="line">        );</span><br><span class="line">        <span class="title function_ invoke__">show_commit</span>(commit);</span><br><span class="line">        raw::<span class="title function_ invoke__">git_commit_free</span>(commit);</span><br><span class="line">        raw::<span class="title function_ invoke__">git_repository_free</span>(repo);</span><br><span class="line">        <span class="title function_ invoke__">check</span>(<span class="string">&quot;shutting down library&quot;</span>, raw::<span class="title function_ invoke__">git_libgit2_shutdown</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这从处理路径参数和初始化库的代码开始，所有这些我们以前都见过。第一个新颖的代码是这样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">repo</span> = ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line"><span class="title function_ invoke__">check</span>(<span class="string">&quot;opening repository&quot;</span>, raw::<span class="title function_ invoke__">git_repository_open</span>(&amp;<span class="keyword">mut</span> repo, path.<span class="title function_ invoke__">as_ptr</span>()));</span><br></pre></td></tr></table></figure>

<p>对 <code>git_repository_open</code> 的调用尝试在给定路径打开 <code>Git</code> 存储库。如果成功，它会为其分配一个新的 <code>git_repository</code> 对象并将 <code>repo</code> 设置为指向该对象。<code>Rust</code> 隐式地将引用强制转换为原始指针，因此在此处传递 <code>&amp;mut repo</code> 提供了调用所期望的 <code>*mut *mut git_repository</code>。</p>
<p>这显示了另一个正在使用的 <code>libgit2</code> 约定（来自 <code>libgit2</code> 文档）：</p>
<pre><code>Objects which are returned via the first argument as a pointer-to-pointer are owned by the caller and it is responsible for freeing them.
</code></pre>
<p>在 <code>Rust</code> 术语中，像 <code>git_repository_open</code> 这样的函数将新值的所有权传递给调用者。接下来，考虑查找存储库当前最新的 <code>commit</code> 对象<code>hash</code> 的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">oid</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">oid</span> = mem::MaybeUninit::<span class="title function_ invoke__">uninit</span>();</span><br><span class="line">    <span class="title function_ invoke__">check</span>(</span><br><span class="line">        <span class="string">&quot;looking up HEAD&quot;</span>,</span><br><span class="line">        raw::<span class="title function_ invoke__">git_reference_name_to_id</span>(oid.<span class="title function_ invoke__">as_mut_ptr</span>(), repo, c_name),</span><br><span class="line">    );</span><br><span class="line">    oid.<span class="title function_ invoke__">assume_init</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>git_oid</code> 类型存储一个对象标识符——一个 <code>160</code> 位的哈希码，<code>Git</code> 在内部（以及在其令人愉悦的用户界面中）使用它来识别提交、文件的单个版本等。对 <code>git_reference_name_to_id</code> 的调用会查找当前“HEAD”提交的对象标识符。</p>
<p>在 <code>C</code> 中，通过将指向变量的指针传递给填充其值的某个函数来初始化变量是完全正常的，这就是 <code>git_reference_name_to_id</code> 期望如何处理它的第一个参数。但是 <code>Rust</code> 不会让我们借用对未初始化变量的引用。我们可以用零初始化 <code>oid</code>，但这是一种浪费：存储在那里的任何值都将被简单地覆盖。</p>
<p>可以要求 <code>Rust</code> 给我们未初始化的内存，但是因为在任何时候读取未初始化的内存都是即时的未定义行为，<code>Rust</code> 提供了一个抽象，<code>MaybeUninit</code>，以简化它的使用。<code>MaybeUninit&lt;T&gt;</code> 告诉编译器为你的类型 <code>T</code> 留出足够的内存，但不要碰它，直到你说这样做是安全的。虽然此内存归 <code>MaybeUninit</code> 所有，但编译器还将避免某些优化，这些优化可能会导致未定义的行为，即使代码中没有对未初始化内存的任何显式访问。</p>
<p><code>MaybeUninit</code> 提供了一个方法 <code>as_mut_ptr()</code>，它产生一个 <code>*mut T</code> 指向它包装的可能未初始化的内存。通过将该指针传递给初始化内存的外部函数，然后在 <code>MaybeUninit</code> 上调用 <code>unsafe </code>方法 <code>assume_init</code> 以生成完全初始化的 <code>T</code>，可以避免未定义的行为，而不会产生初始化和立即丢弃值的额外开销。<code>assume_init</code> 是不安全的，因为在不确定内存是否实际初始化的情况下在 <code>MaybeUninit</code> 上调用它会立即导致未定义行为。</p>
<p>在这种情况下，它是安全的，因为 <code>git_reference_name_to_id</code> 初始化了 <code>MaybeUninit</code> 拥有的内存。我们也可以将 <code>MaybeUninit</code> 用于 <code>repo</code> 和 <code>commit</code> 变量，但由于这些只是单个字，我们只需将它们初始化为 <code>null</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">commit</span> = ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line"><span class="title function_ invoke__">check</span>(<span class="string">&quot;looking up commit&quot;</span>, raw::<span class="title function_ invoke__">git_commit_lookup</span>(&amp;<span class="keyword">mut</span> commit, repo, &amp;oid));</span><br></pre></td></tr></table></figure>

<p>这需要<code>commit</code>的对象标识符并查找实际的<code>commit</code>，成功时将一个 <code>git_commit</code> 指针存储在<code>commit</code>中。</p>
<p><code>main</code> 函数的其余部分应该是不言自明的。它调用前面定义的 <code>show_commit</code> 函数，释放提交和存储库对象，并关闭库。</p>
<p>现在我们可以在手头的任何 <code>Git</code> 存储库上试用该程序：</p>
<pre><code>$ cargo run /home/jimb/rbattle
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
        Running `target/debug/git-toy /home/jimb/rbattle`

Jim Blandy &lt;jimb@red-bean.com&gt;

Animate goop a bit.
</code></pre>
<h3 id="libgit2-的安全接口"><a href="#libgit2-的安全接口" class="headerlink" title="libgit2 的安全接口"></a><code>libgit2</code> 的安全接口</h3><p><code>libgit2</code> 的原始接口是一个<code>unsafe</code>特性的完美示例：它当然可以正确使用，但 <code>Rust</code> 无法强制执行必须遵循的规则。为这样的库设计一个安全的 <code>API</code> 就是识别所有这些规则，然后找到将任何违反它们的行为转变为类型或借用检查错误的方法。</p>
<p>那么，这里是 <code>libgit2</code> 对程序使用功能的规则：</p>
<ul>
<li><p>在使用任何其他库函数之前，必须调用 <code>git_libgit2_init</code>，调用 <code>git_libgit2_shutdown</code> 后不能使用任何库函数；</p>
</li>
<li><p>传递给 <code>libgit2</code> 函数的所有值都必须完全初始化，输出参数除外；</p>
</li>
<li><p>当调用失败时，传递来保存调用结果的输出参数未初始化，不得使用它们的值；</p>
</li>
<li><p><code>git_commit</code> 对象指的是它派生自的 <code>git_repository</code> 对象，因此前者的寿命不能超过后者；</p>
</li>
<li><p>类似地，<code>git_signature</code> 总是从给定的 <code>git_commit</code> 借来的，并且前者的寿命不能超过后者；</p>
</li>
<li><p>与<code>commit</code>相关的消息以及作者的姓名和电子邮件地址都是从<code>commit</code>中借用的，在提交被释放后不得使用；</p>
</li>
<li><p>一旦一个<code>libgit2</code> 对象被释放，它就不能再被使用；</p>
</li>
</ul>
<p>事实证明，可以通过 <code>Rust</code> 的类型系统或通过内部管理细节来构建 <code>libgit2</code> 的 <code>Rust</code> 接口来强制执行所有这些规则。在开始之前，让我们稍微重构一下项目。我们想要一个导出安全接口的 <code>git</code>模块，其中来自之前程序的原始接口是一个私有子模块。</p>
<p>整个源代码树将如下所示：</p>
<pre><code>git-toy/
├── Cargo.toml
├── build.rs
└── src/
    ├── main.rs
    └── git/
        ├── mod.rs
        └── raw.rs
</code></pre>
<p>我们将完全重写 <code>main.rs</code>，它应该以 <code>git</code> 模块的定义开始：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> git;</span><br></pre></td></tr></table></figure>

<p>然后我们创建 <code>git</code> 子目录，将 <code>raw.rs</code> 移入：</p>
<pre><code>$ cd /home/jimb/git-toy
$ mkdir src/git
$ mv src/raw.rs src/git/raw.rs
</code></pre>
<p>需要在 <code>src/git/mod.rs</code> 中声明 <code>raw</code> 模块：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> raw;</span><br></pre></td></tr></table></figure>

<p>因为它不是 <code>pub</code>，所以这个子模块对<code>main</code>程序是不可见的。稍后我们需要使用 <a href="https://crates.io/crates/libc"><code>libc</code></a> 中的一些函数，因此我们必须在 <code>Cargo.toml</code> 中添加依赖项。完整的文件现在显示：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;git-toy&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;You &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">libc</span> = <span class="string">&quot;0.2&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们已经重构了我们的模块，让我们考虑错误处理。甚至<code>libgit2</code>的初始化函数也会返回一个错误码，所以我们需要先把它整理好才能开始。 一个惯用的 <code>Rust</code> 接口需要它自己的 <code>Errortype</code> 来捕获 <code>libgit2</code> 故障代码以及来自 <code>giterr_last</code> 的错误消息和类。正确的错误类型必须实现通常的<code>Error</code>、<code>Display</code>和<code>Debug</code>。然后，它需要自己的 <code>Result</code> 类型来使用这个 <code>Error</code> 类型。 以下是 <code>src/git/mod.rs</code> 中必要的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::result;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    code: <span class="type">i32</span>,</span><br><span class="line">    message: <span class="type">String</span>,</span><br><span class="line">    class: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> result::<span class="type">Result</span>&lt;(), fmt::Error&gt; &#123;</span><br><span class="line">        <span class="comment">// Displaying an `Error` simply displays the message from libgit2.</span></span><br><span class="line">        <span class="keyword">self</span>.message.<span class="title function_ invoke__">fmt</span>(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">Error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = result::<span class="type">Result</span>&lt;T, Error&gt;;</span><br></pre></td></tr></table></figure>

<p>要检查原始库调用的结果，模块需要一个将 <code>libgit2</code> 返回代码转换为<code>Result</code>的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CStr;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_int;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check</span>(code: c_int) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;c_int&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> code &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">error</span> = raw::<span class="title function_ invoke__">giterr_last</span>();</span><br><span class="line">        <span class="comment">// libgit2 ensures that (*error).message is always non-null and null</span></span><br><span class="line">        <span class="comment">// terminated, so this call is safe.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">message</span> = CStr::<span class="title function_ invoke__">from_ptr</span>((*error).message)</span><br><span class="line">            .<span class="title function_ invoke__">to_string_lossy</span>()</span><br><span class="line">            .<span class="title function_ invoke__">into_owned</span>();</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(Error &#123;</span><br><span class="line">            code: code <span class="keyword">as</span> <span class="type">i32</span>,</span><br><span class="line">            message,</span><br><span class="line">            class: (*error).klass <span class="keyword">as</span> <span class="type">i32</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个和原始版本中的 <code>check</code> 函数之间的主要区别在于，它构造了一个<code>Error</code>值，而不是打印<code>Errir</code>消息并立即退出。</p>
<p>现在我们已经准备好处理 <code>libgit2</code> 的初始化了。安全接口将提供一个代表开放 <code>Git</code> 存储库的 <code>Repository</code> 类型，以及用于解析引用、查找提交等的方法。继续 <code>git/mod.rs</code>，这里是 <code>Repository</code> 的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A Git repository.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Repository</span> &#123;</span><br><span class="line">    <span class="comment">// This must always be a pointer to a live `git_repository` structure.</span></span><br><span class="line">    <span class="comment">// No other `Repository` may point to it.</span></span><br><span class="line">    raw: *<span class="keyword">mut</span> raw::git_repository</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Repository</code> 的 <code>raw</code> 字段不是公开的。由于只有此模块中的代码可以访问 <code>raw::git_repository</code> 指针，因此正确获取此模块应确保始终正确使用指针。</p>
<p>如果创建<code>Repository</code>的唯一方法是成功打开一个新的 <code>Git</code> 仓库，这将确保每个<code>Repository</code>都指向一个不同的 <code>git_repository</code> 对象：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">use</span> std::ptr;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Repository</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Repository&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">ensure_initialized</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">path</span> = <span class="title function_ invoke__">path_to_cstring</span>(path.<span class="title function_ invoke__">as_ref</span>())?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">repo</span> = ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">check</span>(raw::<span class="title function_ invoke__">git_repository_open</span>(&amp;<span class="keyword">mut</span> repo, path.<span class="title function_ invoke__">as_ptr</span>()))?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Repository &#123; raw: repo &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用安全接口做任何事情的唯一方法是从 <code>Repository</code> 值开始，并且 <code>Repository::open</code> 以调用 <code>ensure_initialized</code> 开始，我们可以确信 <code>ensure_initialized</code> 将在任何 <code>libgit2</code> 函数之前被调用。其定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ensure_initialized</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> ONCE: std::sync::Once = std::sync::Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    ONCE.<span class="title function_ invoke__">call_once</span>(|| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">check</span>(raw::<span class="title function_ invoke__">git_libgit2_init</span>()).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;initializing libgit2 failed&quot;</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(libc::<span class="title function_ invoke__">atexit</span>(shutdown), <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">check</span>(raw::<span class="title function_ invoke__">git_libgit2_shutdown</span>()) &#123;</span><br><span class="line">            eprintln!(<span class="string">&quot;shutting down libgit2 failed: &#123;&#125;&quot;</span>, e);</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::sync::Once</code> 类型有助于以线程安全的方式运行初始化代码。只有第一个调用 <code>ONCE.call_once</code> 的线程运行给定的闭包。此线程或任何其他线程的任何后续调用都会阻塞，直到第一个调用完成，然后立即返回，而无需再次运行闭包。闭包完成后，调用 <code>ONCE.call_once</code> 很便宜，只需要对存储在 <code>ONCE</code> 中的标志进行原子加载即可。</p>
<p>在前面的代码中，初始化闭包调用<code>git_libgit2_init</code>并检查结果。它稍作调整，只是使用 <code>expect</code> 来确保初始化成功，而不是试图将错误传播回给调用者。     </p>
<p>为了确保程序调用 <code>git_libgit2_shutdown</code>，初始化闭包使用 <code>C</code> 库的 <code>atexit</code> 函数，该函数接受一个指向函数的指针以在进程退出之前调用。 <code>Rust</code> 闭包不能用作 <code>C</code> 函数指针：闭包是某种匿名类型的值，带有它捕获或引用的任何变量的值，<code>C</code>函数指针只是一个指针。但是，<code>Rust</code> <code>fn</code> 类型可以正常工作，只要将它们声明为 <code>extern</code> 以便 <code>Rust</code> 知道使用 <code>C</code> 调用约定。本地函数 <code>shutdown</code> 符合要求，并确保 <code>libgit2</code> 正确关闭。</p>
<p>在之前我们提到恐慌跨越语言边界是未定义的行为。从<code>atexit</code> 到<code>shutdown</code> 的调用就是这样一个边界，所以<code>shutdown</code> 不要<code>panic</code> 是很重要的。这就是为什么 <code>shutdown</code> 不能简单地使用 <code>.expect</code> 来处理从 <code>raw::git_libgit2_shutdown</code> 报告的错误。相反，它必须报告错误并终止进程本身。<code>POSIX</code> 禁止在 <code>atexit</code> 处理程序中调用 <code>exit</code>，因此 <code>shutdown</code> 调用 <code>std::process::abort</code> 以突然终止程序。</p>
<p>也许可以安排尽快调用 <code>git_libgit2_shutdown</code> ——比如说，当最后一个 <code>Repository</code> 值被删除时。但无论我们如何安排，调用 <code>git_libgit2_shutdown</code> 必须是安全 <code>API</code> 的职责。在调用它的那一刻，任何现存的 <code>libgit2</code> 对象都会变得不安全，因此安全的 <code>API</code> 不能直接暴露这个函数。</p>
<p><code>Repository</code>的原始指针必须始终指向一个活动的 <code>git_repository</code> 对象。这意味着关闭<code>存储库</code>的唯一方法是删除拥有它的 <code>Repository</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Repository</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            raw::<span class="title function_ invoke__">git_repository_free</span>(<span class="keyword">self</span>.raw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过仅在指向 <code>raw::git_repository</code> 的唯一指针即将消失时调用 <code>git_repository_free</code>，<code>Repository</code> 类型还确保指针在被释放后永远不会被使用。 <code>Repository::open</code> 方法使用一个名为 <code>path_to_cstring</code> 的私有函数，它有两个定义——一个用于类 <code>Unix</code> 系统，一个用于 <code>Windows</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"><span class="meta">#[cfg(unix)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">path_to_cstring</span>(path: &amp;Path) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;CString&gt; &#123;</span><br><span class="line">    <span class="comment">// The `as_bytes` method exists only on Unix-like systems.</span></span><br><span class="line">    <span class="keyword">use</span> std::os::unix::ffi::OsStrExt;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(CString::<span class="title function_ invoke__">new</span>(path.<span class="title function_ invoke__">as_os_str</span>().<span class="title function_ invoke__">as_bytes</span>())?)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(windows)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">path_to_cstring</span>(path: &amp;Path) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;CString&gt; &#123;</span><br><span class="line">    <span class="comment">// Try to convert to UTF-8. If this fails, libgit2 can&#x27;t handle the path</span></span><br><span class="line">    <span class="comment">// anyway.</span></span><br><span class="line">    <span class="keyword">match</span> path.<span class="title function_ invoke__">to_str</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="title function_ invoke__">Ok</span>(CString::<span class="title function_ invoke__">new</span>(s)?),</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">message</span> = <span class="built_in">format!</span>(<span class="string">&quot;Couldn&#x27;t convert path &#x27;&#123;&#125;&#x27; to UTF-8&quot;</span>, path.<span class="title function_ invoke__">display</span>());</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(message.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>libgit2</code> 接口使这段代码有点棘手。在所有平台上，<code>libgit2</code> 都接受路径为以空字符结尾的 <code>C</code> 字符串。在 <code>Windows</code> 上，<code>libgit2</code> 假定这些 <code>C</code> 字符串保存有效的 <code>UTF-8</code>，并在内部将它们转换为 <code>Windows</code> 实际需要的 <code>16</code> 位路径。这通常有效，但并不理想。<code>Windows</code> 允许文件名不是有效的 <code>Unicode</code>，因此无法以 <code>UTF-8</code> 表示。如果你有这样的文件，就不可能把它的名字传给 <code>libgit2</code>。</p>
<p>在 <code>Rust</code> 中，文件系统路径的正确表示是 <code>std::path::Path</code>，它经过精心设计以处理可能出现在 <code>Windows</code> 或 <code>POSIX</code> 上的任何路径。这意味着 <code>Windows</code> 上的路径值无法传递给 <code>libgit2</code>，因为它们不是有效的 <code>UTF-8</code>。因此，尽管 <code>path_to_cstring</code> 的行为不太理想，但考虑到 <code>libgit2</code> 的接口，这实际上是我们能做的最好的事情。</p>
<p>刚刚显示的两个 <code>path_to_cstring</code> 定义依赖于对我们的<code>Error</code>类型的转换：<code>?</code>运算符尝试进行此类转换，并且 <code>Windows</code> 版本显式调用 <code>.into()</code>。这些转换是不起眼的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(message: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Error &#123;</span><br><span class="line">        Error &#123;</span><br><span class="line">            code: -<span class="number">1</span>,</span><br><span class="line">            message,</span><br><span class="line">            class: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NulError is what `CString::new` returns if a string</span></span><br><span class="line"><span class="comment">// has embedded zero bytes.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;std::ffi::NulError&gt; <span class="keyword">for</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(e: std::ffi::NulError) <span class="punctuation">-&gt;</span> Error &#123;</span><br><span class="line">        Error &#123;</span><br><span class="line">            code: -<span class="number">1</span>,</span><br><span class="line">            message: e.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            class: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们弄清楚如何将 <code>Git</code> 引用解析为对象标识符。由于对象标识符只是一个 <code>20</code> 字节的哈希值，因此可以在安全 <code>API</code> 中公开它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The identifier of some sort of object stored in the Git object</span></span><br><span class="line"><span class="comment">/// database: a commit, tree, blob, tag, etc. This is a wide hash of the</span></span><br><span class="line"><span class="comment">/// object&#x27;s contents.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Oid</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> raw: raw::git_oid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将给 <code>Repository</code> 添加一个用于查找的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Repository</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">reference_name_to_id</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Oid&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">name</span> = CString::<span class="title function_ invoke__">new</span>(name)?;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">oid</span> = &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">oid</span> = mem::MaybeUninit::<span class="title function_ invoke__">uninit</span>();</span><br><span class="line">                <span class="title function_ invoke__">check</span>(raw::<span class="title function_ invoke__">git_reference_name_to_id</span>(</span><br><span class="line">                    oid.<span class="title function_ invoke__">as_mut_ptr</span>(),</span><br><span class="line">                    <span class="keyword">self</span>.raw,</span><br><span class="line">                    name.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> *<span class="keyword">const</span> c_char,</span><br><span class="line">                ))?;</span><br><span class="line">                oid.<span class="title function_ invoke__">assume_init</span>()</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(Oid &#123; raw: oid &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管 <code>oid</code> 在查找失败时未初始化，但此函数保证其调用者永远不会看到未初始化的值，只需遵循 <code>Rust</code> 的 <code>Result</code> 习惯用法：调用者要么得到一个带有正确初始化的 <code>Oid</code> 值的 <code>Ok</code>，要么得到一个 <code>Err</code>。</p>
<p>接下来，该模块需要一种从<code>Git</code>仓库中检索<code>commit</code>的方法。我们将定义一个 <code>Commit</code> 类型，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Commit</span>&lt;<span class="symbol">&#x27;repo</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// This must always be a pointer to a usable `git_commit` structure.</span></span><br><span class="line">    raw: *<span class="keyword">mut</span> raw::git_commit,</span><br><span class="line">    _marker: PhantomData&lt;&amp;<span class="symbol">&#x27;repo</span> Repository&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如我们之前提到的，一个 <code>git_commit</code> 对象永远不能比它从中检索到的 <code>git_repository</code> 对象寿命长。<code>Rust</code> 的生命周期让代码准确地捕捉到了这条规则。</p>
<p>本文前面的 <code>RefWithFlag</code> 示例使用 <code>PhantomData</code> 字段告诉 <code>Rust</code> 将类型视为包含具有给定生命周期的引用，即使该类型显然不包含此类引用，<code>Commit</code> 类型需要做类似的事情。在这种情况下，<code>_marker</code> 字段的类型是 <code>PhantomData&lt;&amp;&#39;repo Repository&gt;</code>，这表明 <code>Rust</code> 应该将 <code>Commit&lt;&#39;repo&gt;</code> 视为它持有对某个 <code>Repository</code> 的生命周期 <code>&#39;repo</code> 的引用。</p>
<p>查找<code>Commit</code>的方法如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Repository</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_commit</span>(&amp;<span class="keyword">self</span>, oid: &amp;Oid) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Commit&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">commit</span> = ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">check</span>(raw::<span class="title function_ invoke__">git_commit_lookup</span>(&amp;<span class="keyword">mut</span> commit, <span class="keyword">self</span>.raw, &amp;oid.raw))?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Commit &#123;</span><br><span class="line">            raw: commit,</span><br><span class="line">            _marker: PhantomData,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这如何将 <code>Commit</code> 的生命周期与 <code>Repository</code> 的生命周期联系起来？ 根据之前概述的规则，<code>find_commit</code> 的签名省略了所涉及的引用的生命周期（<a href="/2021/09/14/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#rule3">看这里</a>）。如果我们要写出生命周期，完整的签名将显示为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_commit</span>&lt;<span class="symbol">&#x27;repo</span>, <span class="symbol">&#x27;id</span>&gt;(&amp;<span class="symbol">&#x27;repo</span> <span class="keyword">self</span>, oid: &amp;<span class="symbol">&#x27;id</span> Oid) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Commit&lt;<span class="symbol">&#x27;repo</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这正是我们想要的：<code>Rust</code> 将返回的 <code>Commit</code> 视为从自身（即 <code>Repository</code>）借来的东西。当一个 <code>Commit</code> 被丢弃时，它必须释放它的 <code>raw::git_commit</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;repo</span>&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Commit</span>&lt;<span class="symbol">&#x27;repo</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            raw::<span class="title function_ invoke__">git_commit_free</span>(<span class="keyword">self</span>.raw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>Commit</code>中，可以借用<code>Signature</code>（姓名和电子邮件地址）和提交消息的文本：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Signature</span>&lt;<span class="symbol">&#x27;text</span>&gt; &#123;</span><br><span class="line">    raw: *<span class="keyword">const</span> raw::git_signature,</span><br><span class="line">    _marker: PhantomData&lt;&amp;<span class="symbol">&#x27;text</span> <span class="type">str</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;repo</span>&gt; Commit&lt;<span class="symbol">&#x27;repo</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Signature &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            Signature &#123;</span><br><span class="line">                raw: raw::<span class="title function_ invoke__">git_commit_author</span>(<span class="keyword">self</span>.raw),</span><br><span class="line">                _marker: PhantomData,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">message</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">message</span> = raw::<span class="title function_ invoke__">git_commit_message</span>(<span class="keyword">self</span>.raw);</span><br><span class="line">            <span class="title function_ invoke__">char_ptr_to_str</span>(<span class="keyword">self</span>, message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>git_signature</code> 对象总是从别处借用它的文本；特别是 <code>git_commit_author</code> 返回的<code>Signature</code>从 <code>git_commit</code> 借用了它们的文本。所以我们的安全 <code>Signature</code> 类型包含一个 <code>PhantomData&lt;&amp;&#39;text str&gt;</code> 来告诉 <code>Rust</code> 表现得好像它包含一个 <code>&amp;str</code> 的生命周期为 ‘<code>text</code>.。就像以前一样，<code>Commit::author</code> 正确地将它返回的<code>Signature</code>的文本生命周期连接到<code>Commit</code>的生命周期，而我们不需要编写任何东西，<code>Commit::message</code> 方法对保存提交消息的 <code>Option&lt;&amp;str&gt;</code> 是同理的。</p>
<p><code>Signature</code> 包括检索作者姓名和电子邮件地址的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;text</span>&gt; Signature&lt;<span class="symbol">&#x27;text</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Return the author&#x27;s name as a `&amp;str`,</span></span><br><span class="line">    <span class="comment">/// or `None` if it is not well-formed UTF-8.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">char_ptr_to_str</span>(<span class="keyword">self</span>, (*<span class="keyword">self</span>.raw).name) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Return the author&#x27;s email as a `&amp;str`,</span></span><br><span class="line">    <span class="comment">/// or `None` if it is not well-formed UTF-8.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">email</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">char_ptr_to_str</span>(<span class="keyword">self</span>, (*<span class="keyword">self</span>.raw).email) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法依赖于私有实用函数 <code>char_ptr_to_str</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Try to borrow a `&amp;str` from `ptr`, given that `ptr` may be null or</span></span><br><span class="line"><span class="comment">/// refer to ill-formed UTF-8. Give the result a lifetime as if it were</span></span><br><span class="line"><span class="comment">/// borrowed from `_owner`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Safety: if `ptr` is non-null, it must point to a null-terminated C</span></span><br><span class="line"><span class="comment">/// string that is safe to access for at least as long as the lifetime of</span></span><br><span class="line"><span class="comment">/// `_owner`.</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">char_ptr_to_str</span>&lt;T&gt;(_owner: &amp;T, ptr: *<span class="keyword">const</span> c_char) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ptr.<span class="title function_ invoke__">is_null</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CStr::<span class="title function_ invoke__">from_ptr</span>(ptr).<span class="title function_ invoke__">to_str</span>().<span class="title function_ invoke__">ok</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_owner</code> 参数的值从未使用，但它有生命周期，如果显示声明是这样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">char_ptr_to_str</span>&lt;<span class="symbol">&#x27;o</span>, T: <span class="symbol">&#x27;o</span>&gt;(_owner: &amp;<span class="symbol">&#x27;o</span> T, ptr: *<span class="keyword">const</span> c_char) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;o</span> <span class="type">str</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>CStr::from_ptr</code> 函数返回一个 <code>&amp;CStr</code>，它的生命周期是完全无界的，因为它是从一个解引用的原始指针中借来的。无限生命周期几乎总是不准确的，因此最好尽快约束它们。包含 <code>_owner</code> 参数会导致 <code>Rust</code> 将其生命周期归因于返回值的类型，因此调用者可以获得更准确的有界引用。</p>
<p>尽管 <code>libgit2</code> 的文档非常好，但从 <code>libgit2</code> 文档中不清楚 <code>git_signature</code> 的电子邮件和作者指针是否可以为空。作者在源代码中挖掘了一段时间，但无法以某种方式说服自己，最终决定 <code>char_ptr_to_str</code> 可能为空，以防万一。但是在 <code>Rust</code> 中，类型会立即回答这类问题：如果是 <code>&amp;str</code>，则可以指望字符串存​​在；如果是 <code>Option&lt;&amp;str&gt;</code>，则为可选。</p>
<p>最后，我们为我们需要的所有功能提供了安全接口。 <code>src/main.rs</code> 中的新 <code>main</code> 函数被精简了很多，看起来像真正的 <code>Rust</code> 代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = std::env::<span class="title function_ invoke__">args_os</span>()</span><br><span class="line">        .<span class="title function_ invoke__">skip</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;usage: git-toy PATH&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">repo</span> = git::Repository::<span class="title function_ invoke__">open</span>(&amp;path).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;opening repository&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">commit_oid</span> = repo</span><br><span class="line">        .<span class="title function_ invoke__">reference_name_to_id</span>(<span class="string">&quot;HEAD&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;looking up &#x27;HEAD&#x27; reference&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">commit</span> = repo.<span class="title function_ invoke__">find_commit</span>(&amp;commit_oid).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;looking up commit&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">author</span> = commit.<span class="title function_ invoke__">author</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125; &lt;&#123;&#125;&gt;\n&quot;</span>,</span><br><span class="line">        author.<span class="title function_ invoke__">name</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;(none)&quot;</span>),</span><br><span class="line">        author.<span class="title function_ invoke__">email</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, commit.<span class="title function_ invoke__">message</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;(none)&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本文中，我们已经从不提供安全保证的简单接口转变为安全 <code>API</code>，通过将任何违反后者规约的行为，改由 <code>Rust</code> 类型错误来包装本质上不安全的 <code>API</code>。 结果是 <code>Rust</code> 可以确保正确使用接口。在大多数情况下，我们让 <code>Rust</code> 强制执行的规则是 <code>C</code> 和 <code>C++</code> 程序员最终强加给自己的那种规则。 让 <code>Rust</code> 感觉比 <code>C</code> 和 <code>C++</code> 严格得多的原因不是规则如此陌生，而是这种执行是机械的和全面的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Rust</code> 不是一门简单的语言，它的目标是跨越两个截然不同的世界，它是一种现代编程语言，设计安全，具有闭包和迭代器等便利性，但它旨在让我们以最小的运行时开销控制运行它的机器的原始功能。</p>
<p>语言的轮廓由这些目标决定，<code>Rust</code> 设法用安全代码弥合了大部分差距。它的借用检查器和零成本抽象使我们尽可能接近裸机，而不会冒未定义行为的风险。当这还不够时，或者当想利用现有的 <code>C</code> 代码时，不安全的代码和外部函数接口已准备就绪。但同样，该语言不仅仅为我们提供这些不安全的功能，目标始终是使用不安全的特性来构建安全的 <code>API</code>，这就是我们对 <code>libgit2</code> 所做的。这也是 <code>Rust</code> 团队对 <code>Box</code>、<code>Vec</code>、其他集合、<code>Chaneel</code>等所做的事情：标准库充满了安全抽象，在幕后用一些不安全的代码实现。</p>
<p>具有 <code>Rust</code> 雄心壮志的语言，或许注定不会成为最简单的工具，但 <code>Rust</code> 是安全、快速、并发且有效的。使用它来构建大型、快速、安全、稳健的系统，充分利用它们所运行的硬件的全部功能，用它来让软件变得更好。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>Foreign Function</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】实现智能指针类型</title>
    <url>/2022/04/14/%E3%80%90Rust%E3%80%91implement-smart-pointer/</url>
    <content><![CDATA[<p>很多时候，我们需要实现一些自动优化的数据结构，在某些情况下是一种优化的数据结构和相应的算法，在其他情况下使用通用的结构和通用的算法。比如当一个 <code>HashSet</code> 的内容比较少的时候，可以用数组实现，但内容逐渐增多，再转换成用哈希表实现。如果我们想让使用者不用关心这些实现的细节，使用同样的接口就能享受到更好的性能，那么，就可以考虑用智能指针来统一它的行为。</p>
<p>我们来实现一个智能 <code>String</code>，<code>Rust</code> 下 <code>String</code> 在栈上占了 <code>24</code> 个字节，然后在堆上存放字符串实际的内容，对于一些比较短的字符串，这很浪费内存。</p>
<p>参考 <code>Cow</code>，我们可以用一个 <code>enum</code> 来处理：当字符串小于 <code>N</code> 字节时，我们直接用栈上的数组，否则使用 <code>String</code>。但是这个 <code>N</code> 不宜太大，否则当使用 <code>String</code> 时，会比目前的版本浪费内存。</p>
<p>当使用 <code>enum</code> 时，额外的 <code>tag</code> + 为了对齐而使用的 <code>padding</code> 会占用一些内存。因为 <code>String</code> 结构是 <code>8</code> 字节对齐的，我们的 <code>enum</code> 最小 <code>8 + 24 = 32</code> 个字节。</p>
<p>所以，可以设计一个数据结构，内部用<code>1</code>个字节表示字符串的长度，用 <code>30</code> 个字节表示字符串内容，再加上 <code>1</code> 个字节的 <code>tag</code>，正好也是 <code>32</code> 字节，可以和 <code>String</code> 放在一个 <code>enum</code> 里使用，我们暂且称这个 <code>enum</code> 叫 <code>SmartString</code>，它的结构如下图所示：</p>
<img data-src="/2022/04/14/%E3%80%90Rust%E3%80%91implement-smart-pointer/Rust-smart-string.png" class="">

<span id="more"></span>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt, ops::Deref, <span class="type">str</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// INLINE_STRING_MAX_LEN represent the maximum length</span></span><br><span class="line"><span class="comment">/// that can be stored in the stack.</span></span><br><span class="line"><span class="keyword">const</span> INLINE_STRING_MAX_LEN: <span class="type">usize</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// InlineString 会被存储在栈上，最多占用 32 字节</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InlineString</span> &#123;</span><br><span class="line">    len: <span class="type">u8</span>,</span><br><span class="line">    data: [<span class="type">u8</span>; INLINE_STRING_MAX_LEN],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">InlineString</span> &#123;</span><br><span class="line">    <span class="comment">/// 这里的 new 接口不能暴露出去，我们需要在调用的时候保证传入的字节长度小于 INLINE_STRING_MAX_LEN</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(input: <span class="keyword">impl</span> <span class="title class_">AsRef</span>&lt;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes</span> = input.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = bytes.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = [<span class="number">0u8</span>; INLINE_STRING_MAX_LEN];</span><br><span class="line">        data[..len].<span class="title function_ invoke__">copy_from_slice</span>(bytes);</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            len: len <span class="keyword">as</span> <span class="type">u8</span>,</span><br><span class="line">            data,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">InlineString</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = <span class="type">str</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="comment">// 由于生成 InlineString 的接口是隐藏的，它只能来自字符串，所以下面这行是安全的</span></span><br><span class="line">        <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;<span class="keyword">self</span>.data[..<span class="keyword">self</span>.len <span class="keyword">as</span> <span class="type">usize</span>]).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">InlineString</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">deref</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SmartString</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Inline</span>(InlineString),</span><br><span class="line">    <span class="title function_ invoke__">Standard</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">SmartString</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = <span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            SmartString::<span class="title function_ invoke__">Inline</span>(<span class="keyword">ref</span> v) =&gt; v.<span class="title function_ invoke__">deref</span>(),</span><br><span class="line">            SmartString::<span class="title function_ invoke__">Standard</span>(<span class="keyword">ref</span> v) =&gt; v.<span class="title function_ invoke__">deref</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;&amp;<span class="type">str</span>&gt; <span class="keyword">for</span> <span class="title class_">SmartString</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> s.<span class="title function_ invoke__">len</span>() &gt; INLINE_STRING_MAX_LEN &#123;</span><br><span class="line">            <span class="literal">true</span> =&gt; SmartString::<span class="title function_ invoke__">Standard</span>(s.<span class="title function_ invoke__">to_owned</span>()),</span><br><span class="line">            _ =&gt; SmartString::<span class="title function_ invoke__">Inline</span>(InlineString::<span class="title function_ invoke__">new</span>(s)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">SmartString</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">deref</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len1</span> = std::mem::size_of::&lt;SmartString&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len2</span> = std::mem::size_of::&lt;InlineString&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Len: SmartString &#123;&#125;, InlineString: &#123;&#125;&quot;</span>, len1, len2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: SmartString = <span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = SmartString::<span class="title function_ invoke__">from</span>(<span class="string">&quot;这是一个超过了三十个字节的很长很长的字符串&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1: &#123;:?&#125;, s2: &#123;:?&#125;&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// display 输出</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;s1: &#123;&#125;(&#123;&#125; bytes, &#123;&#125; chars), s2: &#123;&#125;(&#123;&#125; bytes, &#123;&#125; chars)&quot;</span>,</span><br><span class="line">        s1,</span><br><span class="line">        s1.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">        s1.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>(),</span><br><span class="line">        s2,</span><br><span class="line">        s2.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">        s2.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SmartString 可以使用一切 &amp;str 接口，感谢 Rust 的自动 Deref</span></span><br><span class="line">    <span class="built_in">assert!</span>(s1.<span class="title function_ invoke__">ends_with</span>(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">    <span class="built_in">assert!</span>(s2.<span class="title function_ invoke__">starts_with</span>(<span class="string">&quot;这&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>Len: SmartString 32, InlineString: 31
s1: Inline(hello world), s2: Standard(&quot;这是一个超过了三十个字节的很长很长的字符串&quot;)
s1: hello world(11 bytes, 11 chars), s2: 这是一个超过了三十个字节的很长很长的字符串(63 bytes, 21 chars)
</code></pre>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>smart pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】Mutex 使用示例</title>
    <url>/2022/04/13/%E3%80%90Rust%E3%80%91mutex-multithre-share/</url>
    <content><![CDATA[<p>使用 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>std::sync::Mutex</code></a> 可以多线程共享可变数据，<code>Mutex</code>、<code>RwLock</code> 和原子类型，即使声明为 <code>non-mut</code>，这些类型也可以修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 用 Arc 来提供并发环境下的共享所有权（使用引用计数）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">metrics</span>: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;<span class="symbol">&#x27;static</span>, <span class="type">str</span>&gt;, <span class="type">usize</span>&gt;&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(HashMap::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">m</span> = metrics.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">g</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时只有拿到 MutexGuard 的线程可以访问 HashMap</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">data</span> = &amp;<span class="keyword">mut</span> *g;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cow 实现了很多数据结构的 From trait，</span></span><br><span class="line">            <span class="comment">// 所以我们可以用 &quot;hello&quot;.into() 生成 Cow</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">value</span> = data.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">into</span>()).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">            *value += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MutexGuard 被 Drop，锁被释放</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;metrics: &#123;:?&#125;&quot;</span>, metrics.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】代码片段</title>
    <url>/2022/04/12/%E3%80%90Rust%E3%80%91some-useful-code/</url>
    <content><![CDATA[<h3 id="构造-Double-Free"><a href="#构造-Double-Free" class="headerlink" title="构造 Double Free"></a>构造 <code>Double Free</code></h3><p>使用 <code>unsafe</code> 特性构造指向同一块内存的两个变量，导致 <code>Double Free</code>：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;mem, ptr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">d</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cccc&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d_len</span> = d.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="type">String</span>::<span class="title function_ invoke__">with_capacity</span>(d_len);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">copy</span>(&amp;d, &amp;<span class="keyword">mut</span> c, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, d.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">    d.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<span id="more"></span>

<h3 id="Arc-无法-DerefMove"><a href="#Arc-无法-DerefMove" class="headerlink" title="Arc 无法 DerefMove"></a><code>Arc</code> 无法 <code>DerefMove</code></h3><div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, s.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">    <span class="comment">// DerefMove Error : cannot move out of an `Arc`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = *s;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:p&#125;&quot;, s.as_ptr()); // Moved s</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, s2.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但如果换成 <code>Box</code> 是可以的。</p>
<h3 id="参数生命周期继承"><a href="#参数生命周期继承" class="headerlink" title="参数生命周期继承"></a>参数生命周期继承</h3><p>下面的代码中说明 <code>&#39;a</code> 的生命周期要大于 <code>&#39;c</code>，可以这样理解，如果一个引用的生命周期满足 <code>&#39;a</code>，那么它必然可以满足 <code>&#39;c</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">the_longest</span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1_r</span> = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">the_longest</span>(s1_r, &amp;s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is the longest&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们可以给每个引用都声明一个单独的声明周期参数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">the_longest</span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="早期绑定、晚期绑定"><a href="#早期绑定、晚期绑定" class="headerlink" title="早期绑定、晚期绑定"></a>早期绑定、晚期绑定</h3><p>可以阅读：<a href="https://dtolnay.github.io/rust-quiz/11">https://dtolnay.github.io/rust-quiz/11</a></p>
<p>泛型参数可以是早期绑定或晚期绑定，当前（以及在可预见的将来）类型参数总是早期绑定，但生命周期参数可以是早期绑定或后绑定。</p>
<p>早期绑定参数由编译器在单态化期间确定，由于类型参数始终是早期绑定的，因此不能拥具有未解析类型参数的值。例如：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">m</span>&lt;T&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = m::&lt;<span class="type">u8</span>&gt;; <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m2</span> = m; <span class="comment">// error: cannot infer type for `T`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是这个对于生命周期却是允许的，因为生命周期 <code>&#39;a</code> 的实际选择取决于它的调用方式，因此我们可以省略生命周期参数，它将在调用的地方确定：每次调用的生命周期甚至可能不同：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">m</span>&lt;<span class="symbol">&#x27;a</span>&gt;(_: &amp;<span class="symbol">&#x27;a</span> ()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = m; <span class="comment">// ok even though &#x27;a isn&#x27;t provided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>}

<p>出于这个原因，我们不能指定生命周期直到它被调用，也不能让借用检查器去推断它：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m2</span> = m::&lt;<span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m3</span> = m::&lt;<span class="symbol">&#x27;_</span>&gt;;</span><br></pre></td></tr></table></figure></div>

<p>晚期绑定参数的想法与 <code>Rust</code> 的一个称为“高级<code>Trait</code>边界”（<code>HRTB</code>）的特性有很大的重叠，这是一种机制，用于表示<code>trait</code>参数的界限是后期界限。目前这仅限于生命周期参数，可以使用 <code>for</code> 关键字表达生命周期的<code>HRTB</code>，例如，对于上面的 <code>m1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let m1: impl for&lt;&#x27;r&gt; Fn(&amp;&#x27;r ()) = m;</span><br></pre></td></tr></table></figure>

<p>可以把它理解为这里有一个生命周期，但是我们目前还不需要知道它。</p>
<p>后期绑定生命周期总是无限的；没有语法来表示必须比其他生命周期更长的后期绑定生命周期：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span>: <span class="keyword">for</span>&lt;<span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>&gt; <span class="title function_ invoke__">fn</span>(&amp;<span class="symbol">&#x27;b</span> ()); <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>}

<p>除非开发人员明确使用 <code>HRTB</code> 作为语法，否则数据类型的生命周期总是提前绑定的。在函数上，生命周期默认为后期绑定，但在以下情况下可以提前绑定：</p>
<ul>
<li><p>生命周期在函数签名之外声明，例如在结构体的关联方法中，它可以来自结构体本身；</p>
</li>
<li><p>生命周期参数以它必须超过的其他生命周期为界；</p>
</li>
</ul>
<p>通过这些规则，我们来看个例子：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">g</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;a</span>&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pf</span> = f::&lt;<span class="symbol">&#x27;static</span>&gt; <span class="keyword">as</span> <span class="title function_ invoke__">fn</span>(); <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pg</span> = g::&lt;<span class="symbol">&#x27;static</span>&gt; <span class="keyword">as</span> <span class="title function_ invoke__">fn</span>(); <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, pf == pg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据这些规则，签名 <code>fn f&lt;&#39;a&gt;()</code> 具有后期绑定生命周期参数，而签名 <code>fn g&lt;&#39;a: &#39;a&gt;()</code> 具有早期绑定生命周期参数（即使此处的约束无效）。</p>
<div class="tabs" id="早晚期绑定"><ul class="nav-tabs"><li class="tab active"><a href="#早晚期绑定-1">示例一（错误）</a></li><li class="tab"><a href="#早晚期绑定-2">示例二（通过）</a></li></ul><div class="tab-content"><div class="tab-pane active" id="早晚期绑定-1"><p>下面这段代码编译失败，原因很很直接，我们对 <code>buf</code> 存在两次可变借用，但是我们的第一次可变借用在获取 <code>b1</code> 之后就应该失效，只要 <code>buf</code> 存在，<code>b1</code> 和 <code>b2</code> 就应该保持有效。但是从 <code>read_bytes</code> 的实现中我们可以看出，它有一个后期绑定生命周期参数，返回值还和每次调用的可变借用必须具有相同生命周期，所以可变借用得保留到返回值最后一次使用位置。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    buf: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    pos: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Buffer &#123;</span><br><span class="line">        Buffer &#123;</span><br><span class="line">            buf: <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            pos: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read_bytes</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> [<span class="type">u8</span>] &#123;</span><br><span class="line">        <span class="keyword">self</span>.pos += <span class="number">3</span>;</span><br><span class="line">        &amp;<span class="keyword">self</span>.buf[<span class="keyword">self</span>.pos - <span class="number">3</span>..<span class="keyword">self</span>.pos]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(b1: &amp;[<span class="type">u8</span>], b2: &amp;[<span class="type">u8</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125; &#123;:#?&#125;&quot;</span>, b1, b2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = Buffer::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b1</span> = buf.<span class="title function_ invoke__">read_bytes</span>();   <span class="comment">// -----------第一次-----------+</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b2</span> = buf.<span class="title function_ invoke__">read_bytes</span>();   <span class="comment">// -----------第二次-----------|</span></span><br><span class="line">    <span class="title function_ invoke__">print</span>(b1, b2)                <span class="comment">// --------------------------\|/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="早晚期绑定-2"><p>但是我们将我们的 <code>Buffer</code> 改改，让它拥有一个具有 <code>&#39;a</code> 的 <code>buf</code>，而且让 <code>read_bytes</code> 的返回值生命周期跟 <code>buf</code> 相同，这样就和它的调用者没关系了，生成 <code>b1</code> 和 <code>b2</code> 的可变借用在它们使用完就结束了，这里 <code>read_bytes</code> 的参数生命周期是早期绑定的，在编译期间就能但太态化。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = Buffer::<span class="title function_ invoke__">new</span>(&amp;v);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b1</span> = buf.<span class="title function_ invoke__">read_bytes</span>();    <span class="comment">// 第一次可变借用，相当于 (&amp;mut buf).read_bytes()</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b2</span> = buf.<span class="title function_ invoke__">read_bytes</span>();    <span class="comment">// 第二次可变借用</span></span><br><span class="line">    <span class="title function_ invoke__">print</span>(b1, b2)                 <span class="comment">// b1 和 b2 引用至 v，和 v 有相同的生命周期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(b1: &amp;[<span class="type">u8</span>], b2: &amp;[<span class="type">u8</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125; &#123;:#?&#125;&quot;</span>, b1, b2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    buf: &amp;<span class="symbol">&#x27;a</span> [<span class="type">u8</span>],</span><br><span class="line">    pos: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>&gt; Buffer&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(b: &amp;<span class="symbol">&#x27;a</span> [<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> Buffer &#123;</span><br><span class="line">        Buffer &#123; buf: b, pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read_bytes</span>(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> [<span class="type">u8</span>] &#123;</span><br><span class="line">        <span class="keyword">self</span>.pos += <span class="number">3</span>;</span><br><span class="line">        &amp;<span class="keyword">self</span>.buf[<span class="keyword">self</span>.pos - <span class="number">3</span>..<span class="keyword">self</span>.pos]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】幽灵数据（PhantomData）</title>
    <url>/2022/04/15/%E3%80%90Rust%E3%80%91phantom-data/</url>
    <content><![CDATA[<p><a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"><code>std::marker::PhantomData</code></a> 是一个零大小的类型，用于标记一些类型，这些类型看起来拥有类型 <code>T</code>，但实际上并没有：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PhantomData</span>&lt;T&gt;</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">    T: ?<span class="built_in">Sized</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>Rust</code> 并不希望在定义类型时，出现目前还没使用，但未来会被使用的泛型参数，例如未使用的生命周期参数以及未使用的类型。</strong></p>
<p><code>PhantomData</code> 最常见的用例可能是具有未使用的生命周期参数的结构体，例如，这儿有一个结构体 <code>Slice</code>，它有两个 <code>*const T</code> 类型的指针，可能指向某个地方的数组，我们期望 <code>Slice</code> 类型的值在生命周期 <code>&#39;a</code> 内仅仅有效，但是如果像下面这样，<code>&#39;a</code> 我们又无处安放：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Slice</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    start: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以使用 <code>PhantomData</code> 告诉编译器就像 <code>Slice</code> 结构包含引用 <code>&amp;&#39;a T</code> 一样来纠正这个问题：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Slice</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    start: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">    phantom: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这反过来要求 <code>T</code> 类型中的任何引用在生命周期 <code>&#39;a</code> 内都是有效的，初始化 <code>Slice</code> 时，仅需要为 <code>phantom</code> 字段提供值 <code>PhantomData</code> 即可：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">borrow_vec</span>&lt;T&gt;(vec: &amp;<span class="type">Vec</span>&lt;T&gt;) <span class="punctuation">-&gt;</span> Slice&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = vec.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line">    Slice &#123;</span><br><span class="line">        start: ptr,</span><br><span class="line">        end: <span class="keyword">unsafe</span> &#123; ptr.<span class="title function_ invoke__">add</span>(vec.<span class="title function_ invoke__">len</span>()) &#125;,</span><br><span class="line">        phantom: PhantomData,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>我们现在想设计一个 <code>User</code> 和 <code>Product</code> 的结构体，它们都有数据为 <code>u64</code> 的 <code>id</code> 字段，但是我们不希望 <code>user.id</code> 和 <code>product.id</code> 可以比较：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Eq, PartialEq, Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Identifier</span>&lt;T&gt; &#123;</span><br><span class="line">    inner: <span class="type">u64</span>,</span><br><span class="line">    phantom: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Eq, PartialEq, Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    id: Identifier&lt;<span class="keyword">Self</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Eq, PartialEq, Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    id: Identifier&lt;<span class="keyword">Self</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">id_should_not_be_the_same</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">user</span> = User::<span class="title function_ invoke__">default</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">product</span> = Product::<span class="title function_ invoke__">default</span>();</span><br><span class="line">        <span class="comment">// 两个 id 不能比较，因为他们属于不同的类型</span></span><br><span class="line">        <span class="comment">// assert_ne!(user.id, product.id);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(user.id.inner, product.id.inner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Identifier</code> 中 <code>phantom</code> 字段的引入让 <code>Identifier</code> 在使用时具有了不同的静态类型，但 <code>Identifier</code> 中又实际没有使用类型 <code>T</code>。</p>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>我们可以使用泛型结构体来实现对同一种类对象不同子类对象的区分，例如，我们的系统中要设计这样一个功能，将用户分为免费用户和付费用户，而且免费用户在体验免费功能之后，如果想升级成付费用户也是可以的。按照我们常规的思维，可能是定义两个结构体 <code>FreeCustomer</code> 以及 <code>PaidCustomer</code>，但是我们可以通过泛型结构体来实现，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Customer</span>&lt;T&gt; &#123;</span><br><span class="line">    id: <span class="type">u64</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过，我们这里的 <code>T</code> 又无处安放，所以又不得不使用 <code>PhantomData</code>，它就像一个占位符，但是又没有大小，可以为我们持有在声明时使用不到的数据：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    marker::PhantomData,</span><br><span class="line">    sync::atomic::&#123;<span class="keyword">self</span>, AtomicU64&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NEXT_ID: AtomicU64 = AtomicU64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Customer</span>&lt;T&gt; &#123;</span><br><span class="line">    id: <span class="type">u64</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    phantom: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FreeFeature</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PaidFeature</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Free</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">feature1</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">feature2</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Paid</span>: Free &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">paid_feature</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为 Customer&lt;T&gt; 实现需要的方法</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Customer&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            id: NEXT_ID.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, atomic::Ordering::Relaxed),</span><br><span class="line">            name,</span><br><span class="line">            phantom: PhantomData,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 免费用户可以升级到付费用户</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Customer</span>&lt;FreeFeature&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">advance</span>(<span class="keyword">self</span>, payment: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Customer&lt;PaidFeature&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;&#125;（&#123;&#125;） 将花费 &#123;:.2&#125; 元升级到付费用户&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.name, <span class="keyword">self</span>.id, payment</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 所有客户都有权使用免费功能</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Free <span class="keyword">for</span> <span class="title class_">Customer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">feature1</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 正在使用免费功能一&quot;</span>, <span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">feature2</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 正在使用免费功能二&quot;</span>, <span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 付费用户才能使用的功能</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Paid</span> <span class="keyword">for</span> <span class="title class_">Customer</span>&lt;PaidFeature&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">paid_feature</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 正在使用付费功能&quot;</span>, <span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 允许使用免费用户转换成付费用户</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;Customer&lt;FreeFeature&gt;&gt; <span class="keyword">for</span> <span class="title class_">Customer</span>&lt;PaidFeature&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(c: Customer&lt;FreeFeature&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>(c.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_customer</span>() &#123;</span><br><span class="line">        <span class="comment">// 一开始是免费用户</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">customer</span> = Customer::&lt;FreeFeature&gt;::<span class="title function_ invoke__">new</span>(<span class="string">&quot;MichaelFu&quot;</span>.<span class="title function_ invoke__">to_owned</span>());</span><br><span class="line">        customer.<span class="title function_ invoke__">feature1</span>();</span><br><span class="line">        customer.<span class="title function_ invoke__">feature2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 升级成付费用户，可能使用付费功能和普通功能</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">customer</span> = customer.<span class="title function_ invoke__">advance</span>(<span class="number">99.99</span>);</span><br><span class="line">        customer.<span class="title function_ invoke__">feature1</span>();</span><br><span class="line">        customer.<span class="title function_ invoke__">feature2</span>();</span><br><span class="line">        customer.<span class="title function_ invoke__">paid_feature</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试案例，这将输出：</p>
<pre><code>MichaelFu 正在使用免费功能一
MichaelFu 正在使用免费功能二
MichaelFu（0） 将花费 99.99 元升级到付费用户
MichaelFu 正在使用免费功能一
MichaelFu 正在使用免费功能二
MichaelFu 正在使用付费功能
</code></pre>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用 <code>PhantomData&lt;T&gt;</code> 表示我们的结构体拥有 <code>T</code> 类型的数据，当我们的结构体删除的时候，可能会删除一个或者多个 <code>T</code> 类型的实例。</p>
<p>但是，如果我们的结构体实际上并不拥有类型 <code>T</code> 的数据，那么我们最好使用 <code>PhantomData&lt;&amp;&#39;a T&gt;</code> 或者 <code>PhantomData&lt;*const T&gt; </code>。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>phantom-data</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】交叉编译</title>
    <url>/2022/06/29/%E3%80%90Rust%E3%80%91%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>交叉编译就是跨平台编译，例如在 <code>window</code> 下编译程序的linux版本，或者在 <code>x86_64</code> 平台下编译 <code>aarch64</code> 版本。跨平台编译在Go语言中非常方便，得益于Go语言汇编器的设计。</p>
<h3 id="MacOS-交叉编译-Linux-程序"><a href="#MacOS-交叉编译-Linux-程序" class="headerlink" title="MacOS 交叉编译 Linux 程序"></a>MacOS 交叉编译 Linux 程序</h3><p>本文展示如何在 <code>Apple M1</code> 的平台下编译 <code>Linux aarch64</code> 的应用程序。</p>
<ul>
<li><p><code>Apple M1</code>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/gamelife1314.github.io on  source! ⌚ 13:15:25</span><br><span class="line">$ uname -pvm</span><br><span class="line">Darwin Kernel Version 21.4.0: Fri Mar 18 00:46:32 PDT 2022; root:xnu-8020.101.4~15/RELEASE_ARM64_T6000 arm64 arm</span><br><span class="line"></span><br><span class="line">~/WORKDIR/gamelife1314.github.io on  source! ⌚ 13:15:38</span><br><span class="line">$ gcc -dumpmachine</span><br><span class="line">arm64-apple-darwin21.4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>linux aarch64</code>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@vm-docker:~$ gcc -dumpmachine</span><br><span class="line">aarch64-linux-gnu</span><br><span class="line">ubuntu@vm-docker:~$ uname -pvm</span><br><span class="line">#40-Ubuntu SMP Mon Mar 7 08:06:10 UTC 2022 aarch64 aarch64</span><br><span class="line">ubuntu@vm-docker:~$</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>   

<h4 id="安装-rust-标准库"><a href="#安装-rust-标准库" class="headerlink" title="安装 rust 标准库"></a>安装 rust 标准库</h4><p>在编译之前，我们需要在我们的工作平台，即 Mac 机器中，安装目的平台的标准库，我们可以通过 <code>rustup target list</code> 命令查看 <code>rust</code> 支持哪些平台架构，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/helloworld ⌚ 12:52:32</span><br><span class="line">$ rustup target list | grep aarch64 | grep linux</span><br><span class="line">aarch64-linux-android</span><br><span class="line">aarch64-unknown-linux-gnu (installed)</span><br><span class="line">aarch64-unknown-linux-musl</span><br></pre></td></tr></table></figure>

<p>安装特定平台标准库使用 <code>rustup target add</code> 命令即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/helloworld ⌚ 13:21:34</span><br><span class="line">$ rustup target add --toolchain stable aarch64-unknown-linux-gnu</span><br><span class="line">info: downloading component &#x27;rust-std&#x27; for &#x27;aarch64-unknown-linux-gnu&#x27;</span><br><span class="line">info: installing component &#x27;rust-std&#x27; for &#x27;aarch64-unknown-linux-gnu&#x27;</span><br><span class="line"> 34.9 MiB /  34.9 MiB (100 %)  18.1 MiB/s in  1s ETA:  0s</span><br></pre></td></tr></table></figure>

<p>安装成功之后，通过 <code>rustup show</code> 命令查看本地已安装的工具链和标准库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/helloworld ⌚ 13:22:11</span><br><span class="line">$ rustup show</span><br><span class="line">Default host: aarch64-apple-darwin</span><br><span class="line">rustup home:  /Users/fudenglong/.rustup</span><br><span class="line"></span><br><span class="line">installed toolchains</span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">stable-aarch64-apple-darwin</span><br><span class="line">beta-aarch64-apple-darwin</span><br><span class="line">nightly-aarch64-apple-darwin (default)</span><br><span class="line"></span><br><span class="line">installed targets for active toolchain</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line">aarch64-apple-darwin</span><br><span class="line">aarch64-unknown-linux-gnu</span><br><span class="line">x86_64-unknown-linux-gnu</span><br><span class="line"></span><br><span class="line">active toolchain</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">nightly-aarch64-apple-darwin (default)</span><br><span class="line">rustc 1.62.0-nightly (e745b4ddb 2022-04-07)</span><br></pre></td></tr></table></figure>

<h4 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h4><p>要编译 <code>aarch64-linux-gnu</code> 平台下的程序，就需要特定平台的编译器，这个项目中提供了MAC环境下用于交叉编译的工具，更多请看 <a href="https://github.com/messense/homebrew-macos-cross-toolchains">https://github.com/messense/homebrew-macos-cross-toolchains</a>。</p>
<p>使用 <code>brew</code> 安装非常简单，两条命令即可，耐心等待安装完成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap messense/macos-cross-toolchains</span><br><span class="line">brew install aarch64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>

<p>经过这里之后，我们可以看到我们将所需要的 <code>linux-aarch64</code> 下的工具链都安装下来了：</p>
<img data-src="/2022/06/29/%E3%80%90Rust%E3%80%91%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/brew-install-aarch64-linux-compile-tool.png" class="">

<h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>使用 <code>cargo</code> 命令快速创建一个项目进行测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust ⌚ 13:27:16</span><br><span class="line">$ cargo new crosscompile</span><br><span class="line">     Created binary (application) `crosscompile` package</span><br><span class="line"></span><br><span class="line">~/WORKDIR/rust ⌚ 13:27:50</span><br><span class="line">$ cd crosscompile</span><br><span class="line"></span><br><span class="line">~/WORKDIR/rust/crosscompile on  master! ⌚ 13:27:58</span><br><span class="line">$ cargo run</span><br><span class="line">   Compiling crosscompile v0.1.0 (/Users/fudenglong/WORKDIR/rust/crosscompile)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.59s</span><br><span class="line">     Running `target/debug/crosscompile`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<h5 id="配置文件配置-Cargo"><a href="#配置文件配置-Cargo" class="headerlink" title="配置文件配置 Cargo"></a>配置文件配置 Cargo</h5><p>我们需要配置 <code>cargo</code> 编译时使用的链接器，在配置文件 <code>.cargo/config</code> 中添加如下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/crosscompile on  master! ⌚ 17:15:21</span><br><span class="line">$ ll .cargo/config</span><br><span class="line">-rw-r--r--  1 fudenglong  staff    94B  4  8 17:13 .cargo/config</span><br><span class="line">~/WORKDIR/rust/crosscompile on  master! ⌚ 17:15:25</span><br><span class="line">$ cat .cargo/config</span><br><span class="line">[target.aarch64-unknown-linux-gnu]</span><br><span class="line">linker = &quot;/opt/homebrew/bin/aarch64-unknown-linux-gnu-gcc&quot;</span><br></pre></td></tr></table></figure>

<p>然后我们执行特定编译命令 <code>cargo build -v --target aarch64-unknown-linux-gnu</code>：</p>
<img data-src="/2022/06/29/%E3%80%90Rust%E3%80%91%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/rust-cross-compile-success.png" class="">


<h5 id="环境变量配置-Cargo"><a href="#环境变量配置-Cargo" class="headerlink" title="环境变量配置 Cargo"></a>环境变量配置 Cargo</h5><p>我们也可以使用环境变量配置所需要的链接器，环境变量的形式是：<code>CARGO_TARGET_&lt;triple&gt;_LINKER</code>，这里的 <code>triple</code> 就是我们目标 <code>target</code>，只不过要转换成大写，并且替换 <code>-</code> 为 <code>_</code>，例如:</p>
<blockquote>
<p>CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;aarch64-unknown-linux-gnu-gcc  cargo build -v –target aarch64-unknown-linux-gnu</p>
</blockquote>
<img data-src="/2022/06/29/%E3%80%90Rust%E3%80%91%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/cargo-env-config.png" class="">


<h5 id="编译输出结果"><a href="#编译输出结果" class="headerlink" title="编译输出结果"></a>编译输出结果</h5><p>在下面的目录下能找到编译之后的二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/WORKDIR/rust/crosscompile on  master! ⌚ 17:22:58</span><br><span class="line">$ ll target/aarch64-unknown-linux-gnu/debug</span><br><span class="line">total 7880</span><br><span class="line">drwxr-xr-x  2 fudenglong  staff    64B  4  8 17:13 build</span><br><span class="line">-rwxr-xr-x  1 fudenglong  staff   3.8M  4  8 17:13 crosscompile</span><br><span class="line">-rw-r--r--  1 fudenglong  staff   153B  4  8 17:13 crosscompile.d</span><br><span class="line">drwxr-xr-x  4 fudenglong  staff   128B  4  8 17:13 deps</span><br><span class="line">drwxr-xr-x  2 fudenglong  staff    64B  4  8 17:13 examples</span><br><span class="line">drwxr-xr-x  3 fudenglong  staff    96B  4  8 17:13 incremental</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后去linux下运行也是没有问题的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@vm-docker:~/workdir$ uname</span><br><span class="line">Linux</span><br><span class="line">ubuntu@vm-docker:~/workdir$ uname -a</span><br><span class="line">Linux vm-docker 5.13.0-35-generic #40-Ubuntu SMP Mon Mar 7 08:06:10 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux</span><br><span class="line">ubuntu@vm-docker:~/workdir$ readelf -h crosscompile</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x6720</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          4025296 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         10</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         44</span><br><span class="line">  Section header string table index: 43</span><br><span class="line">ubuntu@vm-docker:~/workdir$ ./crosscompile</span><br><span class="line">Hello, world!</span><br><span class="line">ubuntu@vm-docker:~/workdir$</span><br></pre></td></tr></table></figure>

<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>交叉编译的直接需求就是你得找到一款合适的编译器，能编译出特定平台架构下的二进制程序。</p>
<ol>
<li><code>macos-&gt;windows</code>：<a href="https://words.filippo.io/easy-windows-and-linux-cross-compilers-for-macos/">Macos 平台linux和windows交叉编译器</a></li>
<li><a href="https://www.acmesystems.it/arm9_toolchain">linuxARM compiler for LinuxX86 System</a></li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://www.youtube.com/watch?v=wp6s2sm_7VE">Rust Cross-Compilation with Cargo and Rustup toolchain manager</a></li>
<li><a href="https://colobu.com/2019/12/18/How-to-Cross-Compile-from-Mac-to-Linux-on-Rust/">如何在Mac上为Linux交叉编译Rust程序</a></li>
<li><a href="https://www.cnblogs.com/007sx/p/15191400.html">Rust交叉编译Mac编译Linux&#x2F;Windows平台</a></li>
<li><a href="https://words.filippo.io/easy-windows-and-linux-cross-compilers-for-macos/">Macos 平台linux和windows交叉编译器</a></li>
</ol>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】基础类型</title>
    <url>/2022/06/28/%E3%80%90Rust%E3%80%91%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>下面是在 <code>Rust</code> 中会看到的类型的总结，展示了Rust的基本类型，标准库中一些非常常见的类型，以及一些用户定义类型的例子。</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Description</th>
<th align="center">Values</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>i8, i16, i32, i64, i128 u8, u16, u32, u64, u128</code></td>
<td align="center">给定宽度的有符号和无符号整数</td>
<td align="center"><code>42</code>,<code>-5i8</code>, <code>0x400u16</code>, <code>0o100i16</code>, <code>20_922_789_888_000u64</code>, <code>b&#39;*&#39;</code></td>
</tr>
<tr>
<td align="center"><code>isize</code>, <code>usize</code></td>
<td align="center">有符号整数和无符号整数， 与计算机上的地址大小相同(32位或64位)</td>
<td align="center"><code>137</code>, <code>-0b0101_0010isize</code>, <code>0xffff_fc00usize</code></td>
</tr>
<tr>
<td align="center"><code>f32</code>, <code>f64</code></td>
<td align="center">IEEE浮点数，单精度和双精度</td>
<td align="center"><code>1.61803</code>, <code>3.14f32</code>, <code>6.0221e23f64</code></td>
</tr>
<tr>
<td align="center"><code>bool</code></td>
<td align="center">Boolean</td>
<td align="center"><code>true</code>，<code>false</code></td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">Unicode字符，32位宽</td>
<td align="center"><code>&#39;*&#39;</code>, <code>&#39;\n&#39;</code>, <code>&#39;字&#39;</code>, <code>&#39;\x7f&#39;</code>, <code>&#39;\u&#123;CA0&#125;&#39;</code></td>
</tr>
<tr>
<td align="center"><code>(char, u8, i32)</code></td>
<td align="center">Tuple:允许混合类型</td>
<td align="center"><code>(&#39;%&#39;, 0x7f, -1)</code></td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="center">空元组</td>
<td align="center"><code>()</code></td>
</tr>
<tr>
<td align="center"><code>struct S &#123; x: f32, y: f32 &#125;</code></td>
<td align="center">字段带名称的复合结构</td>
<td align="center"><code>S &#123; x: 120.0, y: 209.0 &#125;</code></td>
</tr>
<tr>
<td align="center"><code>struct T (i32, char);</code></td>
<td align="center">Tuple-like struct</td>
<td align="center"><code>T(120, &#39;X&#39;)</code></td>
</tr>
<tr>
<td align="center"><code>struct E;</code></td>
<td align="center"><code>Unit-like struct; has no fields</code></td>
<td align="center"><code>E</code></td>
</tr>
<tr>
<td align="center"><code>enum Attend &#123; OnTime, Late(u32) &#125;</code></td>
<td align="center">枚举</td>
<td align="center"><code>Attend::Late(5), Attend::OnTime</code></td>
</tr>
<tr>
<td align="center"><code>Box&lt;Attend&gt;</code></td>
<td align="center"><code>Box</code>:拥有指向堆中的值的指针</td>
<td align="center"><code>Box::new(Late(15))</code></td>
</tr>
<tr>
<td align="center"><code>&amp;i32, &amp;mut i32</code></td>
<td align="center">共享引用和可变引用:非拥有指针，不能比它们的引用活得更久</td>
<td align="center"><code>&amp;s.y, &amp;mut v</code></td>
</tr>
<tr>
<td align="center"><code>String</code></td>
<td align="center">动态大小的<code>UTF-8</code>字符串</td>
<td align="center"><code>&quot;ラーメン: ramen&quot;.to_string()</code></td>
</tr>
<tr>
<td align="center"><code>&amp;str</code></td>
<td align="center"><code>Reference to str: non-owning pointer to UTF-8 text</code></td>
<td align="center"><code>&quot;そば: soba&quot;</code>, <code>&amp;s[0..12]</code></td>
</tr>
<tr>
<td align="center"><code>[f64; 4]</code>, <code>[u8; 256]</code></td>
<td align="center">数组，固定长度，元素同类型</td>
<td align="center"><code>[1.0, 0.0, 0.0, 1.0]</code>, <code>[b&#39; &#39;; 256]</code></td>
</tr>
<tr>
<td align="center"><code>Vec&lt;f64&gt;</code></td>
<td align="center">变长<code>Vector</code>，元素同类型</td>
<td align="center"><code>vec![0.367, 2.718, 7.389]</code></td>
</tr>
<tr>
<td align="center"><code>&amp;[u8],&amp;mut [u8]</code></td>
<td align="center">对<code>slice</code>的引用:对数组或<code>vector</code>的一部分的引用，包括指针和长度</td>
<td align="center"><code>&amp;v[10..20]</code>, <code>&amp;mut a[..]</code></td>
</tr>
<tr>
<td align="center"><code>Option&lt;&amp;str&gt;</code></td>
<td align="center">可选值，要么是 <code>None</code>，要么是 <code>Some(v)</code></td>
<td align="center"><code>Some(&quot;Dr.&quot;)</code>, <code>None</code></td>
</tr>
<tr>
<td align="center"><code>Result&lt;u64, Error&gt;</code></td>
<td align="center">可能失败的操作结果，成功就是 <code>Ok(v)</code>，失败则是：<code>Err(e)</code></td>
<td align="center"><code>Ok(4096)</code>, <code>Err(Error::last_os_error())</code></td>
</tr>
<tr>
<td align="center"><code>&amp;dyn Any</code>, <code>&amp;mut dyn Read</code></td>
<td align="center"><code>Trait</code>对象:引用任何实现了给定方法集的值</td>
<td align="center"><code>value as &amp;dyn Any,&amp;mut file as &amp;mut dyn Read</code></td>
</tr>
<tr>
<td align="center"><code>fn(&amp;str) -&gt; bool</code></td>
<td align="center">函数指针</td>
<td align="center"><code>str::is_empty</code></td>
</tr>
<tr>
<td align="center"><code>(Closure types have no written form)</code></td>
<td align="center">闭包</td>
<td align="center">&#96;</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>固定宽度的数字类型可能会溢出或失去精度，但它们对于大多数应用程序来说已经足够了，并且可能比任意精度整数和有理素数等表示快数千倍。如果需要这些功能，可以使用 <a href="https://crates.io/crates/num"><code>num</code></a>。<code>Rust</code> 的类型名称中包含了他们代表的宽度和用途。</p>
<table>
<thead>
<tr>
<th align="center">大小</th>
<th align="center">无符号整数</th>
<th align="center">有符号整数</th>
<th align="center">浮点数</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>8</code></td>
<td align="center"><code>u8</code></td>
<td align="center"><code>i8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>16</code></td>
<td align="center"><code>u16</code></td>
<td align="center"><code>i16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>32</code></td>
<td align="center"><code>u32</code></td>
<td align="center"><code>i32</code></td>
<td align="center"><code>f32</code></td>
</tr>
<tr>
<td align="center"><code>64</code></td>
<td align="center"><code>u64</code></td>
<td align="center"><code>i64</code></td>
<td align="center"><code>f64</code></td>
</tr>
<tr>
<td align="center"><code>128</code></td>
<td align="center"><code>u128</code></td>
<td align="center"><code>i128</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>Machine word</code></td>
<td align="center"><code>usize</code></td>
<td align="center"><code>isize</code></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><code>Rust</code> 有符号数的范围如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>i8</code></td>
<td align="left">$-2^7$ ~ $2^7 - 1$ (−128 ~ 127)</td>
</tr>
<tr>
<td align="center"><code>i16</code></td>
<td align="left">$-2^{15}$ ~ $2^{15}−1$ (−32,768 ~ 32,767)</td>
</tr>
<tr>
<td align="center"><code>i32</code></td>
<td align="left">$-2^{31}$ ~ $2^{31}−1$ (−2,147,483,648 ~ 2,147,483,647)</td>
</tr>
<tr>
<td align="center"><code>i64</code></td>
<td align="left">$-2^{63}$ ~ $2^{63}−1$  (−9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td>
</tr>
<tr>
<td align="center"><code>i128</code></td>
<td align="left">$-2^{127}$ ~ $2^{127}−1$ (roughly ${-1.7} \ast 10^{38}$ ~ $1.7 \ast 10^{38}$)</td>
</tr>
<tr>
<td align="center"><code>isize</code></td>
<td align="left">$-2^{31}$ ~ $2^{31}−1$, 或者 $-2^{63}$ ~ $2^{63}−1$</td>
</tr>
</tbody></table>
<p><code>Rust</code> 无符号数的范围如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>u8</code></td>
<td align="left">0 ~ $2^8−1$ (0 ~ 255)</td>
</tr>
<tr>
<td align="center"><code>u16</code></td>
<td align="left">0 ~ $2^{16}−1$ (0 ~ 65,535)</td>
</tr>
<tr>
<td align="center"><code>u32</code></td>
<td align="left">0 ~ $2^{32}−1$  (0 ~ 4,294,967,295)</td>
</tr>
<tr>
<td align="center"><code>u64</code></td>
<td align="left">0 ~ $2^{64}−1$  (0 ~ 18,446,744,073,709,551,615)</td>
</tr>
<tr>
<td align="center"><code>u128</code></td>
<td align="left">0 ~ $2^{128}−1$ (0 ~ around $3.4 \ast 10^{38}$)</td>
</tr>
<tr>
<td align="center"><code>usize</code></td>
<td align="left">0 ~ $2^{32}−1$, 或者 0 ~ $2^{64}−1$</td>
</tr>
</tbody></table>
<p><code>usize</code>和<code>isize</code>类型类似于<code>C</code>和<code>C++</code>中的<code>size_t</code>和<code>ptrdiff_t</code>，它们的大小和机器架构有关系，要么是 <code>32</code>位 要么是 <code>64</code>位。<code>Rust</code>要求数组索引为<code>usize</code>值，表示数组或<code>vector</code>大小或某些数据结构中元素数量计数的值通常也具有<code>usize</code>类型。</p>
<p>数字字面量可以用一个后缀表示它们的类型，例如：<code>42u8</code>，<code>1729isize</code>。如果没有类型后缀，<code>Rust</code> 会在赋值，函数调用或者比较的时候才确定其类型，也就是根据使用场景将它确定为合适的类型。最后，如果没有指定类型，并且多种类型也都可行，那么默认 <code>i32</code>，否则，就会报告错误。</p>
<p>数字字面量可以用前缀 <code>0x</code>，<code>0o</code> 或者 <code>0b</code> 表示 <code>16</code>进制，<code>8</code>进制 或者 <code>2</code>进制数值。</p>
<p>为了在表示长数字时更具可读性，可以在数字之间插入下划线 <code>_</code>。例如我们可将 <code>u32</code> 的最大值表示为 <code>4_294_967_295</code>。下划线的位置并不重要，例如，我们可以在表示<code>16</code>进制数字和<code>2</code>进制数字，以 <code> 0xffff_ffff</code> 的形式进行分割，或者用 <code>_</code> 分割数值和类型 <code>127_u8</code>。</p>
<p>在 <code>Rust</code> 中，可以将字符表示为 <code>u8</code> 类型，例如用 <code>b&#39;X&#39;</code> 表示字母 <code>X</code>，<code>65</code> 和 <code>b&#39;A&#39;</code> 是完全相等的。对于一些字符不能直接表示，需要转义：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">字面量</th>
<th align="center">等价数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单引号</td>
<td align="center"><code>b&#39;\&#39;&#39;</code></td>
<td align="center"><code>39u8</code></td>
</tr>
<tr>
<td align="center">反斜线</td>
<td align="center"><code>b&#39;\\&#39;</code></td>
<td align="center"><code>92u8</code></td>
</tr>
<tr>
<td align="center">换行键</td>
<td align="center"><code>b&#39;\n&#39;</code></td>
<td align="center"><code>10u8</code></td>
</tr>
<tr>
<td align="center">回车键</td>
<td align="center"><code>b&#39;\r&#39;</code></td>
<td align="center"><code>13u8</code></td>
</tr>
<tr>
<td align="center">水平制表符</td>
<td align="center"><code>b&#39;\t&#39;</code></td>
<td align="center"><code>9u8</code></td>
</tr>
</tbody></table>
<p>对于一些很难表示的字符，可以用<code>16</code>进制表示，形式为 <code>b&#39;\xHH&#39;</code>。例如，<code>ASCII</code> 码，<code>27</code> 代表的 <code>ESC (Escape)</code>，我们可以表示为 <code>\x1b</code>。</p>
<p>对于数值之间的类型转换，可以使用 <code>as</code> 操作符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">10_i8</span> <span class="keyword">as</span> <span class="type">u16</span>, <span class="number">10_u16</span>); <span class="comment">// in range</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">2525_u16</span> <span class="keyword">as</span> <span class="type">i16</span>, <span class="number">2525_i16</span>); <span class="comment">// in range</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(-<span class="number">1_i16</span> <span class="keyword">as</span> <span class="type">i32</span>, -<span class="number">1_i32</span>); <span class="comment">// sign-extended</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">65535_u16</span> <span class="keyword">as</span> <span class="type">i32</span>, <span class="number">65535_i32</span>); <span class="comment">// zero-extended</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Conversions that are out of range for the destination</span></span><br><span class="line"><span class="comment">// produce values that are equivalent to the original modulo 2^N, // where N is the width of the destination in bits. This</span></span><br><span class="line"><span class="comment">// is sometimes called &quot;truncation.&quot; </span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">1000_i16</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">232_u8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">65535_u32</span> <span class="keyword">as</span> <span class="type">i16</span>, -<span class="number">1_i16</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(-<span class="number">1_i8</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">255_u8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">255_u8</span> <span class="keyword">as</span> <span class="type">i8</span>, -<span class="number">1_i8</span>);</span><br></pre></td></tr></table></figure>

<p>标准库提供了很多整数操作方法，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2_u16</span>.<span class="title function_ invoke__">pow</span>(<span class="number">4</span>), <span class="number">16</span>); <span class="comment">// exponentiation</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((-<span class="number">4_i32</span>).<span class="title function_ invoke__">abs</span>(), <span class="number">4</span>); <span class="comment">// absolute value</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0b101101_u8</span>.<span class="title function_ invoke__">count_ones</span>(), <span class="number">4</span>); <span class="comment">// population count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多可以去看每个标准库每个类型的方法，例如 <a href="https://doc.rust-lang.org/std/primitive.i16.html"><code>i16</code></a>。</p>
<p>真实编码情况下，我们编码的时候一般不会写类型后缀，但是像下面这样调用方面就会报错:</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, (-<span class="number">4</span>).<span class="title function_ invoke__">abs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是：</p>
<pre><code>error[E0689]: can&#39;t call method `abs` on ambiguous numeric type `{integer}`
</code></pre>
</div>

<p>这可能会有点令人困惑：所有有符号整数类型都有 <code>abs</code>方法，那么有什么问题呢？出于技术原因，<code>Rust</code> 想知道一个值在调用该类型自己的方法之前具有哪个整数类型。<code>i32</code>的默认值只适用于在所有方法调用解决后，类型仍然不明确的情况，所以在这里已经太晚了，没有帮助。解决方案是用后缀或使用特定类型的函数来阐明打算使用哪种类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, (-<span class="number">4_i32</span>).<span class="title function_ invoke__">abs</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="type">i32</span>::<span class="title function_ invoke__">abs</span>(-<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为方法调用比一元操作符优先级高，所以我们需要将操作数用括号包括，否则 <code>-4_i32.abs()</code> 的结果将是 <code>-4</code>。</p>
<h4 id="溢出处理"><a href="#溢出处理" class="headerlink" title="溢出处理"></a>溢出处理</h4><p>当整数计算溢出时，<code>debug</code> 模式下，程序会奔溃。<code>release</code> 模式下，程序会一直运行，只是结果就不可期望了。对于下面的测试代码，我们使用两种不同的模式进行运行:</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        i *= <span class="number">10</span>; <span class="comment">// panic: debug 模式溢出崩溃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>cargo run</code> 命令时程序会崩溃（默认 <code>debug</code>），但使用 <code>cargo run --release</code> 时会一直运行。默认行为或许不是我们想要的，那么我们可以显示地表达我们的意图：</p>
<ul>
<li><p><code>checked</code> 相关的方法会检查运算结果，如果数学上是正确的，那么就是会返回 <code>Some(v)</code>，否则，会返回 <code>None</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The sum of 10 and 20 can be represented as a u8.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">10_u8</span>.<span class="title function_ invoke__">checked_add</span>(<span class="number">20</span>), <span class="title function_ invoke__">Some</span>(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unfortunately, the sum of 100 and 200 cannot.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">100_u8</span>.<span class="title function_ invoke__">checked_add</span>(<span class="number">200</span>), <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the addition; panic if it overflows.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x.<span class="title function_ invoke__">checked_add</span>(y).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Oddly, signed division can overflow too, in one particular case.</span></span><br><span class="line">    <span class="comment">// A signed n-bit type can represent -2n−1, but not 2n−1.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((-<span class="number">128_i8</span>).<span class="title function_ invoke__">checked_div</span>(-<span class="number">1</span>), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>wrapping</code> operations return the value equivalent to the mathematically correct result modulo the range of the value：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The first product can be represented as a u16;</span></span><br><span class="line">    <span class="comment">// the second cannot, so we get 250000 modulo 216.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">100_u16</span>.<span class="title function_ invoke__">wrapping_mul</span>(<span class="number">200</span>), <span class="number">20000</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">500_u16</span>.<span class="title function_ invoke__">wrapping_mul</span>(<span class="number">500</span>), <span class="number">53392</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Operations on signed types may wrap to negative values.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">500_i16</span>.<span class="title function_ invoke__">wrapping_mul</span>(<span class="number">500</span>), -<span class="number">12144</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In bitwise shift operations, the shift distance</span></span><br><span class="line">    <span class="comment">// is wrapped to fall within the size of the value.</span></span><br><span class="line">    <span class="comment">// So a shift of 17 bits in a 16-bit type is a shift</span></span><br><span class="line">    <span class="comment">// of 1.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5_i16</span>.<span class="title function_ invoke__">wrapping_shl</span>(<span class="number">17</span>), <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Saturating</code> 相关的操作在溢出时会用类型最大值表示结果：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">254_u8</span>.<span class="title function_ invoke__">saturating_add</span>(<span class="number">10</span>), <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">32760_i16</span>.<span class="title function_ invoke__">saturating_add</span>(<span class="number">10</span>), <span class="number">32767</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>((-<span class="number">32760_i16</span>).<span class="title function_ invoke__">saturating_sub</span>(<span class="number">10</span>), -<span class="number">32768</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Overflowing</code> 相关的操作会返回一个 <code>tuple(result, overflowed)</code>，其中 <code>result</code> 是 <code>wrapping</code> 将返回的内容，<code>overflowed</code> 指示是否发生了溢出：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">255_u8</span>.<span class="title function_ invoke__">overflowing_sub</span>(<span class="number">2</span>), (<span class="number">253</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">255_u8</span>.<span class="title function_ invoke__">overflowing_add</span>(<span class="number">2</span>), (<span class="number">1</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>操作名称都以下面的前缀开始：<code>checked_</code>, <code>wrapping_</code>, <code>saturating_</code>, 或者 <code>overflowing_</code>，相关的操作有：</p>
<table>
<thead>
<tr>
<th align="center">Operation</th>
<th align="center">Name suffix</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Addition</code></td>
<td align="center"><code>add</code></td>
<td align="left"><code>100_i8.checked_add(27) == Some(127)</code></td>
</tr>
<tr>
<td align="center"><code>Subtraction</code></td>
<td align="center"><code>sub</code></td>
<td align="left"><code>10_u8.checked_sub(11) == None</code></td>
</tr>
<tr>
<td align="center"><code>Multiplication</code></td>
<td align="center"><code>mul</code></td>
<td align="left"><code>128_u8.saturating_mul(3) == 255</code></td>
</tr>
<tr>
<td align="center"><code>Division</code></td>
<td align="center"><code>div</code></td>
<td align="left"><code>64_u16.wrapping_div(8) == 8</code></td>
</tr>
<tr>
<td align="center"><code>Remainde</code>r</td>
<td align="center"><code>rem</code></td>
<td align="left"><code>(-32768_i16).wrapping_rem(-1) == 0</code></td>
</tr>
<tr>
<td align="center"><code>Negation</code></td>
<td align="center"><code>neg</code></td>
<td align="left"><code>(-128_i8).checked_neg() == None</code></td>
</tr>
<tr>
<td align="center"><code>Absolute value</code></td>
<td align="center"><code>abs</code></td>
<td align="left"><code>(-32768_i16).wrapping_abs() == -32768</code></td>
</tr>
<tr>
<td align="center"><code>Exponentiation</code></td>
<td align="center"><code>pow</code></td>
<td align="left"><code>3_u8.checked_pow(4) == Some(81)</code></td>
</tr>
<tr>
<td align="center"><code>Bitwise left shift</code></td>
<td align="center"><code>shl</code></td>
<td align="left"><code>10_u32.wrapping_shl(34) == 40</code></td>
</tr>
<tr>
<td align="center"><code>Bitwise right shift</code></td>
<td align="center"><code>shr</code></td>
<td align="left"><code>40_u64.wrapping_shr(66) == 10</code></td>
</tr>
</tbody></table>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>Rust</code>提供<code>IEEE</code>单精度和双精度浮点类型。这些类型包括正负无穷大，不同的正负零值，以及非数字值。单双精度数值的范围如下：</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Precision</th>
<th align="center">Range</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>f32</code></td>
<td align="center">单精度（最少<code>6</code>位小数）</td>
<td align="center">Roughly ${–3.4} \ast 10^{38}$ ~ ${+3.4} \ast 10 ^{38}$</td>
</tr>
<tr>
<td align="center"><code>f64</code></td>
<td align="center">双精度 (最少<code>15</code>位小数)</td>
<td align="center">Roughly ${–1.8} \ast 10^{308}$ ~ ${+1.8} \ast 10^{308}$</td>
</tr>
</tbody></table>
<p><code>Rust</code> 的 <code>f32</code> 和 <code>f64</code> 对应于 <code>C</code>，<code>C++</code> 中的 <code>float</code> 和 <code>double</code>（在支持<code>IEEE</code>浮点的实现中）以及 <code>Java</code>（始终使用<code>IEEE</code>浮点）。浮点数的一般形式如下图所示：</p>
<img data-src="/2022/06/28/%E3%80%90Rust%E3%80%91%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/floating-num.png" class="">

<p>整数部分之后浮点数的每个部分都是可选的，但分数部分、指数或类型后缀至少存在一个，以将其与整数文字区分开来。小数部分可能由一个单独的小数点组成，因此<code>5.</code>是一个有效的浮点常数。下面是一些示例：</p>
<table>
<thead>
<tr>
<th align="center">Literal</th>
<th align="center">Type</th>
<th align="center">Mathematical value</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-1.5625</code></td>
<td align="center"><code>Inferred</code></td>
<td align="center">$−(1\frac{9}{16})$</td>
</tr>
<tr>
<td align="center"><code>2.</code></td>
<td align="center"><code>Inferred</code></td>
<td align="center"><code>2</code></td>
</tr>
<tr>
<td align="center"><code>0.25</code></td>
<td align="center"><code>Inferred</code></td>
<td align="center">$\frac{1}{4}$</td>
</tr>
<tr>
<td align="center"><code>1e4</code></td>
<td align="center"><code>Inferred</code></td>
<td align="center"><code>10,000</code></td>
</tr>
<tr>
<td align="center"><code>40f32</code></td>
<td align="center"><code>f32</code></td>
<td align="center"><code>40</code></td>
</tr>
<tr>
<td align="center"><code>9.109_383_56e-31f64</code></td>
<td align="center"><code>f64</code></td>
<td align="center">Roughly $9.10938356 \ast 10^{–31}$</td>
</tr>
</tbody></table>
<p><code>f32</code>和<code>f64</code>类型具有<code>IEEE</code>要求的特殊值的相关常量，如 <code>INFINITY</code>、<code>NEG_INFINITY</code>（负无穷大）、<code>NAN</code>（非数字值）以及<code>MIN</code>和<code>MAX</code>（最大和最小的有限值）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>((-<span class="number">1</span>. / <span class="type">f32</span>::INFINITY).<span class="title function_ invoke__">is_sign_negative</span>());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(-<span class="type">f32</span>::MIN, <span class="type">f32</span>::MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>f32</code> 和 <code>f64</code> 类型为数学计算关系提供了完整的方法补充；例如，<code>2f64.sqrt()</code>是<code>2</code>的双精度平方根。一些例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5f32</span>.<span class="title function_ invoke__">sqrt</span>() * <span class="number">5f32</span>.<span class="title function_ invoke__">sqrt</span>(), <span class="number">5</span>.); <span class="comment">// exactly 5.0, per IEEE</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((-<span class="number">1.01f64</span>).<span class="title function_ invoke__">floor</span>(), -<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，方法调用的优先级高于前缀运算符，因此请务必对否定值对方法调用进行校正括号。</p>
<p><code>std::f32::consts</code> 和 <code>std::f64::consts</code> 模块提供了各种常用的数学常量，如<code>E</code>、<code>PI</code>和两个的平方根。</p>
<p><strong>与<code>C</code>和<code>C++</code>不同，<code>Rust</code>几乎不隐式执行数字转换</strong>。如果函数期望<code>f64</code>类型参数，则传递<code>i32</code>值作为参数是错误的。事实上，<code>Rust</code>甚至不会隐式将<code>i16</code>值转换为<code>i32</code>值，即使每个<code>i16</code>值也是<code>i32</code>值。但始终可以使用 <code>as</code> 运算符写出显式转换：<code>i as f64</code>，或 <code>x as i32</code>。</p>
<p>缺乏隐式转换有时使<code>Rust</code>表达式比类似的<code>C</code>或<code>C++</code>代码更冗长。然而，隐式整数转换有可能导致意想不到的安全漏洞。根据经验，在 <code>Rust</code> 中显示写出数字转换提醒我们注意可能会发生的问题。</p>
<h3 id="Bool-类型"><a href="#Bool-类型" class="headerlink" title="Bool 类型"></a>Bool 类型</h3><p><code>Rust</code> 的 <code>bool</code> 类型具有 <code>true</code> 和 <code>false</code> 两个值。<code>==</code> 和 <code>&lt;</code> 等比较运算符产生 <code>bool</code> 结果：<code>2 &lt; 5</code> 的值为 <code>true</code>。</p>
<p>许多语言在需要布尔值的上下文中能使用其他类型进行自动隐式转换：<code>C</code> 和 <code>C++</code> 隐式将字符、整数、浮点数和指针转换为布尔值，因此它们可以直接用作 <code>if</code> 或 <code>while</code> 语句中的条件。<code>Python</code> 允许在布尔上下文中设置字符串、列表、字典甚至集合，如果这些值是非空的，则将其视为 <code>true</code>。但是 <code>rust</code> 非常严格，对于 <code>if</code> 和 <code>while</code> 这样的控制结构，要求其条件语句必须为 <code>bool</code> 表达式，逻辑运算符<code>&amp;&amp;</code> 和 <code>||</code> 也是如此。所以必须写 <code>if x != 0 &#123; ... &#125;</code> 而不是 <code>if x &#123; ... &#125;</code>。</p>
<p><code>Rust</code> 的 <code>as</code> 操作符可以将<code>bool</code>值转换为整形：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="literal">false</span> <span class="keyword">as</span> <span class="type">i32</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="literal">true</span> <span class="keyword">as</span> <span class="type">i32</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>但是反过来不行，<code>as</code> 不能将数字转化为 <code>bool</code>，所以，必须写显示的比较操作，例如：<code>x != 0</code>。虽然 <code>bool</code> 只需要 <code>1</code> 个 <code>bit</code> 来表示它，但 <code>Rust</code> 使用整个字节（<code>8 bit</code>）来表示内存中的 <code>bool</code> 值，因此可以创建指向它的指针，例如 <code>&amp;true</code>。</p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p><code>Rust</code> 的字符类型 <code>char</code> 表示单个<code>Unicode</code>字符，为<code>32</code>位值。<code>Rust</code> 对单个字符使用 <code>char</code> 类型，但对字符串和文本流使用 <code>UTF-8</code> 编码。因此，字符串将其文本表示为 <code>UTF-8</code> 字节序列，而不是字符数组。字符字面量可以是任何用单引号括起来的<code>Unicode</code> 字符，如<code>&#39;8&#39;</code>，<code>&#39;!&#39;</code>，<code>&#39;中&#39;</code>。</p>
<p>根据个人喜好，如果喜欢，可以用<code>16</code>进制写出任何一个字符的 <code>Unicode</code>码点：</p>
<ul>
<li><p>如果字符的代码点在<code>U+0000</code>到<code>U+007F</code>的范围（也就是<code>ASCII</code>字符），那么我们可以将字符写为<code>\xHH</code>，其中<code>HH</code>是一个两位<code>16</code>进制数字。例如，字符文字<code>*</code>和<code>\x2A</code>是等价的，因为字符<code>*</code>的代码点是<code>42</code>，或<code>16</code>进制为<code>2A</code>；</p>
</li>
<li><p>可以将任何 <code>Unicode</code> 字符写成 <code>\u&#123;HHHHHH&#125;</code>，其中 <code>HHHHHH</code> 是一个<code>16</code>进制数字，长度可达 <code>6</code> 位数，允许使用下划线分组。例如，字面字符<code>\u&#123;CA0&#125;</code>表示字符<code>ಠ</code>。</p>
</li>
</ul>
<p><code>char</code>类型能表示的 <code>Unicode</code> 字符码点在 <code>0x0000 ~ 0xD7FF</code> 或者 <code>xE000 ~ 0x10FFFF</code> 之间。<code>Rust</code> 使用类型系统和动态检查来确保字符值始终在允许范围内。</p>
<p><code>Rust</code> 永远不会在 <code>char</code> 和任何其他类型之间隐式转换。可以使用转换运算符将字符转换为整数类型；对于小于<code>32</code>位的类型，字符值的高位被截断：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;*&#x27;</span> <span class="keyword">as</span> <span class="type">i32</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;ಠ&#x27;</span> <span class="keyword">as</span> <span class="type">u16</span>, <span class="number">0xca0</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;ಠ&#x27;</span> <span class="keyword">as</span> <span class="type">i8</span>, -<span class="number">0x60</span>); <span class="comment">// U+0CA0 truncated to eight bits, signed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有就是 <code>u8</code>是唯一可以直接通过 <code>as</code> 转换为<code>char</code>的类型：但<code>u8</code>以外的每个整数类型都包含不允许的<code>Unicode</code>代码点的值，因此这些转换需要运行时检查。标准库为此提供<code>std::char::from_u32</code>接受任何<code>u32</code>值并返回<code>Option&lt;char&gt;</code>：如果<code>u32</code>不是允许的<code>Unicode</code>代码点，则<code>from_u32</code>返回<code>None</code>；否则，它会返回<code>Some(c)</code>，其中<code>c</code>是<code>char</code>值。</p>
<p>标准库提供了一些关于字符的有用方法，可以查看<a href="https://doc.rust-lang.org/std/primitive.char.html">标准库文档</a>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">is_alphabetic</span>(), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;β&#x27;</span>.<span class="title function_ invoke__">is_alphabetic</span>(), <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;8&#x27;</span>.<span class="title function_ invoke__">to_digit</span>(<span class="number">10</span>), <span class="title function_ invoke__">Some</span>(<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;ಠ&#x27;</span>.<span class="title function_ invoke__">len_utf8</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::<span class="type">char</span>::<span class="title function_ invoke__">from_digit</span>(<span class="number">2</span>, <span class="number">10</span>), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;2&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p><code>Tuple</code>形式上是一个括号围起来的，逗号分割的多元素序列。例如 <code>(&quot;Brazil&quot;, 1985)</code>，它的类型是 <code>(&amp;str, i32)</code>，如果将它赋值给变量 <code>t</code>，可以通过 <code>t.0</code> 或者 <code>t.1</code> 访问元素。</p>
<p>在某种程度上，<code>tuple</code> 很像 <code>array</code>，都表示有序的值序列。有些编程语言中将他们统一在，但是在 <code>rust</code> 中，这完全是隔离开的。主要有两大区别：</p>
<ol>
<li><code>tuple</code> 的元素类型可以不同，但是数组所有元素的类型都是相同的；</li>
<li><code>tuple</code> 只能用常量作为索引，例如 <code>t.4</code>，不能用 <code>t.i</code> 或者 <code>t[i]</code> 去访问第 <code>i</code> 个元素；</li>
</ol>
<p><code>Rust</code> 中，<code>tuple</code> 经常用于函数的多值返回，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at</span>(&amp;<span class="keyword">self</span>, mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>);</span><br></pre></td></tr></table></figure>

<p>返回值 <code>(&amp;str, &amp;str)</code> 是一个包含两个字符串<code>slice</code>的 <code>tuple</code>，可以通过模式匹配将他们赋值给不同的变量:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;I see the eigenvalue in thine eye&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> (head, tail) = text.<span class="title function_ invoke__">split_at</span>(<span class="number">21</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(head, <span class="string">&quot;I see the eigenvalue &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(tail, <span class="string">&quot;in thine eye&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这比下面的代码更具可读性：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;I see the eigenvalue in thine eye&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">temp</span> = text.<span class="title function_ invoke__">split_at</span>(<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">head</span> = temp.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tail</span> = temp.<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(head, <span class="string">&quot;I see the eigenvalue &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(tail, <span class="string">&quot;in thine eye&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另一种常用的元组类型是零元组<code>()</code>，这一般被称为单位类型，因为它只有一个值，也写成 <code>()</code>，虽然单位类型没有携带有意义的值，但某些场景仍然有意义。例如，我们可能有这样一个返回值 <code>Result&lt;(), std::io::Error&gt;</code>，它在成功时没有返回值，当出错时返回 <code>std::io::Error</code>。</p>
<p>还有就是，可以在 <code>tuple</code> 的最后一个元素后面添上逗号，但是还是同一个类型，例如 <code>(&amp;str, i32,)</code> 和 <code>(&amp;str, i32)</code> 是完全等价的。除此之外，<code>Rust</code> 在函数参数，数组，结构体或者枚举定义中都允许使用额外的逗号。</p>
<p>对于一元组，也就是只包含<code>1</code>个元素的 <code>tuple</code>，例如 <code>(&quot;lonely hearts&quot;,) </code> 它的类型是 <code>(&amp;str,)</code>，这里的逗号就是必须的，为了和括号表达式区分。</p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><code>Rust</code> 有几种代表内存地址的指针类型。</p>
<p><code>Rust</code>和大多数具有 <code>GC</code> 功能的语言之间存在巨大差别。在<code>Java</code>中，如果类矩形包含一个类型位 <code>Vector2D</code> 的字段 <code>upperLeft</code>，那么 <code>upperLeft</code> 是对另一个单独创建的 <code>Vector2D</code> 对象的引用，在<code>Java</code>中，对象永远不会实际包含其他对象。</p>
<p><code>Rust</code> 是不同的，该语言旨在帮助将内存分配保持在最低限度，对于值<code>((0，0), (1440，900)) </code>存储为<code>4</code>个相邻整数。如果将其存储在局部变量中，则有一个<code>4</code>个整数宽的局部变量。</p>
<p>这会极大提高内存的效率，但因此，当<code>Rust</code>程序需要值来指向其他值时，它必须显式使用指针类型。好消息是安全 <code>Rust</code> 中使用的指针类型受到限制，以消除未定义的行为，因此在 <code>Rust</code> 中比在 <code>C++</code> 中正确使用指针容易得多。</p>
<p>本节学习几种指针类型：<code>reference</code>，<code>box</code> 以及 <code>unsafe pointer</code>。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><code>&amp;String</code> 类型的值（发音为<code>ref String</code>）是对 <code>String</code> 值的引用，<code>&amp;i32</code> 是对 <code>i32</code> 的引用。</p>
<p>把引用看作是<code>Rust</code>的基本指针类型，是最容易入门的。在运行时，对<code>i32</code> 的引用是保存 <code>i32</code> 地址的单个机器字，该地址可能在堆栈上或堆栈中。表达式 <code>&amp;x</code> 产生对 <code>x</code> 的引用；在<code>Rust</code>术语中，我们说它借用了对 <code>x</code> 的引用。给定引用 <code>r</code>，表达式 <code>*r</code> 指的是<code>r</code> 指向的值。这些非常像<code>C</code>和<code>C++</code>中的 <code>&amp;</code> 和 <code>*</code> 运算符。</p>
<p>然而，与<code>C</code>指针不同，<code>Rust</code>引用永远不会为空：根本无法在安全的<code>Rust</code> 中生成空指针。与 <code>C</code> 不同，<code>Rust</code> 跟踪值的所有权和生命周期，因此在编译时排除了悬垂指针、重复释放等错误。</p>
<p><code>Rust</code> 有两种形式的引用：</p>
<ul>
<li><p><code>&amp;T</code>：可共享的，但不可变的引用，可以一次对给定值进行许多共享引用，但它们是只读的，不能修改它们指向的值，就像 <code>C</code> 中的 <code>const T*</code> 一样；</p>
</li>
<li><p><code>&amp;mut T</code>：可变的，但不可共享引用，可以读取和修改它指向的值，就像 <code>C</code> 中的 <code>T*</code> 一样。但只要该类型引用存在，就不会存在任何其他类型的该值引用；</p>
</li>
</ul>
<p><code>Rust</code>的共享引用和可变引用其实就是多读单写，它可以由任何数量的 <code>reader</code> 共享，但 <code>writer</code> 始终只有一个，<code>Rust</code> 在编译时就会执行这种检查，也是 <code>Rust</code> 安全的核心。</p>
<h4 id="Boxes"><a href="#Boxes" class="headerlink" title="Boxes"></a>Boxes</h4><p>在堆上申请内存的最简单方式是使用 <code>Box::new</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = (<span class="number">12</span>, <span class="string">&quot;eggs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(t); <span class="comment">// allocate a tuple in the heap</span></span><br></pre></td></tr></table></figure>

<p><code>t</code> 的类型是 <code>(i32, &amp;str)</code>，所以 <code>b</code> 的类型是 <code>Box&lt;(i32, &amp;str)&gt;</code>。<code>Box::new</code> 会在堆上申请最够多的内存以容纳 <code>t</code>。当 <code>b</code> 离开作用域时，它的内存会被理解回收，除非它被 <code>move</code> 到其他地方。</p>
<h4 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h4><p><code>Rust</code> 还具有原生指针类型 <code>*mut T</code>和 <code>*const T</code>，原生指针就像 <code>C++</code> 中的指针一样。使用原生指针不安全，因为<code>Rust</code>没有跟踪它指向的内容。例如，原生指针可能是空的，或者可能指向已释放或现在包含不同类型值的内存。</p>
<p>但是，只能在不安全的块中解引用原生指针，<code>unsafe</code> 代码块是 <code>Rust</code> 支持高级语言功能而加入的机制，其安全性由开发者保证。</p>
<h3 id="数组、Vector、slice"><a href="#数组、Vector、slice" class="headerlink" title="数组、Vector、slice"></a>数组、<code>Vector</code>、<code>slice</code></h3><p><code>Rust</code>有三种类型来表示内存中一个连续序列：</p>
<ul>
<li><p><code>[T; N]</code>：表示<code>N</code>个值数组，每个值类型为<code>T</code>。数组的大小是在编译时确定的常量，是类型的一部分，无法在运行时变更数组大小；</p>
</li>
<li><p><code>Vec&lt;T&gt;</code>：称为<code>T</code> 的 <code>vector</code>，是 <code>T</code> 类型的动态分配、变长的值序列。<code>vector</code>的元素分配在堆上，因此可以通过增删元素调整<code>vector</code>大小；</p>
</li>
<li><p><code>&amp;[T]</code>、<code>&amp;mut [T]</code>：只读序列和可变序列，是对一系列元素的引用，这些元素是其他数组或者<code>vector</code>的一部分。可以将<code>slice</code>引用视为指向其第一个元素的指针，以及从该点开始可以访问的元素数量的计数。可变<code>slice``&amp;mut [T]</code>允许读取和修改元素，但无法共享；共享<code>slice``&amp;[T]</code>允许在多个<code>reader</code>之间共享访问权限，但不允许修改元素；</p>
</li>
</ul>
<p>给定这三种类型的值<code>v</code>，表达式<code>v.len()</code>给出了<code>v</code>中的元素数量，<code>v[i]</code>指的是<code>v</code>的第<code>i</code>个元素。第一个元素是<code>v[0]</code>，最后一个元素是<code>v[v.len() - 1]</code>。<code>Rust</code> 会检查 <code>i</code> 是否在这个范围内，不在就会<code>panic</code>。<code>v</code> 的长度可能是<code>0</code>，在这种情况下，任何索引尝试都会<code>panic</code>。<code>i</code> 必须是一个 <code>usize</code> 值，不能使用其他整数类型作为索引。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>下面有几种不同的方式创建数组，最简单的是在方括号内写一系列值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lazy_caterer</span>: [<span class="type">u32</span>; <span class="number">6</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">16</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">taxonomy</span> = [<span class="string">&quot;Animalia&quot;</span>, <span class="string">&quot;Arthropoda&quot;</span>, <span class="string">&quot;Insecta&quot;</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(lazy_caterer[<span class="number">3</span>], <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(taxonomy.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要初始化一个 <code>N</code> 个 <code>V</code> 的数组，可以写作 <code>[V; N]</code>，例如，<code>[true; 10000]</code> 表示有 <code>10000</code> 个 <code>true</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sieve</span> = [<span class="literal">true</span>; <span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">2</span>..<span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sieve[i] &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">j</span> = i * i;</span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="number">10000</span> &#123;</span><br><span class="line">                sieve[j] = <span class="literal">false</span>;</span><br><span class="line">                j += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert!</span>(sieve[<span class="number">211</span>]);</span><br><span class="line">    <span class="built_in">assert!</span>(!sieve[<span class="number">9876</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Rust</code> 不会自动对内存进行初始化，因为不允许我们读未初始化的变量。所以如果我们想初始化一个缓冲池，可以像这样做：<code>[0u8; 1024]</code>。</p>
<p>数组的长度是其类型的一部分，在编译时是固定的。如果 <code>n</code> 是一个变量，则无法编写 <code>[true; n]</code> 来获取 <code>n</code> 个元素的数组。当需要一个长度在运行时有所不同的数组，请使用<code>vector</code>。</p>
<p>数组上看到的一些常用方法，例如，迭代、搜索、排序、填充、过滤等，其实都是作为<code>slice</code>上的方法提供的，而不是数组。但是，在搜索方法时，<code>Rust</code> 会隐式地将对数组的引用转换为<code>slice</code>，因此可以直接调用数组上的任何<code>slice</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chaos</span>=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    chaos.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(chaos, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，排序方法实际上是在<code>slice</code>上定义的，但由于它需要引用做引参数，<code>Rust</code> 隐式生成一个引用整个数组的 <code>&amp;mut [i32]</code> <code>slice</code>,<code>len</code> 也类似。</p>
<h4 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a><code>Vectors</code></h4><p><code>Vec&lt;T&gt;</code>是分配给堆上的<code>T</code>类型的大小可调整的数组。这里有几种创建 <code>vector</code> 的方式</p>
<ol>
<li>最简单的使用 <code>vec!</code> 宏，它给了一个特像创建数组字面量的方式；</li>
<li><code>vec![0; 100]</code>，类似数组的初始化语法，将 <code>vector</code> 中的值都初始化相同的元素，<code>vec!</code> 宏类似于调用 <code>Vec::new</code>；</li>
<li>从迭代器创建；</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 类似数组字面量的方式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">primes</span> = <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(primes.<span class="title function_ invoke__">iter</span>().product::&lt;<span class="type">i32</span>&gt;(), <span class="number">210</span>);</span><br><span class="line">    primes.<span class="title function_ invoke__">push</span>(<span class="number">11</span>);</span><br><span class="line">    primes.<span class="title function_ invoke__">push</span>(<span class="number">13</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(primes.<span class="title function_ invoke__">iter</span>().product::&lt;<span class="type">i32</span>&gt;(), <span class="number">30030</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用类似数组初始化的方式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf</span> = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10</span> * <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从迭代器创建</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">0</span>..<span class="number">5</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>collect</code> 时，通常需要提供该目的类型，因为它可以构建许多不同类型的集合，而不仅仅是 <code>vector</code>。通过指定 <code>v</code> 的类型，我们明确了我们想要哪种集合。</p>
<p>和数组一样，可以在 <code>vector</code> 上使用<code>slice</code>方法，<code>reverse</code> 方法调用时会隐式转换为 <code>&amp;mut [&amp;str]</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// A palindrome!</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">palindrome</span> = <span class="built_in">vec!</span>[<span class="string">&quot;a man&quot;</span>, <span class="string">&quot;a plan&quot;</span>, <span class="string">&quot;a canal&quot;</span>, <span class="string">&quot;panama&quot;</span>];</span><br><span class="line">    palindrome.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">    <span class="comment">// Reasonable yet disappointing:</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(palindrome, <span class="built_in">vec!</span>[<span class="string">&quot;panama&quot;</span>, <span class="string">&quot;a canal&quot;</span>, <span class="string">&quot;a plan&quot;</span>, <span class="string">&quot;a man&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Vec</code> 是 <code>Rust</code> 的基本类型，几乎在需要动态大小列表的地方都可以使用，因此还有许多其他方法来构建新 <code>vector</code> 或扩展现有 <code>vector</code>。<code>Vec</code> 实际上由三部分组成：</p>
<ol>
<li>指向堆内存的指针；</li>
<li>缓冲区的容量，最大能存储多少元素，超过就需要扩容，创建新的缓冲区，更改指针指向，复制当前所有的元素，释放旧的缓冲区；</li>
<li>当前实际存储的元素数量；</li>
</ol>
<p><code>vector</code> 扩容会导致程序性能下降，如果一开始就知道 <code>vector</code> 的大小，可以使用 <code>Vec::with_capacity</code> 创建指定大小的 <code>vector</code>，许多库函数使用<code>Vec::with_capacity</code> 创建新的 <code>vector</code>。<code>len</code> 方法返回了当前元素数量，<code>capacity</code> 返回 <code>vector</code> 的容量:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">len</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">capacity</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">capacity</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// Typically prints &quot;capacity is now 4&quot;:</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;capacity is now &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">capacity</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后打印的容量不能保证正好是<code>4</code>，但它至少是<code>3</code>，因为 <code>vector</code> 包含<code>3</code>个值。可以在 <code>vector</code> 中插入和删除元素，但这些操作会将受影响的所有元素向前或向后移动，因此如果 <code>vector</code> 很长，它们可能会变慢：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="comment">// Make the element at index 3 be 35.</span></span><br><span class="line">    v.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>, <span class="number">35</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">50</span>]);</span><br><span class="line">    <span class="comment">// Remove the element at index 1.</span></span><br><span class="line">    v.<span class="title function_ invoke__">remove</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">10</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">50</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>pop</code> 方法删除最后一个元素并返回它。更准确地说，从 <code>Vec&lt;T&gt;</code> 弹出一个值返回 <code>Option&lt;T&gt;</code>，因为如果 <code>vector</code> 已经为空，则返回 <code>None</code>，如果其最后一个元素是 <code>v</code>，则返回<code>Some(v)</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&quot;Snow Puff&quot;</span>, <span class="string">&quot;Glass Gem&quot;</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Glass Gem&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Snow Puff&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">pop</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>for</code> 循环迭代 <code>vector</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">languages</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">l</span> <span class="keyword">in</span> languages &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, l,</span><br><span class="line">                 <span class="keyword">if</span> l.<span class="title function_ invoke__">len</span>() % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                     <span class="string">&quot;functional&quot;</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="string">&quot;imperative&quot;</span></span><br><span class="line">                 &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下图:</p>
<pre><code>~/WORKDIR/rust/mandelbrot ⌚ 10:10:03
$ cargo run Lisp Scheme C C++ Fortran
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/mandelbrot Lisp Scheme C C++ Fortran`
Lisp, functional
Scheme, functional
C, imperative
C++, imperative
Fortran, imperative
</code></pre>
<h4 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a><code>Slices</code></h4><p><code>slice</code>的类型是 <code>[T]</code>，没有指定长度，是一个数组或者 <code>vector</code> 的一部分。由于<code>slice</code>可以是任何长度，<code>slice</code>不能直接存储在变量中或作为函数参数传递，参数或者变量的大小必须在编译时就能确定占用空间的大小，必须实现 <a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a>，因此<code>slice</code>总是通过引用传递。</p>
<p><code>slice</code>的指针是一个 <code>胖指针</code>，包含了两部分信息：指向的第一个元素地址和包含的元素数量。对于下面这两行代码，<code>Rust</code> 会自动转换 <code>&amp;Vec&lt;f64&gt;</code> 和 <code>&amp;[f64; 4]</code> 到 <code>&amp;[f64]</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0.0</span>, <span class="number">0.707</span>, <span class="number">1.0</span>, <span class="number">0.707</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">f64</span>; <span class="number">4</span>] = [<span class="number">0.0</span>, -<span class="number">0.707</span>, -<span class="number">1.0</span>, -<span class="number">0.707</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sv</span>: &amp;[<span class="type">f64</span>] = &amp;v;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sa</span>: &amp;[<span class="type">f64</span>] = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存分布图，可以展示为下面这样：</p>
<img data-src="/2022/06/28/%E3%80%90Rust%E3%80%91%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/slice-memory-figure.png" class="">

<p>普通指针是指向单个值，而 <code>slice</code> 是指向内存中一系列连续值。可以编写一个参数是 <code>slice</code> 的函数，这样既能处理数组，也能处理 <code>vector</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0.0</span>, <span class="number">0.707</span>, <span class="number">1.0</span>, <span class="number">0.707</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">f64</span>; <span class="number">4</span>] = [<span class="number">0.0</span>, -<span class="number">0.707</span>, -<span class="number">1.0</span>, -<span class="number">0.707</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sv</span>: &amp;[<span class="type">f64</span>] = &amp;v;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sa</span>: &amp;[<span class="type">f64</span>] = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;a); <span class="comment">// works on arrays</span></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;v); <span class="comment">// works on vectors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(n: &amp;[<span class="type">f64</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">elt</span> <span class="keyword">in</span> n &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, elt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于此函数将<code>slice</code>指针作为参数，因此可以将其应用于<code>vector</code>或数组，其实标准库中许多属于<code>vector</code>或数组的方法都是在<code>slice</code>上定义。例如，<code>sort</code> 和 <code>reverse</code>，实际上是<code>slice</code>类型 <code>[T]</code> 上的方法。</p>
<p>我们可以引用数组，<code>vector</code> 或者已有 <code>slice</code> 的部分：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0.0</span>, <span class="number">0.707</span>, <span class="number">1.0</span>, <span class="number">0.707</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">f64</span>; <span class="number">4</span>] = [<span class="number">0.0</span>, -<span class="number">0.707</span>, -<span class="number">1.0</span>, -<span class="number">0.707</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sv</span>: &amp;[<span class="type">f64</span>] = &amp;v;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_sa</span>: &amp;[<span class="type">f64</span>] = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;a); <span class="comment">// works on arrays</span></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;v); <span class="comment">// works on vectors</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;v[<span class="number">0</span>..<span class="number">2</span>]); <span class="comment">// print the first two elements of v</span></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;a[<span class="number">2</span>..]); <span class="comment">// print elements of a starting with a[2]</span></span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;sv[<span class="number">1</span>..<span class="number">3</span>]); <span class="comment">// print v[1] and v[2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(n: &amp;[<span class="type">f64</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">elt</span> <span class="keyword">in</span> n &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, elt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与普通数组访问一样，<code>Rust</code> 检查索引是否有效。正常情况下，总是使用<code>slice</code>的指针，就像 <code>&amp;[T]</code> 或者 <code>&amp;str</code>。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>熟悉 <code>C++</code> 的程序员会记得有两种字符串类型，字符串字面量具有指针类型 <code>const char *</code>。标准库还提供了一个类 <code>std::string</code>，用于在运行时动态创建字符串，<code>Rust</code> 也有类似的设计。本节中，将展示编写字符串文字的所有方法，然后介绍 <code>Rust</code> 的两种字符串类型。</p>
<h4 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h4><p>字符串文字以双引号括起来，可以使用转义符 <code>\</code> 对特殊字符进行转义，字符串字面量中 <code>&quot;</code> 需要转义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">speech</span> = <span class="string">&quot;\&quot;Ouch!\&quot; said the well.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>字符串可以跨多行存在，该字符串文字中的换行符包含在字符串中，因此也包含在输出中。第二行开头的空格也是如此：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;In the room the women come and go, </span></span><br><span class="line"><span class="string">    Singing of Mount Abora&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果字符串的一行以反斜杠 <code>\</code> 结尾，则删除下一行的换行符和前缀空格：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It was a bright, cold day in April, and \</span></span><br><span class="line"><span class="string">        there were four of us—\</span></span><br><span class="line"><span class="string">        more or less.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It was a bright, cold day in April, and</span></span><br><span class="line"><span class="string">        there were four of us—</span></span><br><span class="line"><span class="string">        more or less.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<pre><code>/Users/fudenglong/.cargo/bin/cargo run --color=always --package mandelbrot --bin mandelbrot
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/mandelbrot`
It was a bright, cold day in April, and there were four of us—more or less.
It was a bright, cold day in April, and
        there were four of us—
        more or less.
</code></pre>
<p>对于以 <code>r</code> 开头的原始字符串，其中的所有反斜杠和空格字符都逐字包含在字符串中，所以没法写转义字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">default_win_install_path</span> = <span class="string">r&quot;C:\Program Files\Gorillas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> <span class="variable">pattern</span> = Regex::<span class="title function_ invoke__">new</span>(<span class="string">r&quot;\d+(\.\d+)*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当然也有办法，例如，以 <code>r###&quot;</code>开始，和以 <code>&quot;###</code>结束。可以根据需要添加多个 <code>#</code> 符号：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">r###&quot;</span></span><br><span class="line"><span class="string">        This raw string started with &#x27;r###&quot;&#x27;.</span></span><br><span class="line"><span class="string">        Therefore it does not end until we reach a quote mark (&#x27;&quot;&#x27;)</span></span><br><span class="line"><span class="string">        followed immediately by three pound signs (&#x27;###&#x27;):</span></span><br><span class="line"><span class="string">&quot;###</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节序列"><a href="#字节序列" class="headerlink" title="字节序列"></a>字节序列</h4><p>带有 <code>b</code> 前缀的字符串是一个字节字符串。这样的字符串是<code>u8</code>值（即字节）的<code>slice</code>，而不是<code>Unicode</code>文本：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">method</span> = <span class="string">b&quot;GET&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(method, &amp;[<span class="string">b&#x27;G&#x27;</span>, <span class="string">b&#x27;E&#x27;</span>, <span class="string">b&#x27;T&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>method</code> 的类型是 <code>&amp;[u8; 3]</code>，是一个对拥有<code>3</code>个字节的数组的引用。他不能使用字符串的相关方法，只是看起来和字符串字面量比较像。</p>
<p>字节字符串可以使用我们展示的所有其他字符串语法：它们可以跨多行，使用转义序列，并使用反斜杠连接行。原始字节字符串以<code>br</code>开头。</p>
<p>字节字符串不能包含任意的<code>Unicode</code>字符，他们必须处理<code>ASCII</code>和<code>\xHH</code>转义序列。</p>
<h4 id="字符串内存表示"><a href="#字符串内存表示" class="headerlink" title="字符串内存表示"></a>字符串内存表示</h4><p><code>Rust</code>字符串是<code>Unicode</code>字符的序列，但它们不会作为字符数组存储在内存中。相反，它们使用可变宽度编码<code>UTF-8</code>存储。字符串中的每个<code>ASCII</code>字符都存储在一个字节中，其他字符占用多个字节。</p>
<p>对于下面的示例：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">noodles</span> = <span class="string">&quot;noodles&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">oodles</span> = &amp;noodles[<span class="number">1</span>..];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">poodles</span> = <span class="string">&quot;ಠ_ಠ&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, noodles);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, oodles);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, poodles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>noodles</code>：类型是 <code>String</code>，包含 <code>Unicode</code> 文本，拥有大小可变的缓冲区，能根据需要调整大小，在堆中分配内存；</li>
<li><code>oodles</code>： 类型是 <code>&amp;str</code>，引用 <code>UTF8</code> 文本的一部分。在这里，它引用 <code>noodles</code> 的后<code>6</code>个字符。和其他的<code>slice</code>引用一样，<code>&amp;str</code> 是个胖指针，包含了第一个元素的地址和元素数量；</li>
<li><code>poodles</code>：类型是 <code>&amp;str</code>，引用到预申请的文本，存储值只读内存中，也就是二进制文件的只读段中，<code>poodles</code>只是指向这段内存；</li>
</ul>
<p>它们的内存分布关系图如下：</p>
<img data-src="/2022/06/28/%E3%80%90Rust%E3%80%91%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/str-memory-figure.png" class=""></div>

<p>要注意的是 <code>String</code> 或者 <code>&amp;str</code> 的 <code>len</code> 方法返回的是字节的长度而不是字符的长度：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;ಠ_ಠ&quot;</span>.<span class="title function_ invoke__">len</span>(), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;ಠ_ಠ&quot;</span>.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改变 <code>&amp;str</code> 是不可能的：</p>
<details class="note danger"><summary><p>错误示例</p>
</summary>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// error: `&amp;str` cannot be modified, and other reasons</span></span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;\n&#x27;</span>); <span class="comment">// error: no method named `push` found for reference `&amp;str`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>如果要在运行时创建字符串，使用 <code>String</code>。类型 <code>&amp;mut str</code> 确实存在，但它不是很有用，因为<code>UTF-8</code>上的几乎任何操作都可以更改其整体字节长度，并且<code>slice</code>不能对它引用的值重新分配内存。事实上，<code>&amp;mut str</code>上唯一可用的操作是 <code>make_ascii_uppercase</code> 和 <code>make_ascii_lowercase</code>，根据定义，它们就地修改字符，只影响单个字节字符。</p>
<h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a><code>String</code></h4><p><code>&amp;str</code> 非常像 <code>&amp;[T]</code>：指向数据的胖指针，<code>String</code> 类似于 <code>Vec&lt;T&gt;</code>。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center"><code>Vec&lt;T&gt;</code></th>
<th align="center"><code>&lt;String&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Automatically frees buffers</code></td>
<td align="center"><code>Yes</code></td>
<td align="center"><code>Yes</code></td>
</tr>
<tr>
<td align="left"><code>Growable</code></td>
<td align="center"><code>Yes</code></td>
<td align="center"><code>Yes</code></td>
</tr>
<tr>
<td align="left"><code>::new()and::with_capacity()type-associated functions</code></td>
<td align="center"><code>Yes</code></td>
<td align="center"><code>Yes</code></td>
</tr>
<tr>
<td align="left"><code>.reserve() and .capacity() methods</code></td>
<td align="center"><code>Yes</code></td>
<td align="center"><code>Yes</code></td>
</tr>
<tr>
<td align="left"><code>.push() and .pop() methods</code></td>
<td align="center"><code>Yes</code></td>
<td align="center"><code>Yes</code></td>
</tr>
<tr>
<td align="left"><code>Range syntaxv[start..stop]</code></td>
<td align="center"><code>Yes, returns &amp;[T]</code></td>
<td align="center"><code>Yes, returns &amp;str </code></td>
</tr>
<tr>
<td align="left"><code>Automatic conversion</code></td>
<td align="center"><code>&amp;Vec&lt;T&gt; to &amp;[T]</code></td>
<td align="center"><code>&amp;String to &amp;str </code></td>
</tr>
<tr>
<td align="left"><code>Inherits methods</code></td>
<td align="center"><code>From &amp;[T]</code></td>
<td align="center"><code>From &amp;str</code></td>
</tr>
</tbody></table>
<p>与<code>Vec</code>一样，每个字符串都有自己的堆内存缓冲区，不会与任何其他字符串共享。当字符串变量超出范围时，缓冲区会自动释放，除非字符串被移动。下面是几种创建 <code>String</code> 的方式：</p>
<ul>
<li><p><code>.to_string()</code>：转换 <code>&amp;str</code> 为 <code>String</code>，转换时会复制字符串：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">error_message</span> = <span class="string">&quot;too many pets&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>format!()</code>：格式化产生字符串，返回 <code>String</code> 类型的字符串</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;°&#123;:02&#125;′&#123;:02&#125;′′N&quot;</span>, <span class="number">24</span>, <span class="number">5</span>, <span class="number">23</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串数组，<code>slice</code>或者 <code>vector</code> 有两个方法，<code>.concat()</code> 和 <code>.join(sep)</code> 产生新的 <code>String</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bits</span> = <span class="built_in">vec!</span>[<span class="string">&quot;veni&quot;</span>, <span class="string">&quot;vidi&quot;</span>, <span class="string">&quot;vici&quot;</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(bits.<span class="title function_ invoke__">concat</span>(), <span class="string">&quot;venividivici&quot;</span>); </span><br><span class="line"><span class="built_in">assert_eq!</span>(bits.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>), <span class="string">&quot;veni, vidi, vici&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符串使用"><a href="#字符串使用" class="headerlink" title="字符串使用"></a>字符串使用</h4><p>字符串支持 <code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code> 以及 <code>&gt;=</code> 运算符等很多非常有用的方法，可以在<a href="https://doc.rust-lang.org/std/primitive.str.html">这里</a> 找到标准库中支持的方法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="string">&quot;ONE&quot;</span>.<span class="title function_ invoke__">to_lowercase</span>() == <span class="string">&quot;one&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="string">&quot;peanut&quot;</span>.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;nut&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;ಠ_ಠ&quot;</span>.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;ಠ&quot;</span>, <span class="string">&quot;■&quot;</span>), <span class="string">&quot;■_■&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot; clean\n&quot;</span>.<span class="title function_ invoke__">trim</span>(), <span class="string">&quot;clean&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> <span class="string">&quot;veni, vidi, vici&quot;</span>.<span class="title function_ invoke__">split</span>(<span class="string">&quot;, &quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(word.<span class="title function_ invoke__">starts_with</span>(<span class="string">&quot;v&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，鉴于<code>Unicode</code>的性质，简单的逐个字符比较并不总是给出预期的答案。例如，<code>Rust</code> 字符串<code>th\u&#123;e9&#125;</code>和<code>the\u&#123;301&#125;</code> 都是 <code>thé</code> 的有效<code>Unicode</code>表示，<code>thé</code> 是法语单词<code>tea</code>。<code>Unicode</code>表示，它们应该以相同的方式显示和处理，但<code>Rust</code>将它们视为两个完全不同的字符串。同样，像<code>&lt;</code>这样的<code>Rust</code>的排序运算符使用基于字符代码点的简单词典顺序，这种排序有时只类似于用户语言和文化中用于文本的排序。</p>
<h4 id="其他-String"><a href="#其他-String" class="headerlink" title="其他 String"></a>其他 <code>String</code></h4><p><code>Rust</code>保证字符串是有效的<code>UTF-8</code>。有时，程序真的需要能够处理无效的<code>Unicode</code>字符串。当<code>Rust</code>程序必须与其他不执行任何此类规则的系统互操作时，通常会发生这种情况。例如，在大多数操作系统中，很容易创建具有非<code>Unicode</code>文件名的文件。当<code>Rust</code>程序遇到这种文件名时，<code>Rust</code>的解决方案是为这些情况提供几种字符串类型：</p>
<ul>
<li>坚持使用<code>String</code>和<code>&amp;str</code>获取<code>Unicode</code>文本；</li>
<li>在处理文件名时，请使用<code>std::path::PathBuf</code>和<code>&amp;Path</code>；</li>
<li>在处理完二进制数据时，请使用<code>Vec&lt;u8&gt;</code>和<code>&amp;[u8]</code>；</li>
<li>在处理操作系统的环境变量名称和命令行参数时，请使用<code>OsString</code>和<code>&amp;OsStr</code>；</li>
<li>当与使用空终止字符串的<code>C</code>库互操作时，请使用<code>std::ffi::CString</code>和<code>&amp;CStr</code>；</li>
</ul>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><code>type</code> 关键字可以像 <code>C++</code> 中的 <code>typedef</code> 一样用于为现有类型声明新名称，我们在这里声明的字节类型是这种特殊 <code>Vec</code> 的缩写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Bytes</span> = <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">decode</span>(data: &amp;Bytes) &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>基础类型</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】字符串和文本</title>
    <url>/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<p><code>Unicode</code> 和 <code>ASCII</code> 匹配所有 <code>ASCII</code> 字符，从 <code>0</code> 到 <code>0x7f</code>。例如，都将字符 <code>*</code> 分配给码点 <code>42</code>。类似地，<code>Unicode</code> 将 <code>0</code> 到 <code>0xff</code> 分配给与 <code>ISO/IEC 8859-1</code> 字符集相同的字符，用于西欧语言的 <code>8</code> 位 <code>ASCII</code> 超集。<code>Unicode</code> 将此码点范围称为 <code>Latin-1</code> 代码块。</p>
<p>因为 <code>Unicode</code> 是 <code>Latin-1</code> 的超集，所以从 <code>Latin-1</code> 转换到 <code>Unicode</code> 是完全允许的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">latin1_to_char</span>(latin1: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    latin1 <span class="keyword">as</span> <span class="type">char</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设码点在 <code>Latin-1</code> 范围内，反向转换也很简单：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">char_to_latin1</span>(c: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">as</span> <span class="type">u32</span> &lt;= <span class="number">0xff</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(c <span class="keyword">as</span> <span class="type">u8</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 中 <code>String</code> 和 <code>str</code> 类型都是使用 <code>UTF-8</code> 编码格式，它是一种变长编码，使用<code>1</code>到<code>4</code>个字节对字符进行编码。有效的 <code>UTF-8</code> 序列有两个限制。首先，对于任何给定码点，只有最短的编码被认为是有效的，也就是不能花费<code>4</code>个字节来编码一个适合<code>3</code>个字节的码点。 此规则确保给定代码点只有一个 <code>UTF-8</code> 编码。其次，有效的 <code>UTF-8</code> 不得编码为 <code>0xd800</code> 到 <code>0xdfff</code> 或超过 <code>0x10ffff</code> 的数字：这些数字要么保留用于非字符目的，要么完全超出 <code>Unicode</code> 的范围。</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/utf8-example.png" class="">

<span id="more"></span>

<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p><code>Rust</code> 中使用一个 <code>32</code> 位值存储 <code>Unicode</code> 码点，<code>char</code> 保证落在 <code>0</code> 到 <code>0xd7ff</code> 或 <code>0xe000</code> 到 <code>0x10ffff</code> 的范围内，所有用于创建和操作 <code>char</code> 值的方法都确保这个规则。<code>char</code> 类型实现了 <code>Copy</code> 和 <code>Clone</code>，以及用于比较、<code>hash</code> 和格式化的所有常用 <code>Trait</code>。</p>
<p>例如，通过 <code>&amp;str</code> 获得字符序列：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">&quot;カニ&quot;</span>.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;カ&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>下表是一些常用的字符类型的分类方法：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/char-classfication.png" class="">

<p>下标是一些专门用于 <code>ASCII</code> 字符的方法：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/char-ascii-method.png" class="">

<p>所有的 <code>is_ascii_</code> 开头的方法在 <code>u8</code> 类型上都是可用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(<span class="number">32u8</span>.<span class="title function_ invoke__">is_ascii_whitespace</span>());</span><br><span class="line"><span class="built_in">assert!</span>(<span class="string">b&#x27;9&#x27;</span>.<span class="title function_ invoke__">is_ascii_digit</span>());</span><br></pre></td></tr></table></figure>

<p>在使用这些函数来实现现有规范时要小心，因为分类可能不同。例如 <code>is_whitespace</code> 和 <code>is_ascii_whitespace</code> 在对某些字符的处理上有所不同：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">line_tab</span> = &#x27;\u&#123;<span class="number">000</span>b&#125;&#x27;; <span class="comment">// &#x27;line tab&#x27;, AKA &#x27;vertical tab&#x27;</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(line_tab.<span class="title function_ invoke__">is_whitespace</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(line_tab.<span class="title function_ invoke__">is_ascii_whitespace</span>(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>因为 <code>is_ascii_whitespace</code> 实现了 <code>web</code> 标准的空白字符，而 <code>is_whitespace</code> 实现了 <code>Unicode</code> 标准的字符。</p>
<h4 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h4><p>下面是一些用于处理数字的方法：</p>
<ul>
<li><p><code>ch.to_digit(radix)</code>：转换成 <code>radix</code> 进制数字，返回 <code>Some(num)</code>，<code>num</code> 是 <code>u32</code> 类型；</p>
</li>
<li><p><code>std::char::from_digit(num, radix)</code>：从数字转换成字符，返回 <code>Some(ch)</code>；</p>
</li>
<li><p><code>ch.is_digit(radix)</code>：判断字符是否是一个 <code>ASCII</code> 数字，等价于 <code>ch.to_digit(radix) != None</code>；</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;F&#x27;</span>.<span class="title function_ invoke__">to_digit</span>(<span class="number">16</span>), <span class="title function_ invoke__">Some</span>(<span class="number">15</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::<span class="type">char</span>::<span class="title function_ invoke__">from_digit</span>(<span class="number">15</span>, <span class="number">16</span>), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;f&#x27;</span>));</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="type">char</span>::<span class="title function_ invoke__">is_digit</span>(<span class="string">&#x27;f&#x27;</span>, <span class="number">16</span>));</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="type">char</span>::<span class="title function_ invoke__">is_digit</span>(<span class="string">&#x27;8&#x27;</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><ul>
<li><p><code>ch.is_lowercase()</code>、<code> ch.is_uppercase()</code>：判断字符是否是一个小写或者大写字母；</p>
</li>
<li><p><code>ch.to_lowercase()</code>、<code>ch.to_uppercase()</code>：转换成小写或者大小可迭代字符序列，根据 <code>Unicode</code> 大小写转换算法；</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">upper</span> = <span class="string">&#x27;s&#x27;</span>.<span class="title function_ invoke__">to_uppercase</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(upper.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;S&#x27;</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(upper.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>  这些方法返回一个迭代器而不是单个字符，因为 <code>Unicode</code> 中不是一对一转换：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The uppercase form of the German letter &quot;sharp S&quot; is &quot;SS&quot;:</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">upper</span> = <span class="string">&#x27;ß&#x27;</span>.<span class="title function_ invoke__">to_uppercase</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(upper.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;S&#x27;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(upper.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;S&#x27;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(upper.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="comment">// Unicode says to lowercase Turkish dotted capital &#x27;İ&#x27; to &#x27;i&#x27;</span></span><br><span class="line">    <span class="comment">// followed by `&#x27;\u&#123;307&#125;&#x27;`, COMBINING DOT ABOVE, so that a</span></span><br><span class="line">    <span class="comment">// subsequent conversion back to uppercase preserves the dot.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ch</span> = <span class="string">&#x27;İ&#x27;</span>; <span class="comment">// `&#x27;\u&#123;130&#125;&#x27;`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lower</span> = ch.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(lower.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;i&#x27;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(lower.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&#x27;\u&#123;<span class="number">307</span>&#125;&#x27;));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(lower.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  为了方便，这些迭代器实现了 <code>std::fmt::Display</code>。</p>
</li>
</ul>
<h4 id="与数字之间的转换"><a href="#与数字之间的转换" class="headerlink" title="与数字之间的转换"></a>与数字之间的转换</h4><p>使用 <code>as</code> 操作符可以将字符转换成整数，高位字节可能会被删除：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">&#x27;B&#x27;</span> <span class="keyword">as</span> <span class="type">u32</span>, <span class="number">66</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">&#x27;饂&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">66</span>); <span class="comment">// upper bits truncated</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">&#x27;二&#x27;</span> <span class="keyword">as</span> <span class="type">i8</span>, -<span class="number">116</span>); <span class="comment">// same</span></span><br></pre></td></tr></table></figure>

<p><code>u8</code> 可以转换成 <code>char</code>，<code>char</code> 也实现了 <code>From&lt;u8&gt;</code>。但是更宽的字符可能代表无效的字符，所以必须使用 <code>std::char::from_u32</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="type">char</span>::<span class="title function_ invoke__">from</span>(<span class="number">66</span>), <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(std::<span class="type">char</span>::<span class="title function_ invoke__">from_u32</span>(<span class="number">0x9942</span>), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;饂&#x27;</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(std::<span class="type">char</span>::<span class="title function_ invoke__">from_u32</span>(<span class="number">0xd800</span>), <span class="literal">None</span>); <span class="comment">// reserved for UTF-16</span></span><br></pre></td></tr></table></figure>

<h3 id="String、str"><a href="#String、str" class="headerlink" title="String、str"></a><code>String</code>、<code>str</code></h3><p><code>Rust</code> 的 <code>String</code> 和 <code>str</code> 类型保证只保存有效的 <code>UTF-8</code>。通过限制可以创建 <code>String</code> 和 <code>str</code> 值的方式以及可以对它们执行的操作来确保这一点，这样这些值在引入时有效并在使用它们时保持不变。他们所有的方法都保护了这一保证：对它们的任何安全操作都不会引入无效的 <code>UTF-8</code>，这简化了处理文本的代码。</p>
<p><code>Rust</code> 将文本处理方法放置在 <code>str</code> 或 <code>String</code> 上，具体取决于该方法是否需要可调整大小的缓冲区或内容只是为了使用适当的文本。由于 <code>String</code> 解引用就是 <code>&amp;str</code>，因此在 <code>str</code> 上定义的每个方法也可以直接在 <code>String</code> 上使用。</p>
<p><code>String</code> 被实现为 <code>Vec&lt;u8&gt;</code> 的包装器，以确保 <code>vector</code> 的内容总是有效的 <code>UTF-8</code>。</p>
<p>下表包含后续的解释中用到的词汇：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/string0-explaination.png" class="">

<h4 id="创建-String"><a href="#创建-String" class="headerlink" title="创建 String"></a>创建 <code>String</code></h4><ul>
<li><p><code>String::new()</code>：返回新的空字符串，没有堆内存申请；</p>
</li>
<li><p><code>String::with_capacity(n)</code>：返回新的，预申请 <code>n</code> 字节的字符串；</p>
</li>
<li><p><code>str_slice.to_string()</code>：重新申请一个新的 <code>String</code>，它的整个内容都是字符串切片，例如：<code>&quot;literal text&quot;.to_string()</code>；</p>
</li>
<li><p><code>iter.collect()</code>：通过连接迭代器 <code>item</code> 创建 <code>String</code>，例如：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spacey</span> = <span class="string">&quot;man hat tan&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaceless</span>: <span class="type">String</span> =</span><br><span class="line">spacey.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">filter</span>(|c| !c.<span class="title function_ invoke__">is_whitespace</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(spaceless, <span class="string">&quot;manhattan&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.to_owned()</code>：Returns a copy of slice as a freshly allocated String. The str type cannot implement Clone: the trait would require clone on a &amp;str to return a str value, but str is unsized. However, &amp;str does implement ToOwned, which lets the implementer specify its owned equivalent.</p>
</li>
</ul>
<h4 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h4><p>这些方法能获取字符串基本信息：</p>
<ul>
<li><p><code>slice.len()</code>：字符串字节长度；</p>
</li>
<li><p><code>slice.is_empty()</code>：即 <code>slice.len() == 0</code>；</p>
</li>
<li><p><code>slice[range]</code>：返回给定部分的切片，有界和无界范围都可以，例如：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">full</span> = <span class="string">&quot;bookkeeping&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;full[..<span class="number">4</span>], <span class="string">&quot;book&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;full[<span class="number">5</span>..], <span class="string">&quot;eeping&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;full[<span class="number">2</span>..<span class="number">4</span>], <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(full[..].<span class="title function_ invoke__">len</span>(), <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(full[<span class="number">5</span>..].<span class="title function_ invoke__">contains</span>(<span class="string">&quot;boo&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  不能通过括号单个索引字符，必须要先将字符串转换成 <code>Unicode</code> 字符序列，然后进行迭代：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">full</span> = <span class="string">&quot;你好啊&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(full.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;你&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.split_at(i)</code>：返回 <code>(slice[..i], slice[i..])</code> 这样的 <code>tuple</code>；</p>
</li>
<li><p><code>slice.is_char_boundary(i)</code>：返回 <code>true</code> 如果 <code>i</code> 是一个字符的边界，这样他就可以作为 <code>slice</code> 的边界；</p>
</li>
</ul>
<p>自然地，可以比较切片的相等性、排序和散列。有序比较只是将字符串视为 <code>Unicode</code> 代码点序列，并按字典顺序比较它们。</p>
<h4 id="追加、插入"><a href="#追加、插入" class="headerlink" title="追加、插入"></a>追加、插入</h4><ul>
<li><p><code>string.push(ch)</code>：插入单个字符 <code>ch</code> 到字符串；</p>
</li>
<li><p><code>string.push_str(slice)</code>：追加 <code>slice</code> 的全部内容；</p>
</li>
<li><p><code>string.extend(iter)</code>：将迭代器产生的所有 <code>item</code> 追加到 <code>String</code>，迭代器可以产生 <code>char</code>，<code>str</code> 或者 <code>String</code>，这些都被 <code>String</code> 实现：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">also_spaceless</span> = <span class="string">&quot;con&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">also_spaceless.<span class="title function_ invoke__">extend</span>(<span class="string">&quot;tri but ion&quot;</span>.<span class="title function_ invoke__">split_whitespace</span>());</span><br><span class="line"><span class="built_in">assert_eq!</span>(also_spaceless, <span class="string">&quot;contribution&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>string.insert(i, ch)</code>：插入一个单个的字符在 <code>i</code> 字节处，这会涉及字符串的向后移动；</p>
</li>
<li><p><code>string.insert_str(i, slice)</code>：在 <code>i</code> 字节处插入一个 <code>slice</code>；</p>
</li>
</ul>
<p><code>String</code> 实现了 <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Write.html"><code>std::fmt::Write</code></a>，这就意味着 <code>write!</code> 和 <code>writeln!</code> 可以被用来向 <code>String</code> 中追加格式化文本：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::fmt::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Write;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">letter</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">writeln!</span>(letter, <span class="string">&quot;Whose &#123;&#125; these are I think I know&quot;</span>, <span class="string">&quot;rutabagas&quot;</span>)?;</span><br><span class="line">    <span class="built_in">writeln!</span>(letter, <span class="string">&quot;His house is in the village though;&quot;</span>)?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        letter,</span><br><span class="line">        <span class="string">&quot;Whose rutabagas these are I think I know\n\</span></span><br><span class="line"><span class="string">His house is in the village though;\n&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>String</code> 实现了 <code>Add&lt;&amp;str&gt;</code> 和 <code>AddAssign&lt;&amp;str&gt;</code>，所以你可以使用 <code>+</code> 和 <code>+=</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">left</span> = <span class="string">&quot;partners&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = <span class="string">&quot;crime&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(left + <span class="string">&quot; in &quot;</span> + &amp;right, <span class="string">&quot;partners in crime&quot;</span>);</span><br><span class="line">    right += <span class="string">&quot; doesn&#x27;t pay&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(right, <span class="string">&quot;crime doesn&#x27;t pay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是左操作数不能是 <code>&amp;str</code>，所以下面的写法是不可以的：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">parenthetical</span> = <span class="string">&quot;(&quot;</span> + string + <span class="string">&quot;)&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>而是应该这样写：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">parenthetical</span> = <span class="string">&quot;(&quot;</span>.<span class="title function_ invoke__">to_string</span>() + &amp;string + <span class="string">&quot;)&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>但是，不鼓励从末尾向后构建字符串。字符串的行为方式与向量相同，当它需要更多容量时，它的缓冲区大小总是至少翻倍。这使重新复制开销与最终大小成正比。即便如此，使用  <code>String::with_capacity</code> 创建具有正确缓冲区大小的字符串可以完全避免调整大小，并且可以减少重新的内存分配。</p>
<h4 id="删除、替换"><a href="#删除、替换" class="headerlink" title="删除、替换"></a>删除、替换</h4><p><code>String</code> 有一些删除文本的方法，这个不会影响字符串容量，如果需要可以使用 <code> shrink_to_fit</code>：</p>
<ul>
<li><p><code>string.clear()</code>：重置 <code>String</code> 称为空的；</p>
</li>
<li><p><code>string.truncate(n)</code>：丢掉 <code>n</code> 字节后的所有字符如果原来的字符串就少于 <code>n</code>，不做任何操作；</p>
</li>
<li><p><code>string.pop()</code>：删除字符串中最后一个字符，返回 <code>Option&lt;char&gt;</code>；</p>
</li>
<li><p><code>string.remove(i)</code>：从 <code>String</code> 中删除 <code>i</code> 字节偏移的字符并且返回；</p>
</li>
<li><p><code>string.drain(range)</code>：删除指定范围的资费并且返回，后面的字符会前移：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">choco</span> = <span class="string">&quot;chocolate&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(choco.<span class="title function_ invoke__">drain</span>(<span class="number">3</span>..<span class="number">6</span>).collect::&lt;<span class="type">String</span>&gt;(), <span class="string">&quot;col&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(choco, <span class="string">&quot;choate&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>  如果你仅仅是想去删除区间内的字符，可以立即丢掉返回的迭代器：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">winston</span> = <span class="string">&quot;Churchill&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    winston.<span class="title function_ invoke__">drain</span>(<span class="number">2</span>..<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(winston, <span class="string">&quot;Chill&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  
</code></pre>
</li>
<li><p><code>string.replace_range(range, replacement)</code>：用给定的替换字符串切片替换字符串中的给定范围。切片的长度不必与被替换的范围相同，但除非被替换的范围到达字符串的末尾，否则将需要移动范围末尾之后的所有字节：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">beverage</span> = <span class="string">&quot;a piña colada&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    beverage.<span class="title function_ invoke__">replace_range</span>(<span class="number">2</span>..<span class="number">7</span>, <span class="string">&quot;kahlua&quot;</span>); <span class="comment">// &#x27;ñ&#x27; is two bytes!</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(beverage, <span class="string">&quot;a kahlua colada&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="搜索模式"><a href="#搜索模式" class="headerlink" title="搜索模式"></a>搜索模式</h4><p>当标准库函数需要搜索、匹配、拆分或修剪文本时，它接受几种不同的类型来表示要查找的内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">haystack</span> = <span class="string">&quot;One fine day, in the middle of the night&quot;</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(haystack.<span class="title function_ invoke__">find</span>(<span class="string">&#x27;,&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">12</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(haystack.<span class="title function_ invoke__">find</span>(<span class="string">&quot;night&quot;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">35</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(haystack.<span class="title function_ invoke__">find</span>(<span class="type">char</span>::is_whitespace), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>这些类型叫做 <code>pattern</code>，大多数操作都支持它们：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(</span><br><span class="line">    <span class="string">&quot;## Elephants&quot;</span>.<span class="title function_ invoke__">trim_start_matches</span>(|ch: <span class="type">char</span>| ch == <span class="string">&#x27;#&#x27;</span> || ch.<span class="title function_ invoke__">is_whitespace</span>()),</span><br><span class="line">    <span class="string">&quot;Elephants&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>标准库支持四种类型的模式：</p>
<ol>
<li><p><code>char</code> 类型作为字符匹配的模式；</p>
</li>
<li><p><code>String</code>，<code>&amp;str</code> 或者 <code>&amp;&amp;str</code> 匹配等于它们表示的一个子串；</p>
</li>
<li><p><code>FnMut(char) -&gt; bool</code> 使用闭包匹配单个的字符；</p>
</li>
<li><p><code>&amp;[char]</code> 匹配任何出现在 <code>char</code> 列表中的字符，如果使用数组字面量，需要使用 <code>as_ref</code> 进行类型转换：</p>
<pre><code> <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">code</span> = <span class="string">&quot;\t function noodle() &#123; &quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        code.<span class="title function_ invoke__">trim_start_matches</span>([<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>].<span class="title function_ invoke__">as_ref</span>()),</span><br><span class="line">        <span class="string">&quot;function noodle() &#123; &quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Shorter equivalent: &amp;[&#x27; &#x27;, &#x27;\t&#x27;][..]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>而在库代码中，<code>pattern</code> 是任何实现了 <a href="https://doc.rust-lang.org/stable/std/str/pattern/trait.Pattern.html"><code>std::str::pattern::Pattern</code></a> 的类型，该类型目前还是实验性质，所以为避免引起兼容性问题，不要为自己的类型实现。</p>
<h4 id="搜索、替换"><a href="#搜索、替换" class="headerlink" title="搜索、替换"></a>搜索、替换</h4><p><code>Rust</code> 提供了几种方法用于<code>slice</code>模式搜索以及替换：</p>
<ul>
<li><p><code>slice.contains(pattern)</code>：如果 <code>slice</code> 包含指定模式，返回 <code>true</code>；</p>
</li>
<li><p><code>slice.starts_with(pattern), slice.ends_with(pattern)</code>：<code>slice</code> 是否以某个 <code>pattern</code> 为前缀或者后缀；</p>
</li>
<li><p><code>slice.find(pattern), slice.rfind(pattern)</code>：返回 <code>Some(i)</code> 表示 <code>slice</code> 包含指定的模式，<code>i</code> 是偏移量，<code>find</code> 找到最后一个匹配的，而 <code>rfind</code> 找到最后一个匹配的：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quip</span> = <span class="string">&quot;We also know there are known unknowns&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(quip.<span class="title function_ invoke__">find</span>(<span class="string">&quot;know&quot;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(quip.<span class="title function_ invoke__">rfind</span>(<span class="string">&quot;know&quot;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">31</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(quip.<span class="title function_ invoke__">find</span>(<span class="string">&quot;ya know&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(quip.<span class="title function_ invoke__">rfind</span>(<span class="type">char</span>::is_uppercase), <span class="title function_ invoke__">Some</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>slice.replace(pattern, replacement)</code>：替换所有匹配 <code>pattern</code> 子串：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="string">&quot;The only thing we have to fear is fear itself&quot;</span>.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;fear&quot;</span>, <span class="string">&quot;spin&quot;</span>),</span><br><span class="line">        <span class="string">&quot;The only thing we have to spin is spin itself&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="string">&quot;`Borrow` and `BorrowMut`&quot;</span>.<span class="title function_ invoke__">replace</span>(|ch: <span class="type">char</span>| !ch.<span class="title function_ invoke__">is_alphanumeric</span>(), <span class="string">&quot;&quot;</span>),</span><br><span class="line">        <span class="string">&quot;BorrowandBorrowMut&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>  <code>.replace()</code> 在重叠匹配上的行为可能有点怪，在这里，模式<code>&quot;aba&quot;</code>有四个实例，但在替换第一个和第三个后，第二个和第四个不再匹配：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">&quot;cabababababbage&quot;</span>.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;aba&quot;</span>, <span class="string">&quot;***&quot;</span>), <span class="string">&quot;c***b***babbage&quot;</span>)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>slice.replacen(pattern, replacement, n)</code>：和前者相同，但是至多替换 <code>n</code> 次；</p>
</li>
</ul>
<h4 id="文本迭代"><a href="#文本迭代" class="headerlink" title="文本迭代"></a>文本迭代</h4><p>标准库提供了几种迭代文本的方式，例如：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/string-iter.png" class="">

<p>大多数这些方法返回的迭代器是可反转的，也就是实现了 <code>DoubleEndedIterator</code>：</p>
<ul>
<li><p><code>slice.chars()</code>：返回包含 <code>slice</code> 中所有字符的迭代器；</p>
</li>
<li><p><code>slice.char_indices()</code>：返回 <code>slice</code> 中所有字符的字节的偏移量；</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="string">&quot;élan&quot;</span>.<span class="title function_ invoke__">char_indices</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            (<span class="number">0</span>, <span class="string">&#x27;é&#x27;</span>), <span class="comment">// has a two-byte UTF-8 encoding</span></span><br><span class="line">            (<span class="number">2</span>, <span class="string">&#x27;l&#x27;</span>),</span><br><span class="line">            (<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">            (<span class="number">4</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>  这个和 <code>.chars().enumerate()</code> 不等价。</p>
</li>
<li><p><code>slice.bytes()</code>：返回切片各个字节的迭代器：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(</span><br><span class="line">    <span class="string">&quot;élan&quot;</span>.<span class="title function_ invoke__">bytes</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">195</span>, <span class="number">169</span>, <span class="string">b&#x27;l&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;n&#x27;</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>slice.lines()</code>：以 <code>\n</code> 或者 <code>\r\n</code> 分割字符，返回一个 <code>&amp;str</code> 的迭代器；</p>
</li>
<li><p><code>slice.split(pattern)</code>：由匹配 <code>pattern</code> 的子串进行分割，如果模式是 <code>&amp;str</code>，返回的迭代器是不可反转的；</p>
</li>
<li><p><code>slice.rsplit(pattern)</code>：方法是相同的，只是从右至左扫描；</p>
</li>
<li><p><code>slice.split_terminator(pattern), slice.rsplit_terminator(pattern)</code>：模式被视为终止符，而不是分隔符，如果模式在切片的最后匹配，迭代器不会产生一个空切片，例如：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The &#x27;:&#x27; characters are separators here. Note the final &quot;&quot;.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="string">&quot;jimb:1000:Jim Blandy:&quot;</span>.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;:&#x27;</span>).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="string">&quot;jimb&quot;</span>, <span class="string">&quot;1000&quot;</span>, <span class="string">&quot;Jim Blandy&quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// The &#x27;\n&#x27; characters are terminators here.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="string">&quot;127.0.0.1 localhost\n\</span></span><br><span class="line"><span class="string">127.0.0.1 www.reddit.com\n&quot;</span></span><br><span class="line">            .<span class="title function_ invoke__">split_terminator</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="string">&quot;127.0.0.1 localhost&quot;</span>, <span class="string">&quot;127.0.0.1 www.reddit.com&quot;</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Note, no final &quot;&quot;!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>slice.splitn(n, pattern), slice.rsplitn(n, pattern)</code>：限定最左分割成 <code>n</code> 个 <code>slice</code>；</p>
</li>
<li><p><code>slice.split_whitespace(), slice.split_ascii_whitespace()</code>：通过 <code>Unicode</code> 定义的空格和 <code>ASCII</code> 空格来分割字符串：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">poem</span> = <span class="string">&quot;This is just to say\n\</span></span><br><span class="line"><span class="string">I have eaten\n\</span></span><br><span class="line"><span class="string">the plums\n\</span></span><br><span class="line"><span class="string">again\n&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        poem.<span class="title function_ invoke__">split_whitespace</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;just&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;say&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;eaten&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;plums&quot;</span>, <span class="string">&quot;again&quot;</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>slice.matches(pattern)</code>：返回切片中匹配 <code>pattern</code> 的迭代器，<code>slice.rmatches(pattern)</code> 是相同的，但从右往左迭代；</p>
</li>
<li><p><code>slice.match_indices(pattern), slice.rmatch_indices(pattern)</code>：返回 <code>(offset, match)</code> 对，<code>offset</code> 是匹配到的 <code>match</code> 开始字节偏移量；</p>
</li>
</ul>
<h4 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a><code>Trim</code></h4><p>修剪字符串是从字符串的开头或结尾删除文本，通常是空格。 </p>
<ul>
<li><p><code>slice.trim()</code>：返回删除了前后空格的子串，<code>slice.trim_start()</code> 和 <code>slice.trim_end()</code> 仅删除前或后空格：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;\t*.rs &quot;</span>.<span class="title function_ invoke__">trim</span>(), <span class="string">&quot;*.rs&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;\t*.rs &quot;</span>.<span class="title function_ invoke__">trim_start</span>(), <span class="string">&quot;*.rs &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;\t*.rs &quot;</span>.<span class="title function_ invoke__">trim_end</span>(), <span class="string">&quot;\t*.rs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>slice.trim_matches(pattern)</code>：删除 <code>slice</code> 前后匹配 <code>pattern</code> 的子串，<code>trim_start_matches</code> 和 <code>trim_end_matches</code> 仅作用于前面或者后面：</p>
<pre><code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">&quot;001990&quot;</span>.<span class="title function_ invoke__">trim_start_matches</span>(<span class="string">&#x27;0&#x27;</span>), <span class="string">&quot;1990&quot;</span>);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="转换成其他类型"><a href="#转换成其他类型" class="headerlink" title="转换成其他类型"></a>转换成其他类型</h4><p>如果一个类型实现了 <code>std::str::FromStr</code>，那么它就提供了一个标准的方式可以从字符串生成它的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FromStr</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Err</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_str</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::<span class="literal">Err</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有常用的机器类型都实现了 <code>FromStr</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">usize</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;3628800&quot;</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">3628800</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">f64</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;128.5625&quot;</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">128.5625</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">bool</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;true&quot;</span>), <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="type">f64</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;not a float at all&quot;</span>).<span class="title function_ invoke__">is_err</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="type">bool</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;TRUE&quot;</span>).<span class="title function_ invoke__">is_err</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>char</code> 也实现了 <code>FromStr</code>，但是只针对哪些只包含一个字符的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="type">char</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;é&quot;</span>), <span class="title function_ invoke__">Ok</span>(<span class="string">&#x27;é&#x27;</span>));</span><br><span class="line"><span class="built_in">assert!</span>(<span class="type">char</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;abcdefg&quot;</span>).<span class="title function_ invoke__">is_err</span>());</span><br></pre></td></tr></table></figure>

<p><a href="https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html"><code>std::net::IpAddr</code></a> 也实现了 <code>FromStr</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;AddrParseError, IpAddr&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AddrParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = IpAddr::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;fe80::0000:3ea9:f4ff:fe34:7a50&quot;</span>)?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        address,</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">from</span>([<span class="number">0xfe80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x3ea9</span>, <span class="number">0xf4ff</span>, <span class="number">0xfe34</span>, <span class="number">0x7a50</span>])</span><br><span class="line">    );</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串切片有一个 <code>parse</code> 方法，可以将切片解析为想要的任何类型，只要它实现了 <code>FromStr</code>，但是需要拼出所需的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">address</span> = <span class="string">&quot;fe80::0000:3ea9:f4ff:fe34:7a50&quot;</span>.parse::&lt;IpAddr&gt;()?;</span><br></pre></td></tr></table></figure>

<h4 id="从其他类型转换"><a href="#从其他类型转换" class="headerlink" title="从其他类型转换"></a>从其他类型转换</h4><p>这有三种方式转换非文本值到字符串：</p>
<ul>
<li><p>对于实现了 <code>std::fmt::Display</code> 的类型，可以使用 <code>format!</code> 通过 <code>&#123;&#125;</code> 格式符来构建字符串：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AddrParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="string">&quot;fe80::0000:3ea9:f4ff:fe34:7a50&quot;</span>.parse::&lt;IpAddr&gt;()?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, wow&quot;</span>, <span class="string">&quot;doge&quot;</span>), <span class="string">&quot;doge, wow&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="literal">true</span>), <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(&#123;:.3&#125;, &#123;:.3&#125;)&quot;</span>, <span class="number">0.5</span>, <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(<span class="number">3.0</span>) / <span class="number">2.0</span>),</span><br><span class="line">        <span class="string">&quot;(0.500, 0.866)&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Using `address` from above.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted_addr</span>: <span class="type">String</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, address);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(formatted_addr, <span class="string">&quot;fe80::3ea9:f4ff:fe34:7a50&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  所有 <code>Rust</code> 的数字类型，字符以及字符串都实现了 <code>Display</code>，智能指针 <code>Box&lt;T&gt;, Rc&lt;T&gt;, Arc&lt;T&gt;</code> 在 <code>T</code> 实现 <code>Display</code> 时也会实现 <code>Display</code>，<code>Vec</code> 和 <code>HashMap</code> 没有实现 <code>Display</code>。</p>
</li>
<li><p>如果一个类型实现了 <code>Display</code>，那么他就会自动实现 <code>std::str::ToString</code>，可以通过调用 <code>.to_string()</code> 达到目的：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(address.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;fe80::3ea9:f4ff:fe34:7a50&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准库里面的导出类型都实现了 <code>std::fmt::Debug</code>，可以通过 <code>&#123;:?&#125;</code> 格式声明生成字符串：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AddrParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="string">&quot;fe80::0000:3ea9:f4ff:fe34:7a50&quot;</span>.parse::&lt;IpAddr&gt;()?;</span><br><span class="line">    <span class="comment">// Continued from above.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addresses</span> = <span class="built_in">vec!</span>[address, IpAddr::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;192.168.0.1&quot;</span>)?];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, addresses),</span><br><span class="line">        <span class="string">&quot;[fe80::3ea9:f4ff:fe34:7a50, 192.168.0.1]&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  对于任何实现了 <code>Debug</code> 的 <code>T</code>，<code>Vec&lt;T&gt;</code> 也实现了 <code>Debug</code>，所有 <code>Rust</code> 集合类型都有这样的实现。可以通过派生为自己的类型实现 <code>Debug</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123; re: <span class="type">f64</span>, im: <span class="type">f64</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="借用为其他类型"><a href="#借用为其他类型" class="headerlink" title="借用为其他类型"></a>借用为其他类型</h4><ul>
<li><p>切片和字符串实现 <code>AsRef&lt;str&gt;</code>、<code>AsRef&lt;[u8]&gt;</code>、<code>AsRef&lt;Path&gt;</code> 和 <code>AsRef&lt;OsStr&gt;</code>。许多标准库函数使用这些<code>Trait</code>作为其参数类型的界限，因此可以直接将切片和字符串传递给它们，即使它们真正想要的是其他类型，详细请查看 <a href="/2022/04/29/%E3%80%90Rust%E3%80%91%E5%B8%B8%E7%94%A8-Trait/#asref-asmut">AsRef、AsMut</a>；</p>
</li>
<li><p><code>slice</code> 和字符串也实现了 <code>std::borrow::Borrow&lt;str&gt;</code>，<code>HashMap</code> 和 <code>BTreeMap</code> 使用 <code>Borrow</code> 使 <code>String</code> 可以很好地作为表中的键工作，详细请查看 <a href="/2022/04/29/%E3%80%90Rust%E3%80%91%E5%B8%B8%E7%94%A8-Trait/#borrow-borrowmut">Borrow、BorrowMut</a>。</p>
</li>
</ul>
<h4 id="转化为字节序列"><a href="#转化为字节序列" class="headerlink" title="转化为字节序列"></a>转化为字节序列</h4><ul>
<li><p><code>slice.as_bytes()</code>：将 <code>slice</code> 转换为 <code>&amp;[u8]</code>，由于这不是一个可变引用，所以 <code>slice</code> 可以假设它的字节将保持有效的 <code>UTF-8</code>。</p>
</li>
<li><p><code>string.into_bytes()</code>：获取 <code>String</code> 的所有权，并且转换为 <code>Vec&lt;u8&gt;</code>，这是一种廉价的转换，因为它只是将字符串一直用作其缓冲区的 <code>Vec&lt;u8&gt;</code> 交出。由于字符串不再存在，因此无法再确保是正确的 <code>UTF-8</code> 编码，调用者可以随意修改 <code>Vec&lt;u8&gt;</code>。</p>
</li>
</ul>
<h4 id="从字节序列生成"><a href="#从字节序列生成" class="headerlink" title="从字节序列生成"></a>从字节序列生成</h4><p>这里有一些方法从字节序列转换成 <code>String</code> 或者 <code>slice</code>，取决于你如何处理错误：</p>
<ul>
<li><p><code>str::from_utf8(byte_slice)</code>：以 <code>&amp;[u8]</code> 作为输入，返回 <code>Result</code>，如果正确将生成 <code>Ok(&amp;str)</code>；</p>
</li>
<li><p><code>String::from_utf8(vec)</code>：尝试去构建字符串从 <code>Vec&lt;u8&gt;</code>，如果转化成功，返回 <code>Ok(String)</code>，并且将 <code>Vec</code> 中缓冲区的所有权转移至 <code>String</code>，以至于没有额外的内存申请。如果转换失败，返回 <code>Err(e)</code>，<code>e</code> 的类型是 <code>FromUtf8Error</code>，可以调用 <code>e.into_bytes()</code> 获得原 <code>vec</code> 的所有权：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">good_utf8</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0xe9</span>, <span class="number">0x8c</span>, <span class="number">0x86</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(good_utf8).<span class="title function_ invoke__">ok</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;錆&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bad_utf8</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0x9f</span>, <span class="number">0xf0</span>, <span class="number">0xa6</span>, <span class="number">0x80</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(bad_utf8);</span><br><span class="line">    <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">is_err</span>());</span><br><span class="line">    <span class="comment">// Since String::from_utf8 failed, it didn&#x27;t consume the original</span></span><br><span class="line">    <span class="comment">// vector, and the error value hands it back to us unharmed.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        result.<span class="title function_ invoke__">unwrap_err</span>().<span class="title function_ invoke__">into_bytes</span>(),</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="number">0x9f</span>, <span class="number">0xf0</span>, <span class="number">0xa6</span>, <span class="number">0x80</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String::from_utf8_lossy(byte_slice)</code>：尝试从 <code>&amp;[u8]</code> 共享字节片构造字符串或 <code>&amp;str</code>。此转换始终成功，将任何无效的 <code>UTF-8</code> 替换为 <code>Unicode</code> 替换字符。返回值是一个 <a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html"><code>Cow&lt;str&gt;</code></a>，如果它包含有效的 <code>UTF-8</code>，则直接从 <code>byte_slice</code> 借用 <code>&amp;str</code>，或者拥有一个新分配的字符串，其中替换字符替换了无效的字节。 因此，当 <code>byte_slice</code> 有效时，不会发生堆分配或复制。</p>
</li>
<li><p><a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.from_utf8_unchecked"><code>String::from_utf8_unchecked</code></a>：如果知道 <code>Vec&lt;u8&gt;</code> 包含有效的 <code>UTF-8</code>，那么可以调用 <code>unsafe</code> 函数。这只是将 <code>Vec&lt;u8&gt;</code> 包装为一个字符串并返回它，根本不检查字节，开发者有责任确保你没有将无效的 <code>UTF-8</code> 引入系统，这就是为什么这个函数被标记为不安全的原因。</p>
</li>
<li><p><a href="https://doc.rust-lang.org/stable/std/str/fn.from_utf8_unchecked.html"><code>str::from_utf8_unchecked</code></a>：类似地，这需要一个 <code>&amp;[u8]</code> 并将其作为 <code>&amp;str</code> 返回，而不检查它是否包含有效的 <code>UTF-8</code>。</p>
</li>
</ul>
<h4 id="延迟分配"><a href="#延迟分配" class="headerlink" title="延迟分配"></a>延迟分配</h4><p>来看一个示例：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;USER&quot;</span>) <span class="comment">// Windows uses &quot;USERNAME&quot;</span></span><br><span class="line">    .<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;whoever you are&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数要求返回一个 <code>String</code>，但是实际上它应该返回一个 <code>String</code> 或一个静态文本，我们没必要为静态文本 <code>&amp;&#39;static str</code> 再次分配内存把它转换成 <code>String</code> 返回。这个时候应该使用 <a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a>，<code>Cow&lt;&#39;a, T&gt;</code> 是一个有两种变体的枚举：<code>Owned</code> 和 <code>Borrowed</code>。 <code>Borrowed</code> 持有引用 <code>&amp;&#39;a T</code>，<code>Owned</code> 能将持有的 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#impl-ToOwned"><code>&amp;str</code> 转换为 <code>String</code></a>，<code>&amp;[i32]</code> 转换为 <code>Vec&lt;i32&gt;</code>，依此类推。无论是 <code>Owned</code> 还是 <code>Borrowed</code>，<code>Cow&lt;&#39;a, T&gt;</code> 总能产生一个 <code>&amp;T</code> 供你使用。事实上，<code>Cow&lt;&#39;a, T&gt;</code> 解引用 <code>&amp;T</code> 很像智能指针。</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_name</span>() <span class="punctuation">-&gt;</span> Cow&lt;<span class="symbol">&#x27;static</span>, <span class="type">str</span>&gt; &#123;</span><br><span class="line">    std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|v| Cow::<span class="title function_ invoke__">Owned</span>(v))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(<span class="string">&quot;whoever you are&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>Cow</code> 经常用于字符串，标准库对 <code>Cow&lt;&#39;a, str&gt;</code> 有一些特殊的支持。它提供了来自 <code>String</code> 和 <code>&amp;str</code> 的 <code>From</code> 和 <code>Into</code> 转换，因此可以更简洁地编写 <code>get_name</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_name</span>() <span class="punctuation">-&gt;</span> Cow&lt;<span class="symbol">&#x27;static</span>, <span class="type">str</span>&gt; &#123;</span><br><span class="line">    std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|v| v.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;whoever you are&quot;</span>.<span class="title function_ invoke__">into</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Cow</code> 也实现了 <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#impl-Add%3C%26%27a%20str%3E"><code>Add&lt;&amp;&#39;a str&gt;</code></a>，<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#impl-Add%3CCow%3C%27a%2C%20str%3E%3E"><code>Add&lt;Cow&lt;&#39;a str&gt;&gt;</code></a>，<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#impl-AddAssign%3C%26%27a%20str%3E"><code>AddAsign&lt;&amp;&#39;a str&gt;</code></a>以及<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#impl-AddAssign%3CCow%3C%27a%2C%20str%3E%3E"><code>AddAssign&lt;Cow&lt;&#39;a, str&gt;&gt;</code></a> 所以可以使用 <code>+</code> 和 <code>+=</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(title) = <span class="title function_ invoke__">get_title</span>() &#123;</span><br><span class="line">    name += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    name += title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-Default"><a href="#实现-Default" class="headerlink" title="实现 Default"></a>实现 <code>Default</code></h4><p><code>String</code> 是下了 <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>std::default::Default</code></a> 和 <a href="https://doc.rust-lang.org/std/iter/trait.Extend.html"><code>std::iter::Extend</code></a>：返回空的字符串，以及追加字符，<code>&amp;[str]</code>，<code>Cow&lt;.., str&gt;</code>或者其他字符串。这与 Rust 的其他集合类型（如 <code>Vec</code> 和 <code>HashMap</code>）实现的特征组合相同，用于通用构造模式（如 <code>collect</code> 和 <code>partition</code>）。</p>
<p><code>&amp;str</code> 也实现了 <code>Default</code>，返回空切片。</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><code>Rust</code> 的格式化工具被设计为开放式的。 可以通过实现 <code>std::fmt</code> 模块的格式化特征来扩展这些宏以支持自己的类型。可以使用 <code>format_args！</code> 宏和 <code>std::fmt::Arguments</code> 类型以使自己的函数和宏支持格式化语言。</p>
<p>格式化宏总是借用对其参数的共享引用，他们从不获取所有权或改变它们。</p>
<p><code>&#123;...&#125;</code> 叫做格式化参数，形式是：<code>&#123;which:how&#125;</code>，<code>which</code> 和 <code>how</code> 都可以省略，<code>&#123;&#125;</code> 是我们常用的格式。</p>
<p><code>which</code> 用于指定应该使用模板后面的哪个参数，格式化参数中没有 <code>&#123;&#125;</code> 就会简单的从左到右按序取。</p>
<p><code>how</code> 用来表示参数如何被格式化，填充多少、精度、数字基数等等。 如果 <code>how</code> 存在，则它前面的<code>:</code>是必需的。</p>
<p>下面是一些常用的例子：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/format-exmaple.png" class="">

<h4 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h4><p>对于 <code>String</code> 或者 <code>&amp;str</code> 类型，<code>how</code> 参数的值有几个部分，都是可选的：</p>
<ol>
<li><p>文本长度限制。如果声明，超过这个长度的文本就会被截断；</p>
</li>
<li><p>最小字段宽度。在任何截断之后，如果你的参数比这个短，<code>Rust</code> 会在右边（默认）用空格（默认）填充它，以形成这个宽度的字段。如果省略，<code>Rust </code>不会填充；</p>
</li>
<li><p>对齐方式。可以通过 <code>&lt; ^ &gt;</code> 声明位左对齐，中对齐，右对齐；</p>
</li>
<li><p>填充字符，如果省略，会自动使用空格；如果声明填充字符，必须声明对齐方式；</p>
</li>
</ol>
<p>文本格式化示例：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/text-format-exmaple.png" class="">

<p><code>Rust</code> 的格式化程序假设每个字符占据一列，而不考虑组合字符、全角半角、零宽度空格或 <code>Unicode</code> 的其他现实。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:4&#125;&quot;</span>, <span class="string">&quot;th\u&#123;e9&#125;&quot;</span>), <span class="string">&quot;th\u&#123;e9&#125; &quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:4&#125;&quot;</span>, <span class="string">&quot;the\u&#123;301&#125;&quot;</span>), <span class="string">&quot;the\u&#123;301&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>尽管 <code>Unicode</code> 说这些字符串都等价于 <code>thé</code>，但 <code>Rust</code> 的格式化程序并不知道像 <code>\u&#123;301&#125;</code> 这样的字符，结合了重音符号需要特殊处理。 它正确地填充了第一个字符串，但假定第二个字符串是四列宽并且不添加任何填充。尽管很容易看出 <code>Rust</code> 在这种特定情况下如何改进，但所有 <code>Unicode</code> 脚本的真正多语言文本格式化是一项艰巨的任务，最好依靠平台的用户界面工具包来处理。有一个流行的包 <a href="https://crates.io/crates/unicode-width">unicode-width</a>，可以处理这方面的某些方面。</p>
<p>就像 <code>&amp;str</code> 和 <code>String</code>，还可以传递带有文本引用的格式化宏智能指针类型，例如 <code>Rc&lt;String&gt;</code> 或 <code>Cow&lt;&#39;a, str&gt;</code>。</p>
<p>由于文件名路径不一定是有效的 <code>UTF-8</code>，<code>std::path::Path</code> 不是一个文本类型；不能将 <code>std::path::Path</code> 直接传递给格式化宏。但是，<code>Path</code> 的 <code>display</code> 方法返回一个值，可以以适合平台的方式格式化它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;processing file: &#123;&#125;&quot;</span>, path.<span class="title function_ invoke__">display</span>());</span><br></pre></td></tr></table></figure>

<h4 id="数值格式化"><a href="#数值格式化" class="headerlink" title="数值格式化"></a>数值格式化</h4><p><code>Rust</code> 提供了用于格式化数字的方式：</p>
<ol>
<li>类似于文本的填充和对齐方式；</li>
<li><code>+</code> 显示有数值的正负号；</li>
<li><code>#</code> 要求显示的前缀 <code>0x</code>、<code>0b</code> 或者 <code>0o</code>；</li>
<li><code>0</code> 要求通过在数字中包含前导<code>0</code>来满足最小字段宽度，而不是通常的填充方法；</li>
<li>最小字段宽度。如果格式化后的数字至少没有这么宽，<code>Rust</code> 在左边（默认）用空格（默认）填充它，以形成一个给定宽度的字段；</li>
<li>浮点参数的精度，指示 <code>Rust</code> 应该在小数点后包含多少位。<code>Rust</code> 会根据需要进行四舍五入或零扩展，以准确生成这么多小数位数。如果省略了精度，<code>Rust</code> 会尝试使用尽可能少的数字来准确地表示该值，对于整数类型的参数，精度被忽略；</li>
<li>一个符号。对于整数类型，这可以是 <code>b</code> 表示二进制，<code>o</code> 表示八进制，或者 <code>x</code> 或 <code>X</code> 表示带有小写或大写字母的十六进制。如果包含 <code>#</code> 字符，则这些字符包括显式的 <code>Rust</code> 样式基数前缀、<code>0b</code>、<code>0o</code>、<code>0x</code> 或 <code>0X</code>。对于浮点类型，<code>e</code> 或 <code>E</code> 的基数要求科学记数法，具有归一化系数，使用 <code>e</code> 或 <code>E</code> 作为指数。如果你不指定任何符号，<code>Rust</code> 会以十进制格式格式化数字；</li>
</ol>
<p>下面是一些数字格式化的例子，示例 <code>1234_i32</code>：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/number-format-exmaple.png" class="">

<p>如最后两个示例所示，最小字段宽度适用于整个数字、符号、基数前缀等。负数总是包括它们的符号。 结果与“强制符号”示例中显示的结果类似。当要求前导零时，对齐和填充字符将被忽略，因为零会扩展数字以填充整个字段。</p>
<p>下面以 <code>1234.5678</code> 为例，演示浮点数格式化：</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/float-format-exmaple.png" class="">

<h4 id="格式化其他类型"><a href="#格式化其他类型" class="headerlink" title="格式化其他类型"></a>格式化其他类型</h4><p>除了数字和字符串之外，你还可以格式化下面几种标注库类型：</p>
<ol>
<li><p>错误类型都可以直接格式化，便于将它们包含在错误消息中。每个错误类型都应该实现 <code>std::error::Error</code>，它扩展了默认的格式化<code>std::fmt::Display</code>。因此，任何实现 <code>Error</code> 的类型都可以格式化；</p>
</li>
<li><p>可以格式化互联网协议地址类型，例如 <code>std::net::IpAddr</code> 和 <code>std::net::SocketAddr</code>；</p>
</li>
<li><p><code>true</code> 和 <code>false</code> 可以格式化，尽管这些通常不是直接呈现给最终用户的最佳字符串；</p>
</li>
</ol>
<h4 id="用于调试的格式化"><a href="#用于调试的格式化" class="headerlink" title="用于调试的格式化"></a>用于调试的格式化</h4><p>为了帮助调试和记录，<code>&#123;:?&#125;</code> 参数以对程序员有帮助的方式格式化 <code>Rust</code> 标准库中的任何公共类型。可以使用它来调试 <code>vector</code>、切片、元组、哈希表、线程和数百种其他类型。</p>
<p>例如，你可这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Portland&quot;</span>, (<span class="number">45.5237606</span>, -<span class="number">122.6819273</span>));</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Taipei&quot;</span>, (<span class="number">25.0375167</span>, <span class="number">121.5637</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>&#123;&quot;Taipei&quot;: (25.0375167, 121.5637), &quot;Portland&quot;: (45.5237606, -122.6819273)&#125;
</code></pre>
<p>可以使用 <code>&#123;:#?&#125;</code> 以更适合阅读的方式打印：</p>
<pre><code>&#123;
    &quot;Taipei&quot;: (
        25.0375167,
        121.5637,
    ),
    &quot;Portland&quot;: (
        45.5237606,
        -122.6819273,
    ),
&#125;
</code></pre>
<p>调试格式通常以十进制打印数字，但可以在问号前放置一个 <code>x</code> 或 <code>X</code> 来请求十六进制。前导<code>0</code>和字段宽度语法也可以接受。例如，可以编写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ordinary: &#123;:02?&#125;&quot;</span>, [<span class="number">9</span>, <span class="number">15</span>, <span class="number">240</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hex: &#123;:02x?&#125;&quot;</span>, [<span class="number">9</span>, <span class="number">15</span>, <span class="number">240</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>ordinary: [09, 15, 240]
hex: [09, 0f, f0]
</code></pre>
<p>可以通过 <code>#[derive(Debug)]</code> 让自己的类型支持 <code>&#123;:?&#125;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123; re: <span class="type">f64</span>, im: <span class="type">f64</span> &#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">third</span> = Complex &#123; re: -<span class="number">0.5</span>, im: <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(<span class="number">0.75</span>) &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, third);</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>Complex &#123; re: -0.5, im: 0.8660254037844386 &#125;
</code></pre>
<h4 id="格式化指针"><a href="#格式化指针" class="headerlink" title="格式化指针"></a>格式化指针</h4><p>通常，如果将任何类型的指针传递给格式化宏——<code>引用</code>、<code>Box</code>、<code>Rc</code>——宏只会格式化引用的对象，指针本身并不重要。但是在调试时，有时查看指针会很有帮助：地址可以作为单个值的粗略“名称”，这在检查具有循环或共享的结构时会很有启发性。</p>
<p><code>&#123;:p&#125;</code> 将引用和智能指针格式化为地址：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::rc::Rc;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">original</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;mazurka&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cloned</span> = original.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">impostor</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;mazurka&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;text: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, original, cloned, impostor);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;pointers: &#123;:p&#125;, &#123;:p&#125;, &#123;:p&#125;&quot;</span>, original, cloned, impostor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能输出：</p>
<pre><code>text: mazurka, mazurka, mazurka
pointers: 0x6000024ac2b0, 0x6000024ac2b0, 0x6000024ac2e0
</code></pre>
<p>从结果可以看出 <code>original</code> 和 <code>cloned</code> 具有相同的地址，这也符合 <code>Rc</code> 的定义。 </p>
<h4 id="通过索引或者名称引用参数"><a href="#通过索引或者名称引用参数" class="headerlink" title="通过索引或者名称引用参数"></a>通过索引或者名称引用参数</h4><p>可以简单的通过索引来指定格式化参数使用哪个值，也就是指定开始所说的 <code>which</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;1&#125;,&#123;0&#125;,&#123;2&#125;&quot;</span>, <span class="string">&quot;zeroth&quot;</span>, <span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>),</span><br><span class="line">        <span class="string">&quot;first,zeroth,second&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;2:#06x&#125;,&#123;1:b&#125;,&#123;0:=&gt;10&#125;&quot;</span>, <span class="string">&quot;first&quot;</span>, <span class="number">10</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="string">&quot;0x0064,1010,=====first&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过名称选择参数，有点像<code>Python</code>的关键字参数，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;description:.&lt;25&#125;&#123;quantity:2&#125; @ &#123;price:5.2&#125;&quot;</span>,</span><br><span class="line">            price = <span class="number">3.25</span>,</span><br><span class="line">            quantity = <span class="number">3</span>,</span><br><span class="line">            description = <span class="string">&quot;Maple Turmeric Latte&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;Maple Turmeric Latte..... 3 @ 3.25&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将命名参数，位置参数，索引参数混合起来使用，只是命名参数必须出现在最后。位置参数与参数从左到右配对，就好像索引和命名参数不存在一样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;mode&#125; &#123;2&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;people&quot;</span>,</span><br><span class="line">            <span class="string">&quot;eater&quot;</span>,</span><br><span class="line">            <span class="string">&quot;purple&quot;</span>,</span><br><span class="line">            mode = <span class="string">&quot;flying&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;flying purple people eater&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态宽度和精度"><a href="#动态宽度和精度" class="headerlink" title="动态宽度和精度"></a>动态宽度和精度</h4><p>之前我们看到的宽度和精度都是固定值，也可以在运行时确定：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">format!</span>(<span class="string">&quot;&#123;:&gt;1$&#125;&quot;</span>, content, <span class="title function_ invoke__">get_width</span>())</span><br></pre></td></tr></table></figure>

<p><code>1$</code> 告诉 <code>format!</code> 使用第二个参数作为宽度，宽度的类型必须是 <code>usize</code>，也可以使用命名参数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">format!</span>(<span class="string">&quot;&#123;:&gt;width$&#125;&quot;</span>, content, width=<span class="title function_ invoke__">get_width</span>())</span><br></pre></td></tr></table></figure>

<p>相同的方式处理文本长度限制：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;:&gt;width$.limit$&#125;&quot;</span>,</span><br><span class="line">        content,</span><br><span class="line">        width = <span class="title function_ invoke__">get_width</span>(),</span><br><span class="line">        limit = <span class="title function_ invoke__">get_limit</span>()</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>在文本长度或者浮点参数的位置，你还可以写 <code>*</code>，来使用下一个位置参数作为精度。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_width</span>() <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_limit</span>() <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;:&gt;width$.limit$&#125;&quot;</span>,</span><br><span class="line">        content,</span><br><span class="line">        width = <span class="title function_ invoke__">get_width</span>(),</span><br><span class="line">        limit = <span class="title function_ invoke__">get_limit</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.*&#125;&quot;</span>, <span class="title function_ invoke__">get_limit</span>(), content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>hello worl
hello worl
</code></pre>
<h4 id="格式化自定义类型"><a href="#格式化自定义类型" class="headerlink" title="格式化自定义类型"></a>格式化自定义类型</h4><p>格式化宏实际上是 <code>std::fmt</code> 中定义的一系列宏，可以通过自己实现这些特征中的一个或多个来使 <code>Rust</code> 的格式化宏格式化自己的类型。</p>
<img data-src="/2022/04/24/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/format-custom-type.png" class="">

<p>用于格式化的 <code>Trait</code> 都有相同的结构，仅仅是名字不同，以 <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a> 为例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, dest: &amp;<span class="keyword">mut</span> std::fmt::Formatter)</span><br><span class="line">    <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fmt</code> 方法的工作是生成有效的 <code>self</code> 表示并将其字符写入 <code>dest</code>。 除了作为输出流之外，<code>dest</code> 参数还携带从格式参数解析的详细信息，例如对齐方式和最小字段宽度。</p>
<p>下面是一个完整的实现用于 <code>Complex</code> 格式化输出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    re: <span class="type">f64</span>,</span><br><span class="line">    im: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, dest: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (re, im) = (<span class="keyword">self</span>.re, <span class="keyword">self</span>.im);</span><br><span class="line">        <span class="keyword">if</span> dest.<span class="title function_ invoke__">alternate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">abs</span> = <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(re * re + im * im);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">angle</span> = <span class="type">f64</span>::<span class="title function_ invoke__">atan2</span>(im, re) / std::<span class="type">f64</span>::consts::PI * <span class="number">180.0</span>;</span><br><span class="line">            <span class="built_in">write!</span>(dest, <span class="string">&quot;&#123;&#125; ∠ &#123;&#125;°&quot;</span>, abs, angle)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">im_sign</span> = <span class="keyword">if</span> im &lt; <span class="number">0.0</span> &#123; <span class="string">&#x27;-&#x27;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&#x27;+&#x27;</span> &#125;;</span><br><span class="line">            <span class="built_in">write!</span>(dest, <span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;i&quot;</span>, re, im_sign, <span class="type">f64</span>::<span class="title function_ invoke__">abs</span>(im))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ninety</span> = Complex &#123; re: <span class="number">0.0</span>, im: <span class="number">2.0</span> &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ninety), <span class="string">&quot;0 + 2i&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#&#125;&quot;</span>, ninety), <span class="string">&quot;2 ∠ 90°&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果格式化参数中携带 <code>#</code>，我们以极坐标的形式显示负数，否则我们按照常规的方式展示。虽然 <code>fmt</code> 返回 <code>Result</code>，但是我们通常不用处理错误，只需向上传递，<a href="https://doc.rust-lang.org/std/fmt/struct.Formatter.html#implementations"><code>Formatter</code></a> 还有很多其他有用的方法，<code>alternate</code> 只是其中一个。</p>
<h4 id="format-args"><a href="#format-args" class="headerlink" title="format_args!"></a><code>format_args!</code></h4><p>可以使用 <code>Rust</code> 的 <code>format_args</code> 编写自己的函数和宏来接受类型为 <a href="https://doc.rust-lang.org/std/fmt/struct.Arguments.html"><code>std::fmt::Arguments</code></a> 的参数。例如，假设程序需要在运行时记录状态消息，并且想使用 <code>Rust</code> 的文本格式化语言来生成它们，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code, unused_imports)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::fs::OpenOptions;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> log &#123;</span><br><span class="line">    ($format:tt, $($arg:expr),*) =&gt; (</span><br><span class="line">        <span class="title function_ invoke__">write_log_entry</span>(<span class="built_in">format_args!</span>($format, $($arg),*))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">logging_enabled</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">write_log_entry</span>(entry: std::fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_ invoke__">logging_enabled</span>() &#123;</span><br><span class="line">        <span class="comment">// Keep things simple for now, and just</span></span><br><span class="line">        <span class="comment">// open the file every time.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">log_file</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">append</span>(<span class="literal">true</span>)</span><br><span class="line">            .<span class="title function_ invoke__">create</span>(<span class="literal">true</span>)</span><br><span class="line">            .<span class="title function_ invoke__">open</span>(<span class="string">&quot;log-file-name&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to open log file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        log_file.<span class="title function_ invoke__">write_fmt</span>(entry).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to write to log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    re: <span class="type">f64</span>,</span><br><span class="line">    im: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mysterious_value</span> = Complex &#123; re: <span class="number">0.2</span>, im: <span class="number">1.2</span> &#125;;</span><br><span class="line"></span><br><span class="line">    log!(</span><br><span class="line">        <span class="string">&quot;O day and night, but this is wondrous strange! &#123;:?&#125;\n&quot;</span>,</span><br><span class="line">        mysterious_value</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译时，<code>format_args!</code> 宏解析模板字符串并根据参数类型检查它，如果有任何问题则报告错误。在运行时，它计算参数值并构建一个 <code>Arguments</code> ，其中包含格式化文本所需的所有信息：模板的预解析形式，以及对参数值的共享引用。</p>
<p>构造一个 <code>Arguments</code> 没有什么消耗：它只是收集一些指针，还没有进行格式化工作。这很重要：如果未启用日志记录，则将数字转换为十进制、填充值等所花费的任何时间都将被浪费。</p>
<p><code>File</code> 类型实现了 <code>std::io::Write</code> 特征，其 <code>write_fmt</code> 方法接受 <code>Argument</code> 并进行格式化，它将结果写入底层流。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><a href="https://crates.io/crates/regex"><code>regex</code></a> 是 <code>Rust</code> 的官方正则表达式库，它提供通常的搜索和匹配功能。它对 <code>Unicode</code> 有很好的支持，但它也可以搜索字节字符串，尽管它不支持在其他正则表达式包中经常发现的某些功能，例如反向引用和环视模式，但这些简化允许正则表达式确保搜索时间与表达式的大小和正在搜索的文本长度呈线性关系。除其他外，这些保证使正则表达式可以安全使用，即使是在搜索不可信文本的不可信表达式中也是如此。</p>
<p>尽管 <code>regex</code> 不在 <code>std</code> 中，但它由 <code>Rust</code> 库团队维护。要使用正则表达式，请将以下行放在<code>Cargo.toml</code> 文件的 <code>[dependencies]</code> 部分中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regex = &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>Regex</code> 值表示已解析的正则表达式可供使用。<code>Regex::new</code> 构造函数尝试将 <code>&amp;str</code> 解析为正则表达式，并返回一个结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> regex::&#123;Error, Regex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> StdError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> StdError + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">semver</span> = Regex::<span class="title function_ invoke__">new</span>(<span class="string">r&quot;(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?&quot;</span>)?;</span><br><span class="line">    <span class="comment">// Simple search, with a Boolean result.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">haystack</span> = <span class="string">r#&quot;regex = &quot;0.2.5&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(semver.<span class="title function_ invoke__">is_match</span>(haystack));</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Regex::captures</code> 方法在字符串中搜索第一个匹配项，并返回一个 <code>regex::Captures</code> 值，其中包含表达式中每个组的匹配信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// You can retrieve capture groups:</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">captures</span> = semver</span><br><span class="line">    .<span class="title function_ invoke__">captures</span>(haystack)</span><br><span class="line">    .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;semver regex should have matched&quot;</span>)?;</span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;captures[<span class="number">0</span>], <span class="string">&quot;0.2.5&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;captures[<span class="number">1</span>], <span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;captures[<span class="number">2</span>], <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;captures[<span class="number">3</span>], <span class="string">&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用索引可能会发生 <code>panic</code>，可以使用 <code>Captures::get</code>，它返回一个 <code>Option&lt;regex::Match&gt;</code>，<code>Match</code> 包含了的那个的组匹配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(captures.<span class="title function_ invoke__">get</span>(<span class="number">4</span>), <span class="literal">None</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(captures.<span class="title function_ invoke__">get</span>(<span class="number">3</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">start</span>(), <span class="number">13</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(captures.<span class="title function_ invoke__">get</span>(<span class="number">3</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">end</span>(), <span class="number">14</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(captures.<span class="title function_ invoke__">get</span>(<span class="number">3</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>find_iter</code> 为文本中每个连续的非重叠匹配返回一个迭代器，返回相对于文本的开始和结束字节索引。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">haystack</span> = <span class="string">&quot;In the beginning, there was 1.0.0. \</span></span><br><span class="line"><span class="string">For a while, we used 1.0.1-beta, \</span></span><br><span class="line"><span class="string">but in the end, we settled on 1.2.4.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">matches</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = semver</span><br><span class="line">    .<span class="title function_ invoke__">find_iter</span>(haystack)</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|match_| match_.<span class="title function_ invoke__">as_str</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(matches, <span class="built_in">vec!</span>[<span class="string">&quot;1.0.0&quot;</span>, <span class="string">&quot;1.0.1-beta&quot;</span>, <span class="string">&quot;1.2.4&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p><code>captures_iter</code> 产生的 <a href="https://docs.rs/regex/1.5.5/regex/struct.Captures.html"><code>Captures</code></a> 包含所有匹配组：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">caps</span> <span class="keyword">in</span> semver.<span class="title function_ invoke__">captures_iter</span>(haystack) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">m</span> <span class="keyword">in</span> caps.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(m) = m &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;, &#123;&#125;&quot;</span>, m.<span class="title function_ invoke__">start</span>(), m.<span class="title function_ invoke__">end</span>(), &amp;haystack[m.<span class="title function_ invoke__">range</span>()]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>28 -&gt; 33, 1.0.0
56 -&gt; 66, 1.0.1-beta
98 -&gt; 103, 1.2.4
</code></pre>
<h4 id="懒惰构建-Regex"><a href="#懒惰构建-Regex" class="headerlink" title="懒惰构建 Regex"></a>懒惰构建 <code>Regex</code></h4><p><code>Regex::new</code> 构造函数可能很昂贵：为 <code>1,200</code> 个字符的正则表达式构造 <code>Regex</code> 即使在快速机器上也需要一毫秒，即使是很小的表达式也需要数微秒，因此，最好将 <code>Regex</code> 构造排除在繁重的计算循环之外，而是应该构建一次正则表达式，然后重用同一个。</p>
<p><a href="https://docs.rs/lazy_static/latest/lazy_static/"><code>lazy_static</code></a> 提供了一种比较好的方式用于延迟初始化静态值，这些值只有在第一次使用时才会被初始化，在 <code>Cargo.toml</code> 添加如下依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> regex::&#123;Error, Regex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> StdError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> StdError + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;&gt; &#123;</span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> SEMVER: Regex =</span><br><span class="line">            Regex::<span class="title function_ invoke__">new</span>(<span class="string">r&quot;(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error parsing regex&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple search, with a Boolean result.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">haystack</span> = <span class="string">r#&quot;regex = &quot;0.2.5&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(SEMVER.<span class="title function_ invoke__">is_match</span>(haystack));</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该宏为一个名为 <code>SEMVER</code> 的静态变量的声明，但它的类型不完全是 <code>Regex</code>。 相反，它是实现 <code>Deref&lt;Target=Regex&gt;</code> 的宏生成类型，因此公开了与 <code>Regex</code> 相同的所有方法。第一次解引用 <code>SEMVER</code> 时会进行初始化，并保存该值以供以后使用。由于 <code>SEMVER</code> 是一个静态变量，而不仅仅是一个局部变量，因此初始化程序在每次程序执行时最多运行一次。</p>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>大多数用户会认为茶的法语单词 <code>thé</code> 是三个字符长。然而，<code>Unicode</code> 实际上有两种方式来表示这个文本：</p>
<ul>
<li><p>在<code>composed</code>形式中，<code>thé</code> 包含三个字符 <code>t</code>、<code>h</code> 和 <code>é</code>，其中 <code>é</code> 是单个 <code>Unicode</code> 字符，代码点为 <code>0xe9</code>。</p>
</li>
<li><p>在<code>decomposed</code>形式中，<code>thé</code> 包含四个字符 <code>t</code>、<code>h</code>、<code>e</code> 和 <code>\u&#123;301&#125;</code>，其中 <code>e</code> 是纯 <code>ASCII</code> 字符，没有重音符号，代码点 <code>0x301</code> 是“组合重音符号”字符，它为它后面的任何字符添加一个尖锐的重音。</p>
</li>
</ul>
<p><code>Unicode</code> 不认为 <code>é</code> 的组合形式或分解形式是“正确的”形式；相反，它认为它们都是相同抽象字符的等效表示。<code>Unicode</code> 表示两种表单都应该以相同的方式显示，并且允许使用文本输入法生成任何一种，因此用户通常不会知道他们正在查看或输入哪种表单。（<code>Rust</code> 允许直接在字符串文字中使用 <code>Unicode</code> 字符，因此如果不在乎获得哪种编码，可以简单地编写 <code>thé</code>。为了清楚起见，我们将使用 <code>\u</code> 转义。）</p>
<p>然而，考虑到 <code>Rust</code> 中 <code>&amp;str</code> 或 <code>String</code> 值，<code>“th\u&#123;e9&#125;”</code>和<code>“the\u&#123;301&#125;”</code>是完全不同的。它们有不同的长度，比较不相等，有不同的哈希值，并且相对于其他字符串有不同的顺序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::hash_map::DefaultHasher;</span><br><span class="line"><span class="keyword">use</span> std::hash::&#123;Hash, Hasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hash</span>&lt;T: ?<span class="built_in">Sized</span> + Hash&gt;(t: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    t.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    s.<span class="title function_ invoke__">finish</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="string">&quot;th\u&#123;e9&#125;&quot;</span> != <span class="string">&quot;the\u&#123;301&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="string">&quot;th\u&#123;e9&#125;&quot;</span> &gt; <span class="string">&quot;the\u&#123;301&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">hash</span>(<span class="string">&quot;th\u&#123;e9&#125;&quot;</span>), <span class="number">0x53e2d0734eb1dff3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">hash</span>(<span class="string">&quot;the\u&#123;301&#125;&quot;</span>), <span class="number">0x90d837f0a0928144</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，如果打算比较用户提供的文本或将其用作哈希表或 <code>Btree</code> 中的键，则需要首先将每个字符串放在某种规范形式中。</p>
<p>幸运的是，<code>Unicode</code> 指定了字符串的规范化形式。每当根据 <code>Unicode</code> 规则将两个字符串视为等效时，它们的规范化形式是逐字符相同的。当使用 <code>UTF-8</code> 编码时，它们是逐字节相同的。这意味着可以将规范化的字符串与 <code>==</code> 进行比较，将它们用作 <code>HashMap</code> 或 <code>HashSet</code> 中的键等。</p>
<p>未能规范化甚至会产生安全后果，例如，如果网站在某些情况下对用户名进行了规范化，但在其他情况下没有规范化用户名，最终可能会得到两个不同的用户，名为 <code>bananasflambé</code>，代码的某些部分将其视为同一个用户，但其他部分将其区别开来，从而导致一个人的权限被错误地扩展到另一个。当然，有很多方法可以避免此类问题，但历史表明也有很多方法可以避免。</p>
<h4 id="Normalization-Forms"><a href="#Normalization-Forms" class="headerlink" title="Normalization Forms"></a><code>Normalization Forms</code></h4><p><code>Unicode</code> 定义了四种规范化形式，每一种都适用于不同的用途。 有两个问题需要回答：</p>
<ul>
<li><p>首先，更喜欢字符是尽可能组合还是尽可能分开？例如，越南语单词 <code>Phở</code> 的 <code>composed</code> 形式是三个字符串<code>&quot;Ph\u&#123;1edf&#125;&quot;</code>，其中声调符号̉和元音符号̛都应用于单个字符的基本字符<code>&quot;o&quot;</code>，<code>Unicode</code> 负责将拉丁小写字母 <code>o</code> 命名为上面带有角和钩的字符。</p>
<p>  <code>decomposed</code> 形式将基本字母及其两个标记拆分为三个单独的 <code>Unicode</code> 字符：<code>o</code>、<code>\u&#123;31b&#125;</code>和 <code>\u&#123;309&#125;</code>，从而产生 <code>Pho\u&#123;31b&#125;\u&#123;309&#125;</code>。组合形式通常兼容性问题较少，因为它与大多数语言在 <code>Unicode</code> 建立之前用于其文本的表示形式更加匹配。它还可以很好地与 <code>Rust</code> 的 <code>format!</code> 工作。另一方面，<code>decomposed</code> 形式可能更适合显示文本或搜索，因为它使文本的详细结构更加明确。</p>
</li>
<li><p>第二个问题是：如果两个字符序列表示相同的基本文本，但文本格式的方式不同，你想将它们视为等价还是保持不同？</p>
<p>  <code>Unicode</code> 对普通数字 <code>5</code>、上标数字 <code>⁵</code>（或 <code>\u&#123;2075&#125;</code>）和带圆圈的数字 <code>⑤</code>（或<code>\u&#123;2464&#125;</code>）有单独的字符，但声明所有这三个是兼容性等价的。类似地，<code>Unicode</code> 有一个用于连字的单个字符 <a href="https://www.compart.com/en/unicode/U+FB03"><code>\u&#123;fb03&#125;</code></a>，但声明它与三个字符序列 <code>ffi</code> 等效。</p>
<p>  兼容性等价对搜索有意义：仅使用 <code>ASCII</code> 字符搜索<code>&quot;difficult&quot;</code>，应该匹配字符串<code>&quot;di\u&#123;fb03&#125;cult&quot;</code>。对后一个字符串应用兼容性分解会将连字替换为三个纯字母“ffi”，从而使搜索更容易。但是将文本规范化为兼容性等效形式可能会丢失基本信息，因此不应粗心地应用它。例如，在大多数情况下将<code>2⁵</code>存储为<code>25</code>是不正确的。</p>
</li>
</ul>
<p><code>Unicode</code> 规范化形式 <code>NFC</code> 和规范化形式 <code>NFD</code> 使用每个字符的最大组合和最大分解形式，但不尝试统一兼容性等效序列。而<code>NFKC</code> 和 <code>NFKD</code> 规范化形式类似于 <code>NFC</code> 和 <code>NFD</code>，但将所有兼容性等价序列规范化为它们类的一些简单代表。</p>
<p>万维网联盟的建议对所有内容使用 <code>NFC</code>。 <code>Unicode</code> 标识符和模式语法建议在编程语言中使用 <code>NFKC</code> 作为标识符，并提供必要时调整格式的原则。</p>
<h4 id="unicode-normalization"><a href="#unicode-normalization" class="headerlink" title="unicode-normalization"></a><code>unicode-normalization</code></h4><p><code>Rust</code> 的 <code>unicode-normalization</code> 提供了一个 <code>trait</code>，它向 <code>&amp;str</code> 添加方法以将文本置于四种规范化形式中的任何一种。要使用它，将以下行添加到 <code>Cargo.toml</code> 文件的 <code>[dependencies]</code> 部分：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">unicode-normalization</span> = <span class="string">&quot;0.1.17&quot;</span></span><br></pre></td></tr></table></figure>

<p>有了这个声明，<code>&amp;str</code> 有四个新方法，它们返回对特定规范化字符串形式的迭代器：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> unicode_normalization::UnicodeNormalization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// No matter what representation the left-hand string uses</span></span><br><span class="line">    <span class="comment">// (you shouldn&#x27;t be able to tell just by looking),</span></span><br><span class="line">    <span class="comment">// these assertions will hold.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;Phở&quot;</span>.<span class="title function_ invoke__">nfd</span>().collect::&lt;<span class="type">String</span>&gt;(), <span class="string">&quot;Pho\u&#123;31b&#125;\u&#123;309&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;Phở&quot;</span>.<span class="title function_ invoke__">nfc</span>().collect::&lt;<span class="type">String</span>&gt;(), <span class="string">&quot;Ph\u&#123;1edf&#125;&quot;</span>);</span><br><span class="line">    <span class="comment">// The left-hand side here uses the &quot;ffi&quot; ligature character.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="string">&quot;① Di\u&#123;fb03&#125;culty&quot;</span>.<span class="title function_ invoke__">nfkc</span>().collect::&lt;<span class="type">String</span>&gt;(),</span><br><span class="line">        <span class="string">&quot;1 Difficulty&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Taking a normalized string and normalizing it again in the same form is guaranteed to return identical text.</p>
<p>Although any substring of a normalized string is itself normalized, the concatenation of two normalized strings is not necessarily normalized: for example, the second string might start with combining characters that should be placed before combining characters at the end of the first string.</p>
<p>As long as a text uses no unassigned code points when it is normalized, Unicode promises that its normalized form will not change in future versions of the standard. This means that normalized forms are generally safe to use in persistent storage, even as the Unicode standard evolves.</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>String 和文本</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】宏</title>
    <url>/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/</url>
    <content><![CDATA[<p><code>Rust</code> 语言支持宏，如我们之前使用的 <code>assert_eq!</code>，<code>println!</code> 等。宏做了函数不能做的一些事情，例如，<code>assert_eq!</code> 当一个断言失败时，<code>assert_eq!</code> 生成包含断言的文件名和行号的错误消息，普通函数无法获取这些信息，但宏可以，因为它们的工作方式完全不同。</p>
<p>宏是一种简写，在编译期间，在检查类型和生成任何机器代码之前，每个宏调用都会被扩展。也就是说，它被一些 <code>Rust</code> 代码替换。<code>assert_eq!</code> 调用扩展为大致如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">match</span> (&amp;<span class="title function_ invoke__">gcd</span>(<span class="number">6</span>, <span class="number">10</span>), &amp;<span class="number">2</span>) &#123;</span><br><span class="line">    (left_val, right_val) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> !(*left_val == *right_val) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;assertion failed: `(left == right)`, (left: `&#123;:?&#125;`, right: `&#123;:?&#125;`)&quot;</span>,</span><br><span class="line">                left_val, right_val</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>panic!</code> 也是一个宏，它本身扩展为更多的 <code>Rust</code> 代码。该代码使用到了另外两个宏：<code>file!()</code> 和 <code>line!()</code>。 一旦 <code>crate</code> 中的每个宏调用都被完全展开，<code>Rust</code> 就会进入下一个编译阶段。</p>
<p>在运行时，断言失败看起来像这样：</p>
<pre><code>thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`, (left: `17`, right: `2`)&#39;, gcd.rs:7
</code></pre>
<p>如果熟悉 <code>C++</code>，可能对宏有过一些不好的体验。但是 <code>Rust</code> 宏采用不同的方法，类似于 <code>Scheme</code> 的语法规则。与 <code>C++</code> 宏相比，<code>Rust</code> 宏可以更好地与语言的其余部分集成，因此更不容易出错。宏调用总是标有感叹号 <code>!</code>，因此在阅读代码时它们会比较突出，所以不会意外调用它们。<code>Rust</code> 宏从不插入不匹配的括号或圆括号，并且 <code>Rust</code> 宏带有模式匹配，使得编写既可维护又易于使用的宏变得更加容易。</p>
<p>在本节中，我们将通过几个简单的例子来展示如何编写宏。但与 <code>Rust</code> 的大部分内容一样，理解宏需要下很大功夫。在这里将介绍一个很复杂的宏的设计，它可以将 <code>JSON</code> 文字直接嵌入到我们的程序中。但是宏的内容涵盖的非常多，因此这里将提供一些进一步研究的建议，包括我们在此处展示的高级技术，以及称为过程宏的更强大的工具。</p>
<span id="more"></span>

<h3 id="宏基础"><a href="#宏基础" class="headerlink" title="宏基础"></a>宏基础</h3><p>首先我们来看下 <code>assert_eq!</code> 的代码：</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/assert_eq.png" class="">

<p><code>macro_rules!</code> 是在 <code>Rust</code> 中定义宏的主要方式。在此宏定义中的 <code>assert_eq</code> 之后没有<code>!</code>，<code>!</code> 仅在调用宏时，而不是在定义时。</p>
<p>并非所有的宏都以这种方式定义：如 <code>file!</code>、<code>line!</code> 和 <code>macro_rules！</code> 它本身是内置在编译器中的，我们将在本章末尾讨论另一种方法，称为过程宏。但在大多数情况下，我们将专注于 <code>macro_rules!</code>，这是迄今为止自己编写宏最简单的方法。</p>
<p>用 <code>macro_rules!</code> 定义的宏完全通过模式匹配工作。宏的主体只是一系列规则：</p>
<pre><code>( pattern1 ) =&gt; ( template1 );
( pattern2 ) =&gt; ( template2 );
...
</code></pre>
<p>顺便说一句，可以使用方括号或花括号代替模板周围的圆括号；这对 <code>Rust</code> 没有任何影响。同样，当调用宏时，这些都是等价的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">gcd</span>(<span class="number">6</span>, <span class="number">10</span>), <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>[<span class="title function_ invoke__">gcd</span>(<span class="number">6</span>, <span class="number">10</span>), <span class="number">2</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>&#123;<span class="title function_ invoke__">gcd</span>(<span class="number">6</span>, <span class="number">10</span>), <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的区别是花括号后面的分号通常是可选的。按照惯例，我们在调用 <code>assert_eq!</code> 时使用括号，为 <code>vec!</code> 使用方括号，为 <code>macro_rules!</code> 使用花括号。</p>
<p>现在我们已经展示了一个宏扩展的简单示例和生成它的定义，我们可以深入了解使其工作所需的细节：</p>
<ul>
<li><p>我们将准确解释 <code>Rust</code> 如何在程序中查找和扩展宏定义；</p>
</li>
<li><p>我们将指出从宏模板生成代码的过程中固有的一些微妙之处；</p>
</li>
<li><p>最后，我们将展示模式如何处理重复结构；</p>
</li>
</ul>
<h4 id="宏扩展"><a href="#宏扩展" class="headerlink" title="宏扩展"></a>宏扩展</h4><p><code>Rust</code> 在编译前期就会将宏展开，编译器从头到尾读取源代码，将定义的宏进行展开，所以不能在定义之前使用宏。（相比之下，函数和其他项不必按任何特定顺序排列，可以调用直到稍后在 <code>crate</code> 中才定义的函数。）</p>
<p>当 <code>Rust</code> 展开一个 <code>assert_eq</code> 宏调用时，发生的事情很像计算匹配表达式。<code>Rust</code> 首先将参数与模式匹配，如下图所示：</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/macro-pateern-match.png" class="">

<p>宏模式是 <code>Rust</code> 中的一种小型语言，它们本质上是用于匹配代码的正则表达式。但正则表达式是对字符进行操作，而模式则是对 <code>token</code> 进行操作–数字、名字、标点符号等等，这些都是Rust程序的组成部分。这意味着你可以在宏模式中自由地使用注释和空白，以使它们尽可能地可读。注释和空白不是标记，所以它们不会影响匹配。              </p>
<p>正则表达式和宏模式之间的另一个重要区别是，在 <code>Rust</code> 中，小括号、大括号和圆括号总是以匹配对的形式出现。不仅在宏模式中，而且在整个语言中，在展开宏之前都会检查这些。               </p>
<p>在这个例子中，我们的模式包含了 <code>$left:expr</code> 这个片段，它告诉 <code>Rust</code> 匹配一个表达式（在这个例子中，<code>gcd(6, 10)</code>）并将其命名为<code>$left</code>。然后 <code>Rust</code> 将模式中的逗号与 <code>gcd</code> 的参数后面的逗号进行匹配。就像正则表达式一样，模式中只有几个特殊的字符可以触发有趣的匹配行为，比如这个逗号，都必须逐字匹配，否则匹配失败。最后，<code>Rust</code> 匹配了表达式 <code>2</code>，并给它命名 <code>$right</code>。                   </p>
<p>这个模式中的两个代码片段都是 <code>expr</code> 类型的：期望匹配表达式。由于这个模式匹配了所有的参数，<code>Rust</code> 展开了相应的模板，如下图所示：</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/asseteq-macro-expanding.png" class="">

<p><code>Rust</code> 将 <code>$left</code> 和 <code>$right</code> 替换成它在匹配过程中发现的代码片段。                </p>
<p>在输出模板中包含片段类型是一个常见的错误：写<code>$left:expr</code>而不是只写<code>$left</code>。<code>Rust</code>不会立即发现这种错误。它把<code>$left</code>看作是一个替换，然后它把:expr和模板中的其他东西一样看待：要包含在宏的输出代码中的<code>token</code>。因此，在你调用宏之前，这些错误不会发生；然后它将产生假的输出，无法编译。如果你得到错误信息，如在这个范围内找不到<code>expr</code>类型：<code> help: maybe you meant to use a path separator here</code>。</p>
<p>宏模板与网络编程中常用的十几种模板语言并无太大区别。唯一不同的是，它的输出是 <code>Rust</code> 代码，这一点很重要。</p>
<h4 id="意外后果"><a href="#意外后果" class="headerlink" title="意外后果"></a>意外后果</h4><p>将代码片段插入模板，与使用数值的常规代码有微妙的不同,这些差异起初并不总是很明显。我们一直在看的宏，<code>assert_eq!</code>，包含了一些略显奇怪的代码片段，其中的原因说明了宏编程的很多问题，让我们特别看看两个有趣的部分。   </p>
<p>首先，为什么这个宏要创建变量 <code>left_val</code> 和 <code>right_val</code>，下面这样写为何不可以？</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !($left == $right) &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;assertion failed: `(left == right)` (left: `&#123;:?&#125;`, right: `&#123;:?&#125;`)&quot;</span>, $left, $right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要回答这个问题，请尝试在头脑中展开宏调用 <code>assert_eq!(letters.pop(), Some(&#39;z&#39;))</code>。输出会是什么？当然，<code>Rust</code> 会把匹配的表达式插入到模板的多个地方。不过，在构建错误信息时重新计算这些表达式似乎是个坏主意，这不仅仅是因为它会花费两倍的时间：因为 <code>letters.pop()</code> 会从一个向量中移除一个值，所以在我们第二次调用时它会产生一个不同的值，这就是为什么真正的宏只计算一次<code>$left</code>和<code>$right</code>并存储它们的值。         </p>
<p>接下来是第二个问题：为什么这个宏要借用 <code>$left</code> 和 <code>$right</code> 的值的引用，为什么不直接在变量中存储这些值，像这样？</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> bad_assert_eq &#123;</span><br><span class="line">    ($left:expr, $right:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="title function_ invoke__">match</span> ($left, $right) &#123;</span><br><span class="line">            (left_val, right_val) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> !(left_val == right_val) &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;assertion failed&quot;</span> <span class="comment">/* ... */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于我们所考虑的特殊情况，即宏的参数是整数，这可以正常工作。但是，如果调用者将一个字符串变量作为 <code>$left</code> 或 <code>$right</code> 来传递，这段代码就会将该变量的值移出：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;a rose&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    bad_assert_eq!(s, <span class="string">&quot;a rose&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;confirmed: &#123;&#125; is a rose&quot;</span>, s); <span class="comment">// error: use of moved value &quot;s&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为我们不希望断言移动数值，所以这个宏借用了引用来代替，看一个个经典的 <code>C++</code> 宏错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buggy C++ macro to add 1 to a number</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ONE(n) n + 1</span></span><br></pre></td></tr></table></figure>

<p>大多数 <code>C++</code> 程序员很熟悉这个原因，像 <code>ADD_ONE(1)*10</code> 或 <code>ADD_ONE(1&lt;&lt;4)</code> 这样不起眼的代码在这个宏下会产生非常意想不到的结果。要解决这个问题，需要在宏定义中加入更多的括号。这在 <code>Rust</code> 中是没有必要的，因为 <code>Rust</code> 的宏与语言的集成度更高。<code>Rust</code> 知道它是如何处理表达式的，所以当它把一个表达式粘贴到另一个表达式上时，它就会自动添加有效的括号。</p>
<h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><p>标准的 <code>vec!</code> 有两种使用方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Repeat a value N times</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">buffer</span> = <span class="built_in">vec!</span>[<span class="number">0_u8</span>; <span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// A list of values, separated by commas</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="string">&quot;udon&quot;</span>, <span class="string">&quot;ramen&quot;</span>, <span class="string">&quot;soba&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>它可以被像下面这样实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ($elem:expr ; $n:expr) =&gt; &#123;</span><br><span class="line">        ::std::vec::<span class="title function_ invoke__">from_elem</span>($elem, $n)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &lt;[_]&gt;::<span class="title function_ invoke__">into_vec</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>([ $( $x ),* ]))</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ( $( $x:expr ),+ ,) =&gt; &#123;</span><br><span class="line">        <span class="built_in">vec!</span>[ $( $x ),* ]</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有 <code>3</code> 个规则，我们将解释多个规则如何工作，然后挨着解释。</p>
<p>当 <code>Rust</code> 展开宏 <code>vec![1, 2, 3]</code>，它首先使用第一个规则匹配 <code>1, 2, 3</code>。但是第一条规则中的 <code>$elem:expr ; $n:expr</code> 匹配失败，<code>1</code> 是一个表达式，但是要求其之后应该是一个 <code>;</code>，这里没有。所以 <code>Rust</code> 开始尝试第二条规则，如果所有规则尝试之后都没有匹配，就会报错。</p>
<p>第一条规则处理像 <code>vec![0u8; 1000]</code> 这样的用法。碰巧的是，有一个标准的碰巧有一个标准的函数，<code>std::vec::from_elem</code>，它正好做了这里所需要的事情，所以这条规则很简单。</p>
<p>第二条规则处理像 <code>vec![&quot;udon&quot;, &quot;ramen&quot;, &quot;soba&quot;]</code> 这样的用法，规则 <code>$( $x:expr ),*</code> 匹配 <code>0</code> 个或者多个有 <code>,</code> 分割的表达式。更一般地说，语法<code>$( PATTERN ),*</code> 用于匹配任何逗号分隔的列表，其中列表中的每一项都与 <code>PATTERN</code> 匹配。</p>
<p><code>*</code> 是一个重复符号，类似于正则表达式中，表示重复 <code>0</code> 个或者多个，而 <code>+</code> 相同，只是只是重复 <code>1</code> 个或者多个。</p>
<p>下面是 <code>Rust</code> 支持的重复规则：</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/macro-repeat-pattern.png" class="">

<p>示例中的 <code>$x</code> 不是一个单个的表达式，而是一个表达式列表，这个规则的模板也使用了重复的语法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&lt;[_]&gt;::<span class="title function_ invoke__">into_vec</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>([ $( $x ),* ]))</span><br></pre></td></tr></table></figure>

<p>这里也有标准的方法能够确切完成我们想要的工作，这里的代码创建了一个 <code>boxed</code> 数组，然后使用 <code>[T]::into_vec</code> 转换成一个 <code>vector</code>。第一点，<code>&lt;[_]&gt;</code>，是一种不寻常的写法，用来写 <strong>“某类型的切片”</strong> 类型，同时希望<code>Rust</code>能推断出元素的类型。普通标识符类型名称可以被用在表达式中，但是 <code>fn()</code>，<code>&amp;str</code>或者 <code>[_]</code> 必须由尖括号 <code>&lt;&gt;</code> 包裹。</p>
<p>重复出现在模板的最后，我们有 <code>$($x),*</code>，这个 <code>$(...),*</code> 与我们在模式中看到的语法相同。它遍历了我们为 <code>$x</code> 匹配的表达式列表，并将它们全部插入到模板中，用逗号分隔。 </p>
<p>在这种情况下，重复输出看起来就像输入一样，但情况不一定是这样的，我们可以把规则写成这样。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        $( v.<span class="title function_ invoke__">push</span>($x); )*</span><br><span class="line">        v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里，模板中读取 <code>$( v.push($x); )*</code> 的部分为 <code>$x</code> 中的每个表达式插入了对 <code>v.push()</code> 的调用。一个宏匹配规则可以扩展到一连串的表达式，但这里我们只需要一个表达式，所以我们把 <code>vector</code> 的组装包在一个块中。         </p>
<p>与 <code>Rust</code> 的其他部分不同，使用 <code>$( ...),*</code> 的模式不会自动支持可选的尾部逗号。然而，有一个标准的技巧来支持尾部逗号，那就是添加一个额外的规则，这就是我们的<code>vec！</code>宏的第三条规则的作用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">( $( $x:expr ),+ ,) =&gt; &#123; <span class="comment">// if trailing comma is present,</span></span><br><span class="line">    <span class="built_in">vec!</span>[ $( $x ),* ] <span class="comment">// retry without it</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>$( ...),+ ,</code> 来匹配一个带有额外逗号的列表。然后，在模板中，我们递归地调用 <code>vec!</code>，把多余的逗号留出来。这一次，第二条规则将被匹配。</p>
<h3 id="内建宏"><a href="#内建宏" class="headerlink" title="内建宏"></a>内建宏</h3><p><code>Rust</code> 编译器提供了几个宏，当定义自己的宏时，这些宏很有帮助。这些都不能单独使用 <code>macro_rules!</code> 来实，它们在 <code>rustc</code> 中是硬编码的。</p>
<ul>
<li><p><code>file!()</code>、<code>line!()</code>、<code>column!()</code>：<code>file!()</code> 展开成一个字符串字面量，表示当前文件的名称；<code>line!()</code> 和 <code>column!()</code> 扩展成 <code>u32</code> 字面量表示当前的行号和列号；</p>
<p>  如果一个宏调用另一个宏，而另一个宏又调用另一个宏，而且都在不同的文件中，最后一个宏调用 <code>file!()</code>、<code>line!()</code> 或 <code>column!()</code>，它将展开以指示第一个宏调用的位置。</p>
</li>
<li><p><code>stringify!(...tokens...)</code>：展开成一个包含给定标识的字符串字面量，<code>assert!</code> 宏使用它来生成一个错误信息，其中包括断言的代码。 </p>
<p>  参数中的宏调用不会被扩展：<code>stringify!(line!())</code> 会扩展为字符串 <code>&quot;line!()&quot;</code>。 <code>Rust</code> 从标示中构造字符串，所以字符串中没有换行或注释。</p>
</li>
<li><p><code>concat!(str0, str1, ...)</code>：将它的参数连接起来，展开成一个字符串；</p>
</li>
</ul>
<p><code>Rust</code> 还定义了一些查询环境变量的宏：</p>
<ul>
<li><p><code>cfg!(...)</code>：展开为一个布尔值，如果当前的编译配置符合括号中的条件，则为真。例如，如果你在编译时启用了调试断言，<code>cfg!(debug_assertions)</code> 则为真。 </p>
<p>  这个宏支持的语法与 <code>#[cfg(...)]</code> 属性完全相同，但你得到的不是条件性编译，而是一个真或假的值。</p>
</li>
<li><p><code>env!(&quot;VAR_NAME&quot;)</code>：展开成一个字符串：在编译时指定的环境变量的值，如果这个变量不存在，就是一个编译错误。         </p>
<p>  除了 <code>Cargo</code> 在编译时设置了几个有趣的环境变量外，这将是相当无用的。例如，要获得 <code>crate</code> 的当前版本字符串，可以这样写。  </p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">version</span> = <span class="built_in">env!</span>(<span class="string">&quot;CARGO_PKG_VERSION&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  环境变量的完整列表可以看 <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates"><code>Cargo Documentation</code></a>。</p>
</li>
<li><p><code>option_env!(&quot;VAR_NAME&quot;)</code>：和 <code>env!</code> 大致相同，除了返回 <code> Option&lt;&amp;&#39;static str&gt;</code>，所以如果设置的环境变量不存在，将返回 <code>None</code>；</p>
</li>
</ul>
<p>这里还有三个内建的宏可以将代码或者数据从另外的文件中包含进来：</p>
<ul>
<li><p><code>include!(&quot;file.rs&quot;)</code>：展开成指定文件的内容，必须是有效的 <code>Rust</code> 代码；</p>
</li>
<li><p><code>include_str!(&quot;file.txt&quot;)</code>：展开成指定文件的静态文本，类型是 <code>&amp;&#39;static str</code>，可以这样使用：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> COMPOSITOR_SHADER: &amp;<span class="type">str</span> = <span class="built_in">include_str!</span>(<span class="string">&quot;../resources/compositor.glsl&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  如果文件不存在或者不是有效的 <code>utf-8</code>，就会有编译错误。</p>
</li>
<li><p><code>include_bytes!(&quot;file.dat&quot;)</code>：这是和之前的相同的，只是被当做二进制数据，不是 <code>UTF-8</code> 文本，结果是 <code>&amp;&#39;static [u8]</code>；</p>
</li>
</ul>
<p>像所有的宏一样，这些都在编译时间处理，如果文件不存在那就编译失败，在所有的例子中，文件名称是一个相对路径，相对当前文件进行解析。</p>
<p><code>Rust</code> 还提供了几个我们之前没有介绍过的方便的宏：</p>
<ul>
<li><p><code>todo!()</code>、<code>unimplemented!()</code>：这些与 <code>panic!()</code> 等价，但表达了不同的意图。<code>unimplemented!()</code> 出现在 <code>if</code> 子句、匹配分支和其他尚未处理的情况中。<code>todo!()</code> 也是如此，但它传达的意思是，这段代码还没有写完；</p>
</li>
<li><p><code>matches!(value, pattern)</code>：将一个值与一个模式进行比较，如果匹配则返回真，否则返回假，这等同于写：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> value &#123;</span><br><span class="line">    pattern =&gt; <span class="literal">true</span>,</span><br><span class="line">    _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调试宏"><a href="#调试宏" class="headerlink" title="调试宏"></a>调试宏</h3><p>调试一个宏可能是一个挑战，最大的问题是缺乏对宏扩展过程的了解。<code>Rust</code> 经常会展开所有的宏，发现某种错误，然后打印一条错误信息，但并不显示包含错误的完全展开的代码。        </p>
<p>这里有三个工具可以帮助排除宏的故障。(这些功能都是不稳定的，但由于它们确实是被设计成在开发过程中使用，而不是在你要检查的代码中使用，所以在实践中这不是一个大问题)。            </p>
<p>首先，也是最简单的，你可以要求 <code>rustc</code> 显示你的代码在扩展所有宏之后的样子。使用 <code>cargo build --verbose</code> 来查看 <code>Cargo</code> 是如何调用 <code>rustc</code> 的。 复制 <code>rustc</code> 的命令行，并添加 <code>-Z unstable-options --pretty expanded</code> 作为选项，完全展开的代码会被输出终端。不幸的是，这只有在代码没有语法错误的情况下才有效。              </p>
<p>其次，<code>Rust</code> 提供了一个 <code>log_syntax!()</code> 宏，在编译时简单地将其参数打印到终端，可以用它来进行 <code>println!-style</code> 调试，这个宏需要 <code>#![feature(log_syntax)]</code>特性标志。           </p>
<p>第三，可以要求 <code>Rust</code> 编译器将所有宏调用打印到终端，在代码中插入<code>trace_macros!(true);</code>。从那时起，每次 <code>Rust</code> 展开一个宏时，它都会打印出宏的名称和参数，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code, unused_imports)]</span></span><br><span class="line"><span class="meta">#![feature(trace_macros)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    trace_macros!(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    trace_macros!(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;total: &#123;&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().sum::&lt;<span class="type">u64</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>note: trace_macro
--&gt; src/main.rs:6:19
|
6 |     let numbers = vec![1, 2, 3];
|                   ^^^^^^^^^^^^^
|
= note: expanding `vec! &#123; 1, 2, 3 &#125;`
= note: to `$crate :: __rust_force_expr! (&lt; [_] &gt; :: into_vec(box [1, 2, 3]))`
= note: expanding `__rust_force_expr! &#123; &lt; [_] &gt; :: into_vec(box [1, 2, 3]) &#125;`
= note: to `&lt;[_]&gt;::into_vec(box [1, 2, 3])`

    Finished dev [unoptimized + debuginfo] target(s) in 0.51s
    Running `target/debug/crosscompile`
total: 6
</code></pre>
<p>编译器展示了每个宏展开前后调用的代码，<code>trace_macros!(false);</code> 会关闭这个 <code>trace</code>，所以 <code>println!()</code> 展开的内容不会打印出来。</p>
<h3 id="构建-json"><a href="#构建-json" class="headerlink" title="构建 json!"></a>构建 <code>json!</code></h3><p>我们现在已经讨论了 <code>macro_rules!</code> 的核心功能! 在本节中，我们将逐步开发一个用于构建<code>JSON</code> 数据的宏。我们将用这个例子来说明宏的开发，介绍 <code>macro_rules!</code> 的其余部分，并提供一些建议以确保宏的行为符合要求。我们来看一个表示 <code>JSON</code> 数据的枚举：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">    Null,</span><br><span class="line">    <span class="title function_ invoke__">Boolean</span>(<span class="type">bool</span>),</span><br><span class="line">    <span class="title function_ invoke__">Number</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">String</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Array</span>(<span class="type">Vec</span>&lt;Json&gt;),</span><br><span class="line">    <span class="title function_ invoke__">Object</span>(<span class="type">Box</span>&lt;HashMap&lt;<span class="type">String</span>, Json&gt;&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不幸的是，写出 <code>Json</code> 值的语法相当冗长。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">students</span> = Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[</span><br><span class="line">    Json::<span class="title function_ invoke__">Object</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            (<span class="string">&quot;name&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">String</span>(<span class="string">&quot;Jim Blandy&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">            (<span class="string">&quot;class_of&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">Number</span>(<span class="number">1926.0</span>)),</span><br><span class="line">            (</span><br><span class="line">                <span class="string">&quot;major&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                Json::<span class="title function_ invoke__">String</span>(<span class="string">&quot;Tibetan throat singing&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            ),</span><br><span class="line">        ]</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>(),</span><br><span class="line">    )),</span><br><span class="line">    Json::<span class="title function_ invoke__">Object</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            (</span><br><span class="line">                <span class="string">&quot;name&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                Json::<span class="title function_ invoke__">String</span>(<span class="string">&quot;Jason Orendorff&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            ),</span><br><span class="line">            (<span class="string">&quot;class_of&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">Number</span>(<span class="number">1702.0</span>)),</span><br><span class="line">            (<span class="string">&quot;major&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">String</span>(<span class="string">&quot;Knots&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">        ]</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>(),</span><br><span class="line">    )),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>我们希望能用一种更类似 <code>JSON</code> 的语法来写这个：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">students</span> = json!([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jim Blandy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;class_of&quot;</span>: <span class="number">1926</span>,</span><br><span class="line">        <span class="string">&quot;major&quot;</span>: <span class="string">&quot;Tibetan throat singing&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jason Orendorff&quot;</span>,</span><br><span class="line">        <span class="string">&quot;class_of&quot;</span>: <span class="number">1702</span>,</span><br><span class="line">        <span class="string">&quot;major&quot;</span>: <span class="string">&quot;Knots&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>我们想要的是一个 <code>json!</code> 宏，它接受一个 <code>JSON</code> 值作为参数，并展开为一个像前面例子中的 <code>Rust</code> 表达式。</p>
<p>本节完整的代码可以看 <a href="https://github.com/ProgrammingRust/examples/tree/master/json-macro">https://github.com/ProgrammingRust/examples/tree/master/json-macro</a>。</p>
<h4 id="片段类型"><a href="#片段类型" class="headerlink" title="片段类型"></a>片段类型</h4><p>写入任何复杂宏的前提是指出如何匹配或解析所需的输入。</p>
<p>我们已经可以看到，这个宏会有几条规则，因为<code>JSON</code>数据中有几种不同的东西：对象、数组、数字，等等。事实上，我们可以猜测，我们将为每种<code>JSON</code> 类型制定一条规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macro_rules! json &#123;</span><br><span class="line">    (null) =&gt; &#123; Json::Null &#125;;</span><br><span class="line">    ([ ... ]) =&gt; &#123; Json::Array(...) &#125;;</span><br><span class="line">    (&#123; ... &#125;) =&gt; &#123; Json::Object(...) &#125;;</span><br><span class="line">    (???) =&gt; &#123; Json::Boolean(...) &#125;;</span><br><span class="line">    (???) =&gt; &#123; Json::Number(...) &#125;;</span><br><span class="line">    (???) =&gt; &#123; Json::String(...) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这并不完全正确，因为宏模式没有提供区分后三种情况的方法，但我们以后会看到如何处理这个问题。至少前三种情况显然是以不同的标记开始的，所以我们就从这些开始。第一条规则已经起作用了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> json &#123;</span><br><span class="line">    (null) =&gt; &#123;</span><br><span class="line">        Json::Null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">json_null</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(json!(null), Json::Null); <span class="comment">// passes!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了增加对 <code>JSON</code> 数组的支持，我们可以尝试将元素匹配为 <code>exprs</code>：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> json &#123;</span><br><span class="line">    (null) =&gt; &#123;</span><br><span class="line">        Json::Null</span><br><span class="line">    &#125;;</span><br><span class="line">    ([ $( $element:expr ),* ]) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[ $( $element ),* ])</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不幸的是，这并不符合所有的 <code>JSON</code> 数组，这里有一个测试，说明了这个问题。</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">json_array_with_json_element</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">macro_generated_value</span> = json!(</span><br><span class="line">    [</span><br><span class="line">    <span class="comment">// valid JSON that doesn&#x27;t match `$element:expr`</span></span><br><span class="line">    &#123; <span class="string">&quot;pitch&quot;</span>: <span class="number">440.0</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hand_coded_value</span> = Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[Json::<span class="title function_ invoke__">Object</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="built_in">vec!</span>[(<span class="string">&quot;pitch&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">Number</span>(<span class="number">440.0</span>))]</span><br><span class="line">            .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">            .<span class="title function_ invoke__">collect</span>(),</span><br><span class="line">    ))]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(macro_generated_value, hand_coded_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>表达式 <code>$( $element:expr ),*</code> 表示一个逗号分割的 <code>Rust</code> 表达式，但是许多 <code>JSON</code> 值，特别是 <code>JSON</code> 对象，不是有效的 <code>Rust</code> 表达式，它们不匹配。所以这里的 <code>&#123; &quot;pitch&quot;: 440.0 &#125;</code> 匹配失败。</p>
<p>由于不是每一段你想匹配的代码都是表达式，<code>Rust</code> 支持其他几种片段类型，如下图所示：</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/macro-rule-fragment-type.png" class="">

<p>表中的大多数选项都严格执行 <code>Rust</code> 语法。<code>expr</code> 类型只匹配 <code>Rust</code> 表达式（不是 <code>JSON</code> 值），<code>ty</code> 只匹配 <code>Rust</code> 类型，以此类推。它们是不可扩展的：没有办法定义新的算术运算符或 <code>expr</code> 可以识别的新关键字，我们将无法使其中任何一个匹配任意的 <code>JSON</code> 数据。               </p>
<p>最后两个，<code>ident</code> 和 <code>tt</code>，支持匹配看起来不像 <code>Rust</code> 代码的宏参数，<code>ident</code> 匹配任何标识符。<code>tt</code> 匹配一个单一的 <code>token</code>树：要么是一对提前匹配的括号，<code>(...)</code>，<code>[...]</code>，或 <code>&#123;...&#125;</code>，以及两者之间的一切，包括嵌套的标记树，或者不是括号的单一标记，如 <code>1926</code> 或 <code>&quot;Knots&quot;</code>。</p>
<p><code>token</code> 树正是我们的 <code>json!</code> 宏所需要的，每个 <code>JSON</code> 值都是一个单一的标记树：数字、字符串、布尔值和 <code>null</code> 都是单一的标记，对象和数组则用括号表示，所以我们可以这样写模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> json &#123;</span><br><span class="line">    </span><br><span class="line">    (null) =&gt; &#123;</span><br><span class="line">        Json::Null</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ([ $( $element:tt ),* ]) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Array</span>(...)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Object</span>(...)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ($other:tt) =&gt; &#123;</span><br><span class="line">        ... <span class="comment">// <span class="doctag">TODO:</span> Return Number, String, or Boolean</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本的 <code>json!</code> 宏可以匹配所有的 <code>JSON</code> 数据，现在我们只需要编写正确的<code>Rust</code>代码。          </p>
<p>为了确保 <code>Rust</code> 能够在未来获得新的语法特性而不破坏你现在编写的任何宏，<code>Rust</code> 限制了紧随片段之后出现在模式中的标记。上表中的 <code>&quot;Can be followed by...&quot;</code> 列显示了哪些标记被允许。例如，模式 <code>$x:expr ~ $y:expr</code> 是一个错误，因为 <code>~</code> 在 <code>expr</code> 后面是不允许的。模式 <code>$vars:pat =&gt; $handler:expr</code> 是可以的，因为 <code>$vars:pat</code> 后面是箭头 <code>=&gt;</code>，是 <code>pat</code> 允许的标记之一，而<code>$handler:expr</code> 后面是空的，这也是允许的。</p>
<h4 id="宏中的递归"><a href="#宏中的递归" class="headerlink" title="宏中的递归"></a>宏中的递归</h4><p>我们已经看到了一个宏调用自身的例子：我们对 <code>vec!</code> 的实现使用递归来支持尾部逗号。这里我们可以展示一个更重要的例子：<code>json!</code> 需要递归地调用自己。我们可以尝试在不使用递归的情况下支持 <code>JSON</code> 数组，像这样。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">([ $( $element:tt ),* ]) =&gt; &#123;</span><br><span class="line">    Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[ $( $element ),* ])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这并不可行，我们会把 <code>JSON</code> 数据（ <code>$elemen</code> 标记树）直接粘贴到 <code>Rust</code> 表达式中，它们是两种不同的语言。我们需要将数组的每个元素从 <code>JSON</code> 形式转换为 <code>Rust</code> 形式。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">([ $( $element:tt ),* ]) =&gt; &#123;</span><br><span class="line">    Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[ $( json!($element) ),* ])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>JSON</code> 对象可以按照这种方式支持：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">(&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;</span><br><span class="line">    Json::<span class="title function_ invoke__">Object</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[</span><br><span class="line">        $( ($key.<span class="title function_ invoke__">to_string</span>(), json!($value)) ),*</span><br><span class="line">    ].<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器对宏施加了一个递归限制。默认情况下是 <code>64</code> 个调用。这对于 <code>json</code> 的正常使用是绰绰有余的，但复杂的递归宏有时会触及这个限制。可以通过在使用宏的 <code>crate</code> 顶部添加下面这个属性来调整它。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![recursion_limit = <span class="string">&quot;256&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>至此 <code>json!</code> 宏已经接近完成，剩下的就是支持布尔值、数字和字符串值了。</p>
<h4 id="使用-Trait"><a href="#使用-Trait" class="headerlink" title="使用 Trait"></a>使用 <code>Trait</code></h4><p>在这里，我们需要支持 <code>json!(true)</code>、<code>json!(1.0)</code> 和 <code>json!(&quot;yes&quot;)</code>，将值转换为适当类型的 <code>Json</code> 值，但是宏并不擅长区分类型，我们可以想象一下写成这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> json &#123;</span><br><span class="line">    (<span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法马上就被证明是错的，只有两个布尔值，但比这更多的数字，甚至更多的字符串。幸运的是，有一种标准的方法可以将各种类型的值转换为一种指定的类型：<code>From</code>，我们只需要为一些类型实现这个特性。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">bool</span>&gt; <span class="keyword">for</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(b: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> Json &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Boolean</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Json &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Number</span>(i <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Json &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">String</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; <span class="built_in">From</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; <span class="keyword">for</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> Json &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">String</span>(s.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，所有<code>12</code>种数字类型都应该有非常相似的实现，所以写一个宏可能是有意义的，只是为了避免复制和粘贴。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> impl_from_num_for_json &#123;</span><br><span class="line">    ( $( $t:ident )* ) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="keyword">impl</span> <span class="title class_">From</span>&lt;$t&gt; <span class="keyword">for</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">                <span class="keyword">fn</span> <span class="title function_">from</span>(n: $t) <span class="punctuation">-&gt;</span> Json &#123;</span><br><span class="line">                    Json::<span class="title function_ invoke__">Number</span>(n <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )*</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl_from_num_for_json!(<span class="type">u8</span> <span class="type">i8</span> <span class="type">u16</span> <span class="type">i16</span> <span class="type">u32</span> <span class="type">i32</span> <span class="type">u64</span> <span class="type">i64</span> <span class="type">u128</span> <span class="type">i128</span> <span class="type">usize</span> <span class="type">isize</span> <span class="type">f32</span> <span class="type">f64</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们可以使用 <code>Json::from(value)</code> 来将任何支持的类型的值转换为 <code>Json</code>。在我们的宏中，它看起来会是这样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">( $other:tt ) =&gt; &#123;</span><br><span class="line">    Json::<span class="title function_ invoke__">from</span>($other) <span class="comment">// Handle Boolean/number/string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把这个规则添加到我们的 <code>json!</code> 宏中，使它通过我们到目前为止所写的所有测试。把所有的部分组合起来，目前看起来是这样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> json &#123;</span><br><span class="line">    (null) =&gt; &#123;</span><br><span class="line">        Json::Null</span><br><span class="line">    &#125;;</span><br><span class="line">    ([ $( $element:tt ),* ]) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[ $( json!($element) ),* ])</span><br><span class="line">    &#125;;</span><br><span class="line">    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">Object</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[</span><br><span class="line">            $( ($key.<span class="title function_ invoke__">to_string</span>(), json!($value)) ),*</span><br><span class="line">        ].<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>()))</span><br><span class="line">    &#125;;</span><br><span class="line">    ( $other:tt ) =&gt; &#123;</span><br><span class="line">        Json::<span class="title function_ invoke__">from</span>($other) <span class="comment">// Handle Boolean/number/string</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实证明，这个宏出乎意料地支持在 <code>JSON</code> 数据中使用变量，甚至是任意的 <code>Rust</code> 表达式，这是一个方便的额外功能。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">width</span> = <span class="number">4.0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">desc</span> =</span><br><span class="line">json!(&#123;</span><br><span class="line">    <span class="string">&quot;width&quot;</span>: width,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: (width * <span class="number">9.0</span> / <span class="number">4.0</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为 <code>(width * 9.0 / 4.0)</code> 是括号内的，它是一个单一的 <code>token</code> 树，所以宏在解析对象时成功地将其与 <code>$value:tt</code> 相匹配。</p>
<h4 id="Scoping-and-Hygiene"><a href="#Scoping-and-Hygiene" class="headerlink" title="Scoping and Hygiene"></a><code>Scoping and Hygiene</code></h4><p>接下来介绍了 <code>Rust</code> 处理范围的两种方式：一种方式用于局部变量和参数，另一种方式用于其他所有内容。为了说明为什么这很重要，让我们重写解析 <code>JSON</code> 对象的规则（前面显示的 <code>json!</code> 宏中的第三条规则）以消除临时向量，我们可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">(&#123; $($key:tt : $value:tt),* &#125;) =&gt; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fields</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HashMap::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        $( fields.<span class="title function_ invoke__">insert</span>($key.<span class="title function_ invoke__">to_string</span>(), json!($value)); )*</span><br><span class="line">        Json::<span class="title function_ invoke__">Object</span>(fields)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们不是通过使用 <code>collect()</code> 而是通过重复调用 <code>.insert()</code> 方法来填充 <code>HashMap</code>。这意味着我们需要将 <code>map</code> 存储在一个临时变量中，我们称之为<code>fields</code>。如果在调用 <code>json!</code> 的地方正好有个临时变量 <code>fields</code> 会如何？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">fields</span> = <span class="string">&quot;Fields, W.C.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">role</span> = json!(&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Larson E. Whipsnade&quot;</span>,</span><br><span class="line">    <span class="string">&quot;actor&quot;</span>: fields</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>宏展开会将两处代码粘贴在一起，但是两处都使用的 <code>fields</code> 是不同的，就像：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">fields</span> = <span class="string">&quot;Fields, W.C.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">role</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fields</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HashMap::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    fields.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;name&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Larson E. Whipsnade&quot;</span>));</span><br><span class="line">    fields.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;actor&quot;</span>.<span class="title function_ invoke__">to_string</span>(), Json::<span class="title function_ invoke__">from</span>(fields));</span><br><span class="line">    Json::<span class="title function_ invoke__">Object</span>(fields)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的宏正常工作，<code>Rust</code> 重命名变量。这个功能首先在 <code>Scheme</code> 宏中实现，称为<code>hygiene</code>，因此据说 <code>Rust</code> 具有 <code>hygienic macros</code>，理解宏 <code>hygiene</code> 的最简单方法是想象每次展开宏时，来自宏本身的扩展部分都被涂上不同的颜色。</p>
<p>然后，不同颜色的变量被视为具有不同的名称：</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/hygiene-macro.png" class="">

<p>注意，由宏调用者传入并粘贴到输出中的代码位，如 <code>&quot;name&quot;</code> 和 <code>&quot;actor&quot;</code>，保持其原始颜色（黑色），只有源自宏模板的 <code>token</code> 被换装。         </p>
<p>现在有一个名为 <code>fields</code> 的变量（在调用者中声明）和一个名为 <code>fields</code> 的单独变量（由宏引入）。由于名字是不同的颜色，这两个变量不会被混淆。         </p>
<p>如果一个宏真的需要引用调用者范围内的一个变量，调用者必须把这个变量的名字传给宏。     </p>
<p>你可能已经注意到，随着宏的展开，许多其他标识符被涂上一种或多种颜色。例如，<code>Box</code>、<code>HashMap</code> 和 <code>Json</code>。尽管被涂上了颜色，<code>Rust</code>在识别这些类型名称时并没有遇到困难。这是因为 <code>Rust</code> 中的 <code>hygiene</code> 被限制在局部变量和参数上。当涉及到常量、类型、方法、模块、状态和宏名称时，<code>Rust</code> 是<mark class="label ">色盲</mark>的。        </p>
<p>这意味着，如果我们的 <code>json!</code> 宏在一个模块中使用，而<code>Box</code>、<code>HashMap</code>或<code>Json</code>不在范围内，那么这个宏就不能工作。</p>
<p>首先，我们将考虑一种情况，即 <code>Rust</code> 的严格 <code>hygiene</code> 规定会妨碍我们的工作，而我们需要绕过它，假设我们有很多函数都包含这一行代码。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">req</span> = ServerRequest::<span class="title function_ invoke__">new</span>(server_socket.<span class="title function_ invoke__">session</span>());</span><br></pre></td></tr></table></figure>

<p>假设我们改为用宏：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> setup_req &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">req</span> = ServerRequest::<span class="title function_ invoke__">new</span>(server_socket.<span class="title function_ invoke__">session</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_http_request</span>(server_socket: &amp;ServerSocket) &#123;</span><br><span class="line">    setup_req!(); <span class="comment">// declares `req`, uses `server_socket`</span></span><br><span class="line">    ... <span class="comment">// code that uses `req`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>正如所写，这不起作用。它需要宏中的名称 <code>server_socket</code> 来引用函数中声明的本地 <code>server_socket</code>，变量 <code>req</code> 反之亦然。但是<code>hygiene</code> 可以防止宏中的名称与其他范围内的名称冲突。</p>
<p>解决方案是将计划在宏代码内部和外部使用的任何标识符传递给宏：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> setup_req &#123;</span><br><span class="line">    ($req:ident, $server_socket:ident) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> $req = ServerRequest::<span class="title function_ invoke__">new</span>($server_socket.<span class="title function_ invoke__">session</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_http_request</span>(server_socket: &amp;ServerSocket) &#123;</span><br><span class="line">    setup_req!(req, server_socket);</span><br><span class="line">    ... <span class="comment">// code that uses `req`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为 <code>req</code> 和 <code>server_socket</code> 现在是由函数提供的，它们是该范围的正确”颜色”。     </p>
<h4 id="宏的导入和导出"><a href="#宏的导入和导出" class="headerlink" title="宏的导入和导出"></a>宏的导入和导出</h4><p>由于宏在编译的早期就被展开了，在 <code>Rust</code> 知道你项目的完整模块结构之前，编译器就有了导出和导入它们的特殊功能。</p>
<p>在一个模块中可见的宏在其子模块中自动可见，要将宏从模块向上导出到其父模块，请使用 <code>#[macro_use] </code>属性。例如，假设我们的 <code>lib.rs</code> 看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span> <span class="keyword">mod</span> macros;</span><br><span class="line"><span class="keyword">mod</span> client;</span><br><span class="line"><span class="keyword">mod</span> server;</span><br></pre></td></tr></table></figure>

<p>在 <code>macros</code> 模块中定义的所有宏都导入到 <code>lib.rs</code> 中，因此在包的其余部分中可见，包括在 <code>client</code> 和 <code>server</code> 中。</p>
<p>标有 <code>#[macro_export]</code> 的宏是自动发布的，可以像其他项目一样通过路径引用。   </p>
<p>例如，<code>lazy_static</code> 提供了一个名为 <code>lazy_static</code> 的宏，它被标记为 <code>#[macro_export]</code>。要使用这个宏，你可以写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line">lazy_static!&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>一旦被导入，他就可以像其他的任何导入一样使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> m &#123;</span><br><span class="line">    crate::lazy_static!&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，实际做这些事情意味着你的宏可能被其他模块调用。因此，一个导出的宏不应该依赖于任何在范围内的东西。不知道在它被使用的地方会有什么在作用域内，即使是标准预导入的功能也会被屏蔽。       </p>
<p><code>macro_rules</code> 提供了特殊 <code>$crate</code> 来帮助解决这个问题。这与 <code>crate</code> 不同，<code>crate</code> 是一个关键词，可以在任何地方用于路径，而不仅仅是在宏中。<code>$crate</code> 的作用就像一个绝对路径，指向定义宏的 <code>crate</code> 的根模块。我们不能写成 <code>Json</code>，而写成 <code>$crate::Json</code>，即使 <code>Json</code> 没有被导入，它也能发挥作用。<code>HashMap</code> 可以改成 <code>::std::collections::HashMap</code> 或者<code>$crate::macros::HashMap</code> 。在后一种情况下，我们必须重新导出 <code>HashMap</code>，因为 <code>$crate</code> 不能被用来访问 <code>crate</code> 的私有特性。</p>
<p>来看下我们最终版本的 <code>json!</code>：</p>
<figure class="highlight rust"><figcaption><span>macros.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> std::boxed::<span class="type">Box</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> std::string::<span class="built_in">ToString</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> json &#123;</span><br><span class="line">    (null) =&gt; &#123;</span><br><span class="line">        $crate::Json::Null</span><br><span class="line">    &#125;;</span><br><span class="line">    ([ $( $element:tt ),* ]) =&gt; &#123;</span><br><span class="line">        $crate::Json::<span class="title function_ invoke__">Array</span>(<span class="built_in">vec!</span>[ $( json!($element) ),* ])</span><br><span class="line">    &#125;;</span><br><span class="line">    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fields</span> = $crate::macros::<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                $crate::macros::HashMap::<span class="title function_ invoke__">new</span>());</span><br><span class="line">            $(</span><br><span class="line">                fields.<span class="title function_ invoke__">insert</span>($crate::macros::<span class="built_in">ToString</span>::<span class="title function_ invoke__">to_string</span>($key),</span><br><span class="line">                              json!($value));</span><br><span class="line">            )*</span><br><span class="line">            $crate::Json::<span class="title function_ invoke__">Object</span>(fields)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ($other:tt) =&gt; &#123;</span><br><span class="line">        $crate::Json::<span class="title function_ invoke__">from</span>($other)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>.to_string()</code> 方法是标准 <code>ToString</code> 的一部分，我们也用 <code>$crate</code> 来引用它，使用”完全限定的方法调用”语法：<code>$crate::macros::ToString::to_string($key)</code>。在我们的例子中，这对于宏的工作并不是严格必要的，因为 <code>ToString</code> 是在标准的预导入中。但是如果你要调用一个 <code>Trait</code> 的方法，而这个 <code>Trait</code> 在调用宏的时候可能不在范围内，那么完全限定的方法调用是最好的方式。</p>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>下面的宏只是看起来合理：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> complain &#123;</span><br><span class="line">    ($msg:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Complaint filed: &#123;&#125;&quot;</span>, $msg);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    (user : $userid:tt , $msg:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Complaint from user &#123;&#125;: &#123;&#125;&quot;</span>, $userid, $msg);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>假设我们这样调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">complain!(user: <span class="string">&quot;jimb&quot;</span>, <span class="string">&quot;the AI lab&#x27;s chatbots keep picking on me&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在我们看来，这显然与第二个模式相匹配。但是<code>Rust</code>首先尝试了第一条规则，试图用<code>$msg:expr</code>来匹配所有的输入。但是 <code>user: &quot;jimb&quot;</code> 不是一个表达式，所以我们得到了一个语法错误。<code>Rust</code> 拒绝把语法错误传递到下面–宏已经够难调试了。相反，它会被立即报告并停止编译。   </p>
<p>如果一个模式中的任何其他标记不能匹配，<code>Rust</code> 就会进入下一个规则。只有语法错误是致命的，而且只在试图匹配片段时发生。   </p>
<p>这里的问题并不难理解：我们正试图在错误的规则中匹配一个片段 <code>$msg:expr</code>。它不会被匹配，调用者其实想要匹配另一条规则，有两个简单的方法来避免这种情况。     </p>
<p>首先，避免易混淆的规则。例如，我们可以改变宏，使每个模式以不同的标识符开始。</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> complain &#123;</span><br><span class="line">    (msg : $msg:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Complaint filed: &#123;&#125;&quot;</span>, $msg);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    (user : $userid:tt , msg : $msg:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Complaint from user &#123;&#125;: &#123;&#125;&quot;</span>, $userid, $msg);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当宏参数以 <code>msg</code> 开头时，将匹配规则 <code>1</code>。当它们以 <code>user</code> 开头时，将匹配规则<code>2</code>。无论哪种方式，我们都知道在尝试匹配片段之前我们已经获得了正确的规则。</p>
<p>避免虚假语法错误的另一种方法是首先放置更具体的规则，将 <code>user:</code> 规则放在第一个，就能解决了 <code>complain!</code> 的问题，因为导致语法错误的规则永远不会到达。</p>
<h3 id="不止-macro-rules"><a href="#不止-macro-rules" class="headerlink" title="不止 macro_rules!"></a>不止 <code>macro_rules!</code></h3><p>宏模式可以解析比 <code>JSON</code> 更复杂的输入，但我们发现复杂性很快就会失控。          </p>
<p><a href="https://danielkeep.github.io/tlborm/book/">《Rust Macros小书》</a>是一本优秀的高级 <code>macro_rules!</code> 编程手册。这本书清晰明了，而且比我们这里更详细地描述了宏展开的每一个方面。它还介绍了几种非常聪明的技术，将 <code>macro_rules!</code> 模式作为一种神秘的编程语言来使用，以解析复杂的输入。      </p>
<p><code>Rust 1.15</code> 引入了一个单独的机制，叫做过程宏，它支持扩展 <code>#[derive]</code> 属性以处理自定义派生，如下图所示，也支持创建自定义属性和新的宏，其调用方式与前面讨论的 <code>macro_rules!</code> 宏一样。</p>
<img data-src="/2022/04/19/%E3%80%90Rust%E3%80%91%E5%AE%8F/derive-macro.png" class="">

<p>实际上没有 <code>IntoJson</code>，但这并不重要：过程宏可以使用这个钩子来插入任何它想要的代码（在这种情况下，可能是 <code>impl From&lt;Money&gt; for Json &#123; ... &#125;</code>）。         </p>
<p>过程宏是作为<code>Rust</code>的一个函数来实现的，而不是一个声明性的规则集。这个函数通过一个薄薄的抽象层与编译器交互，可以是任意复杂的。例如，<a href="https://crates.io/crates/diesel"><code>diesel</code></a>使用过程宏来连接数据库，并在编译时根据该数据库的模式生成代码。          </p>
<p>由于过程宏与编译器内部相互作用，编写有效的宏需要对编译器的运行方式有所了解，<a href="https://www.rustwiki.org.cn/zh-CN/book/ch19-06-macros.html">可以在这里寻找你想要的</a>。</p>
<p>也许，在阅读了这些内容之后，更不想用宏。另一个选择是使用<a href="https://www.rustwiki.org.cn/zh-CN/cargo/reference/build-scripts.html">构建脚本</a>来生成 <code>Rust</code> 代码，<code>Cargo</code> 文档显示了如何一步一步地做到这一点。它包括编写一个程序来生成你想要的 <code>Rust</code>代码，在<code> Cargo.toml</code> 中添加一行，作为构建过程的一部分来运行该程序，并使用 <code>include!</code> 来将生成的代码放入你的<code>crate</code>中。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】常用 Trait</title>
    <url>/2022/05/29/%E3%80%90Rust%E3%80%91%E5%B8%B8%E7%94%A8-Trait/</url>
    <content><![CDATA[<p><code>Rust</code> 中的 <code>Trait</code> 可以分为三类：</p>
<ol>
<li><p>语言扩展 <code>Trait</code>：主要用于运算符重载，我们可以将常用的运算符使用在自己的类型之中，只要相应的 <code>Trait</code> 即可，例如 <code>Eq</code>，<code>AddAssign</code>，<code>Dere</code>，<code>Drop</code> 以及 <code>From</code> 和 <code>Into</code> 等；</p>
</li>
<li><p>标记类型 <code>Trait</code>：这些 <code>Trait</code> 主要用于绑定泛型类型变量，以表达无法以其他方式捕获的约束，这些包括 <code>Sized</code> 和 <code>Copy</code>；</p>
</li>
<li><p>剩下的主要是一些为解决常遇到的问题，例如：<code>Default</code>，<code>AsRef</code>，<code>AsMut</code>，<code>Borrow</code>，<code>BorrowMut</code>，<code>TryFrom</code> 和 <code>TryInto</code>；</p>
</li>
</ol>
<h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a><code>Drop</code></h3><p><code>Rust</code> 中当一个值离开作用域时就会对它的内存进行清理，但是所有权转移不会，这类似于 <code>C++</code> 中的析构函数。在 <code>Rust</code> 中我们也可以对析构的过程进行自定义，只要实现 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html"><code>std::ops::Drop</code></a> 即可，在值需要清理的时候会自动调用 <code>drop</code> 函数，不能显示调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Drop</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常不需要实现 <code>std::ops::Drop</code>，除非定义了一个拥有 <code>Rust</code> 不知道的资源的类型。 例如，在 <code>Unix</code> 系统上，<code>Rust</code> 的标准库在内部使用以下类型来表示操作系统文件描述符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FileDesc</span> &#123;</span><br><span class="line">    fd: c_int,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.rs/fd/0.2.1/src/fd/.cargo/registry/src/github.com-1ecc6299db9ec823/fd-0.2.1/src/lib.rs.html#57-63"><code>FileDesc</code></a> 的 <code>fd</code> 字段只是程序完成时应该关闭的文件描述符的编号，<code>c_int</code> 是 <code>i32</code> 的别名。标准库为 <code>FileDesc</code> 实现 <code>Drop</code> 如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FileDesc</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.close_on_drop &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; ::libc::<span class="title function_ invoke__">close</span>(<span class="keyword">self</span>.fd); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>libc::close</code> 是 <code>C</code> 库关闭函数的 <code>Rust</code> 名称，<code>Rust</code> 仅能在 <code>unsafe</code> 块中调用 <code>C</code> 函数。</p>
<p>如果一个类型实现了 <code>Drop</code>，它就不能实现 <code>Copy</code>，如果类型可 <code>Copy</code>，则意味着简单的逐字节复制足以生成该值的独立副本，但是在相同的数据上多次调用相同的 <code>drop</code> 方法通常是错误的。</p>
<p>标准库预包含的 <a href="https://doc.rust-lang.org/stable/std/mem/fn.drop.html"><code>drop</code></a> 函数可以显示删除一个值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">drop</span>(v); <span class="comment">// explicitly drop the vector</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Sized"><a href="#Sized" class="headerlink" title="Sized"></a><code>Sized</code></h3><p><code>Sized</code> 类型表明了它的内存在编译时确定的，该类型的所有值大小相等，<code>Rust</code> 中几乎所有类型大小确定，<code>u64</code> 占 <code>8</code> 个字节，<code> (f32, f32, f32)</code> 占 <code>12</code> 个字节，枚举也是大小确定的，它的大小能够容纳最大的项，对于 <code>Vec&lt;T&gt;</code>，尽管它拥有一个大小可变的堆内存，但就其自身而言，包含了指向堆的指针，容量和长度，所以它也是 <code>Sized</code>。</p>
<p>所有的 <code>Sized</code> 类型都实现了 <code>std::marker::Sized</code>，这个 <code>Trait</code> 没有任何方法和关联的类型，我们也不需要手动实现，<code>Rust</code> 会为所有适用的类型自动实现，<code>Sized</code> 类型唯一的用途是泛型的边界。</p>
<p><code>Rust</code> 内部也有一些 <code>unsized</code> 类型，它们的值大小不一，例如 <code>str</code>，字符串 <code>slice</code>，它的值大小不确定，<code>&quot;diminutive&quot;</code> 和 <code>&quot;big&quot;</code> 都是 <code>str</code> 类型，但是它们分别占用 <code>10</code> 和 <code>3</code> 个字节。数组 <code>slice</code>，<code>[T]</code> 也是 <code>unsized</code>，一个共享引用 <code>&amp;[u8]</code> 可以指向任何大小的 <code>[u8]</code>。<code>str</code> 和 <code>[T]</code> 都表示一个变长的数据集合，大小不定。</p>
<img data-src="/2022/05/29/%E3%80%90Rust%E3%80%91%E5%B8%B8%E7%94%A8-Trait/sized-unszied.png" class="">

<p>另外一种是 <code>dyn Trait</code> 类型，由于 <code>Trait</code> 可能指向多种类型，所以它的大小是不确定的，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">writer</span>: <span class="keyword">dyn</span> Write = buf; <span class="comment">// error: `Write` does not have a constant size</span></span><br></pre></td></tr></table></figure></div>

<p>但是 <code>&amp;dyn Trait</code>，包含指向实现 <code>Trait</code> 的值和一个指向拥有该值类型方法表的指针，所以它的大小是确定的，详细请看 <a href="/2022/04/29/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/#trait-%E5%AF%B9%E8%B1%A1"><code>Trait</code>对象</a>。</p>
<p><code>Rust</code> 不能将 <code>unsized</code> 值存储到变量或者传递给参数，唯一能使用它们的方式是使用指针，例如：<code>&amp;str</code> 和 <code>Box&lt;dyn Write&gt;</code>，指向 <code>unsized</code> 值的指针是胖指针，包含了指向值的指针和 <code>size</code> 信息。</p>
<p>因为 <code>unsized</code> 类型限制比较多，所以大多数泛型都是 <code>sized</code> 类型，而且为了方便，<code>Rust</code> 隐式设置泛型是 <code>Sized</code>。例如，如果你写了 <code>struct S&lt;T&gt; &#123;...&#125;</code>，<code>Rust</code> 会自动加上 <code>Sized</code> 限制 <code>struct S&lt;T: Sized&gt; &#123;...&#125;</code>。如果不想这样做，可以显示设置 <code>struct S&lt;T: ?Sized&gt;</code>，<code>?Sized</code> 表明的意思是<strong>没必要是<code>Sized</code>，那也就是既可以是，也可以不是</strong>。因此，如果定义了泛型 <code>struct S&lt;T: ?Sized&gt; &#123; b: Box&lt;T&gt; &#125;</code>，<code>Rust</code> 允许我们为 <code>str</code> 和 <code>dyn Write</code> 实现该类型，例如，<code>S&lt;str&gt;</code> 和 <code>S&lt;dyn Write&gt;</code>，<code>b</code> 在这里包含了一个胖指针；以及 <code>S&lt;i32&gt;</code> 和 <code>S&lt;String&gt;</code>，<code>b</code> 包含一个普通指针。</p>
<p>除了 <code>slice</code> 和 <code>Trait</code> 之外，这里还有一种 <code>unsized</code> 类型。结构体的最后一个字段，也只能最后一个字段，可以是 <code>unszied</code>，这样的结构体也就是 <code>unsized</code>。我们看 <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> 的实现中使用到的 <code>RcBox&lt;T&gt;</code> 类型的定义（该类型未导出）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RcBox</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    strong: Cell&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">    weak: Cell&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">    value: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将 <code>RcBox</code> 用于 <code>Sized</code> 类型，如：<code>RcBox&lt;String&gt;</code>，也可以用于 <code>unszied</code> 类型，例如：<code>RcBox&lt;dyn std::fmt::Display&gt;</code>，但是我们不能直接创建 <code>RcBox&lt;dyn std::fmt::Display&gt;</code>，而是先要创建一个实现了 <code>Display</code> 的类型，例如 <code>RcBox&lt;String&gt;</code>，然后再将 <code>&amp;RcBox&lt;String&gt;</code> 转换成 <code>&amp;RcBox&lt;dyn Display&gt;</code>，这个转换在传递给函数的时候还会隐式进行：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RcBox</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    strong: Cell&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">    weak: Cell&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">    value: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(boxed: &amp;RcBox&lt;<span class="keyword">dyn</span> Display&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;For your enjoyment: &#123;&#125;&quot;</span>, &amp;boxed.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">boxed_lunch</span>: RcBox&lt;<span class="type">String</span>&gt; = RcBox &#123;</span><br><span class="line">        strong: Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">        weak: Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">        value: <span class="string">&quot;Michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">boxed_displayable</span>: &amp;RcBox&lt;<span class="keyword">dyn</span> Display&gt; = &amp;boxed_lunch;</span><br><span class="line">    <span class="title function_ invoke__">display</span>(boxed_displayable);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;boxed_lunch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a><code>Clone</code></h3><p><a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html"><code>std::clone::Clone</code></a> 用于类型副本的创建，它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone_from</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, source: &amp;<span class="keyword">Self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = source.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Clone</code> 扩展了 <code>Sized</code>，这意味着实现着都必须是 <code>Sized</code>，<code>clone</code> 方法构造了一个新的副本并且返回。</p>
<p><code>clone</code> 值成本很高，体现在时间和内存上，例如，要克隆 <code>Vec&lt;String&gt;</code>，要复制其中的每个 <code>String</code>，所以 <code>Rust</code> 不会自动进行 <code>clone</code>，而是需要我们显示进行方法调用。这里有个例外就是 <code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>，它们只是简单地增加引用计数。</p>
<p><code>clone_from</code> 是根据 <code>source</code> 覆盖自身，工作过程就是先克隆 <code>t</code>，然后赋值给 <code>*self</code>，并且将 <code>self</code> 原来的值丢掉。这有时候成本很高，例如 <code>s</code> 和 <code>t</code> 都是 <code>String</code>，但是如果 <code>s</code> 的 <code>buffer</code> 有足够的容量容纳 <code>t</code>，只需要将 <code>t</code> 中的内容逐个复制，然后调整 <code>s</code> 的长度，所以 <code>clone_from</code> 尽可能使用优化实现。</p>
<p>如果 <code>Clone</code> 实现只是将 <code>clone</code> 应用于类型的每个字段或元素，然后从这些克隆中构造一个新值，并且 <code>clone_from</code> 的默认定义足够好，那么可以使用 <code>#[derive(Clone )]</code> 自动实现。</p>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a><code>Copy</code></h3><p>赋值操作在大多数时候会将值移动并且让原来的值变成未初始化，但是，对于简单的值，赋值操作会自动生成产生一个副本。例如，<code>People</code> 未实现 <code>Copy</code>，所以会转移值的所有权，而简单整数则会赋值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    age: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = People &#123; age: <span class="number">128</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1); <span class="comment">// 不能打印p，因为他已经处于未初始化，它的值被move</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span> = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n2</span> = n1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;n1: &#123;&#125;, n2: &#123;&#125;&quot;</span>, n1, n2); <span class="comment">// n1 被复制，仍然可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们可以通过 <a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html"><code>std::marker::Copy</code></a> 告诉 <code>Rust</code>我们的类型是支持 <code>Copy</code> 的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    age: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Copy</code> 只是一个标记，它扩展了 <code>Clone</code>，但没有任何方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Copy</span>: <span class="built_in">Clone</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>但是因为 <code>Copy</code> 是一种对语言具有特殊意义的标记 <code>trait</code>，<code>Rust</code> 只允许一个类型实现 <code>Copy</code>，前提是它可以按字节复制。拥有任何其他资源（如堆缓冲区或操作系统句柄）的类型无法实现 <code>Copy</code>。</p>
<p>实现了 <code>Drop</code> 的类型也不能 <code>Copy</code>，<code>Rust</code> 认为一个类型如果需要特殊清理，那么它就需要特殊复制。</p>
<h3 id="Deref、DerefMut"><a href="#Deref、DerefMut" class="headerlink" title="Deref、DerefMut"></a><code>Deref</code>、<code>DerefMut</code></h3><p>我们可以通过实现 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>std::ops::Deref</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>std::ops::DerefMut</code></a> 来自定义 <code>*</code> 操作符的逻辑。这两个 <code>trait</code> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?<span class="built_in">Sized</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">DerefMut</span>: Deref &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们熟悉的 <code>Box&lt;T&gt;</code> 和 <code>Rc&lt;T&gt;</code> 就实现它们，以至于它们能变现的像内建的指针一样，例如 <code>&amp;Box&lt;T&gt;</code> 实际上返回的是 <code>&amp;T</code>。</p>
<p><code>Deref</code> 和 <code>DerefMut</code> 的另一个重要功能是它们能够实现将 <code>&amp;Self</code> 引用自动转换为 <code>&amp;Self::Target</code>。这样，当我们使用 <code>*</code> 或者 <code>.</code> 运算符时发现类型不匹配，<code>Rust</code> 会为我们自动插入 <code>deref</code> 或者 <code>deref_mut</code> 调用，这在某些场景中很方便，例如：</p>
<ul>
<li><p>如果我们有 <code>Rc&lt;String&gt;</code> 的值 <code>r</code>，并且想使用 <code>String::find</code>，我们可以简单的调用 <code>r.find(&#39;?&#39;)</code> 而不是 <code>(*r).find(&#39;?&#39;)</code>，这个方调用隐式借用 <code>r</code>，<code>&amp;Rc&lt;String&gt;</code> 转换成了 <code>&amp;String</code>；</p>
</li>
<li><p>我们可以使用 <code>split_at</code> 这些属于 <code>String</code> 的方法在 <code>[str]</code> 类型上，因为 <code>String</code> 实现了 <code>Deref&lt;Target=str&gt;</code>，所以我们可以从 <code>&amp;String</code> 直接转换成 <code>&amp;str</code>；</p>
</li>
<li><p>我们可以将 <code>&amp;Vec&lt;T&gt;</code> 传递给参数是 <code>&amp;[T]</code> 的类型，因为 <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=T&gt;</code>；</p>
</li>
</ul>
<p>如果有必要，<code>Rust</code> 可以连续应用 <code>deref</code>，例如我们可以将 <code>&amp;Rc&lt;String&gt;</code> 直接转换成 <code>&amp;String</code>，又可以直接转换成 <code>&amp;str</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::&#123;Deref, DerefMut&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Selector</span>&lt;T&gt; &#123;</span><br><span class="line">    elements: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Selector</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.elements[<span class="keyword">self</span>.current]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">Selector</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.elements[<span class="keyword">self</span>.current]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Selector &#123;</span><br><span class="line">        elements: <span class="built_in">vec!</span>[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">        current: <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Because `Selector` implements `Deref`, we can use the `*` operator to</span></span><br><span class="line">    <span class="comment">// refer to its current element.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(*s, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert that &#x27;z&#x27; is alphabetic, using a method of `char` directly on a</span></span><br><span class="line">    <span class="comment">// `Selector`, via deref coercion.</span></span><br><span class="line">    <span class="built_in">assert!</span>(s.<span class="title function_ invoke__">is_alphabetic</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the &#x27;z&#x27; to a &#x27;w&#x27;, by assigning to the `Selector`&#x27;s referent.</span></span><br><span class="line">    *s = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s.elements, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;w&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Deref</code> 和 <code>DerefMut</code> 被设计用于实现智能指针类型，如 <code>Box</code>、<code>Rc</code> 和 <code>Arc</code> 以及 <code>Vec&lt;T&gt;</code> 和 <code>Stirng</code> 这种，不能仅仅为了这种隐式的自动转换而实现它。</p>
<p><code>deref</code> 转换可能引起一些混乱，可以用来解决类型冲突，但是不能满足变量的边界。例如，下面的函数调用是可以进行的，<code>&amp;Selector&lt;&amp;str&gt;</code> 会转换成 <code>&amp;str</code>，<code>Rust</code> 发现传入的是 <code>Selector&lt;&amp;str&gt;</code>，但是要求的是 <code>&amp;str</code>，同时该类型实现了 <code>Deref&lt;Target=str&gt;</code>，所以就会将函数调用重写成 <code>show_it(s.deref())</code>：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">show_it</span>(thing: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Selector &#123;</span><br><span class="line">        elements: <span class="built_in">vec!</span>[<span class="string">&quot;good&quot;</span>, <span class="string">&quot;bad&quot;</span>, <span class="string">&quot;ugly&quot;</span>],</span><br><span class="line">        current: <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">show_it</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是当我们使用泛型函数时，就会遇到问题，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">show_it_generic</span>&lt;T: Display&gt;(thing: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Selector &#123;</span><br><span class="line">        elements: <span class="built_in">vec!</span>[<span class="string">&quot;good&quot;</span>, <span class="string">&quot;bad&quot;</span>, <span class="string">&quot;ugly&quot;</span>],</span><br><span class="line">        current: <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">show_it_generic</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 提示我们的 <code>Selector&lt;&amp;str&gt;</code> 没有实现 <code>Display</code>，但我们的 <code>&amp;str</code> 确实可以。实际上因为传递了一个 <code>&amp;Selector&lt;&amp;str&gt;</code> 类型的参数，而函数的参数类型是 <code>&amp;T</code>，所以类型变量 <code>T</code> 必须是 <code>Selector&lt;&amp;str&gt;</code>。 然后，<code>Rust</code> 检查边界 <code>T: Display</code> 是否满足，因为它没有应用 <code>deref</code> 强制来满足类型变量的边界，所以这个检查失败。</p>
<pre><code>    Compiling crosscompile v0.1.0 (/Users/fudenglong/WORKDIR/rust/crosscompile)
    error[E0277]: `Selector&lt;&amp;str&gt;` doesn&#39;t implement `std::fmt::Display`
    --&gt; src/main.rs:38:21
    |
    38 |     show_it_generic(&amp;s);
    |     --------------- ^^
    |     |               |
    |     |               `Selector&lt;&amp;str&gt;` cannot be formatted with the default formatter
    |     |               help: consider dereferencing here: `&amp;*s`
    |     required by a bound introduced by this call
    |
    = help: the trait `std::fmt::Display` is not implemented for `Selector&lt;&amp;str&gt;`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: required because of the requirements on the impl of `std::fmt::Display` for `&amp;Selector&lt;&amp;str&gt;`
</code></pre>
</div>

<p>所以我们可以显示地告诉编译器怎么做：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">show_it_generic</span>(&amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>)</span><br></pre></td></tr></table></figure>

<p>或者按照编译器提示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">show_it_generic</span>(&amp;*s);</span><br></pre></td></tr></table></figure></div>

<h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a><code>Default</code></h3><p>有些类型有一个相当明显的默认值，例如 <code>Vec</code> 或者字符串是空，数字默认是<code>0</code>，而 <code>Option</code> 默认是 <code>None</code>，像这样的类型都实现了 <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>std::default::Default</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Default</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default</code> 简单的返回了一个 <code>Self</code> 新值，<code>String</code> 的实现很直接：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 <code>Rust</code> 的集合类型 <code>Vec</code>，<code>HashMap</code>，<code>BinaryMap</code> 等都实现了 <code>Default</code>，返回新的空的集合。如果类型 <code>T</code> 实现 <code>Default</code>，则标准库会自动为 <code>Rc&lt;T&gt;</code>、<code>Arc&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>、<code>Cell&lt;T&gt;</code>、<code>RefCell&lt;T&gt;</code>、<code>Cow&lt;T&gt;</code>、<code>Mutex&lt;T&gt;</code>、 和 <code>RwLock&lt;T&gt;</code> 实现 <code>Default</code>。</p>
<p>如果一个<code>tuple</code>的所有元素类型都实现了默认值，那么<code>tuple</code>也会实现，默认为一个包含每个元素默认值的<code>tuple</code>。</p>
<p><code>Rust</code> 不会为结构类型隐式实现 <code>Default</code>，但如果一个结构的所有字段都实现 <code>Default</code>，您可以使用 <code>#[derive(Default)]</code> 自动为该结构实现 <code>Default</code>。</p>
<h3 id="AsRef、AsMut"><a href="#AsRef、AsMut" class="headerlink" title="AsRef、AsMut"></a><code>AsRef</code>、<code>AsMut</code></h3><p>当一个类型实现 <a href="https://doc.rust-lang.org/stable/std/convert/trait.AsRef.html"><code>AsRef&lt;T&gt;</code></a> 时，这意味着可以从中借用 <code>&amp;T</code>，实现<a href="https://doc.rust-lang.org/stable/std/convert/trait.AsMut.html"><code>AsMut&lt;T&gt;</code></a> 可以借用 <code>&amp;mut T</code>，它们可以实现引用到引用之间的转换，不像 <a href="#from-into"><code>From</code> 和 <code>Into</code></a> 用于值到值之间的转移，它们的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">AsRef</span>&lt;T&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: ?<span class="built_in">Sized</span>, </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">as_ref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">AsMut</span>&lt;T&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: ?<span class="built_in">Sized</span>, </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">as_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，<code>Vec[T]</code> 实现了 <code>AsRef&lt;[T]&gt;</code>，<code>String</code> 实现了 <code>AsRef&lt;str&gt;</code> 和 <code>AsRef&lt;[u8]&gt;</code>，<code>AsRef</code> 通常用于使函数在它们接受的参数类型中更加灵活。 例如， <code>std::fs::File::open</code> 函数声明如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;File&gt;</span><br></pre></td></tr></table></figure>

<p><code>open</code> 真正需要的是 <code>&amp;Path</code>，表示文件系统路径的类型。但是有了这个签名，<code>open</code> 接受任何它可以借用 <code>&amp;Path</code> 的东西——也就是说，任何实现 <code>AsRef&lt;Path&gt;</code> 的东西。这样的类型包括 <code>String</code> 和 <code>str</code>，操作系统接口字符串类型 <code>OsString</code> 和 <code>OsStr</code>，当然还有 <code>PathBuf</code> 和 <code>Path</code>；这是允许传递字符串文字以打开文件的原因：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dot_emacs</span> = std::fs::File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;/home/jimb/.emacs&quot;</span>)?;</span><br></pre></td></tr></table></figure>

<p>但是字符串文字是 <code>&amp;str</code>，但实现 <code>AsRef&lt;Path&gt;</code> 的类型是 <code>str</code>，没有 <code>&amp;</code>，<code>Rust</code> 不会尝试 <code>deref</code> 强制来满足类型变量的界限，幸运的是，标准库为所有实现了 <code>AsRef&lt;U&gt;</code> 的类型 <code>T</code>，自动为 <code>&amp;T</code> 实现了 <code>AsRef&lt;U&gt;</code>，<a href="https://doc.rust-lang.org/stable/std/convert/trait.AsRef.html#impl-AsRef%3CU%3E">查看这里</a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, U: ?<span class="built_in">Sized</span>&gt; <span class="keyword">const</span> <span class="built_in">AsRef</span>&lt;U&gt; <span class="keyword">for</span> &amp;T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: ~<span class="keyword">const</span> <span class="built_in">AsRef</span>&lt;U&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">as_ref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;U &#123;</span><br><span class="line">        &lt;T <span class="keyword">as</span> <span class="built_in">AsRef</span>&lt;U&gt;&gt;::<span class="title function_ invoke__">as_ref</span>(*<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Borrow、BorrowMut"><a href="#Borrow、BorrowMut" class="headerlink" title="Borrow、BorrowMut"></a><code>Borrow</code>、<code>BorrowMut</code></h3><p><a href="https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html"><code>std::borrow::Borrow</code></a> 类似于 <code>AsRef</code>：如果一个类型实现了 <code>Borrow&lt;T&gt;</code>，那么它的 <code>borrow</code> 方法有效地从它借用一个 <code>&amp;T</code>。但是 <code>Borrow</code> 施加了更多的限制：一个类型应该实现 <code>Borrow&lt;T&gt;</code> 只有当 <code>&amp;T</code> 的 <code>hash</code> 和它借用的值的 <code>hash</code> 相同时。（<code>Rust</code> 不强制执行这一点，它只是 <code>Trait</code> 的意图。）</p>
<p>这种区别在借用字符串时很重要，例如：<code>String</code> 实现 <code>AsRef&lt;str&gt;</code>、<code>AsRef&lt;[u8]&gt;</code> 和 <code>AsRef&lt;Path&gt;</code>，但这三种目标类型通常具有不同的哈希值。只有 <code>&amp;str</code> 切片保证和 <code>String</code> 有一样 <code>hash</code> 值，所以 <code>String</code> 只实现 <code>Borrow&lt;str&gt;</code>。</p>
<p><code>Borrow</code> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Borrow</span>&lt;Borrowed: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">borrow</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Borrowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Borrow</code> 被设计出用于解决通用<code>hash</code>表和其他集合类型的场景，假设，我们有个 <code>std::collections::HashMap&lt;String, i32&gt;</code>，现在想实现查找方法，这可能是我们的第一版：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K, V&gt; HashMap&lt;K, V&gt; <span class="keyword">where</span> K: <span class="built_in">Eq</span> + Hash</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, key: K) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;V&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现中，意味着你必须传入和键值完全匹配的类型。这里，<code>K</code> 是 <code>String</code>，意思是调用 <code>get</code> 方法必须传入一个 <code>String</code>，有点浪费，再来修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K, V&gt; HashMap&lt;K, V&gt; <span class="keyword">where</span> K: <span class="built_in">Eq</span> + Hash</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, key: &amp;K) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;V&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这有点好了，但是如果我们传入一个长岭的字符串，我们就得这样写，先申请一段内存将我们的文本放进去，然后传入，再然后丢掉：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">hashtable.<span class="title function_ invoke__">get</span>(&amp;<span class="string">&quot;twenty-two&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br></pre></td></tr></table></figure>

<p>更好的方法是应该能传入和我们的 <code>key</code> 进行比较且能<code>hash</code>的值，这里 <code>&amp;str</code> 完全是可以的，所以，我们的最终版形成了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K, V&gt; HashMap&lt;K, V&gt; <span class="keyword">where</span> K: <span class="built_in">Eq</span> + Hash</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get</span>&lt;Q: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">self</span>, key: &amp;Q) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;V&gt;</span><br><span class="line">        <span class="keyword">where</span> K: Borrow&lt;Q&gt;,</span><br><span class="line">              Q: <span class="built_in">Eq</span> + Hash</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>String</code> 实现了 <code>Borrow&lt;str&gt;</code> 和 <code>Borrow&lt;String&gt;</code>，因此这个最终版本的 <code>get</code> 允许您根据需要传递 <code>&amp;String</code> 或 <code>&amp;str</code> 作为键。并且所有标准库的关联集合类型都使用 <code>Borrow</code> 来决定哪些类型可以传递给它们的查找函数。</p>
<p>另外，标准库为所有类型实现了 <code>impl&lt;T&gt; Borrow&lt;T&gt; for T</code>，这确保 <code>&amp;K</code> 始终允许在 <code>HashMap&lt;K, V&gt;</code> 中查找条目时可用。</p>
<p>为方便起见，每个 <code>&amp;mut T</code> 类型也实现了 <code>Borrow&lt;T&gt;</code>，返回一个共享的像往常一样引用 <code>&amp;T</code>。</p>
<h3 id="From、Into"><a href="#From、Into" class="headerlink" title="From、Into"></a><code>From</code>、<code>Into</code></h3><p>标准库中提供的 <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code>std::convert::From</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code>std::convert::Into</code></a> 用于不同类型值之间的转换，它们获取值的所有权并且转换成另一个类型的值，而 <code>AsRef</code> 用于引用到引用之间的转换。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Into</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">From</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库自动实现了类型转换为自身的实现，<a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html#impl-From%3CT%3E-12">例如</a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="keyword">const</span> <span class="built_in">From</span>&lt;T&gt; <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">/// Returns the argument unchanged.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(t: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个 <code>Trait</code> 用于两个方向之间的转换，<code>A into B</code> 或者 <code>B from A</code>，例如，对于标注库的 <a href="https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html"><code>std::net::Ipv4Addr</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::Ipv4Addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ping</span>&lt;A&gt;(address: A) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;<span class="type">bool</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> A: <span class="built_in">Into</span>&lt;Ipv4Addr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ipv4_address</span> = address.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以从 [u8; 4]，u32 转换成 Ipv4Addr</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">ping</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">23</span>, <span class="number">21</span>, <span class="number">68</span>, <span class="number">141</span>))); <span class="comment">// pass an Ipv4Addr</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">ping</span>([<span class="number">66</span>, <span class="number">146</span>, <span class="number">219</span>, <span class="number">98</span>])); <span class="comment">// pass a [u8; 4]</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">ping</span>(<span class="number">0xd076eb94_u32</span>)); <span class="comment">// pass a u32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以调用 Ipv4Addr::from 从 u32 和 [u8; 4] 转换</span></span><br><span class="line"><span class="comment">// 类型推断会自动选择相应的实现</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">addr1</span> = Ipv4Addr::<span class="title function_ invoke__">from</span>([<span class="number">66</span>, <span class="number">146</span>, <span class="number">219</span>, <span class="number">98</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">addr2</span> = Ipv4Addr::<span class="title function_ invoke__">from</span>(<span class="number">0xd076eb94_u32</span>);</span><br></pre></td></tr></table></figure>

<p>由于 <code>from</code> 和  <code>into</code> 是相对的，标准库对于任何实现了 <code>From</code> 的类型实现了 <code>Into</code>，<a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html#impl-Into%3CU%3E">例如</a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; <span class="keyword">const</span> <span class="built_in">Into</span>&lt;U&gt; <span class="keyword">for</span> <span class="title class_">T</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    U: ~<span class="keyword">const</span> <span class="built_in">From</span>&lt;T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// Calls `U::from(self)`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// That is, this conversion is whatever the implementation of</span></span><br><span class="line">    <span class="comment">/// &lt;code&gt;[From]&amp;lt;T&amp;gt; for U&lt;/code&gt; chooses to do.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> U &#123;</span><br><span class="line">        U::<span class="title function_ invoke__">from</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryFrom、TryInto"><a href="#TryFrom、TryInto" class="headerlink" title="TryFrom、TryInto"></a><code>TryFrom</code>、<code>TryInto</code></h3><p><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html"><code>std::convert::TryFrom</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html"><code>std::convert::TryInto</code></a> 也用于数据类型之间的转换，只是它们可能失败：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">TryFrom</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_from</span>(value: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">TryInto</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_into</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;T, <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; <span class="keyword">const</span> TryInto&lt;U&gt; <span class="keyword">for</span> <span class="title class_">T</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    U: ~<span class="keyword">const</span> TryFrom&lt;T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = U::Error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_into</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, U::Error&gt; &#123;</span><br><span class="line">        U::<span class="title function_ invoke__">try_from</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，如果我们将一个较大 <code>i64</code> 转换为 <code>i32</code> 时可能会发生溢出，我们可以使用 <code>try_into()</code> 根据结果进行判断：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">huge</span> = <span class="number">2_000_000_000_000i64</span>;</span><br><span class="line">    <span class="comment">// Saturate on overflow, rather than wrapping</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">smaller</span>: <span class="type">i32</span> = huge.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="type">i32</span>::MAX);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ToOwned"><a href="#ToOwned" class="headerlink" title="ToOwned"></a><code>ToOwned</code></h3><p>如果我们想要根据 <code>&amp;str</code> 或者 <code>&amp;[i32]</code> 生成 <code>String</code> 或者 <code>Vec&lt;i32&gt;</code>，由于 <code>Clone</code> 是不允许的，它只能返回相同类型的版本。所以 <code>Rust</code> 提供了 <a href="https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html"><code>std::borrow::ToOwned</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">ToOwned</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Owned</span>: Borrow&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_owned</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Owned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Borrow</code> 和 <code>AsRef</code> 的区别是它的目的类型和当前类型的 <code>hash</code> 值一样，可以认为就是同一个东西。</p>
<h3 id="Cow"><a href="#Cow" class="headerlink" title="Cow"></a><code>Cow</code></h3><p><a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html">Cow（Clone-on-Write）</a>是 <code>Rust</code> 中一个很有意思且很重要的数据结构。它就像 <code>Option</code> 一样，在返回数据的时候，提供了一种可能：要么返回一个借用的数据（只读），要么返回一个拥有所有权的数据（可写）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Cow</span>&lt;<span class="symbol">&#x27;a</span>, B&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    B: <span class="symbol">&#x27;a</span> + <span class="built_in">ToOwned</span> + ?<span class="built_in">Sized</span>, </span><br><span class="line"> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Borrowed</span>(&amp;<span class="symbol">&#x27;a</span> B),</span><br><span class="line">    <span class="title function_ invoke__">Owned</span>(&lt;B <span class="keyword">as</span> <span class="built_in">ToOwned</span>&gt;::Owned),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Cow</code> 的合理使用能减少不必要的堆内存分配，例如，我们写一个替换 <code>:</code> 的程序，如果原文字符串中没有包含 <code>:</code>，就返回原来的字符串；如果包含，就替换为空格，返回一个 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_cow</span>(cow: Cow&lt;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> cow &#123;</span><br><span class="line">        Cow::<span class="title function_ invoke__">Borrowed</span>(v) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;Borrowed &#123;&#125;&quot;</span>, v),</span><br><span class="line">        Cow::<span class="title function_ invoke__">Owned</span>(v) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;Owned &#123;&#125;&quot;</span>, v),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">replace_colon</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Cow&lt;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> input.<span class="title function_ invoke__">find</span>(<span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; Cow::<span class="title function_ invoke__">Borrowed</span>(input),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(_) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = input.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            input = input.<span class="title function_ invoke__">replace</span>(<span class="string">&#x27;:&#x27;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            Cow::<span class="title function_ invoke__">Owned</span>(input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">show_cow</span>(<span class="title function_ invoke__">replace_colon</span>(<span class="string">&quot;hello world&quot;</span>)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">show_cow</span>(<span class="title function_ invoke__">replace_colon</span>(<span class="string">&quot;hello:world&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>常用 Trait</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】并发</title>
    <url>/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>Rust 提供了一种非常好的并发使用方法，它不强制所有程序采用单一风格，而是通过安全地支持多种风格，并由编译器强制执行。我们将介绍三种使用 <code>Rust</code> 线程的方法：</p>
<ul>
<li><code>Fork-join</code> 并行；</li>
<li>通道（<code>Chanel</code>）；</li>
<li>共享可变状态；</li>
</ul>
<p>在此过程中，将使用到目前为止所学的有关 <code>Rust</code> 语言的所有内容，<code>Rust</code> 对引用、可变性和生命周期的关注在单线程程序中足够有价值，但在并发编程中，这些规则的真正意义变得显而易见。</p>
<h3 id="Fork-Join-Parallelism"><a href="#Fork-Join-Parallelism" class="headerlink" title="Fork-Join Parallelism"></a><code>Fork-Join Parallelism</code></h3><p>最简单的用于多线程的案例是处理互不相干的任务，例如，我们要处理大量的文档，可能会这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">document</span> <span class="keyword">in</span> filenames &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">text</span> = <span class="title function_ invoke__">load</span>(&amp;document)?; <span class="comment">// read source file</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">results</span> = <span class="title function_ invoke__">process</span>(text); <span class="comment">// compute statistics</span></span><br><span class="line">        <span class="title function_ invoke__">save</span>(&amp;document, results)?; <span class="comment">// write output file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>因为每个文档是被单独处理的，所以很容易分成线程来加速处理，如下图所示：</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/threads-case-multiple-threads.png" class="">


<p>这种模式称为 <code>fork-join</code>，<code>fork</code> 就是启动一个新线程，<code>join</code> 一个线程就是等待它完成，这种模式之所以具有吸引力，有以下原因：</p>
<ul>
<li><p>没有瓶颈，<code>fork-join</code> 中没有共享资源的锁定，唯一一次任何线程必须等待另一个线程是在最后。同时，每个线程都可以自由运行，这有助于保持较低的任务切换开销；</p>
</li>
<li><p>性能提升明显，在最好的情况下，通过启动<code>4</code>个线程，我们可以在<code>4</code>分之一的时间内完成我们的工作，然而我们不应该期望达到这种理想加速。但是对于任何具有独立工作单元的 <code>CPU</code> 密集型程序都可以期待显着的提升；</p>
</li>
<li><p>很容易保证序的正确性，只要线程真正隔离，<code>fork-join</code> 程序就是确定性的，无论线程速度如何变化，程序总是产生相同的结果，这是一个没有竞争条件的并发模型。</p>
</li>
</ul>
<h4 id="线程创建和等待"><a href="#线程创建和等待" class="headerlink" title="线程创建和等待"></a>线程创建和等待</h4><p>可以使用 <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>std::thread::spawn</code></a> 启动一个新线程：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello from a child thread&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>它接受一个参数，一个 <code>FnOnce</code> 闭包或函数，<code>Rust</code> 启动一个新线程来运行该闭包或函数的代码。新线程是一个真正的操作系统线程，具有自己的堆栈，就像 <code>C++</code>、<code>C#</code> 和 <code>Java</code> 中的线程一样。</p>
<p>下面是一个实现本节开始并行处理文档的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;io, thread&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files_in_parallel</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// Divide the work into several chunks.</span></span><br><span class="line">    <span class="keyword">const</span> NTHREADS: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">worklists</span> = <span class="title function_ invoke__">split_vec_into_chunks</span>(filenames, NTHREADS);</span><br><span class="line">    <span class="comment">// Fork: Spawn a thread to handle each chunk.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">thread_handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">worklist</span> <span class="keyword">in</span> worklists &#123;</span><br><span class="line">        thread_handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="title function_ invoke__">process_files</span>(worklist)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Join: Wait for all threads to finish.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> thread_handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>()?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>.spawn()</code> 启动一个新线程处理 <code>worklist</code>，它返回 <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"><code>std::thread::JoinHandle</code></a>，我们使用 <code>move</code> 将 <code>worklist</code> 放进我们新建的闭包函数，这个代价是很低的，不涉及到内存的申请和释放，只是所有权的转移而已。</p>
<p>然后我们通过调用 <code>JoinHandle</code> 的 <code>.join()</code> 方法等待每个线程完成。等待线程完成通常是正确性所必需的，因为 <code>Rust</code> 程序在 <code>main</code> 返回时立即退出，即使其他线程仍在运行，这样未结束的线程就被杀死了。如果这不是想要的，确保在从 <code>main</code> 返回之前等待子线程完成。</p>
<h4 id="跨线程错误处理"><a href="#跨线程错误处理" class="headerlink" title="跨线程错误处理"></a>跨线程错误处理</h4><p>我们再来看看 <code>.join()</code> 的方法的使用，它实际上为我们做了两件事：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>()?;</span><br></pre></td></tr></table></figure>

<p>首先，<code>handle.join()</code> 返回一个 <a href="https://doc.rust-lang.org/std/thread/type.Result.html"><code>std::thread::Result</code></a> 即使子线程发生 <code>panic</code>，这使得 <code>Rust</code> 中的线程比 <code>C++</code> 中的线程更加健壮。在 <code>C++</code> 中，越界数组访问是未定义的行为，并且无法保护系统的其余部分免受影响。在 <code>Rust</code> 中，<code>panic</code> 是安全的并且每个线程都是安全的，线程之间的边界充当<code>panic</code>的防火墙，<code>panic</code>不会自动从一个线程传播到依赖它的线程。而是一个线程中的 <code>panic</code> 会在其他线程中报告为错误结果，整个程序可以轻松恢复。</p>
<p>但是，在我们的程序中，我们没有处理任何错误。而是，我们立即在这个 <code>Result</code> 上使用 <code>.unwrap()</code>，断言它是 <code>Ok</code> 结果而不是 <code>Err</code> 结果。如果子线程确实 <code>panic</code>，那么这个断言就会失败，所以父线程也会 <code>panic</code>，我们明确地将<code>panic</code>从子线程传播到父线程。</p>
<p>其次，<code>handle.join()</code> 将子线程的返回值传递回父线程。我们传递给 <code>spawn</code> 的闭包的返回类型是 <code>io::Result&lt;()&gt;</code>，因为这是 <code>process_files</code> 返回的，这个返回值不会被丢弃。当子线程完成时，它的返回值被保存，并且 <code>JoinHandle::join()</code> 将该值传回给父线程。</p>
<p>在这个程序中，<code>handle.join()</code> 返回的完整类型是 <code>std::thread::Result&lt;std::io::Result&lt;()&gt;&gt;</code>。<code>thread::Result</code> 是 <code>spawn/join API</code> 的一部分，<code>io::Result</code> 是我们应用程序的一部分。</p>
<p>在我们的例子中，在展开 <code>thread::Result</code> 之后，我们在 <code>io::Result</code> 上使用 <code>?</code> 运算符，将 <code>I/O</code> 错误从子线程显式传播到父线程。</p>
<p>所有这些似乎都相当复杂，但是 <code>Rust</code> 中只有一行代码。<code>Java</code> 和 <code>C#</code> 中的默认行为是将子线程中的异常转储到终端然后丢掉。在 <code>C++</code> 中，默认设置是中止进程。在 <code>Rust</code> 中，错误是 <code>Result</code>（数据）而不是异常（控制流），它们像任何其他值一样跨线程传递。当使用低级线程 <code>API</code> 时，都需要编写对错误的处理，但 <code>Rust</code> 中只要处理 <code>Result</code> 即可。</p>
<h4 id="跨线程共享不可变数据"><a href="#跨线程共享不可变数据" class="headerlink" title="跨线程共享不可变数据"></a>跨线程共享不可变数据</h4><p>假设我们正在进行的分析需要一个包含大量英语单词和短语的数据库，需要对我们之前的方法进行修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, glossary: &amp;GigabyteMap)</span><br></pre></td></tr></table></figure>

<p>由于 <code>glossary</code> 比较大，所以我们通过引用传递，但是我们如何在多线程之间使用它，如果仅仅是下面这样处理，肯定会报错：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files_in_parallel</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, glossary: &amp;GigabyteMap) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">worklist</span> <span class="keyword">in</span> worklists &#123;</span><br><span class="line">    thread_handles.<span class="title function_ invoke__">push</span>(</span><br><span class="line">      <span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="title function_ invoke__">process_files</span>(worklist, glossary)) <span class="comment">// error</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译错误：</p>
<pre><code>error[E0621]: explicit lifetime required in the type of `glossary` --&gt; src/lib.rs:75:17
|
61 | glossary: &amp;GigabyteMap)
| ------------ help: add explicit lifetime `&#39;static` to the
type of `glossary`: `&amp;&#39;static BTreeMap&lt;String,
String&gt;`
...
75 | spawn(move || process_files(worklist, glossary))
| ^^^^^ lifetime `&#39;static` required
</code></pre>
<p>因为，<code>spawn</code> 启动独立线程，<code>Rust</code> 无法知道子线程将运行多长时间，因此它假设最坏的情况：它假设即使在父线程完成并且父线程中的所有值都消失后，子线程仍可能继续运行。显然，如果子线程要持续那么长时间，它运行的闭包也需要持续那么长时间，但是这个闭包有一个有限的生命周期：它依赖于<code>glossary</code>的引用。</p>
<p><code>Rust</code> 拒绝此代码是正确的！我们编写此函数的方式是，一个线程可能会遇到 <code>I/O</code> 错误，导致 <code>process_files_in_parallel</code> 在其他线程完成之前退出，子线程最终可能会在主线程释放 <code>glossary</code> 后尝试使用它。</p>
</div>

<p>似乎 <code>spawn</code> 过于开放，无法支持跨线程共享引用。我们之前的解决方案是使用<code>move</code>闭包将数据的所有权转移到新线程。这在这里行不通，因为我们有很多线程都需要使用相同的数据。一种安全的替代方法是为每个线程克隆整个词汇表，但由于它很大，我们希望避免这种情况。幸运的是，标准库提供了 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>。</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files_in_parallel</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, glossary: Arc&lt;GigabyteMap&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">worklist</span> <span class="keyword">in</span> worklists &#123;</span><br><span class="line">      <span class="comment">// This call to .clone() only clones the Arc and bumps the</span></span><br><span class="line">      <span class="comment">// reference count. It does not clone the GigabyteMap.</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">glossary_for_child</span> = glossary.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">      thread_handles.<span class="title function_ invoke__">push</span>(</span><br><span class="line">          <span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="title function_ invoke__">process_files</span>(worklist, &amp;glossary_for_child))</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们更改了<code>glossary</code>的类型：要并行运行分析，调用者必须传入一个 <code>Arc&lt;GigabyteMap&gt;</code>，这是一个指向已移动到堆中的 <code>GigabyteMap</code> 的智能指针，通过使用 <code>Arc::new(giga_map)</code> 创建。</p>
<p>当我们调用<code>glossary.clone()</code> 时，我们正在创建 <code>Arc</code> 智能指针的副本，而不是整个 <code>GigabyteMap</code>，这相当于增加引用计数。</p>
<p>通过此更改，程序可以编译并运行，因为它不再依赖于引用生命周期。只要任何线程拥有 <code>Arc&lt;GigabyteMap&gt;</code>，它就会使地图保持活动状态，即使父线程提前退出。也不存在任何数据竞争，因为 <code>Arc</code> 中的数据是不可变的。</p>
</div>

<h4 id="Rayon"><a href="#Rayon" class="headerlink" title="Rayon"></a><a href="https://crates.io/crates/rayon"><code>Rayon</code></a></h4><p><a href="https://crates.io/crates/rayon"><code>Rayon</code></a> 提供了两种并发机制：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;do 2 things in parallel&quot;</span></span><br><span class="line"><span class="keyword">let</span> (v1, v2) = rayon::<span class="title function_ invoke__">join</span>(fn1, fn2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;do N things in parallel&quot;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_of_squares</span>(giant_vector: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    giant_vector.<span class="title function_ invoke__">par_iter</span>() <span class="comment">// &lt;-- just change that!</span></span><br><span class="line">         .<span class="title function_ invoke__">map</span>(|&amp;i| i * i)</span><br><span class="line">         .<span class="title function_ invoke__">sum</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rayon::join(fn1, fn2)</code> 调用这两个函数并返回两个结果。<code>.par_iter()</code> 方法创建一个 <code>ParallelIterator</code>，一个带有 <code>map</code>、<code>filter</code> 和其他方法的值，很像 <code>Rust</code> 迭代器。在这两种情况下，<code>Rayon</code> 都会尽可能使用自己的工作线程池来分散工作。只需告诉 <code>Rayon</code> 可以并行完成哪些任务，<code>Rayon</code> 管理线程并尽其所能分配工作。</p>
<p>下图说明了对调用 <code>giant_vector.par_iter().for_each(...)</code> 的两种方式。 <code>(a)</code> <code>Rayon</code> 就像它为向量中的每个元素生成一个线程一样。 <code>(b)</code> 在幕后，<code>Rayon</code> 每个 <code>CPU</code> 核心有一个工作线程，效率更高，这个工作线程池由程序的所有线程共享。当数以千计的任务同时进入时，<code>Rayon</code> 会分工。</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/rayon-theory.png" class="">

<p>使用 <code>Rayon</code> 编写的 <code>process_files_in_parallel</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_files_in_parallel</span>(filenames: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, glossary: &amp;GigabyteMap) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">&#123;</span><br><span class="line">  filenames.<span class="title function_ invoke__">par_iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|filename| <span class="title function_ invoke__">process_file</span>(filename, glossary))</span><br><span class="line">    .<span class="title function_ invoke__">reduce_with</span>(|r1, r2| &#123;</span><br><span class="line">      <span class="keyword">if</span> r1.<span class="title function_ invoke__">is_err</span>() &#123; r1 &#125; <span class="keyword">else</span> &#123; r2 &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">unwrap_or</span>(<span class="title function_ invoke__">Ok</span>(()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在背后，<code>Rayon</code> 使用<code>work-stealing</code>技术动态平衡线程间的工作负载。<code>Rayon</code> 支持跨线程共享引用，任何发生在幕后的并行处理都保证在 <code>reduce_with</code> 返回时完成。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><code>Channel</code></h3><p>通道是用于将值从一个线程发送到另一个线程的单向管道，换句话说，它是一个线程安全的队列。</p>
<p>下图说明了如何使用通道，它们有点像 <code>Unix</code> 管道：一端用于发送数据，另一端用于接收，两端通常由两个不同的线程拥有。但是 <code>Unix</code> 管道用于发送字节，而通道用于发送 <code>Rust</code> 值。<code>sender.send(item)</code> 将单个值放入通道，<code>receiver.recv()</code> 删除一个，所有权从发送线程转移到接收线程，如果通道为空，<code>receiver.recv()</code> 会阻塞，直到发送一个值。</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/channel-exmaple.png" class="">

<p>使用通道，线程可以通过相互传递值来进行通信。这是线程协同工作的一种非常简单的方式，无需使用锁定或共享内存。</p>
<p>这不是一项新技术，<code>Erlang</code> 已经有 <code>30</code> 年的隔离进程和消息传递了。<code>Unix</code> 管道已经存在了将近 <code>50</code> 年。我们倾向于认为管道提供了灵活性和可组合性，而不是并发性，但实际上，它们完成了上述所有工作。下图是 <code>Unix</code> 管道的示例，所有三个程序都可以同时运行。</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/unix-channel.png" class="">

<p><code>Rust</code> 通道比 <code>Unix</code> 管道快。发送一个值会移动它而不是复制它，即使你正在移动包含许多兆字节数据的数据结构也是很快的。</p>
<h4 id="Send"><a href="#Send" class="headerlink" title="Send"></a><code>Send</code></h4><p>接下来我们将使用通道来构建一个创建倒排索引的并发程序，倒排索引是搜索引擎的关键要素之一，每个搜索引擎都处理特定的文档集合，倒排索引是告诉哪些单词出现在哪里的数据库。</p>
<p>我们的程序结构为管道，如下图所示。管道只是使用通道的众多方式之一。</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/send-pipeline.png" class="">

<p>我们将使用总共五个线程，每个线程执行不同的任务。每个线程在程序的生命周期内不断产生输出。例如，第一个线程只是将源文档从磁盘一个一个地读取到内存中。（我们需要一个线程来执行此操作，因为我们将在这里编写最简单的代码，使用 <code>fs::read_to_string</code>，这是一个阻塞 <code>API</code>，我们不希望 <code>CPU</code> 在磁盘工作时处于空闲状态。）这个阶段的输出是每个文档一个长字符串，所以这个线程通过一个字符串通道连接到下一个线程。</p>
<p>首先我们创建新线程处理文档，假设这里的 <code>documents</code> 是 <code>Vec&lt;PathBuf&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fs, thread&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">filename</span> <span class="keyword">in</span> documents &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">text</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)?;</span><br><span class="line">        <span class="keyword">if</span> sender.<span class="title function_ invoke__">send</span>(text).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Channel</code> 是 <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code></a> 模块的一部分，首先来看创建通道的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br></pre></td></tr></table></figure>

<p><code>.channel()</code> 返回了一对值，发送通道和接收通道，我们将使用这个通道来发送每个文件的文本，所以我们有一个 <code>Sender&lt;String&gt;</code> 类型的发送者和一个 <code>Receiver&lt;String&gt;</code> 类型的接收者。我们可以通过编写 <code>mpsc::channel::&lt;String&gt;()</code> 明确地请求字符串通道。但是，我们让 <code>Rust</code> 的类型推断来解决这个问题。</p>
<p>我们使用 <code>thread::spawn</code> 创建了新线程，并且使用 <code>move</code> 将 <code>sender</code>的所有权转移给我们新建的线程：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> ||</span><br></pre></td></tr></table></figure>

<p>在成功读取到数据之后，我们使用将内容发送到通道中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> sender.<span class="title function_ invoke__">send</span>(text).<span class="title function_ invoke__">is_err</span>() &#123;</span><br></pre></td></tr></table></figure>

<p><code>sender.send(text)</code> 将值文本移动到通道中。最终，它将再次转移到接收价值的人手中。无论文本包含 <code>10</code> 行文本还是 <code>10MB</code> 字节，此操作都会复制<code>3</code>个机器字（<code>String</code> 结构体的大小），相应的接收器 <code>.recv()</code> 调用也会复制<code>3</code>个机器字。</p>
<p><code>send</code> 和 <code>recv</code> 方法都返回结果，但这些方法只有在通道的另一端被丢弃时才会失败。如果 <code>Receiver</code> 已被丢弃，则发送调用失败，否则该值将永远位于通道中但没有 <code>Receiver</code>，任何线程都无法接收它。同样，如果通道中没有等待的值并且 <code>Sender</code> 已被丢弃，则 <code>recv</code> 调用将失败，否则 <code>recv</code> 将永远等待但没有 <code>Sender</code>，任何线程都无法发送下一个值。</p>
<p>在我们的代码中，<code>sender.send(text)</code> 只有当接收者的线程提前退出时才会失败，这对于使用通道的代码很典型，无论这是故意发生的还是由于错误，我们的接收者线程都可以安静地自行关闭。</p>
<p>程序运行结束时返回 <code>Ok(())</code>，闭包返回的是 <code>Result</code>，如果线程遇到错误会立即返回，错误被存储在线程的 <code>JoinHandle</code> 中。</p>
<p>为方便起见，我们的程序将所有这些代码包装在一个函数中，该函数返回接收器（我们尚未使用）和新线程的 <code>JoinHandle</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">start_file_reader_thread</span>(documents: <span class="type">Vec</span>&lt;PathBuf&gt;) <span class="punctuation">-&gt;</span> (mpsc::Receiver&lt;<span class="type">String</span>&gt;, thread::JoinHandle&lt;io::<span class="type">Result</span>&lt;()&gt;&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  (receiver, handle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数启动新线程并且立即返回。</p>
<h4 id="Receiving"><a href="#Receiving" class="headerlink" title="Receiving"></a><code>Receiving</code></h4><p>我们来创建第二个线程使用一个循环并且调用 <code>.loop()</code> 接收值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(text) = receiver.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_something_with</span>(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者由于 <code>Receiver</code> 是可迭代类型，可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">text</span> <span class="keyword">in</span> receiver &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_something_with</span>(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个循环是等价的，无论哪种方式，如果在控制到达循环顶部时通道恰好是空的，则接收线程将阻塞，直到其他线程发送一个值。当通道为空且 <code>Sender</code> 已被丢弃时，循环将正常退出。在我们的程序中，这会在读取线程退出时自然发生。该线程正在运行一个拥有变量 <code>sender</code> 的闭包，当闭包退出时，发送者被丢弃。现在我们可以为管道的第二阶段编写代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">start_file_indexing_thread</span>(</span><br><span class="line">    texts: mpsc::Receiver&lt;<span class="type">String</span>&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> (mpsc::Receiver&lt;InMemoryIndex&gt;, thread::JoinHandle&lt;()&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="title function_ invoke__">for</span> (doc_id, text) <span class="keyword">in</span> texts.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">index</span> = InMemoryIndex::<span class="title function_ invoke__">from_single_document</span>(doc_id, text);</span><br><span class="line">            <span class="keyword">if</span> sender.<span class="title function_ invoke__">send</span>(index).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    (receiver, handle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数生成一个线程，该线程从一个通道（文本）接收字符串值并将 <code>InMemoryIndex</code> 值发送到另一个通道（发送方&#x2F;接收方）。该线程的工作是获取在第一阶段加载的每个文件，并将每个文档变成一个小的单文件内存倒排索引。</p>
<p>这个线程的主循环很简单，索引文档的所有工作都由函数 <code>InMemoryIndex::from_single_document</code> 完成。我们不会在这里展示它的源代码，但它会在单词边界处拆分输入字符串，然后生成从单词到位置列表的映射。此阶段不执行 <code>I/O</code>，因此不必处理 <code>io::Error</code>。它返回 <code>()</code>，而不是 <code>io::Result&lt;()&gt;</code>。</p>
<h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a><code>Pipeline</code></h4><p>其余<code>3</code>个阶段的设计相似，每个人都使用前一阶段创建的接收器。我们对管道其余部分的目标是将所有小索引合并到磁盘上的单个大索引文件中。我们发现最快的方法是分<code>3</code>个阶段，我们不会在这里展示代码，只展示这<code>3</code>个函数的类型签名。 </p>
<p>首先，我们在内存中合并索引（第 3 阶段）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">start_in_memory_merge_thread</span>(file_indexes: mpsc::Receiver&lt;InMemoryIndex&gt;)</span><br><span class="line"> <span class="punctuation">-&gt;</span> (mpsc::Receiver&lt;InMemoryIndex&gt;, thread::JoinHandle&lt;()&gt;)</span><br></pre></td></tr></table></figure>

<p>将这些大索引写入磁盘（第 <code>4</code> 阶段）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">start_index_writer_thread</span>(big_indexes: mpsc::Receiver&lt;InMemoryIndex&gt;, output_dir: &amp;Path)</span><br><span class="line"> <span class="punctuation">-&gt;</span> (mpsc::Receiver&lt;PathBuf&gt;, thread::JoinHandle&lt;io::<span class="type">Result</span>&lt;()&gt;&gt;)</span><br></pre></td></tr></table></figure>

<p>最后，如果我们有多个大文件，我们使用基于文件的合并算法将它们合并（第 <code>5</code> 阶段）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">merge_index_files</span>(files: mpsc::Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br></pre></td></tr></table></figure>

<p>现在，我们将所有的代码整合在一起：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_pipeline</span>(documents: <span class="type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// Launch all five stages of the pipeline.</span></span><br><span class="line">    <span class="keyword">let</span> (texts, h1) = <span class="title function_ invoke__">start_file_reader_thread</span>(documents);</span><br><span class="line">    <span class="keyword">let</span> (pints, h2) = <span class="title function_ invoke__">start_file_indexing_thread</span>(texts);</span><br><span class="line">    <span class="keyword">let</span> (gallons, h3) = <span class="title function_ invoke__">start_in_memory_merge_thread</span>(pints);</span><br><span class="line">    <span class="keyword">let</span> (files, h4) = <span class="title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for threads to finish, holding on to any errors that they encounter.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = h1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    h2.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    h3.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r4</span> = h4.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the first error encountered, if any.</span></span><br><span class="line">    <span class="comment">// (As it happens, h2 and h3 can&#x27;t fail: those threads</span></span><br><span class="line">    <span class="comment">// are pure in-memory data processing.)</span></span><br><span class="line">    r1?;</span><br><span class="line">    r4?;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和以前一样，我们使用 <code>.join().unwrap()</code> 将 <code>panic</code> 从子线程显式传播到主线程。这里唯一的另一个不寻常的事情是，没有立即使用 <code>?</code> 马上，我们将 <code>io::Result</code> 值放在一边，直到我们加入所有四个线程。</p>
<p>该管道比单线程等效管道快 <code>40%</code>，有提升但是我们显然还没有使系统的 <code>I/O</code> 或所有 <code>CPU</code> 饱和。</p>
<p>因为管道就像制造工厂中的装配线：性能受到最慢阶段的吞吐量的限制。一条全新的、未经调整的装配线可能与单位生产一样慢，但装配线奖励有针对性的调整。在我们的案例中，测量表明第二阶段是瓶颈。我们的索引线程使用 <code>.to_lowercase()</code> 和 <code>.is_alphanumeric()</code>，因此它会花费大量时间在 <code>Unicode</code> 表中查找。索引下游的其他阶段大部分时间都在 <code>Receiver::recv</code> 中休眠，等待输入。</p>
<p>这意味着我们应该能够走得更快，随着我们解决瓶颈问题，并行度将会提高。既然知道如何使用通道并且我们的程序是由独立的代码片段组成的，那么很容易找到解决第一个瓶颈的方法。我们可以手动优化第二阶段的代码，就像任何其他代码一样，将工作分成两个或多个阶段，或一次运行多个文件索引线程。</p>
<h4 id="功能和性能"><a href="#功能和性能" class="headerlink" title="功能和性能"></a>功能和性能</h4><p><code>std::sync::mpsc</code> 的 <code>mpsc</code> 部分代表多生产者单消费者，这是对 <code>Rust</code> 通道提供的通信类型的简洁描述。</p>
<p>我们示例程序中的通道将值从单个发送者传送到单个接收者，这是一个相当普遍的情况。但是 <code>Rust</code> 通道也支持多个发送者，以防你需要一个线程来处理来自多个客户端线程的请求，如下图所示：</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/mpsc-channel.png" class="">

<p><code>Sender&lt;T&gt;</code> 实现了 <code>Clone</code>。要获得具有多个 <code>Sender</code> 的 <code>Channel</code>，只需创建一个常规 <code>Channel</code> 并根据需要多次克隆 <code>Sender</code>，可以将每个 <code>Sender</code> 移动到不同的线程。<code>Receiver&lt;T&gt;</code> 不能被克隆，所以如果你需要多个线程从同一个通道接收值，你需要一个 <code>Mutex</code>。 </p>
<p><code>Rust</code> 通道经过精心优化，首次创建通道时，<code>Rust</code> 使用特殊的“一次性”队列实现。如果只通过通道发送一个对象，则开销是最小的，如果发送第二个值，<code>Rust</code> 会切换到不同的队列实现。实际上，它正在为长期稳定做好准备，让通道准备好传输许多值，同时最大限度地减少分配开销。如果克隆 <code>Sender</code>，<code>Rust</code> 必须依靠另一种实现，当多个线程尝试同时发送值时，这种实现是安全的。但即使是这三种实现中最慢的也是无锁队列，所以发送或接收一个值至多是几个原子操作和一个堆分配，再加上移动本身。仅当队列为空并且接收线程因此需要使自己进入睡眠状态时才需要系统调用。当然，在这种情况下，通过<code>Chaneel</code>的流量无论如何都不会达到最大值。</p>
<p>尽管进行了所有优化工作，但应用程序很容易在通道性能方面犯一个错误：发送值的速度超过了接收和处理的速度。这会导致越来越多的积压值在渠道中累积。例如，在我们的程序中，我们发现文件读取线程（阶段 1）可以比文件索引线程（阶段 2）更快地加载文件。结果是数百兆字节的原始数据将从磁盘读取并立即填充到队列中。</p>
<p>这种不当行为会消耗内存并伤害局部性。更糟糕的是，发送线程继续运行，占用 <code>CPU</code> 和其他系统资源来发送更多的值，而这些资源正好在接收端最需要这些资源。</p>
<p>这里 <code>Rust</code> 再次从 <code>Unix</code> 管道中获取一个技巧，<code>Unix</code> 使用了一个优雅的技巧来提供一些背压，以便快速发送者被迫放慢速度：<code>Unix</code> 系统上的每个管道都有固定的大小，如果一个进程试图写入一个暂时已满的管道，系统会简单地阻止该进程 直到管道中有空间，<code>Rust</code> 也有类似的，称为同步通道：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>同步通道与常规通道完全相同，只是在创建它时，指定它可以保存多少个值。对于同步通道，<code>sender.send(value)</code> 可能是一个阻塞操作。毕竟，这个想法是阻塞并不总是坏事。在我们的示例程序中，将 <code>start_file_reader_thread</code> 中的通道更改为可容纳 <code>32</code> 个值的 <code>sync_channel</code> 将我们的基准数据集的内存使用量减少了三分之二，而不会降低吞吐量。</p>
<h4 id="Send、Sync"><a href="#Send、Sync" class="headerlink" title="Send、Sync"></a><code>Send</code>、<code>Sync</code></h4><p>到目前为止，我们一直认为所有值都可以在线程之间自由移动和共享。这基本上是正确的，但 <code>Rust</code> 的完整线程安全取决于两个内置 <code>Trait</code>，<code>std::marker::Send</code> 和 <code>std::marker::Sync</code>。</p>
<ul>
<li><p>实现 <code>Send</code> 的类型可以安全地按值传递给另一个线程，它们可以跨线程移动；</p>
</li>
<li><p>实现 <code>Sync</code> 的类型可以安全地通过非 <code>mut</code> 引用传递给另一个线程，它们可以跨线程共享；</p>
</li>
</ul>
<p>这里的安全指的是：没有数据竞争和其他未定义的行为，前面我们使用闭包将 <code>Vec&lt;String&gt;</code> 从父线程传递给每个子线程。我们当时没有指出，但这意味着 <code>vector</code> 及其字符串在父线程中分配，但在子线程中释放。<code>Vec&lt;String&gt;</code> 实现 <code>Send </code>的事实是：<code>Vec</code> 和 <code>String</code> 内部使用的内存分配器是线程安全的。（如果要使用快速但非线程安全的分配器编写自己的 <code>Vec</code> 和 <code>String</code> 类型，则必须使用 <code>非 Send</code> 类型来实现它们，例如不安全的指针。<code>Rust</code> 会推断 <code>NonThreadSafeVec</code> 和 <code>NonThreadSafeString</code> 类型不是 <code>Send</code> 并将它们限制为单线程使用，但这比较少见。）</p>
<p>如下图所示，大多数类型都是 <code>Send</code> 和 <code>Sync</code>， 甚至不必使用 <code>#[derive]</code>，<code>Rust</code> 会自动处理。如果结构或枚举的字段为 <code>Send</code>，则结构或枚举为<code>Send</code>，如果其字段为<code>Sync</code>，则为<code>Sync</code>。</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/send-sync-types.png" class="">

<p>有些类型是<code>Send</code>，但不是 <code>Sync</code>。这通常是有目的的，例如 <code>mpsc::Receiver</code>，它保证 <code>mpsc</code> 通道的接收端一次只被一个线程使用。</p>
<p>少数既不是 <code>Send</code> 也不是 <code>Sync</code> 的类型主要是那些以非线程安全的方式使用可变性的类型。例如，考虑 <code>std::rc::Rc&lt;T&gt;</code>，引用计数智能指针的类型。</p>
<p>如果 <code>Rc&lt;String&gt;</code> 是 <code>Sync</code>，允许线程通过共享引用共享单个 <code>Rc</code>，会发生什么？如果两个线程碰巧同时尝试克隆 <code>Rc</code>，如下图所示，我们就会发生数据竞争，因为两个线程都会增加共享引用计数。引用计数可能变得不准确，从而导致 <code>use-afterfree</code> 或 <code>double free</code> 行为。</p>
<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/rc-string-not-sync-send.png" class="">

<p>而且 <code>Rust</code> 是不会让这样的代码编译通过的：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rc1</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;ouch&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rc2</span> = rc1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        rc2.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    rc1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出错：</p>
<pre><code>error[E0277]: `Rc&lt;String&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:9:5
    |
9   |       thread::spawn(move || {
    |  _____^^^^^^^^^^^^^_-
    | |     |
    | |     `Rc&lt;String&gt;` cannot be sent between threads safely
10  | |         // error
11  | |         rc2.clone();
12  | |     });
    | |_____- within this `[closure@src/main.rs:9:19: 12:6]`
    |
    = help: within `[closure@src/main.rs:9:19: 12:6]`, the trait `Send` is not implemented for `Rc&lt;String&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:9:19: 12:6]`
note: required by a bound in `spawn`
  --&gt; /Users/fudenglong/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/thread/mod.rs:646:8
    |
646 |     F: Send + &#39;static,
    |        ^^^^ required by this bound in `spawn`
</code></pre>
</div>

<p>可以看到 <code>Send</code> 和 <code>Sync</code> 帮助 <code>Rust</code> 加强线程安全，它们在跨线程边界传输数据的函数的类型签名中显示为边界。当生成一个线程时，传递的闭包必须是 <code>Send</code>，这意味着它包含的所有值都必须是 <code>Send</code>。类似地，如果想通过一个通道向另一个线程发送值，这些值必须是 <code>Send</code>。</p>
<h4 id="迭代-Pipeline"><a href="#迭代-Pipeline" class="headerlink" title="迭代 Pipeline"></a>迭代 <code>Pipeline</code></h4><p>如果我们能使用迭代器的方法处理我们之前的倒排索引，就会显得很清晰，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">documents.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">  .<span class="title function_ invoke__">map</span>(read_whole_file)</span><br><span class="line">  .<span class="title function_ invoke__">errors_to</span>(error_sender) <span class="comment">// filter out error results</span></span><br><span class="line">  .<span class="title function_ invoke__">off_thread</span>() <span class="comment">// spawn a thread for the above work</span></span><br><span class="line">  .<span class="title function_ invoke__">map</span>(make_single_file_index)</span><br><span class="line">  .<span class="title function_ invoke__">off_thread</span>() <span class="comment">// spawn another thread for stage 2</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>因为 <code>Trait</code> 允许我们为标准库类型添加功能，所以我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">OffThreadExt</span>: <span class="built_in">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">/// Transform this iterator into an off-thread iterator: the</span></span><br><span class="line">    <span class="comment">/// `next()` calls happen on a separate worker thread, so the</span></span><br><span class="line">    <span class="comment">/// iterator and the body of your loop run concurrently.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">off_thread</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> mpsc::IntoIter&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; OffThreadExt <span class="keyword">for</span> <span class="title class_">T</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Iterator</span> + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    T::Item: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">off_thread</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> mpsc::IntoIter&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// Create a channel to transfer items from the worker thread.</span></span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// Move this iterator to a new worker thread and run it there.</span></span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> sender.<span class="title function_ invoke__">send</span>(item).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Return an iterator that pulls values from the channel.</span></span><br><span class="line">        receiver.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，这就是 <code>Rust</code> 的特点：我们可以自由地为该语言中的几乎每个迭代器添加一个新方法。</p>
<h4 id="Beyond-Pipelines"><a href="#Beyond-Pipelines" class="headerlink" title="Beyond Pipelines"></a><code>Beyond Pipelines</code></h4><p>前面我们使用管道作为示例，因为管道是使用通道的一种很好的、​​明显的方式，每个人都理解他们。它们是具体的、实用的和确定性的。不过，通道不仅仅对管道有用。它们也是向同一进程中的其他线程提供任何异步服务的一种快速、简单的方法。</p>
<p>例如，假设想在自己的线程上进行日志记录，其他线程可以通过通道向日志线程发送日志消息；由于可以克隆通道的<code>Sender</code>，因此许多客户端线程可以拥有<code>Sender</code>，而接收者处理只有一个。日志记录线程可以在需要时轮换日志文件，它不必与其他线程进行任何协调。</p>
<p>到目前为止，已经介绍的工具——用于高度并行计算的 <code>fork-join</code>、用于松散连接组件的通道——对于广泛的应用程序来说已经足够了，但还不够。</p>
<h3 id="共享可变状态"><a href="#共享可变状态" class="headerlink" title="共享可变状态"></a>共享可变状态</h3><p>如何在多个线程之间共享可变数据？</p>
<ul>
<li><p>可以通过创建一个新线程来解决此问题，该线程的全部工作是管理此可变数据，其他线程将通过通道与其通信。当然，这会花费一个线程，这会产生一些操作系统开销。</p>
</li>
<li><p>另一种选择是使用 <code>Rust</code> 提供的工具来安全地共享可变数据，互斥锁、读&#x2F;写锁、条件变量和原子整数。</p>
</li>
</ul>
<h4 id="什么是-Mutex？"><a href="#什么是-Mutex？" class="headerlink" title="什么是 Mutex？"></a>什么是 <code>Mutex</code>？</h4><p>互斥体（或锁）用于强制多个线程在访问某些数据时轮流进行，我们将在下一节介绍 <code>Rust</code> 的互斥锁。首先，回忆一下其他语言中的互斥锁是什么是有意义的。 <code>C++</code> 中互斥锁的简单使用可能如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FernEmpireApp::JoinWaitingList</span><span class="params">(PlayerId player)</span> </span>&#123;</span><br><span class="line">    mutex.<span class="built_in">Acquire</span>();</span><br><span class="line">    waitingList.<span class="built_in">push_back</span>(player);</span><br><span class="line">    <span class="comment">// Start a game if we have enough players waiting.</span></span><br><span class="line">    <span class="keyword">if</span> (waitingList.<span class="built_in">size</span>() &gt;= GAME_SIZE) &#123;</span><br><span class="line">        vector&lt;PlayerId&gt; players;</span><br><span class="line">        waitingList.<span class="built_in">swap</span>(players);</span><br><span class="line">        <span class="built_in">StartGame</span>(players);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>mutex.Acquire()</code> 和 <code>mutex.Release()</code> 标记此代码中关键部分的开始和结束。对于程序中的每个互斥体，一次只能在临界区内运行一个线程。 如果一个线程处于临界区，则调用 <code>mutex.Acquire()</code> 的所有其他线程将阻塞，直到第一个线程到达 <code>mutex.Release()</code>。</p>
<p>我们说互斥体保护数据：在这种情况下，互斥体保护 <code>waitingList</code>。但是，程序员有责任确保每个线程在访问数据之前总是获取互斥锁，然后再释放它。</p>
<p>它们防止数据竞争，即竞争线程同时读取和写入相同内存的情况。即使不存在数据竞争，即使所有读取和写入都按程序顺序一一发生，如果没有互斥锁，不同线程的操作也可能以任意方式交错。 </p>
<p>当然，所有这些实际上都是同一个原因：不受控制的竞争条件使编程变得棘手，而互斥锁就是为了解决这种混乱。然而，在大多数语言中，互斥锁很容易搞砸。 在 <code>C++</code> 中，与大多数语言一样，数据和锁是独立的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FernEmpireApp</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// List of players waiting to join a game. Protected by `mutex`.</span></span><br><span class="line">  vector&lt;PlayerId&gt; waitingList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock to acquire before reading or writing `waitingList`.</span></span><br><span class="line">  Mutex mutex;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是即使有注释，编译器也不能在这里强制安全访问。当一段代码忽略获取互斥锁时，我们会得到未定义的行为。实际上，这意味着极难重现和修复的错误。即使在 <code>Java</code> 中，对象和互斥体之间存在一些概念上的关联，这种关系也不是很深。编译器不会尝试强制执行它，实际上，受锁保护的数据很少完全是关联对象的字段，它通常包含多个对象中的数据。</p>
<h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex&lt;T&gt;"></a><code>Mutex&lt;T&gt;</code></h4><p>其他语言的锁看起来不那么好有两点：一个是锁和数据独立，一个是编译器不能进行强制检查可能存在竞争的数据是否受锁保护。继续前面的例子，我们来看 <code>Rust</code> 的解决方案：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PlayerId</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GAME_SIZE: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/// A waiting list never grows to more than GAME_SIZE players.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WaitingList</span> = <span class="type">Vec</span>&lt;PlayerId&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FernEmpireApp</span> &#123;</span><br><span class="line">    waiting_list: Mutex&lt;WaitingList&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app</span> = Arc::<span class="title function_ invoke__">new</span>(FernEmpireApp &#123;</span><br><span class="line">        waiting_list: Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不像 <code>c++</code>，数据是锁的一部分。创建一个新的 <code>Mutex</code> 看起来像创建一个新的 <code>Box</code> 或 <code>Arc</code>，但 <code>Box</code> 和 <code>Arc</code> 表示堆分配，<code>Mutex</code> 只是关于锁定。如果希望在堆中分配 <code>Mutex</code>，则必须像我们在这里通过对整个应用程序使用 <code>Arc::new</code> 和仅对受保护数据使用 <code>Mutex::new</code> 所做的那样。这些类型通常一起使用：<code>Arc</code> 可方便地跨线程共享事物，而 <code>Mutex</code> 可方便地用于跨线程共享的可变数据。</p>
<p>我们可以看下如何使用锁，唯一获取数据的方式是使用 <code>self.waiting_list.lock()</code>，它可以一直阻塞到数据可以获取。<code>guard</code> 的类型是 <code>MutexGuard&lt;WaitingList&gt;</code>，由于实现了 <code>Deref</code>，所以我们可以直接调用 <code>guard.push(player)</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">FernEmpireApp</span> &#123;</span><br><span class="line">    <span class="comment">/// Add a player to the waiting list for the next game.</span></span><br><span class="line">    <span class="comment">/// Start a new game immediately if enough players are waiting.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">join_waiting_list</span>(&amp;<span class="keyword">self</span>, player: PlayerId) &#123;</span><br><span class="line">        <span class="comment">// Lock the mutex and gain access to the data inside.</span></span><br><span class="line">        <span class="comment">// The scope of `guard` is a critical section.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = <span class="keyword">self</span>.waiting_list.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// Now do the game logic.</span></span><br><span class="line">        guard.<span class="title function_ invoke__">push</span>(player);</span><br><span class="line">        <span class="keyword">if</span> guard.<span class="title function_ invoke__">len</span>() == GAME_SIZE &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">players</span> = guard.<span class="title function_ invoke__">split_off</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">start_game</span>(players);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>guard</code> 甚至允许我们借用对基础数据的直接引用。<code>Rust</code> 的生命周期系统确保这些引用不会超过 <code>guard</code> 本身。如果不持有锁，就无法访问 <code>Mutex</code> 中的数据。当 <code>guard</code> 离开作用域时，锁被释放，通常这发生在块的末尾，但也可以手动删除它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> guard.<span class="title function_ invoke__">len</span>() == GAME_SIZE &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">players</span> = guard.<span class="title function_ invoke__">split_off</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(guard); <span class="comment">// don&#x27;t keep the list locked while starting a game</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">start_game</span>(players);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mut-和-Mutex"><a href="#mut-和-Mutex" class="headerlink" title="mut 和 Mutex"></a><code>mut</code> 和 <code>Mutex</code></h4><p>上面的例子中，我们的 <code>join_waiting_list</code> 方法的第一个参数竟然是 <code>&amp;self</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">join_waiting_list</span>(&amp;<span class="keyword">self</span>, player: PlayerId)</span><br></pre></td></tr></table></figure>

<p>但是我们调用的 <code>push</code> 方法需要可变引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item: T)</span><br></pre></td></tr></table></figure>

<p>互斥锁提供对内部数据的独占（<code>mut</code>）访问，即使许多线程可能对互斥锁本身具有共享（<code>非mut</code>）访问。<code>Rust</code> 的类型系统告诉我们 <code>Mutex</code> 做了什么。它动态地强制执行独占访问，这通常由 <code>Rust</code> 编译器在编译时静态完成，这其实类似于 <a href="/2022/04/24/%E3%80%90Rust%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/?highlight=cel#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><code>内部可变性</code></a>。</p>
<h4 id="Mutex-无法解决的问题"><a href="#Mutex-无法解决的问题" class="headerlink" title="Mutex 无法解决的问题"></a><code>Mutex</code> 无法解决的问题</h4><p>几乎可以肯定，<code>Rust</code> 互斥锁的设计会让你比以往任何时候都更系统、更明智地使用互斥锁。但是值得停下来思考一下 <code>Rust</code> 的安全保证可以和不能帮助什么。安全的 <code>Rust</code> 代码不能触发数据竞争，这是一种特定类型的错误，其中多个线程同时读取和写入相同的内存，从而产生毫无意义的结果。这很棒：数据竞争总是错误的，在真正的多线程程序中并不罕见。但是，使用互斥锁的线程会遇到 <code>Rust</code> 无法解决其他一些问题：</p>
<ul>
<li><p>有效的 <code>Rust</code> 程序不能有数据竞争，但它们仍然可以有其他竞争条件——程序的行为取决于线程之间的时间，因此可能因运行而异。一些竞争条件是良性的。有些表现为一般的脆弱性和难以修复的错误，以非结构化方式使用互斥锁会引发竞争条件；</p>
</li>
<li><p>共享可变状态也会影响程序设计。通道在代码中充当抽象边界，便于分离隔离的组件以进行测试，互斥锁鼓励“仅添加方法”的工作方式，这可能导致相互关联的代码的整体块；</p>
</li>
<li><p>最后，互斥锁并不像一开始看起来那么简单，正如接下来的两节将展示的那样；</p>
</li>
</ul>
<h5 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a><code>Deadlock</code></h5><p>线程可以通过尝试获取它已经持有的锁来使自己死锁：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard1</span> = <span class="keyword">self</span>.waiting_list.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard2</span> = <span class="keyword">self</span>.waiting_list.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// deadlock</span></span><br></pre></td></tr></table></figure>

<p>假设第一次调用 <code>self.waiting_list.lock()</code> 成功，获得了锁。第二个调用看到锁被持有，所以它阻塞，等待它被释放。它将永远等待。等待线程是持有锁的线程。</p>
<p>换句话说，互斥锁中的锁不是递归锁。</p>
<p>这里的错误很明显。在实际程序中，两个 <code>lock()</code> 调用可能在两个不同的方法中，其中一个调用另一个。每个方法的代码，分开来看，看起来不错。还有其他方法可以导致死锁，涉及多个线程，每个线程一次获取多个互斥锁。 <strong>Rust 的借用系统无法做到避免死锁。最好的保护措施是将关键部分保持在较小的范围内：进入，完成工作，然后退出。</strong></p>
<p>也有可能与渠道陷入僵局。例如，两个线程可能会阻塞，每个线程都在等待从另一个接收消息。然而，再一次，好的程序设计可以让你高度相信这在实践中不会发生。在管道中，就像我们的倒排索引构建器一样，数据流是非循环的。在这样的程序中，死锁的可能性与在 <code>Unix shell</code> 管道中一样。</p>
<h5 id="Poisoned-Mutexes"><a href="#Poisoned-Mutexes" class="headerlink" title="Poisoned Mutexes"></a><code>Poisoned Mutexes</code></h5><p><code>Mutex::lock()</code> 返回 <code>Result</code> 的原因与 <code>JoinHandle::join()</code> 所做的相同：如果另一个线程发生<code>panic</code>，则优雅地失败。当我们编写 <code>handle.join().unwrap()</code> 时，我们是在告诉 <code>Rust</code> 将 <code>panic</code> 从一个线程传播到另一个线程，<code>mutex.lock().unwrap()</code> 类似。</p>
<p>如果线程在持有 <code>Mutex</code> 时发生 <code>panic</code>，<code>Rust</code> 会将 <code>Mutex</code> 标记为 <code>Poisoned</code>。任何后续尝试锁定 <code>Poisoned Mutex</code> 都会得到错误结果。如果发生这种情况，我们的 <code>.unwrap()</code> 调用会告诉 <code>Rust</code> <code>panic</code>，将 <code>panic</code> 从另一个线程传播到这个线程。</p>
<p>有一个<code>Poisoned</code>互斥锁有多糟糕？毒药听起来很致命，但这种情况并不一定是致命的。<code>panic</code>是安全的，一个 <code>panic</code> 线程使程序的其余部分处于安全状态。</p>
<p>因此，互斥锁因 <code>panic</code> 而 <code>Poisoned</code> 原因并不是因为害怕未定义的行为。相反，担心的是一直在使用不变量进行编程。由于程序在没有完成它正在做的事情的情况下 <code>panic</code> 并退出了关键部分，可能已经更新了受保护数据的某些字段但没有更新其他字段，因此不变量现在可能已损坏。 <code>Rust</code> 会毒化互斥体，以防止其他线程无意中误入这种损坏的情况并使其变得更糟。但仍然可以锁定中毒的互斥体并访问其中的数据，完全强制互斥，请看 <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html">PoisonError::into_inne()</a> 的文档。</p>
<h4 id="多消费者通道"><a href="#多消费者通道" class="headerlink" title="多消费者通道"></a>多消费者通道</h4><p>我们前面提到，Rust 的通道是多生产者，单消费者。或者更具体地说，一个通道只有一个 <code>Receiver</code>。我们不能有一个线程池，其中许多线程使用单个 <code>mpsc</code> 通道作为共享工作列表。</p>
<p>然而，事实证明有一个非常简单的解决方法，只使用标准库片段。我们可以在 <code>Receiver</code> 周围添加一个 <code>Mutex</code> 并无论如何共享它。这是一个这样做的模块：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> shared_channel &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">use</span> std::sync::mpsc::&#123;channel, Receiver, Sender&#125;;</span><br><span class="line">    <span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// A thread-safe wrapper around a `Receiver`.</span></span><br><span class="line">    <span class="meta">#[derive(Clone)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SharedReceiver</span>&lt;T&gt;(Arc&lt;Mutex&lt;Receiver&lt;T&gt;&gt;&gt;);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> <span class="title class_">SharedReceiver</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Item</span> = T;</span><br><span class="line">        <span class="comment">/// Get the next item from the wrapped receiver.</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">guard</span> = <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            guard.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">ok</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/// This returns a sender and a receiver, just like the stdlib&#x27;s</span></span><br><span class="line">    <span class="comment">/// `channel()`, and sometimes works as a drop-in replacement.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shared_channel</span>&lt;T&gt;() <span class="punctuation">-&gt;</span> (Sender&lt;T&gt;, SharedReceiver&lt;T&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line">        (sender, <span class="title function_ invoke__">SharedReceiver</span>(Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/2022/04/21/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/mc-channel.png" class="">

<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>互斥锁只有一个 <code>.lock()</code>，而<a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>std::sync::RwLock</code></a> 有两种锁方法，<code>.read()</code> 和 <code>.write()</code>，<code>RwLock::write</code> 方法类似于 <code>Mutex::lock</code>。它等待对受保护数据的独占 <code>mut</code> 访问。<code>RwLock::read</code> 方法提供 <code>non mut</code> 访问，其优点是不必等待，因为许多线程可以安全地一次读取。使用互斥锁，在任何给定时刻，受保护的数据只有一个读取器或写入器（或没有）。使用<code>std::sync::RwLock</code>，它可以有一个 <code>Writer</code> 或多个 <code>Reader</code>，就像通常的 <code>Rust</code> 引用一样。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FernEmpireApp</span> &#123;</span><br><span class="line">    waiting_list: RwLock&lt;WaitingList&gt;,</span><br><span class="line">    config: RwLock&lt;AppConfig&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FernEmpireApp</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mushrooms_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">config_guard</span> = <span class="keyword">self</span>.config.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        config_guard.mushrooms_enabled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">reload_config</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_config</span> = AppConfig::<span class="title function_ invoke__">load</span>()?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">config_guard</span> = <span class="keyword">self</span>.config.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *config_guard = new_config;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多读单写是 <code>Rust</code> 借用系统的核心。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>通常一个线程需要等到某个条件变为真：</p>
<ul>
<li><p>在服务器关闭期间，主线程可能需要等待，直到所有其他线程完成退出；</p>
</li>
<li><p>当一个工作线程无事可做时，它需要等待，直到有一些数据要处理；</p>
</li>
<li><p>实现分布式共识协议的线程可能需要等到一定数量的对等方做出响应；</p>
</li>
</ul>
<p>在 <code>Rust</code> 中，<a href="https://doc.rust-lang.org/std/sync/struct.Condvar.html"><code>std::sync::Condvar</code></a> 类型实现了条件变量，它有方法 <code>.wait()</code> 和 <code>.notify_all()</code>，<code>.wait()</code> 会阻塞到直到有其他线程调用 <code>.notify_all()</code> 或者 <code>notify_one()</code>。</p>
<p>当等待的条件到来时，可以使用 <code>.notify_all()</code> 或者 <code>notify_one()</code> 通知其他线程：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.has_data_condvar.<span class="title function_ invoke__">notify_all</span>();</span><br></pre></td></tr></table></figure>

<p>为了进入休眠等待条件变为 <code>true</code>，可使用 <code>Condvar::wait()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> !guard.<span class="title function_ invoke__">has_data</span>() &#123;</span><br><span class="line">    guard = <span class="keyword">self</span>.has_data_condvar.<span class="title function_ invoke__">wait</span>(guard).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>while</code> 循环是条件变量的标准习惯用法。 但是，<code>Condvar::wait</code> 的签名是不寻常的。它按值获取 <code>MutexGuard</code> 对象，使用它，并在成功时返回一个新的 <code>MutexGuard</code>。</p>
<h4 id="原子锁"><a href="#原子锁" class="headerlink" title="原子锁"></a>原子锁</h4><p><a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a> 模块包含用于无锁并发编程的原子类型。这些类型与标准 <code>C++</code> 原子基本相同，但有一些额外的：</p>
<ul>
<li><p><code>AtomicIsize</code> 和 <code>AtomicUsize</code> 是对应于单线程 <code>isize</code> 和 <code>usize</code> 类型的共享整数类型；</p>
</li>
<li><p><code>AtomicI8</code>、<code>AtomicI16</code>、<code>AtomicI32</code>、<code>AtomicI64</code> 及其无符号变体（如 <code>AtomicU8</code>）是共享整数类型，对应于单线程类型 <code>i8</code>、<code>i16</code> 等。</p>
</li>
<li><p><code>AtomicBool</code> 是一个共享的布尔值；</p>
</li>
<li><p><code>AtomicPtr&lt;T&gt;</code> 是不安全指针类型 <code>*mut T</code> 的共享值；</p>
</li>
</ul>
<p>说多个线程可以一次读取和写入一个原子值而不会导致数据竞争。与通常的算术和逻辑运算符不同，原子类型公开了执行原子操作的方法、单独的加载、存储、交换和算术操作，这些操作作为一个单元安全发生，即使其他线程也在执行触及同一内存的原子操作。递增一个名为 <code>atom</code> 的 <code>AtomicIsize</code> 如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicIsize, Ordering&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">atom</span> = AtomicIsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">atom.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br></pre></td></tr></table></figure>

<p>这些方法可以编译成专门的机器语言指令。在 <code>x86-64</code> 架构上，此 <code>.fetch_add()</code> 调用编译为 <code>lock incq</code> 指令，其中普通的 <code>n += 1</code> 可能编译为普通的 <code>incq</code> 指令。<code>Rust</code> 编译器还必须放弃围绕原子操作的一些优化，因为与正常的加载或存储不同，它可以合法地立即影响其他线程或被其他线程影响。</p>
<p>参数 <a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html"><code>Ordering::SeqCst</code></a> 是内存排序，内存排序类似于数据库中的事务隔离级别，内存顺序对于程序的正确性至关重要，而且它们很难理解和推理。令人高兴的是，选择顺序一致性（最严格的内存排序）的性能损失通常非常低——与将 <code>SQL</code> 数据库置于 <code>SERIALIZABLE</code> 模式的性能损失不同。因此，如有疑问，请使用 <code>Ordering::SeqCst</code>。 <code>Rust</code> 从标准 <code>C++</code> 原子继承了其他几个内存排序，对存在的本质和因果关系有各种较弱的保证。 </p>
<p>原子的一种简单用途是取消。 假设我们有一个线程正在执行一些长时间运行的计算，例如渲染视频，并且我们希望能够异步取消它。 问题是与我们希望它关闭的线程进行通信。 我们可以通过共享的 <code>AtomicBool</code> 做到这一点：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::AtomicBool;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cancel_flag</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">worker_cancel_flag</span> = cancel_flag.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码创建了两个 <code>Arc&lt;AtomicBool&gt;</code> 智能指针，它们指向同一个堆分配的 <code>AtomicBool</code>，其初始值为 <code>false</code>。 第一个名为 <code>cancel_flag</code>，将留在主线程中。 第二个，<code>worker_cancel_flag</code>，将被移动到工作线程。</p>
<p>下面是工作线程中的示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">worker_handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">pixel</span> <span class="keyword">in</span> animation.<span class="title function_ invoke__">pixels_mut</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(pixel); <span class="comment">// ray-tracing - this takes a few microseconds</span></span><br><span class="line">        <span class="keyword">if</span> worker_cancel_flag.<span class="title function_ invoke__">load</span>(Ordering::SeqCst) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(animation)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>load(Ordering::SeqCst)</code> 来检查循环要不要继续，我们可以在主线程中取消工作线程继续执行任务：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cancel rendering.</span></span><br><span class="line">cancel_flag.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line"><span class="comment">// Discard the result, which is probably `None`.</span></span><br><span class="line">worker_handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>当然，还有其他方法可以实现这一点，这里的 <code>AtomicBool</code> 可以替换为 <code>Mutex&lt;bool&gt;</code> 或通道，主要区别在于原子具有最小的开销，原子操作从不使用系统调用，加载或存储通常编译为单个 <code>CPU</code> 指令。</p>
<p>原子是内部可变性的一种形式，例如 <code>Mutex</code> 或 <code>RwLock</code>，因此它们的方法通过共享（非 <code>mut</code>）引用来获取自身，这使得它们可用作简单的全局变量。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p><code>Rust</code> 尽其所能阻止全局可变状态，用 <code>const</code> 声明的常量当然是不可变的。默认情况下，静态变量也是不可变的，因此没有办法获得一个 <code>mut</code> 引用。静态可以声明为 <code>mut</code>，但随后访问它是不安全的，<code>Rust</code> 对线程安全的坚持是所有这些规则的主要原因。</p>
<p>全局可变状态往往使程序的各个部分更紧密耦合，更难测试，也更难在以后更改。尽管如此，在某些情况下还是没有合理的替代方案，所以我们最好找到一种安全的方法来声明可变静态变量。</p>
<p>我们可以使用原子整数保证线程安全，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::AtomicUsize;</span><br><span class="line"><span class="keyword">static</span> PACKETS_SERVED: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用以下方式增加它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::Ordering;</span><br><span class="line">PACKETS_SERVED.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br></pre></td></tr></table></figure>

<p>原子全局变量仅限于简单的整数和布尔值。尽管如此，创建任何其他类型的全局变量都相当于解决两个问题。</p>
<p>首先，变量必须以某种方式成为线程安全的，否则它就不能是全局的：为了安全起见，静态变量必须是 <code>Sync</code> 和 <code>non-mut</code>。但是 <code>Rust</code> 有用于安全共享变化值的类型：<code>Mutex</code>、<code>RwLock</code> 和原子类型，即使声明为<code>非 mut</code>，这些类型也可以修改。</p>
<p>其次，静态初始化器只能调用特别标记为 <code>const</code> 的函数，编译器可以在编译期间对其进行评估。换句话说，它们的输出是确定性的；它仅取决于它们的参数，而不取决于任何其他状态或 <code>I/O</code>。这样，编译器可以将该计算的结果作为编译时常量嵌入，这类似于 <code>C++ constexpr</code>。</p>
<p><code>Atomic</code> 类型（<code>AtomicUsize</code>、<code>AtomicBool</code> 等）的构造函数都是 <code>const</code> 函数，这使我们能够更早地创建静态<code> AtomicUsize</code>。其他一些类型，如 <code>String</code>、<code>Ipv4Addr</code> 和 <code>Ipv6Addr</code>，也有简单的构造函数，它们也是 <code>const</code>。</p>
<p>也可以通过简单地在函数的签名前加上 <code>const</code> 来定义自己的 <code>const</code> 函数。<code>Rust</code> 将 <code>const</code> 函数的功能限制为一小组操作，这些操作足够有用，但仍然不允许任何不确定的结果。<code>const</code> 函数不能将类型作为泛型参数，只能作为生命周期，并且不能分配内存或对原始指针进行操作，即使在不安全的块中也是如此。但是，我们可以使用算术运算、逻辑运算以及其他 <code>const</code> 函数。例如，我们可以创建方便的函数来简化静态和常量的定义并减少代码重复：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">mono_to_rgba</span>(level: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> Color &#123;</span><br><span class="line">    Color &#123;</span><br><span class="line">        red: level,</span><br><span class="line">        green: level,</span><br><span class="line">        blue: level,</span><br><span class="line">        alpha: <span class="number">0xFF</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> WHITE: Color = <span class="title function_ invoke__">mono_to_rgba</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">const</span> BLACK: Color = <span class="title function_ invoke__">mono_to_rgba</span>(<span class="number">000</span>);</span><br></pre></td></tr></table></figure>

<p>但是我们不能写下面这样的函数：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HOSTNAME: Mutex&lt;<span class="type">String</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>()); <span class="comment">// error: calls in statics are limited to</span></span><br></pre></td></tr></table></figure></div>

<p>因为 <code>Mutex::new</code> 不是 <code>const fn</code>，而 <code>AtomicUsize::new()</code> 和 <code>String::new()</code> 是的。为了绕过这些限制，我们可以使用 <code>lazy_static</code>：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> HOSTNAME: Mutex&lt;<span class="type">String</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>lazy_static</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> HASHMAP: Arc&lt;Mutex&lt;HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt;&gt;&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(m))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HASHMAP.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>, <span class="string">&quot;waz&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;map: &#123;:?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>同样的技术适用于其他复杂的数据结构，如 <code>HashMaps</code> 和 <code>Deques</code>。 使用 <code>lazy_static！</code> 对静态数据的每次访问都会产生很小的性能成本。 该实现使用 <a href="https://doc.rust-lang.org/std/sync/struct.Once.html"><code>std::sync::Once</code></a>，这是一种为一次性初始化而设计的低级同步原语。在幕后，每次访问惰性静态时，程序都会执行原子加载指令来检查初始化是否已经发生。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】实战突破</title>
    <url>/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><code>Rust</code> 是一门赋予每个人构建可靠且高效软件能力的语言。</p>

</blockquote>

<p><code>Rust</code> 相比其他语言，具有显著的特点，尤其是：</p>
<ol>
<li><p>性能高；<code>Rust</code> 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。 </p>
</li>
<li><p>高可靠；<code>Rust</code> 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</p>
</li>
<li><p>极具生产力；<code>Rust</code> 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
</li>
</ol>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/why-is-rust-programmng-language-so-popular-fi.png" class="" title="why rust so popular">

<span id="more"></span>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a><code>loop</code></h4><p>不同于其他语言，<code>rust</code> 的 <code>loop</code> 循环是可以返回值的，因为 <code>loop</code> 循环是一个表达式，表达式可以求值，这样就可以作为赋值语句使用，如下示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a><code>if let</code></h4><p>由于 <code>match</code> 模式匹配必须要指出所有的可能性，所以在使用上不是很优雅，因此有了 <code>if let</code>，可以说它是 <code>match</code> 的语法糖，可以按需只匹配自己想要的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rust 中的 None 值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(n) = none &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is &#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is none&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="while-let"><a href="#while-let" class="headerlink" title="while let"></a>while let</h4><p>同 <code>if let</code> 类似，<code>while let</code> 可以简化代码的书写方式，使得呈现上更加优雅。</p>
<div class="tabs" id="loop-and-while-let"><ul class="nav-tabs"><li class="tab"><a href="#loop-and-while-let-1">loop match</a></li><li class="tab active"><a href="#loop-and-while-let-2">while let</a></li></ul><div class="tab-content"><div class="tab-pane" id="loop-and-while-let-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> number &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> value &gt; <span class="number">9</span> &#123;</span><br><span class="line">                    number = <span class="literal">None</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    number = <span class="title function_ invoke__">Some</span>(value + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;number is &#123;:?&#125;&quot;</span>, number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is none: &#123;&#125;&quot;</span>, number.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane active" id="loop-and-while-let-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = number &#123;</span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">9</span> &#123;</span><br><span class="line">            number = <span class="literal">None</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            number = <span class="title function_ invoke__">Some</span>(value + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;number is &#123;:?&#125;&quot;</span>, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is none: &#123;&#125;&quot;</span>, number.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="零类型"><a href="#零类型" class="headerlink" title="零类型"></a>零类型</h3><p><code>rust</code> 中某些类型的是不占用任何内存的，享受 <code>rust</code> 为他们提供的优化，我们可以用标准库提供的 <code>std::mem::size_of_val</code> 函数进行测量。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">R</span>(<span class="type">i16</span>),</span><br><span class="line">    <span class="title function_ invoke__">G</span>(<span class="type">i16</span>),</span><br><span class="line">    <span class="title function_ invoke__">B</span>(<span class="type">i16</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该枚举等价于，所以他们可以被当做函数使用</span></span><br><span class="line"><span class="comment">// fn Color::R(c: i16) -&gt; Color &#123; /* ... */ &#125;</span></span><br><span class="line"><span class="comment">// fn Color::G(c: i16) -&gt; Color &#123; /* ... */ &#125;</span></span><br><span class="line"><span class="comment">// fn Color::B(c: i16) -&gt; Color &#123; /* ... */ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 同样一个函数，我们再赋值给一个变量时，在指定函数指针类型时，占用8个字节</span></span><br><span class="line">    <span class="comment">// 不指定时，为函数项类型，占用0字节，函数项类型在必要时可以自动转化为函数指针类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span> = add;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_ptr</span>: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>, <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = add;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add size: &#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add)); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add_ptr size: &#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add_ptr)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举项占用的大小也是0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Color::B size: &#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;Color::B)); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>rust</code>提供<code>match</code>关键字用于模式匹配，类似于其他语言中的<code>switch</code>，不同的是<code>match</code>必须列出所有可能情况。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// match 分支必须覆盖所有可能的情况</span></span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="comment">// 可以匹配单个值</span></span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="comment">// 可以匹配多个值</span></span><br><span class="line">        <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;2 -&gt; 5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还可以匹配一个范围</span></span><br><span class="line">        <span class="number">6</span>..=<span class="number">10</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;6 -&gt; 10&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;others&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅如此，<code>match</code> 还可以用于解构枚举<code>enum</code>，下面是一个复杂的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举值相互嵌套</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>, r, g, b)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,</span><br><span class="line">                h, s, v</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配剩下所有的情况</span></span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code> 在匹配到第一个条件之后，不会再往下匹配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">match</span> pair &#123;</span><br><span class="line">        <span class="comment">// 只会匹配到这里</span></span><br><span class="line">        (<span class="number">0</span>, y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;First is `0` and `y` is `&#123;:?&#125;`&quot;</span>, y),</span><br><span class="line">        (x, <span class="number">0</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;`x` is `&#123;:?&#125;` and last is `0`&quot;</span>, x),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h4><p><code>match</code> 模式匹配可以加上 <code>if</code>条件语句来过滤分支，提供更加灵活的匹配方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = (<span class="number">2</span>, -<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">match</span> pair &#123;</span><br><span class="line">        (x, y) <span class="keyword">if</span> x + y == <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; == 0&quot;</span>, x, y),</span><br><span class="line">        (x, y) <span class="keyword">if</span> x == y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x == y&quot;</span>),</span><br><span class="line">        (x, y) <span class="keyword">if</span> x % y == <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; % &#123;&#125; == 0&quot;</span>, x, y),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绑定"><a href="#绑定" class="headerlink" title="@ 绑定"></a>@ 绑定</h4><p><code>match</code> 提供了 <code>@</code> 运算符用于将值绑定到变量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">age</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_number</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tell me type of person you are&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">age</span>() &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m not born yet I guess&quot;</span>),</span><br><span class="line">        <span class="comment">// 可以直接 `match` 1 ..= 12，但怎么把岁数打印出来呢？</span></span><br><span class="line">        <span class="comment">// 相反，在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。</span></span><br><span class="line">        n @ <span class="number">1</span>..=<span class="number">12</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m a child of age &#123;:?&#125;&quot;</span>, n),</span><br><span class="line">        n @ <span class="number">13</span>..=<span class="number">19</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m a teen of age &#123;:?&#125;&quot;</span>, n),</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        n =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m an old person of age &#123;:?&#125;&quot;</span>, n),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用于枚举</span></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">some_number</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n @ <span class="number">42</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The Answer: &#123;&#125;!&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Not interesting... &#123;&#125;&quot;</span>, n),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><p>解构可以非常方便地从一个结构体或者元组中提取某个字段或者全部：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        x: (<span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">        y: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构结构体的成员，字段x是一个元组，分别解析到a，b；字段y解析到y</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo</span> = Foo &#123; x: (<span class="number">1</span>, <span class="number">2</span>), y: <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; x: (a, b), y &#125; = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;,  y = &#123;&#125; &quot;</span>, a, b, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以解构结构体并重命名变量，成员顺序并不重要；将y解析成i；x解析成j；</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; y: i, x: j &#125; = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;:?&#125;, j = &#123;:?&#125;&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以忽略某些变量，只解析y，忽略x</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; y, .. &#125; = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h4><p>对指针来说，解构（<code>destructure</code>）和解引用（<code>dereference</code>）要区分开，因为这两者的概念 是不同的，和 C 那样的语言用法不一样。</p>
<ul>
<li>解引用使用 <code>*</code></li>
<li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference</span> = &amp;<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> reference &#123;</span><br><span class="line">        <span class="comment">// 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：</span></span><br><span class="line">        <span class="comment">// `&amp;i32`（译注：即 `reference` 的类型）</span></span><br><span class="line">        <span class="comment">//    |</span></span><br><span class="line">        <span class="comment">// `&amp;val`（译注：即用于匹配的模式）</span></span><br><span class="line">        <span class="comment">// ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。</span></span><br><span class="line">        <span class="comment">// 译注：因此可用 `val` 表示被 `reference` 引用的值 4。</span></span><br><span class="line">        &amp;val =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a value via destructuring: &#123;:?&#125;&quot;</span>, val),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想用 `&amp;`，需要在匹配前解引用。</span></span><br><span class="line">    <span class="keyword">match</span> *reference &#123;</span><br><span class="line">        val =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a value via dereferencing: &#123;:?&#125;&quot;</span>, val),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句</span></span><br><span class="line">    <span class="comment">// 的右边已经是一个引用。但下面这个不是引用，因为右边不是。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_not_a_reference</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。</span></span><br><span class="line">    <span class="comment">// 下面这行将得到一个引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> _is_a_reference = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mut_value</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 `ref` 关键字来创建引用。</span></span><br><span class="line">    <span class="comment">// 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上</span></span><br><span class="line">    <span class="comment">// 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能</span></span><br><span class="line">    <span class="comment">// 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解</span></span><br><span class="line">    <span class="comment">// 引用。</span></span><br><span class="line">    <span class="keyword">match</span> value &#123;</span><br><span class="line">        <span class="keyword">ref</span> r =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a reference to a value: &#123;:?&#125;&quot;</span>, r),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似地使用 `ref mut`。</span></span><br><span class="line">    <span class="keyword">match</span> mut_value &#123;</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">mut</span> m =&gt; &#123;</span><br><span class="line">            <span class="comment">// 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。</span></span><br><span class="line">            *m += <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;We added 10. `mut_value`: &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;</code> 和 <code>ref</code> 都表示获取引用，只是一个出现在表达式左边一个出现在右边，当 <code>&amp;</code> 出现在右边的时候等价于 <code>ref</code> 出现在左边，<code>&amp;</code> 出现在左边的时候等价于 <code>*</code> 出现在右边：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(core_intrinsics)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="literal">false</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &amp;x = &amp;<span class="literal">false</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> x = &amp;<span class="literal">false</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *x;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_type_name_of</span>&lt;T&gt;(_: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; std::intrinsics::type_name::&lt;T&gt;() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;bool</span><br><span class="line">bool</span><br><span class="line">&amp;&amp;bool</span><br><span class="line">&amp;i32</span><br><span class="line">i32</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://users.rust-lang.org/t/ref-keyword-versus/18818/2"><code>https://users.rust-lang.org/t/ref-keyword-versus/18818/2</code></a></p>
<h4 id="可反驳性"><a href="#可反驳性" class="headerlink" title="可反驳性"></a>可反驳性</h4><p>模式有两种形式：<code>refutable</code>（可反驳的）和 <code>irrefutable</code>（不可反驳的）。能匹配任何传递的可能值的模式被称为是不可反驳的（<code>irrefutable</code>），反之，对某些可能的值进行匹配会失败的模式被称为是可反驳的（<code>refutable</code>）。</p>
<p>举个例子，<code>let x = 5;</code> 中的 <code>x</code> 可以匹配任何值不会失败，所以称为不可反驳。<code>if let Some(x) = a_value</code> 中，如果 <code>a_value</code> 是 <code>None</code>，那么这个表达式就匹配不上，所以称为可反驳。</p>
<p>为什么有这么个模式？因为，函数参数，<code>let</code>，<code>for</code> 只能接收不可反驳的模式，也就是说只允许匹配成功，是一种确定性操作。而 <code>if let</code>，或者 <code>while let</code> 表达式被限制为只能接收可反驳的模式，也就是说他们允许出现匹配不上，即匹配失败的情况，再者说，他们的出现就是为了处理成功和失败这两种情况。下面的这段代码就会<mark class="label danger">编译失败</mark>，因为没有处理 <code>a_value</code> 为 <code>None</code> 的情况，<code>let</code> 也处理不了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Some</span>(x) = a_value;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于此，<code>match</code> 匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。<code>Rust</code> 允许我们在只有一个匹配分支的 <code>match</code> 中使用不可反驳模式，不过这么做不是特别有用，并可以被更简单的 <code>let</code> 语句替代。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法通常用于和函数对比，和函数的区别是方法附着于对象，方法分为静态方法和实例方法，静态方法常用语构造对象，实例方法中通过关键字 <code>self</code> 来引用对象中的数据。</p>
<div class="tabs" id="静态方法和实例方法"><ul class="nav-tabs"><li class="tab active"><a href="#静态方法和实例方法-1">静态方法</a></li><li class="tab"><a href="#静态方法和实例方法-2">实例方法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="静态方法和实例方法-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法，返回原点</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">origin</span>() <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定坐标构造</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point::<span class="title function_ invoke__">origin</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">other</span> = Point::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="静态方法和实例方法-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;self 其实是 self: &amp;Self 的语法糖，表示不可变引用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;mut self 其实是 self: &amp;mut Self, 表示可变引用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">plus_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.width += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.height += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self 直接将所有权转移</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">transfer</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rec</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">1</span>,</span><br><span class="line">        height: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rectangle &#123;:?&#125;, area is: &#123;&#125;&quot;</span>, rec, rec.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">    rec.<span class="title function_ invoke__">plus_one</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rectangle &#123;:?&#125;, area is: &#123;&#125;&quot;</span>, rec, rec.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rec1</span> = rec.<span class="title function_ invoke__">transfer</span>();</span><br><span class="line">    <span class="comment">// rec; // 编译失败，rec 的所有权已经转移至 rec1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是函数式编程中不可获取的一员，<code>rust</code> 对此也提供了支持，也叫 <code>lambda</code>，能够捕获环境中的变量，例如：</p>
<blockquote>
<p><code>|val| val + x</code></p>
</blockquote>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>这种超级简便的语法使得它在临时使用时非常方便，输入和返回值类型都可以自行推导，但是必须指定输入参数名称。在声明参数是，同函数不同，它是使用 <code>||</code> 而不是 <code>()</code> 将参数包裹起来；另外们对于单个表达式的闭包，<code>&#123;&#125;</code> 是可以省略的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b) = (<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">// 捕获变量 b</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plus_b_closure</span> = |input| input + b;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plus_one</span> = |x| x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">plus_b_fn</span>(input: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        input + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + b = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_b_closure</span>(a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + b = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_b_fn</span>(a, b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_one</span>(a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_one</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h4><p>闭包会自动满足函数功能的要求，使得闭包不需要类型说明就可以工作。这允许变量捕获（<code>capture</code>）灵活地适应使用场合，既可移动（<code>move</code>）又可借用（<code>borrow</code>）变量。闭包可以通过：<code>引用 &amp;T</code>， <code>可变引用 &amp;mut T</code>，<code>值 T</code>  自动捕获变量，也可以通过 <code>move</code> 强制获得变量的所有权：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">color</span> = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    <span class="comment">// 这个闭包打印 `color`。它会立即借用（通过引用，`&amp;`）`color` 并将该借用和</span></span><br><span class="line">    <span class="comment">// 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到 `print` 离开作用域。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">print</span> = || <span class="built_in">println!</span>(<span class="string">&quot;`color`: &#123;&#125;&quot;</span>, color);</span><br><span class="line">    <span class="title function_ invoke__">print</span>();</span><br><span class="line">    <span class="title function_ invoke__">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&amp;mut count` 或者</span></span><br><span class="line">    <span class="comment">// `count` 本身。`inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&amp;mut` 变量。</span></span><br><span class="line">    <span class="comment">// 调用闭包时，该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inc</span> = || &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;`count`: &#123;&#125;&quot;</span>, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">inc</span>();</span><br><span class="line">    <span class="title function_ invoke__">inc</span>();</span><br><span class="line">    <span class="comment">// 不能再次获得 count 的可变引用，因为前面的闭包中已经借用一次了</span></span><br><span class="line">    <span class="comment">// let reborrow = &amp;mut count;</span></span><br><span class="line">    <span class="comment">// reborrow += 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可复制类型（non-copy type）。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">movable</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，</span></span><br><span class="line">    <span class="comment">// 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动</span></span><br><span class="line">    <span class="comment">// （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;`movable`: &#123;:?&#125;&quot;</span>, movable);</span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(movable);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// `consume` 消耗了该变量，所以该闭包只能调用一次。</span></span><br><span class="line">    <span class="title function_ invoke__">consume</span>();</span><br><span class="line">    <span class="comment">// consume();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 move 关键字强制将 numbers 的所有权移动到闭包中</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contains</span> = <span class="keyword">move</span> |needle| numbers.<span class="title function_ invoke__">contains</span>(needle);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;numbers include 1 ? &#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;numbers include 4 ? &#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 由于 numbers 的所有权已经被移入 contains 中，所以这里不能再使用</span></span><br><span class="line">    <span class="comment">// println!(&quot;numbers length is &#123;&#125;&quot;, numbers.len());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作为入参"><a href="#作为入参" class="headerlink" title="作为入参"></a>作为入参</h4><p>虽然闭包可以自动做类型推断，但是在编写函数以闭包作为参数时，还是得必须明确指定类型，可以通过以下三个之一来指定闭包捕获变量的类型，他们的受限程度依次递减：</p>
<ul>
<li><code>Fn</code>：表示捕获方式为通过引用（<code>&amp;T</code>）的闭包</li>
<li><code>FnMut</code>：表示捕获方式为通过可变引用（<code>&amp;mut T</code>）的闭包</li>
<li><code>FnOnce</code>：表示捕获方式为通过值（<code>T</code>）的闭包</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>&lt;T&gt;(<span class="keyword">mut</span> f: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">FnMut</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;execute plus one&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数将闭包作为参数并调用它。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="comment">// 闭包没有输入值和返回值。</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_ invoke__">plus_one</span>(|| number += <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is &#123;&#125;&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 不可复制的类型。`to_owned` 从借用的数据创建有所有权的数据。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">farewell</span> = <span class="string">&quot;goodbye&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diary</span> = || &#123;</span><br><span class="line">        <span class="comment">// `greeting` 通过引用捕获，故需要闭包是 `Fn`。</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I said &#123;&#125;.&quot;</span>, greeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。</span></span><br><span class="line">        <span class="comment">// 现在需要 `FnMut`。</span></span><br><span class="line">        farewell.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Then I screamed &#123;&#125;.&quot;</span>, farewell);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动调用 drop 又要求闭包通过值获取 `farewell`。</span></span><br><span class="line">        <span class="comment">// 现在需要 `FnOnce`。</span></span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(farewell);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以闭包作为参数，调用函数 `apply`。</span></span><br><span class="line">    <span class="title function_ invoke__">apply</span>(diary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h4><p>闭包可以作为输入参数，也可以作为返回值返回，由于闭包的类型是未知的，所以只有使用 <code>impl Trait</code> 才能返回一个闭包。除此之外，还必须使用 <code>move</code> 关键字，它表明所有的捕获都是通过值进行的。因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fn</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;Fn&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;This is a: &#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fnmut</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;FnMut&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;This is a: &#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fnonce</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnOnce</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;FnOnce&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;This is a: &#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_plain</span> = <span class="title function_ invoke__">create_fn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fn_mut</span> = <span class="title function_ invoke__">create_fnmut</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_once</span> = <span class="title function_ invoke__">create_fnonce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">fn_plain</span>();</span><br><span class="line">    <span class="title function_ invoke__">fn_mut</span>();</span><br><span class="line">    <span class="title function_ invoke__">fn_once</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><a href="https://doc.rust-lang.org/std/primitive.fn.html">函数指针</a>是指向代码而非数据的指针。它们可以像函数一样被调用。与引用一样，函数指针被假定为不为空，因此如果想通过 FFI 传递函数指针并能够容纳空指针，需要使用所需的的类型 <code>Option&lt;fn()&gt; </code>。</p>
<p>函数指针的类型是 <code>fn</code>，注意和 <code>Fn</code> 区分，后者是闭包实现的 <code>trait</code> 类型。 函数指针实现了<strong>所有三个闭包</strong> <code>trait</code>（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 <code>trait</code> 的函数，这样它就能接受函数或闭包作为参数。<code>Fn</code> 系列 <code>trait</code> 由标准库提供，<strong>所有的闭包都实现了 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 中的一个或多个</strong>。</p>
<p>我们可以将一个闭包转换为函数指针作为参数传入，但是仅限于没有捕获任何环境变量的闭包，这个从闭包和函数的概念上也能区分出来，闭包相对于函数，就是捕获了环境变量。没有捕获任何环境变量的闭包会被编译器重写为匿名独立函数。</p>
<div class="tabs" id="函数和闭包作为参数"><ul class="nav-tabs"><li class="tab active"><a href="#函数和闭包作为参数-1">闭包作为参数</a></li><li class="tab"><a href="#函数和闭包作为参数-2">函数作为参数</a></li><li class="tab"><a href="#函数和闭包作为参数-3">元组结构体作为参数</a></li><li class="tab"><a href="#函数和闭包作为参数-4">闭包转换为函数</a></li><li class="tab"><a href="#函数和闭包作为参数-5">闭包不能转换为函数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="函数和闭包作为参数-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-3"><p>在构造元组结构体时使用 <code>()</code> 语法进行初始化，很像是函数调用，实际上它们确实被实现为返回由参数构造的实例的函数，所以它们也被称为实现了闭包 <code>trait</code> 的函数指针。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;Status&gt; = (<span class="number">0u32</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(Status::Value).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_statuses);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;State&gt; = (<span class="number">0u32</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(State).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_statuses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-4"><p>没有捕获任何环境变量的闭包会被编译器重写为匿名独立函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>() <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    <span class="title function_ invoke__">RGB</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show</span>(f: <span class="title function_ invoke__">fn</span>() <span class="punctuation">-&gt;</span> RGB) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;color is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">f</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = || <span class="title function_ invoke__">RGB</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包自动转换为函数指针</span></span><br><span class="line">    <span class="title function_ invoke__">show</span>(c);</span><br><span class="line">    <span class="title function_ invoke__">show</span>(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-5"><p>闭包捕获环境变量之后，就不能再转换为函数了。这里有个例子：<a href="https://stackoverflow.com/questions/52696907/why-does-passing-a-closure-to-function-which-accepts-a-function-pointer-not-work?answertab=active#tab-top">https://stackoverflow.com/questions/52696907/why-does-passing-a-closure-to-function-which-accepts-a-function-pointer-not-work?answertab=active#tab-top</a> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wrap</span>(c: <span class="title function_ invoke__">fn</span>() <span class="punctuation">-&gt;</span> ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="title function_ invoke__">c</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">wrap</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这段代码就会报错，帮我们指出闭包只有在没有捕获任何环境变量的情况下才能转换为函数，不得不说 <code>rust</code> 的编译器还是很友好：</p>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/closure-convert-to-fn-failed.PNG" class="" title="closure convert to fn failed"></div></div></div>

<h3 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h3><p><code>trait</code> 用于定义共享的行为，<code>trait</code> 告诉 <code>Rust</code> 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 <code>trait</code> 以一种抽象的方式定义共享的行为，可以使用 <code>trait bounds</code> 指定泛型是任何拥有特定行为的类型。<code>trait</code> 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合，这里定义的方法可以只是签名说明而没有函数体。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="默认类型和关联参数"><a href="#默认类型和关联参数" class="headerlink" title="默认类型和关联参数"></a>默认类型和关联参数</h4><p><code>rust</code> 官方提供了一个 <code>use std::ops::Add;</code>，可以用于重载 <code>+</code> 运算符，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>Output</code> 被称作关联类型，用来决定 <code>add</code> 的返回值类型，在具体实现的时候指定具体类型。这里的 <code>RHS=Self</code> 语法表示：<strong>默认类型参数</strong>，<code>RHS</code> 是 <code>right hand side</code> 的缩写，用于定义 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add trait</code> 时不指定 <code>RHS</code> 的具体类型，<code>RHS</code> 的类型将是默认的 <code>Self</code> 类型，也就是在其上实现 <code>Add</code> 的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 关联类型 Output 指定为 Point</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RHS 默认类型参数指定为：Meters</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="comment">// 关联类型 Output 指定为 Millimeters，指定 add 方法返回值类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">        Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">meter</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">millimeters</span> = <span class="title function_ invoke__">Millimeters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Millimeters</span>(<span class="number">1001</span>), millimeters + meter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完全限定语法"><a href="#完全限定语法" class="headerlink" title="完全限定语法"></a>完全限定语法</h4><p><code>Rust</code> 既不能避免一个 <code>trait</code> 与另一个 <code>trait</code> 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 <code>trait</code>。甚至直接在类型上实现开始已经有的同名方法也是可能的。下面的示例中通过在方法名称前面添加 <code>trait</code> 限定符，我们向 <code>rust</code> 指定我们需要哪个实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();         <span class="comment">// 直接调用 Human 的方法</span></span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);  <span class="comment">// 调用 Human 为 Pilot 的 fly 实现</span></span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person); <span class="comment">// 调用 Human 为 Wizard 的 fly 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>像上面这种 <code>fly</code> 方法有一个 <code>self</code> 参数，即使有多个类型实现同一 <code>trait</code>，在使用 <code>Trait::method(self)</code>时，<code>rust</code> 可以根据 <code>self</code> 类型帮我们定位具体哪个类型的实现。然而，当遇到关联函数，即第一个参数不是 <code>self</code> 时，<code>rust</code> 就不能帮我们计算出该使用哪个类型了。下面的示例中使用完全限定语法消除歧义，该语法为：</p>
<blockquote>
<p><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></p>
<p> 关联函数没有 <code>receiver</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Dog 类型的实现</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="comment">// Dog 类型为 Animal trait 的实现</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><p>实现 <code>trait</code> 时需要注意的一个限制是，只有当 <code>trait</code> 或者要实现 <code>trait</code> 的类型位于 <code>crate</code> 的本地作用域时，才能为该类型实现 <code>trait</code>，这个限制是被称为<code>相干性（coherence）</code> 的程序属性的一部分，或者更具体的说是<code>孤儿规则（orphan rule）</code>。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个<code>crate</code>可以分别对相同类型实现相同的<code>trait</code>，而<code>Rust</code>将无从得知应该使用哪一个实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = Article &#123;</span><br><span class="line">        content: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><p>默认实现指我们在定义 <code>trait</code> 方法时提供默认的实现行为，在为类型实现<code>trait</code>时，就可以不用再去实现它的方法了。默认实现的<code>trait</code>方法中还允许我们调用相同<code>trait</code>的其他方法，即使他们没有实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;author is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.author.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = Article &#123;</span><br><span class="line">        content: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_owned</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h4><p>我们可以将函数参数定义为实现了某个<code>trait</code>的类型，这样我们不用于去关心<code>trait</code>背后的具体类型，只在乎这些类型的行为。实现这一目标以多种不同的语法方式，它们是等价的，只是表现形式不同。</p>
<div class="tabs" id="trait作为参数"><ul class="nav-tabs"><li class="tab active"><a href="#trait作为参数-1">impl</a></li><li class="tab"><a href="#trait作为参数-2">trait bound</a></li><li class="tab"><a href="#trait作为参数-3">多个 trait bound</a></li></ul><div class="tab-content"><div class="tab-pane active" id="trait作为参数-1"><p>如下，我们定义 <code>notify</code> 函数，指定 <code>item</code> 参数为实现了 <code>Summary</code> 的一个类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;author is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;notify: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="trait作为参数-2"><p><code>impl</code> 看起来比较直观，它实际上是一个较长形式的语法糖，称之为 <code>trait bound</code>，所以前面的 <code>impl Summary</code> 等价于如下的形式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;notify: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_bound</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;notify: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl</code> 形式在参数较少时比较方便，在参数较多时就看起来比较冗余，使用 <code>trait bound</code> 看起来就比较方便：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_para2</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;notify1: &#123;&#125;, notify2: &#123;&#125;&quot;</span>,</span><br><span class="line">        item1.<span class="title function_ invoke__">summarize</span>(),</span><br><span class="line">        item2.<span class="title function_ invoke__">summarize</span>()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_para2_bound</span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;notify1: &#123;&#125;, notify2: &#123;&#125;&quot;</span>,</span><br><span class="line">        item1.<span class="title function_ invoke__">summarize</span>(),</span><br><span class="line">        item2.<span class="title function_ invoke__">summarize</span>()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="trait作为参数-3"><p><code>trait bound</code> 可以理解为将 <code>trait</code> 绑定到某个泛型上，当需要将参数声明为实现了多个<code>trait</code>的类型时，可以使用 <code>+</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_two_trait</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_two_trait_bound</span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用过多的 <code>trait bound</code> 也有缺点。每个泛型有其自己的 <code>trait bound</code>，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 <code>trait bound</code> 信息，这使得函数签名难以阅读。为此，<code>Rust</code> 有另一个在函数签名之后的 <code>where</code> 从句中指定 <code>trait bound</code> 的语法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_complex</span>&lt;T: Summary + Display, U: <span class="built_in">Debug</span> + <span class="built_in">Copy</span>&gt;(item1: T, item2: U) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;item1: &#123;&#125;, item2: &#123;:?&#125;&quot;</span>, item1, item2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_complex_where</span>&lt;T, U&gt;(item1: T, item2: U)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Debug</span> + <span class="built_in">Copy</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;item1: &#123;&#125;, item2: &#123;:?&#125;&quot;</span>, item1, item2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="作为返回值-1"><a href="#作为返回值-1" class="headerlink" title="作为返回值"></a>作为返回值</h4><p>我们可以将函数的返回值定义为实现了某个trait的类型，例如我们指定 <code>returns_summarizable</code> 函数返回实现了 <code>Summary</code> 的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = <span class="title function_ invoke__">returns_summarizable</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们想从一个函数中返回多种实现了同一<code>trait</code>的类型，就不可以了，如下面这段代码就<mark class="label danger">不能通过编译</mark>，因为<code>rust</code>需要在编译时期就确定函数返回值的大小。返回不同的类型，意味着函数的返回值大小是不确定的，这对于 <code>rust</code> 来说是<mark class="label danger">不允许</mark>的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">try_return_multiple_types</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Article &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们确实想这样做，我们可以使用 <code>Box&lt;T&gt;</code> 类型，这个类型将数据实际存储在堆上，保留该数据的指针，所以其大小是固定的，这样就实现了动态分发：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">try_return_multiple_types</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Summary&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Tweet &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Article &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有条件地实现方法"><a href="#有条件地实现方法" class="headerlink" title="有条件地实现方法"></a>有条件地实现方法</h4><p>有时候我们在为某一个泛型结构体实现方法的时候，首先需要它的类型实现某些<code>trait</code>。如下示例中，类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有那些为 <code>T</code> 类型实现了 <code>PartialOrd trait</code> （来允许比较） 和 <code>Display trait</code> （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = Pair &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line">    pair.<span class="title function_ invoke__">cmp_display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以对任何实现了特定 <code>trait</code> 的类型有条件地实现 <code>trait</code>。对任何满足特定 <code>trait bound</code> 的类型实现 <code>trait</code> 被称为 <code>blanket implementations</code>，他们被广泛的用于 <code>Rust</code> 标准库中。例如，标准库为任何实现了 <code>Display trait</code> 的类型实现了 <code>ToString trait</code>。这个 <code>impl</code> 块看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以对任何实现了 <code>Display trait</code> 的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。</p>
<blockquote>
<p><code>let s = 3.to_string();</code></p>
</blockquote>
<h4 id="父-trait"><a href="#父-trait" class="headerlink" title="父 trait"></a>父 trait</h4><p>在前面的例子中，我们演示过可以在 <code>trait</code> 的默认实现中使用相同<code>trait</code>的其他方法，即使该方法未实现。但是，我们有时也需要在当前<code>trait</code>中使用其他<code>trait</code>中的功能，这就形成了 <code>trait</code> 依赖，被依赖的<code>trait</code>的我们称之为当前<code>trait</code>的 <strong>父trait</strong>。</p>
<p>下面的例子中，<code>OutlinePrint</code> 在定义的默认方法 <code>outline_print</code> 调用了 <code>fmt::Display</code> 中的 <code>to_string</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    point.<span class="title function_ invoke__">outline_print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Copy、Clone"><a href="#Copy、Clone" class="headerlink" title="Copy、Clone"></a>Copy、Clone</h4><p><code>Copy</code> 和 <code>Clone</code> 直接从字面意义上感觉没什么区别，它们最终都是产生了一个新的对象，但是这两个 <code>trait</code> 面向的对象不同，<code>Copy</code> 面向编译器，而 <code>Clone</code> 面向开发者。换句话说就是<code>copy</code>操作编译器帮我们做了，但是 <code>clone</code> 需要我们自己手动调用。</p>
<p>参考文章：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone?answertab=active#tab-top"><code>https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone?answertab=active#tab-top</code></a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone"><code>https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone</code></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21730929"><code>https://zhuanlan.zhihu.com/p/21730929</code></a></li>
<li><a href="https://hashrust.com/blog/moves-copies-and-clones-in-rust/"><code>https://hashrust.com/blog/moves-copies-and-clones-in-rust/</code></a></li>
</ol>
<h5 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h5><p><code>Copy</code> 的全称是 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>std::marker::Copy</code></a>，它的内部其实什么方法都没有，但是实现它必须实现 <code>Clone</code>。一旦一个类型实现 <code>Copy</code> 意味着在任何需要的时候，我们可以简单的通过内存拷贝（C语言的按位拷贝<code>memcpy</code>）实现该类型的复制，而不会出现任何问题。在变量绑定、函数参数传递、函数返回值传递等场景下，它都是 <code>copy</code> 语义，而不再是默认的 <code>move</code> 语义</p>
<blockquote>
<p><code>pub trait Copy: Clone &#123; &#125;</code></p>
</blockquote>
<div class="tabs" id="copy对所有权移动的影响"><ul class="nav-tabs"><li class="tab active"><a href="#copy对所有权移动的影响-1">实现 Copy</a></li><li class="tab"><a href="#copy对所有权移动的影响-2">未实现Copy</a></li></ul><div class="tab-content"><div class="tab-pane active" id="copy对所有权移动的影响-1"><p><code>i32</code> 实现了 <code>Copy</code>，所以我们在使用 <code>let</code> 表达式的时候，其实是复制而不是所有权转移。</p>
<p>实现 <code>Copy</code> 的基本类型： <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors"><code>https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors</code></a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="copy对所有权移动的影响-2"><p><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-cant-my-type-be-copy"><code>String</code> 没有实现 <code>Copy</code></a>，所以它在使用 <code>let</code> 表达式的时候，是所有权转移，下面的代码<mark class="label danger">编译失败</mark></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/string-not-implement-copy.PNG" class="" title="String not implement Copy"></div></div></div>

<p>并不是所有的类型都可以实现 <code>Copy</code> 。<code>Rust</code> 规定，对于自定义类型，只有所有的成员都实现了 <code>Copy</code> ，这个类型才有资格实现 <code>Copy</code>。例如下面的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">   x: <span class="type">i32</span>,</span><br><span class="line">   y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是看下面的 <code>PointList</code> 类型，他就不能实现 <code>Copy</code>，因为 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 没有实现 <code>Copy</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PointList</span> &#123;</span><br><span class="line">    points: <span class="type">Vec</span>&lt;Point&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 <code>PointList</code> 不能实现 <code>Copy</code>，但是是由于共享引用 <code>&amp;T</code> 可以 <code>Copy</code>，所以我们可以实现一个 <code>PointListWrapper</code>，包含 <code>PointList</code> 的一个引用，这样即使 <code>PointList</code> 不能 <code>Copy</code>，<code>PointListWrapper</code> 也可以 <code>Copy</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PointListWrapper</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    point_list_ref: &amp;<span class="symbol">&#x27;a</span> PointList,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h5><p><code>Clone</code> 的全称是 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>std::clone::Clone;</code></a>，他定义了两个方法，其中 <code>clone_from</code> 默认实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone_from</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, source: &amp;<span class="keyword">Self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = source.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clone</code> 方法一般用于基于语义的复制操作。所以，它做什么事情，跟具体类型的作用息息相关。比如对于 <code>Box</code> 类型，<code>clone</code> 就是执行的深拷贝，而对于 <code>Rc</code> 类型，<code>clone</code> 做的事情就是把引用计数值加<code>1</code>。你可以根据情况在 <code>clone</code> 函数中编写任意的逻辑。但是有一条规则需要注意：对于实现了 <code>Copy</code> 的类型，它的 <code>clone</code> 方法应该跟 <code>Copy</code> 语义相容，等同于按位拷贝。</p>
<p>实现了 <code>Clone</code> 的所有基本类型： <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#implementors"><code>https://doc.rust-lang.org/std/clone/trait.Clone.html#implementors</code></a></p>
<p>下面这段代码是<mark class="label success">编译通过</mark>的，可以看到，<code>String</code> 虽然未实现 <code>Copy</code>，但是它实现了 <code>Clone</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Fn、FnMut、FnOnce"><a href="#Fn、FnMut、FnOnce" class="headerlink" title="Fn、FnMut、FnOnce"></a>Fn、FnMut、FnOnce</h4><p>这三个 <code>trait</code> 位于 <code>std::ops</code> 模块中，其实是对函数调用运算符 <code>()</code> 的重载，区别在于 <code>receiver</code> 的类型，可以看到 <code>Fn</code> 的受限成都最高，<code>FnOnce</code> 最低：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FnMut</span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, </span><br><span class="line">        args: Args</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Fn</span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>Once</code> 的意义， 正如<a href="https://kaisery.github.io/trpl-zh-cn/ch13-01-closures.html#%E9%97%AD%E5%8C%85%E4%BC%9A%E6%8D%95%E8%8E%B7%E5%85%B6%E7%8E%AF%E5%A2%83">闭包会捕获其环境</a> 中描述的那样：</p>
<ul>
<li><p><code>FnOnce</code> 消费从周围作用域捕获的变量，闭包周围的作用域被称为其环境，<code>environment</code>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</p>
</li>
<li><p>由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 <code>FnOnce</code> 。</p>
</li>
</ul>
<h5 id="FnOnce"><a href="#FnOnce" class="headerlink" title="FnOnce"></a>FnOnce</h5><p><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> 获取了 <code>receiver</code> 的所有权，如果一个类型仅仅实现了 <code>FnOnce</code> 它只可以被调用一次。<code>FnOnce</code> 由可能消耗捕获变量的闭包以及实现 <code>FnMut</code> 的所有类型自动实现。</p>
<p>由于 <code>Fn</code> 和 <code>FnMut</code> 都是 <code>FnOnce</code> 的 <code>subtraits</code> ，因此可以在需要 <code>FnOnce</code> 的地方使用 <code>Fn</code> 或 <code>FnMut</code> 的任何实例。如果我们在一个类函数类型参数使用场景中，如果我们期望只调用它一次，就使用 <code>FnOnce</code> 作为其类型，如果我们需要调用它多次是就使用 <code>FnMut</code> 作为其类型，如果我们还想要它不改变状态时，我们就用 <code>Fn</code>。</p>
<p>从 <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#implementors"><code>implementors</code></a> 也可以看出，对于任何实现了 <code>FnOnce</code> 的类型 <code>F</code>，<code>&amp;F</code> 和 <code>&amp;mut F</code> 也自动实现 <code>FnOnce</code>。</p>
<div class="tabs" id="fnonce"><ul class="nav-tabs"><li class="tab active"><a href="#fnonce-1">闭包捕获非Copy类型，获取其所有权</a></li><li class="tab"><a href="#fnonce-2">闭包捕获可Copy类型</a></li><li class="tab"><a href="#fnonce-3">非Copy类型，获取所有权，但是并不消耗</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fnonce-1"><p>这个例子中，<code>consume_and_return_x</code> 捕获了 <code>x</code> 并获得了其所有权，并且在第一次调用时已经将 <code>x</code> 的所有权转移，所以无法再次调用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_relish</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>,</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func 消耗了它捕获的环境变量，所以它只能被运行一次</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Consumed: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Delicious!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果再尝试调用，func()，将会出现编译错误</span></span><br><span class="line">    <span class="comment">// func();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume_and_return_x</span> = <span class="keyword">move</span> || x;</span><br><span class="line">    <span class="title function_ invoke__">consume_with_relish</span>(consume_and_return_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fnonce-2"><p>当我们将前面例子中变量 <code>x</code> 的类型由 <code>String</code> 改为 <code>i32</code>，我们来看几个变种类型，改动很小。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_relish</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Consumed: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>());</span><br><span class="line">    <span class="comment">// 这里调用会出现编译错误，在首次调用时，会将捕获的变量 x 消耗掉</span></span><br><span class="line">    <span class="comment">// func(); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里 x 移入闭包的时候，由于 x 默认实现了 Copy 类型，所以执行的是 copy 操作，而不是获取所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume_and_return_x</span> = <span class="keyword">move</span> || x;</span><br><span class="line">    <span class="title function_ invoke__">consume_with_relish</span>(consume_and_return_x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;print x again: &#123;&#125;&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是由于 <code>i32</code> 是可复制的，所以生成的闭包也是可复制的，还记得 <code>Copy</code> 的含义，当所有成员都实现 <code>Copy</code> 的时候，这个类型就可能实现 <code>Copy</code>。我们可以将上面示例中泛型参数 <code>F</code> 的类型声明为以下任何一种，就可以实现 <code>func</code> 多次调用，我们其实是在告诉编译器，可以通过 <code>Copy</code> 避免所有权的转移：</p>
<ul>
<li><code>F: FnOnce() -&gt; i32 + Copy</code></li>
<li><code>F: Copy + FnOnce() -&gt; i32</code></li>
<li><code>F: Copy + FnOnce() -&gt; i32 + Copy</code></li>
</ul></div><div class="tab-pane" id="fnonce-3"><p>下面的例子运行是没有问题的，<code>consume_and_return_x</code> 获取了变量 <code>x</code> 的所有权，因为 <code>String</code> 不可 <code>Copy</code>。但是我们在使用的时候并没有消耗它的所有权，所以是可以多次使用的。这个时候 <code>consume_and_return_x</code> 其实已经实现了 <code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_relish</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume_and_return_x</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="title function_ invoke__">consume_and_return_x</span>();</span><br><span class="line">    <span class="title function_ invoke__">consume_and_return_x</span>();</span><br><span class="line">    <span class="title function_ invoke__">consume_with_relish</span>(consume_and_return_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h5 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a>FnMut</h5><p><code>FnMut</code> 实例可以被重复多次调用，并且可以改变环境变量。它被那些捕获了环境变量可变引用的闭包，所有<code>Fn</code> 的实现者，以及函数指针自动实现。对于任何实现了 <code>FnMut</code> 的类型 <code>F</code>，<code>&amp;mut F</code> 也实现了 <code>FnMut</code>。</p>
<p>另外，因为 <code>FnOnce</code> 是 <code>FnMut</code> 的 <strong>父trait</strong>，所以任何需要 <code>FnOnce</code> 的地方都可以传入 <code>FnMut</code>。当你需要对一个类似函数类型的参数限定为，可调用多次并且可改变内部状态时，可以使用 <code>FnMut</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>&lt;F&gt;(<span class="keyword">mut</span> func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span>: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_two_to_x</span> = || x += <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">do_twice</span>(add_two_to_x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a>Fn</h5><p><code>Fn</code> 要和 函数指针 <a href="https://doc.rust-lang.org/std/primitive.fn.html"><code>fn</code></a> 区别，<code>Fn</code> 被那些仅捕获环境中变量不可变引用的闭包，或者不捕获任何东西的闭包，或者函数指针自动实现。需要 <code>Fn</code>或者<code>FnMut</code> 的地方，都可以传入 <code>Fn</code>。如果类型 <code>F</code> 实现 <code>Fn</code>，那么 <code>&amp;F</code> 也将自动实现 <code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call_with_one</span>&lt;F&gt;(func: F) <span class="punctuation">-&gt;</span> <span class="type">usize</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">double</span> = |x| x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">call_with_one</span>(double), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deref、DerefMut"><a href="#Deref、DerefMut" class="headerlink" title="Deref、DerefMut"></a>Deref、DerefMut</h4><p><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> 允许我们重载解引用运算符 <code>*</code>，它包含一个 <code>deref</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?<span class="built_in">Sized</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。下面的示例中创建了一个 <code>i32</code> 值的引用，接着使用解引用运算符来跟踪所引用的数据：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义我们自己的 <code>MyBox</code> 类型，实现 <code>Deref</code>，<code>deref</code> 方法体中写入了 <code>&amp;self.0</code>，这样 <code>deref</code> 返回了我希望通过 <code>*</code> 运算符访问的值的引用。没有 <code>Deref trait</code> 的话，编译器只会解引用 <code>&amp;</code> 引用类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(item: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">    <span class="comment">// Rust 将 * 运算符替换为先调用 deref 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 deref 方法了</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *(y.<span class="title function_ invoke__">deref</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="隐式引用强制转换"><a href="#隐式引用强制转换" class="headerlink" title="隐式引用强制转换"></a>隐式引用强制转换</h5><p><a href="https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">隐式引用强制转换</a>是 Rust 在函数或方法传参上的一种便利，这仅仅用在实现了 <code>Deref</code> 的 trait，隐式引用强制将这样一个类型转换为另一个类型或者引用。例如，<code>&amp;String</code> 转换为 <code>&amp;str</code>，因为 <code>String</code> 实现了 <code>Deref</code> 返回了 <code>&amp;str</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(item: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello: &#123;&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;potato&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;MyBox::<span class="title function_ invoke__">new</span>(<span class="string">&quot;michael&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">people</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="comment">// 如果没有隐式引用强制转换，我们就得这样做</span></span><br><span class="line">    <span class="comment">// *people == *(people.deref()) -&gt; String</span></span><br><span class="line">    <span class="comment">// &amp;(*people) -&gt; &amp;String</span></span><br><span class="line">    <span class="comment">// &amp;(*people)[..] -&gt; &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;(*people)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="隐式引用强制转换与可变性"><a href="#隐式引用强制转换与可变性" class="headerlink" title="隐式引用强制转换与可变性"></a>隐式引用强制转换与可变性</h5><p>类似于如何使用 <code>Deref</code> 重载不可变引用的 <code>*</code> 运算符，Rust 提供了 <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> 用于重载可变引用的 <code>*</code> 运算符。</p>
<p>Rust 在发现类型和 trait 实现满足三种情况时会自动进行引用强制转换：</p>
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>；</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>；</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>；</li>
</ul>
<h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 <code>Drop</code> 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。</p>
<p>指定在值离开作用域时应该执行的代码的方式是实现 <code>Drop</code>。<code>Drop</code> 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。</p>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/drop_trait.png" class="" title="实现Drop">

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>任何程序都不能完全正确地按照开发者的意愿去运行，总会遇到错误，例如打开文件时，文件不存在。Rust 将程序可能出现的错误分为<strong>可恢复错误（recoverable）</strong>和<strong>不可恢复错误（unrecoverable）</strong>。可恢复错误通常意味着意料之中的情况，我们可以选择向用户报告错误或者进行重试。不可恢复的错误往往意味着bug，比如数组访问越界。</p>
<p>Rust 中没有异常，如果遇到可恢复错误就返回 <code>Result&lt;T, E&gt;</code> 让开发者处理，遇到不可恢复的错误就 <code>panic!</code>。</p>
<h4 id="panic-，不可恢复错误"><a href="#panic-，不可恢复错误" class="headerlink" title="panic!，不可恢复错误"></a>panic!，不可恢复错误</h4><p>当程序遇到不可处理的异常时，选择 <code>panic</code> 未尝不可。可以通过宏 <code>panic!</code>，退出程序。</p>
<p>当程序 <code>panic</code> 时，程序默认会开始<strong>展开（unwinding）</strong>，这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接<strong>终止（abort）</strong>，这会不清理数据就退出程序，那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，<code>panic</code> 时通过在 <code>Cargo.toml</code> 的 <code>[profile]</code> 部分增加 <code>panic = &#39;abort&#39;</code>，可以由展开切换为终止。例如，如果你想要在<code>release</code>模式中 <code>panic</code> 时直接终止：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = &#x27;abort&#x27;</span><br></pre></td></tr></table></figure>
<p>我们可以通过将 <code>RUST_BACKTRACE</code> 设置为一个非 <code>0</code> 的数值，用于在程序 <code>panic</code> 时得到程序的调用栈。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还提示我们可以通过将 <code>RUST_BACKTRACE</code> 设置为 <code>full</code>，得到更详细的调用栈。</p>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/vec-over-panic.png" class="" title="数组越界panic">


<h4 id="Result，可恢复错误"><a href="#Result，可恢复错误" class="headerlink" title="Result，可恢复错误"></a>Result，可恢复错误</h4><p>程序往往不会严重到不能执行，在出现异常情况时，返回一个错误大多是比较合适的处理方式。Rust 中经常通过枚举类型 <code>Result</code> 代表返回一个错误或者一个期望的值。如下面 <code>Result</code> 的定义所示，它被定义为一个泛型，在处理正确时返回 <code>Ok(T)</code>，出现错误时返回错误 <code>Err(E)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一个打开文件的例子，目的是获得操作文件的句柄，在文件不存在时，我们创建新的文件，如果都失败或者其他未知错误，直接 <code>panic</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_name</span> = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(file_name) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;create file failed: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_err =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;open file failed: &#123;:?&#125;&quot;</span>, other_err),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看着上面层层嵌套的 <code>match</code>，在感叹其强大的匹配功能的同时，也会感慨较深的代码嵌套不易阅读，我们尝试对其进行简化，其中 <code>unwrap_or_else</code> 接受一个闭包，它在前面的返回值没有问题时，直接返回；当遇到错误时，调用我们传入的闭包继续处理，期望返回我们需要的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_name</span> = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file_name).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(file_name).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;meet unkown error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h4><p>当我们开发一个功能在遇到错误时，经常会选择向上传递错误，让调用者自由选择处理的方式，例如我们开发一个函数，读取指定的文件内容，我们可能会这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Error, ErrorKind, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(file: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(f) =&gt; f,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到的是，我们使用 <code>match</code> 完成错误匹配，选择继续执行还是返回。但也展现出语法繁琐，所以就有了 <strong>?</strong> 运算符。<code>?</code> 在遇到返回值 <code>OK(value)</code>，将取出 <code>value</code> 继续执行，如果遇到 <code>Err</code>，将会返回当前的错误。我们来改写上面的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Error, ErrorKind, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(file: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(file)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code> 表达式与问号运算符所做的有一点不同：<code>?</code> 运算符所使用的错误值被传递给了 <code>from</code> 函数，它定义于标准库的 <code>From trait</code> 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 运算符调用 <code>from</code> 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 <code>from</code> 函数来定义如何将自身转换为返回的错误类型，<code>?</code> 运算符会自动处理这些转换。<strong>总结就是，? 将收集到错误值自动转换为要返回的错误类型。</strong></p>
<p>另外，由于 <code>main</code> 函数是比较特殊的，它返回什么类型是由限制的，一般情况下它的返回值是 <code>()</code>，但是为了方便，他也允许返回 <code>Result&lt;(), E&gt;</code>，因此，我们也可以在 <code>main</code> 中使用 <code>?</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Error, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(file: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(file)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="title function_ invoke__">read_file_content</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;content is: &#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运算符"><a href="#运算符" class="headerlink" title="? 运算符"></a>? 运算符</h4><p><code>?</code> 除了可以用于 <code>Result</code> 类型之外，还可以用于 <code>Option</code> 类型。如果 <code>x</code> 是 <code>Option</code>，那么若 <code>x</code> 是 <code>Some</code> ，对 <code>x?</code> 表达式求值将返回底层值，否则无论函数是否正在执行都将终止且返回 <code>None</code> 。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    job: <span class="type">Option</span>&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">work_phone_area_code</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.job?.phone_number?.area_code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    phone_number: <span class="type">Option</span>&lt;PhoneNumber&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    area_code: <span class="type">Option</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    number: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        job: <span class="title function_ invoke__">Some</span>(Job &#123;</span><br><span class="line">            phone_number: <span class="title function_ invoke__">Some</span>(PhoneNumber &#123;</span><br><span class="line">                area_code: <span class="title function_ invoke__">Some</span>(<span class="number">128</span>),</span><br><span class="line">                number: <span class="number">439222222</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(p.<span class="title function_ invoke__">work_phone_area_code</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">128</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h4><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#implementations"><code>Option</code></a> 自己实现了很多有用的方法，可以更快速的完成我们的代码编写。</p>
<div class="tabs" id="option-methods"><ul class="nav-tabs"><li class="tab active"><a href="#option-methods-1">map</a></li><li class="tab"><a href="#option-methods-2">and_then</a></li></ul><div class="tab-content"><div class="tab-pane active" id="option-methods-1"><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>map</code></a> 可以做的 <code>Some</code> -&gt; <code>Some</code>，<code>None</code> -&gt; <code>None</code> 的映射，可以串起来调用，我们来举一个煮饭的例子。<code>map</code> 中返回的是一个新的类型，当然这个类型可以是 <code>Option</code>，不过这将导致 <code>Option</code> 嵌套。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Carrot,</span><br><span class="line">    Potato,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Peeled</span>(Food);</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chopped</span>(Food);</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cooked</span>(Food);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cook</span>(food: <span class="type">Option</span>&lt;Food&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Cooked&gt; &#123;</span><br><span class="line">    food.<span class="title function_ invoke__">map</span>(|f| <span class="title function_ invoke__">Peeled</span>(f))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|<span class="title function_ invoke__">Peeled</span>(f)| <span class="title function_ invoke__">Chopped</span>(f))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|<span class="title function_ invoke__">Chopped</span>(f)| <span class="title function_ invoke__">Cooked</span>(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat</span>(food: <span class="type">Option</span>&lt;Cooked&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> food &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(f) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Mmm. I love &#123;:?&#125;&quot;</span>, f),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Oh no! It wasn&#x27;t edible.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = <span class="title function_ invoke__">Some</span>(Food::Apple);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">carrot</span> = <span class="title function_ invoke__">Some</span>(Food::Carrot);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">potato</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">eat</span>(<span class="title function_ invoke__">cook</span>(apple));</span><br><span class="line">    <span class="title function_ invoke__">eat</span>(<span class="title function_ invoke__">cook</span>(carrot));</span><br><span class="line">    <span class="title function_ invoke__">eat</span>(<span class="title function_ invoke__">cook</span>(potato));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="option-methods-2"><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>and_then</code></a> 当 <code>Option</code> 是 <code>None</code> 时，返回 <code>None</code>。否则将 <code>Some</code> 中包裹的值传入闭包函数，这个闭包返回一个新的 <code>Option</code>。 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sq</span>(x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x * x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">nope</span>(_: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>).<span class="title function_ invoke__">and_then</span>(sq).<span class="title function_ invoke__">and_then</span>(sq), <span class="title function_ invoke__">Some</span>(<span class="number">16</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>).<span class="title function_ invoke__">and_then</span>(sq).<span class="title function_ invoke__">and_then</span>(nope), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>).<span class="title function_ invoke__">and_then</span>(nope).<span class="title function_ invoke__">and_then</span>(sq), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">None</span>.<span class="title function_ invoke__">and_then</span>(sq).<span class="title function_ invoke__">and_then</span>(sq), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="定义错误类型"><a href="#定义错误类型" class="headerlink" title="定义错误类型"></a>定义错误类型</h4><p>定义自己的错误类型在传递错误信息时是必要的，我们来看一个例子，将一个字符串数组中的第一个元素转换为数字并且乘以2。下面的代码中我们也定义了自己的 <code>Result</code> 类型，定义自己的错误类型需要实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, DoubleFirstError&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleFirstError</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;double first int error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first</span>(vec: &amp;<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">ok_or</span>(DoubleFirstError).<span class="title function_ invoke__">and_then</span>(|s| &#123;</span><br><span class="line">        s.parse::&lt;<span class="type">i32</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| DoubleFirstError)</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|i| <span class="number">2</span> * i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(result: <span class="type">Result</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(r) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;&#125;&quot;</span>, r),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err is &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="string">&quot;42&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">empty</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;tofu&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;numbers));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;empty));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Box"><a href="#Box" class="headerlink" title="Box&lt;error::Error&gt;"></a><code>Box&lt;error::Error&gt;</code></h4><p>当我们只关注错误信息，而不关注错误类型的时候，我们可以将错误装进 <code>Box</code>，我们对上面的例子稍加修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> error::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleFirstError</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;double first int error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first</span>(vec: &amp;<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">ok_or</span>(DoubleFirstError.<span class="title function_ invoke__">into</span>()).<span class="title function_ invoke__">and_then</span>(|s| &#123;</span><br><span class="line">        s.parse::&lt;<span class="type">i32</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| DoubleFirstError.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|i| <span class="number">2</span> * i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(result: <span class="type">Result</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(r) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;&#125;&quot;</span>, r),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err is &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="string">&quot;42&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">empty</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;tofu&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;numbers));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;empty));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Rust 使用 trait 解决类型之间的转换问题。最一般的转换会用到 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 两个 trait。</p>
<h4 id="From、Into"><a href="#From、Into" class="headerlink" title="From、Into"></a><code>From</code>、<code>Into</code></h4><p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 定义怎么根据另一种类型生成自己，而在定义 <code>From</code> 之后，我们就自然的获得了 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>，因为它就是 <code>From</code> 倒过来，但是在使用 <code>Into</code> 的时候，我们得指明要转换的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Number &#123; value: item &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = Number::<span class="title function_ invoke__">from</span>(<span class="number">188</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, number);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span>: Number = <span class="number">166i32</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TryFrom、TryInto"><a href="#TryFrom、TryInto" class="headerlink" title="TryFrom、TryInto"></a><code>TryFrom</code>、<code>TryInto</code></h4><p>类似于 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>，不过 <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> 用于易出错的转换，他们的返回值类型是 <code>Result</code> 类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::convert::&#123;TryFrom, TryInto&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EvenNumber</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TryFrom</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">EvenNumber</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = ();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNumber</span>(item))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// try from</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNumber::<span class="title function_ invoke__">try_from</span>(<span class="number">8</span>), <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNumber</span>(<span class="number">8</span>)));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNumber::<span class="title function_ invoke__">try_from</span>(<span class="number">5</span>), <span class="title function_ invoke__">Err</span>(()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNumber, ()&gt; = <span class="number">8i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNumber</span>(<span class="number">8</span>)), result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNumber, ()&gt; = <span class="number">5i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Err</span>(()), result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ToString、FromStr"><a href="#ToString、FromStr" class="headerlink" title="ToString、FromStr"></a><code>ToString</code>、<code>FromStr</code></h4><p>在我们需要将类型转换成字符串类型时，我们只需实现 <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>，但是最好的是实现 <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a>，它会自动提供 <code>to_string()</code> 方法。</p>
<p>另外，我们也经常需要将字符串转换成我们需要的目标类型，只要目标类型实现了 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>，我们就可以使用字符串的 <code>parse</code> 方法解析，不过我们得提供要转换到的目标类型，或者使用涡轮鱼（turbo fish）语法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;Display, Formatter, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Circle(&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.radius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; radius: <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, circle.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">i32</span> = <span class="string">&quot;45&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num1</span> = <span class="string">&quot;55&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;num: &#123;&#125;, num1: &#123;&#125;&quot;</span>, num, num1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型可以极大地降低代码重复度，我们可以定义泛型结构体，泛型函数，泛型方法，泛型枚举等。但是我们不用担心泛型的性能，Rust 通过在编译时进行泛型代码的单态化(monomorphization)来保证效率。<strong>单态化</strong>是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<div class="tabs" id="泛型种类"><ul class="nav-tabs"><li class="tab active"><a href="#泛型种类-1">枚举</a></li><li class="tab"><a href="#泛型种类-2">结构体和方法</a></li><li class="tab"><a href="#泛型种类-3">函数</a></li><li class="tab"><a href="#泛型种类-4">trait</a></li></ul><div class="tab-content"><div class="tab-pane active" id="泛型种类-1"><p>泛型枚举我们最常见的应该是：<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> 和 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型种类-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型种类-3"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型种类-4"><p>也可以参考： <a href="https://doc.rust-lang.org/stable/rust-by-example/generics/gen_trait.html#traits">https://doc.rust-lang.org/stable/rust-by-example/generics/gen_trait.html#traits</a> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Mul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Area</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&lt;T&gt; &#123;</span><br><span class="line">    width: T,</span><br><span class="line">    height: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span> + Mul&lt;Output = T&gt;&gt; Area&lt;T&gt; <span class="keyword">for</span> <span class="title class_">Rectangle</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rec</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        height: <span class="number">4</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rec.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><strong>指针</strong>是一个包含内存地址变量的通用概念，rust 中使用 <code>&amp;</code> 或者 <code>ref</code> 引用一个变量。<strong>智能指针</strong>是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有他们指向的数据。</p>
<p>本节介绍几个常见的智能指针类型。</p>
<h4 id="Box-指向堆上的数据"><a href="#Box-指向堆上的数据" class="headerlink" title="Box 指向堆上的数据"></a>Box<T> 指向堆上的数据</h4><p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 将数据存储在堆上，留在栈上的仅仅是数据的指针，除此之外，box 没有性能损失。它们多用于如下场景：</p>
<ul>
<li>当在编译时不确定类型大小，又想在需要确切大小的上下文中使用时，例如，使用 <code>Box&lt;dyn error:Error&gt;</code> 动态分发；</li>
<li>当有大量数据并希望在转移所有权的时候，不发生数据拷贝；</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候；</li>
</ul>
<h5 id="数据存储在堆上"><a href="#数据存储在堆上" class="headerlink" title="数据存储在堆上"></a>数据存储在堆上</h5><p>如下示例，定义了变量 <code>b</code>，其值是一个指向被分配在堆上的值 <code>5</code> 的 <code>Box</code>。我们可以像数据是储存在栈上的那样访问 <code>box</code> 中的数据，正如任何拥有数据所有权的值那样，当像 <code>b</code> 这样的 <code>box</code> 在 <code>main</code> 的末尾离开作用域时，它将被释放。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建递归类型"><a href="#创建递归类型" class="headerlink" title="创建递归类型"></a>创建递归类型</h5><p>Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type），其值的一部分可以是相同类型的另一个值。我们探索一下 <a href="https://en.wikipedia.org/wiki/Cons">cons list</a>，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念。</p>
<p><code>cons list</code> 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。<code>cons list</code> 通过递归调用 <code>cons</code> 函数产生。代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。</p>
<p>下面这段代码是<mark class="label danger">不能编译通过</mark>的，编译提示我们这个类型大小<mark class="label danger">无限大</mark>：</p>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/recursive-list.png" class="" title="错误递归类型">

<p>另外编译器还提醒我们，不能直接存储一个值，而是应该存储一个指向这个值的指针，还提示我们应该用 <code>Box&lt;List&gt;</code>：</p>
<pre><code>= help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
make `List` representable
</code></pre>
<p>因为 <code>Box&lt;T&gt;</code> 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变，我们对上面的程序做出修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Rc-引用计数"><a href="#Rc-引用计数" class="headerlink" title="Rc 引用计数"></a>Rc<T> 引用计数</h4><p>大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点直到没有任何边指向它之前都不应该被清理。</p>
<p>为了启用多所有权，Rust 有一个叫做 <a href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> 的类型。其名称为 引用计数（reference counting）的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p>
<p>可以将其想象为客厅中的电视。当一个人进来看电视时，他打开电视。其他人也可以进来看电视。当最后一个人离开房间时，他关掉电视因为它不再被使用了。如果某人在其他人还在看的时候就关掉了电视，正在看电视的人肯定会抓狂的！</p>
<p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。</p>
<blockquote>
<p><code>Rc&lt;T&gt;</code> 只能用于单线程场景</p>
</blockquote>
<h5 id="使用-Rc-共享数据"><a href="#使用-Rc-共享数据" class="headerlink" title="使用 Rc&lt;T&gt; 共享数据"></a>使用 <code>Rc&lt;T&gt;</code> 共享数据</h5><p>我们继续看上面的例子，这一次，我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如下图所示：</p>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/rct-example.svg" class="" title="Rc&lt;T&gt;共享数据">

<p>我们使用之前的 <code>Box&lt;List&gt;</code> 尝试时，发现<mark class="label danger">编译失败</mark>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/rct-example-failed.png" class="" title="Rc&lt;T&gt;Box例子失败">

<p>我们修改 <code>List</code> 的定义为使用 <code>Rc&lt;T&gt;</code> 代替 <code>Box&lt;T&gt;</code>，现在每一个 <code>Cons</code> 变量都包含一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。当创建 <code>b</code> 时，不同于获取 <code>a</code> 的所有权，这里会克隆 <code>a</code> 所包含的 <code>Rc&lt;List&gt;</code>，这会将引用计数从 <code>1</code> 增加到 <code>2</code> 并允许 <code>a</code> 和 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 中数据的所有权。创建 <code>c</code> 时也会克隆 <code>a</code>，这会将引用计数从 <code>2</code> 增加为 <code>3</code>。每次调用 <code>Rc::clone</code>，<code>Rc&lt;List&gt;</code> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Rc-strong-count"><a href="#Rc-strong-count" class="headerlink" title="Rc::strong_count"></a>Rc::strong_count</h5><p>可以使用 <a href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.strong_count"><code>Rc::strong_count</code></a> 查看 <code>Rc&lt;T&gt;</code> 的引用计数值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h4><p>内部可变性（Interior mutability）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。不同于 <code>Rc&lt;T&gt;</code>，<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> 代表其数据的唯一的所有权。我们之前学习的借用规则是这样的：</p>
<ul>
<li>在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用之一（而不是两者）。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>对于引用和 <code>Box&lt;T&gt;</code>，借用规则的不可变性作用于编译时。对于 <code>RefCell&lt;T&gt;</code>，这些不可变性作用于运行时。对于引用，如果违反这些规则，会得到一个编译错误。而对于 <code>RefCell&lt;T&gt;</code>，如果违反这些规则程序会 <code>panic</code> 并退出。</p>
<p>在编译时检查借用规则的优势是这些错误将在开发过程的早期被捕获，同时对运行时没有性能影响，因为所有的分析都提前完成了。为此，在编译时检查借用规则是大部分情况的最佳选择，这也正是其为何是 Rust 的默认行为。相反在运行时检查借用规则的好处则是允许出现特定内存安全的场景，而它们在编译时检查中是不允许的。静态分析，正如 Rust 编译器，是天生保守的。</p>
<p>因为一些分析是不可能的，如果 Rust 编译器不能通过所有权规则编译，它可能会拒绝一个正确的程序；从这种角度考虑它是保守的。如果 Rust 接受不正确的程序，那么用户也就不会相信 Rust 所做的保证了。然而，如果 Rust 拒绝正确的程序，虽然会给程序员带来不便，但不会带来灾难。<code>RefCell&lt;T&gt;</code> 正是用于当你确信代码遵守借用规则，而编译器不能理解和确定的时候。</p>
<p>如下为选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p>
<ul>
<li><code>Rc&lt;T&gt;</code> 允许相同数据有多个所有者；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li>
<li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code> 仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变或可变借用检查。</li>
<li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下修改其内部的值。</li>
</ul>
<blockquote>
<p><code>RefCell&lt;T&gt;</code> 只能用于单线程场景</p>
</blockquote>
<p>来看一个例子，我们定义了 <code>Messenger</code> 用于发送消息，真实场景可能是发送短信或者发送邮件，注意它的 <code>receiver</code> 是 <code>&amp;ref</code>；然后我们定义结构体 <code>LimitTracker</code>，它用来实现我们的业务功能，当调用它的 <code>set_value</code> 方法时，根据业务逻辑发送不同的消息。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LimitTracker</span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="type">usize</span>,</span><br><span class="line">    max: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Messenger &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(messenger: &amp;T, max: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">percentage_of_max</span> = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">             <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们对 <code>LimitTracker</code> 的功能进行测试，但是肯定不能真正实现 <code>Messenger</code>，所以需要对其打桩，计划是对其进行 <code>Mock</code>，记录发送的消息，初步计划是这样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: <span class="built_in">vec!</span>[] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出意外，<mark class="label danger">编译失败</mark>，不能对不可变引用做修改：</p>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/refcell-mock-failed.png" class="" title="编译失败">

<p>按照编译器的提示，改成这样，依然编译失败，<code>receiver</code> 类型不匹配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/refcell-mock-failed-again.png" class="" title="编译失败">

<p>然后我们引出我们今天的大招，<code>RefCell</code>，看下面的修改，我们使用 <code>borrow_mut</code> 和 <code>borrow</code> 分别在运行时进行可变借用和不可变借用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="comment">// Vec&lt;String&gt; -&gt; RefCell&lt;Vec&lt;String&gt;&gt;</span></span><br><span class="line">        sent_messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="comment">// borrow_mut，可变借用</span></span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// borrow，不可变借用</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/refcell-mock-pass.png" class="" title="测试通过">

<h5 id="结合-Rc-和-RcCell"><a href="#结合-Rc-和-RcCell" class="headerlink" title="结合 Rc&lt;T&gt; 和 RcCell&lt;T&gt;"></a>结合 Rc<code>&lt;</code>T<code>&gt;</code> 和 RcCell<code>&lt;</code>T<code>&gt;</code></h5><p><code>Rc&lt;T&gt;</code> 通过引用计数的方式可以让一个值有多个所有者，<code>RcCell&lt;T&gt;</code> 可以在运行时获取值的可变引用对其修改。下面的例子中，通过对 <code>value</code> 的修改，<code>a</code>，<code>b</code>，<code>c</code> 都改了。 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">6</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">10</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2023/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/rct-and-refcellt.png" class="" title="一处修改处处改">
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】所有权</title>
    <url>/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/</url>
    <content><![CDATA[<p>在编程语言的内存使用中，我们经常遇到什么时候释放内存以及如何确定访问的内存是否已被释放等问题。对于内存管理方式，存在着两大阵营：</p>
<ul>
<li><p>一种是以 <code>Python</code>，<code>JavaScript</code>， <code>Ruby</code>，<code>Java</code>， <code>C#</code>，以及 <code>Go</code> 等为代表的拥有垃圾回收器的语言，垃圾回收器在对象不再被访问时，会释放对象所持有的内存。这种方式对开发者友好，因为我们不用太多关心内存的申请和释放，但是这意味着将对象释放的权利交给了垃圾回收器，对于理解什么时候释放内存会是一个较大的挑战。</p>
</li>
<li><p>另一种是以 <code>C</code> 和 <code>C++</code> 为代表的语言，它们将内存的申请和回收完全交给了开发者，这造成过很多致命的问题，悬垂指针，访问已释放内存以及多重释放等问题；</p>
</li>
</ul>
<p><code>Rust</code>旨在既安全又高效，因此这两种方案都不能接受，但如果有更好的方案，估计早就有人做了。<code>Rust</code> 通过限制程序使用指针的方式打破了这种非得妥协的僵局。<code>Rust</code>的做法激进，但这成了它成功的基础，尽管有诸多限制，但使用起来依然足够灵活。</p>
<span id="more"></span>

<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>在 <code>Rust</code> 中，所有权的概念根植于语言自身并且由编译器在编译时检查。每个值都有一个决定其生死的所有者，当这个所有者被释放（在 <code>Rust</code> 中，称为 <code>Drop</code>）时，它所拥有的值占用的的内存也会被释放。</p>
<p>每个变量都有一个值，当变量离开它的作用域时，就会被 <code>drop</code>，它拥有的值也会被从内存中释放。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_padovan</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">padovan</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]; <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">3</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next</span> = padovan[i - <span class="number">3</span>] + padovan[i - <span class="number">2</span>];</span><br><span class="line">        padovan.<span class="title function_ invoke__">push</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;P(1..10) = &#123;:?&#125;&quot;</span>, padovan);</span><br><span class="line">    <span class="comment">// padovan 离开作用域，值被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 <code>padovan</code> 的类型是 <code>Vec&lt;i32&gt;</code>，在内存中，它的值看起来像下面这样，<code>padovan</code> 的指针，容量和长度分配在函数 <code>print_padovan</code> 的栈帧上，只有 <code>vector</code> 的缓冲池是在堆上分配的：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/padovan-mem-like.png" class="">

<p><code>Rust</code> 的 <code>Box</code> 类型是所有权的另一个代表。<code>Box&lt;T&gt;</code> 是存储在堆上的 <code>T</code> 类型值的指针。调用 <code>Box::new(v)</code> 分配一些堆空间，将值<code>v</code>移动到其中，并返回包含指向堆内存指针的 <code>Box</code>。由于<code>Box</code>拥有它指向的空间，当 <code>Box</code> 离开作用域时，它也会释放相应的堆内存。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>((<span class="number">0.625</span>, <span class="number">0.5</span>)); <span class="comment">// point allocated here </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">label</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, point); <span class="comment">// label allocated here </span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(label, <span class="string">&quot;(0.625, 0.5)&quot;</span>);</span><br><span class="line">&#125;  <span class="comment">// both dropped here</span></span><br></pre></td></tr></table></figure>

<p>当程序调用 <code>Box::new</code> 时，它会在堆上为两个<code>f64</code>值的元组分配空间，将<code>(0.625，0.5)</code>移动到该空间中，并返回指向它的指针。当程序运行到<code>assert_eq!</code>时，栈帧如下图所示：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/box-mem-like.png" class="">


<p>来看一个结构体的例子，结构体字段也可以是 <code>String</code>，<code>Array</code> 或者 <code>Vector</code> 等：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    birth: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">composers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    composers.<span class="title function_ invoke__">push</span>(Person&#123;name: <span class="string">&quot;Palestrina&quot;</span>.<span class="title function_ invoke__">to_string</span>(), birth: <span class="number">1525</span>&#125;);</span><br><span class="line">    composers.<span class="title function_ invoke__">push</span>(Person&#123;name: <span class="string">&quot;Dowland&quot;</span>.<span class="title function_ invoke__">to_string</span>(), birth: <span class="number">1563</span>&#125;);</span><br><span class="line">    composers.<span class="title function_ invoke__">push</span>(Person&#123;name: <span class="string">&quot;Lully&quot;</span>.<span class="title function_ invoke__">to_string</span>(), birth: <span class="number">1632</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">composer</span> <span class="keyword">in</span> &amp;composers &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, born &#123;&#125;&quot;</span>, composer.name, composer.birth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>composers</code> 的类型是 <code>Vec&lt;Person&gt;</code>，它在内存中的表示如下图所示：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/composers-mem-like.png" class="">

<p>这里有很多所有权关系，但每个关系都非常简单：<code>composers</code> 拥有一个 <code>vector</code>，<code>vector</code> 拥有它的元素，每个元素都是 <code>Person</code> 结构体，每个结构体都拥有自己的字段，<code>name</code> 字段拥有其文本。当<code>composers</code>离开作用域时，程序会释放掉所有堆上分配的内存。</p>
<p>从上面的示例来看，每个值都有一个所有者，所有者离开作用域值被释放。为了对开发友好，<code>Rust</code> 的所有权概念有一些变通：</p>
<ul>
<li><p>值的所有者可以进行转移；</p>
</li>
<li><p>简单的整数，浮点数，字符这些类型不受所有者规则约束，它们在参数传递，重新赋值时会进行拷贝，它们实现了 <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>；</p>
</li>
<li><p>标准库提供了引用计数类型 <code>Rc</code> 和 <code>Arc</code>，允许值在某些规则下可以有多个所有者；</p>
</li>
<li><p>可以借用值的引用，引用不改变值的所有者；</p>
</li>
</ul>
<h3 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h3><p>在 <code>Rust</code> 中，赋值类操作，比如传递值给变量，或者从函数返回都不会复制值，仅仅是把值的所有权从一个变量转向另一个变量。来看一个例子说明值的所有权是如何转移的，而且在不同的语言中都是如何处理，我们对比 <code>Python</code>，<code>C++</code> 以及 <code>Rust</code>：</p>
<div class="tabs" id="不同的语言的赋值"><ul class="nav-tabs"><li class="tab active"><a href="#不同的语言的赋值-1">Rust</a></li><li class="tab"><a href="#不同的语言的赋值-2">Python</a></li><li class="tab"><a href="#不同的语言的赋值-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="不同的语言的赋值-1"><div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">vec!</span>[<span class="string">&quot;udon&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;ramen&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;soba&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span> = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当 <code>s</code> 初始化的时候，我们看到的是<code>s</code>拥有这个值，它的值的所有者：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/rust-value-initialize.png" class="" title="[s初始化]">


<p>但是在将 <code>s</code> 赋值给 <code>t</code> 之后，我们看到值的所有权转移了：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/rust-value-move.png" class="" title="[值得所有权从s转移至t]">

<p>但是在将 <code>s</code> 赋值给 <code>t</code> 之后，值得所有权从 <code>s</code> 转移到了 <code>t</code>，成了 <code>vector</code> 新的主人，这段代码在运行时会报如下的错误:</p>
<pre><code>error[E0382]: use of moved value: `s`
--&gt; src/main.rs:5:12
|
3 |     let s = vec![&quot;udon&quot;.to_string(), &quot;ramen&quot;.to_string(), &quot;soba&quot;.to_string()];
|         - move occurs because `s` has type `Vec&lt;String&gt;`, which does not implement the `Copy` trait
4 |     let t= s;
|            - value moved here
5 |     let u= s;
|            ^ value used here after move
</code></pre>
<p>所以说这里将 <code>s</code> 赋值给 <code>t</code>，操作使很轻量的，没有内存的复制，只是值的所有权的转移。如果我们要实现内存的复制，我们需要对值进行 <code>clone</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">vec!</span>[<span class="string">&quot;udon&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;ramen&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;soba&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span>= s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span>= s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="不同的语言的赋值-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">&#x27;udon&#x27;</span>, <span class="string">&#x27;ramen&#x27;</span>, <span class="string">&#x27;soba&#x27;</span>] </span><br><span class="line">t = s</span><br><span class="line">u = s</span><br></pre></td></tr></table></figure>

<p>对于类似的代码，我们可以对比在<code>python</code>语言中，<code>s</code>初始化的时候，和值<code>s</code>赋值给<code>t</code>和<code>u</code>时的内存布局：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/py-value-initialize.png" class="" title="[s初始化]"></div><div class="group-picture-column"><img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/py-value-ref.png" class="" title="[s赋值给t和u]"></div></div></div>

<p><code>Python</code> 的实现是将指针从<code>s</code>复制到<code>t</code>和<code>u</code>，并且更新列表对象的引用计数。</p></div><div class="tab-pane" id="不同的语言的赋值-3"><p>我们来看 C++ 中的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt; s = &#123; <span class="string">&quot;udon&quot;</span>, <span class="string">&quot;ramen&quot;</span>, <span class="string">&quot;soba&quot;</span> &#125;; </span><br><span class="line">vector&lt;string&gt; t = s;</span><br><span class="line">vector&lt;string&gt; u = s;</span><br></pre></td></tr></table></figure>

<p><code>s</code> 新创建的时候，内存布局如下图所示:</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/cplusplus-assign.png" class="">

<p>在将 <code>s</code> 赋值给 <code>t</code> 和 <code>u</code> 之后如下图所示，可见<code>C++</code>实现了内存的复制:</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/cplus.png" class=""></div></div></div>

<p>在通过 <code>let</code> 语句将值赋值给已经初始化的变量时，变量先前拥有的值将会被释放掉，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;Govinda&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">s = <span class="string">&quot;Siddhartha&quot;</span>.<span class="title function_ invoke__">to_string</span>(); <span class="comment">//  &quot;Govinda&quot; 被释放掉</span></span><br></pre></td></tr></table></figure>

<p>但是如果在给<code>s</code>重新赋值之前，将原先拥有的<code>Govinda</code>转移给另外的变量<code>t</code>，再赋值 <code>Siddhartha</code> 时，<code>s</code> 是未初始化状态，所以就不会释放任何值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;Govinda&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = s;</span><br><span class="line">s = <span class="string">&quot;Siddhartha&quot;</span>.<span class="title function_ invoke__">to_string</span>(); <span class="comment">// 啥也不释放</span></span><br></pre></td></tr></table></figure>

<p>除了赋值之外，函数参数传递，从函数返回值以及构建结构体或者 <code>tuple</code>，都会涉及到所有权的转移。下面这段代码展示了这几种情况：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123; name: <span class="type">String</span>, birth: <span class="type">i32</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">composers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    composers.<span class="title function_ invoke__">push</span>(Person &#123; name: <span class="string">&quot;Palestrina&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        birth: <span class="number">1525</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从函数返回值：<code>Vec::new()</code> 构造了一个新的 <code>vector</code> 并且返回，不是指向 <code>vector</code> 的指针，而是 <code>vector</code> 本身。它的所有权从 <code>Vec::new </code> 转移给了变量 <code>composers</code>。类似，<code>to_string</code> 也返回了一个新的 <code>String</code>；</p>
</li>
<li><p>构造结构体或者<code>tuple</code>：<code>Person</code> 的 <code>name</code> 字段使用 <code>to_string</code> 方法返回了一个 <code>String</code>，因此这个结构体现在拥有这个 <code>String</code> 的所有权；</p>
</li>
<li><p>传值到函数：整个 <code>Person</code> 结构体，传递给了 <code>vector</code> 的 <code>push</code> 方法，<code>vector</code> 拥有了 <code>Person</code> 的所有权，间接拥有了 <code>Palestrina</code> 的所有权；</p>
</li>
</ul>
<p><strong>当一个变量拥有的值转移到其他变量，或者函数之后，原先的变量就会变得未初始化，在重新初始化之前是不能使用的。</strong></p>
<p>在控制流中要尤其注意：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]; </span><br><span class="line"><span class="keyword">if</span> c &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(x); <span class="comment">// ... ok to move from x here </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">g</span>(x); <span class="comment">// ... and ok to also move from x here </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">h</span>(x); <span class="comment">// 这里不能使用x了，除非重新初始化它</span></span><br></pre></td></tr></table></figure></div>

<h3 id="所有权转移和索引"><a href="#所有权转移和索引" class="headerlink" title="所有权转移和索引"></a>所有权转移和索引</h3><p><code>move</code> 会让值得原所有者变得未初始化，因为它的所有者换人了，但不是所有类型的值都会这样。</p>
<div class="note danger"><p>例如，这段代码无法正常编译：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Build a vector of the strings &quot;101&quot;, &quot;102&quot;, ... &quot;105&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">101</span>..<span class="number">106</span> &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(i.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pull out random elements from the vector.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">third</span> = v[<span class="number">2</span>]; <span class="comment">// error: Cannot move out of index of Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fifth</span> = v[<span class="number">4</span>]; <span class="comment">// here too</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试图运行此段代码会遇到下面的错误:</p>
<pre><code>--&gt; src/main.rs:9:17
|
9 |     let third = v[2]; // error: Cannot move out of index of Vec
|                 ^^^^
|                 |
|                 move occurs because value has type `String`, which does not implement the `Copy` trait
|                 help: consider borrowing here: `&amp;v[2]`
</code></pre>
<p>理解这里为什么不能编译其实也很简单，站在编程语言的角度，如果允许这样做，那么 <code>vector</code> 就需要记录哪些元素是活着的，哪些元素被 <code>move</code> 而变得未初始化。根据错误提示，我们可以用一个引用。</p>
</div>

<p>但是如果我们确实想获取 <code>vector</code> 中一些元素的所有权，我们可以使用一些方法：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Build a vector of the strings &quot;101&quot;, &quot;102&quot;, &quot;103&quot;, &quot;104&quot;, &quot;105&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">101</span>..<span class="number">106</span>&#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(i.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 vector 中弹出最后一个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fifth</span> = v.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;vector empty!&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(fifth, <span class="string">&quot;105&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从指定的索引处取出一个值，并且将最后一个元素填充到这里</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = v.<span class="title function_ invoke__">swap_remove</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(second, <span class="string">&quot;102&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 替换指定位置的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">third</span> = std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> v[<span class="number">2</span>], <span class="string">&quot;substitute&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(third, <span class="string">&quot;103&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在 vector 的值如下所示</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="built_in">vec!</span>[<span class="string">&quot;101&quot;</span>, <span class="string">&quot;104&quot;</span>, <span class="string">&quot;substitute&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>类似 <code>Vec</code> 的集合类方法也提供了用于消费它们中的元素的方法，当我们直接将 <code>vector</code> 传递给 <code>for</code> 语句时，实际上我们已经将 <code>v</code> 的所有权转移了，<code>v</code> 处于未初始化状态，下面这段代码也是不能编译的。</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="string">&quot;liberté&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;égalité&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;fraternité&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> s <span class="keyword">in</span> v &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据编译器提示是由于隐式调用了 <code>into_iter</code> 方法，<code>vector</code> 的所有权被转移，<code>v</code> 已经变成未初始化状态：</p>
<pre><code>error[E0382]: borrow of moved value: `v`
--&gt; src/main.rs:11:22
    |
2   |     let v = vec![
    |         - move occurs because `v` has type `Vec&lt;String&gt;`, which does not implement the `Copy` trait
...
7   |     for mut s in v {
    |                  - `v` moved due to this implicit call to `.into_iter()`
...
11  |     println!(&quot;{:?}&quot;, v);
    |                      ^ value borrowed here after move
    |
</code></pre>
<p><code>for</code> 循环运行过程中，它会获取 <code>vector</code> 的所有权，并且在每次迭代的过程中将它赋值给 <code>s</code>。</p>
</div>

<h3 id="Copy-类型的所有权转移"><a href="#Copy-类型的所有权转移" class="headerlink" title="Copy 类型的所有权转移"></a>Copy 类型的所有权转移</h3><p>本节到目前为止，所展示的所有权转移示例示例涉及 <code>vector</code>、字符串等这些类型可能会占用大量内存的类型，并且复制成本高昂，通过 <code>move</code> 转移值的所有权会使操作成本低廉。但对于整数或字符等更简单的类型，这种出于成本的考虑就没有必要了。我们来看下面这段代码就能看到他们之间的差别：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="string">&quot;somnambulance&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = string1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num1</span>: <span class="type">i32</span> = <span class="number">36</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num2</span> = num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串类型会执行所有权转移的策略，而对于简单类型，则是采取复制策略：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/string-int-move-cmp.png" class="">


<p>实际上，在处理 <code>Copy</code> 类型时，是复制值而不是 <code>move</code>，标准的 <code>Copy</code> 类型包括了所有的整数，浮点数，<code>char</code>，<code>bool</code> 类型以及大小固定的数组或者<code>tuple</code>，或者说可以按 <code>bit</code> 复制的类型都能被 <code>Copy</code>，<code>String</code> 由于包含一个堆中的缓冲池，所以不允许 <code>Copy</code>，<code>Box&lt;T&gt;</code> 类似。而 <code>File</code>类型包含了一个操作系统的文件句柄，所以也不能 <code>Copy</code>。还有例如 <code>MutexGuard</code> 互斥锁类型，复制是没有意义的，并且只能由一个线程持有。</p>
<p>根据经验，当值被删除时需要做一些特殊事情的任何类型都不能复制：<code>Vec</code> 需要释放其元素，<code>File</code> 需要关闭句柄，<code>MutexGuard</code> 需要解锁，这种类型的位按<code>bit</code>复制将会导致谁拥有原始的资源不清晰。</p>
<div class="note danger"><p>默认情况下，自定义的类型是不能复制的，所以我们自己定义的结构体或者枚举都不满足复制条件。例如下面这段代码会编译失败：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Label</span> &#123;</span><br><span class="line">        number: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(l: Label) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;STAMP: &#123;&#125;&quot;</span>, l.number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Label &#123; number: <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print</span>(l);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;My label number is: &#123;&#125;&quot;</span>, l.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是 <code>Label</code> 不能 <code>Copy</code>，在调用 <code>print</code> 函数的时候，<code>l</code> 拥有的值已经被转移，在调用结束之后被释放掉：</p>
<pre><code>error[E0382]: borrow of moved value: `l`
--&gt; src/main.rs:13:40
|
11 |     let l = Label { number: 3 };
|         - move occurs because `l` has type `Label`, which does not implement the `Copy` trait
12 |     print(l);
|           - value moved here
13 |     println!(&quot;My label number is: {}&quot;, l.number);
|                                        ^^^^^^^^ value borrowed here after move
|
</code></pre>
</div>

<p>但是这个设计看起来很蠢，因为我们结构体里面的都是基本类型。如果我们想这样做，并且结构体内部所有字段都是可复制的，那么我们可以通过 <code>#[derive(Copy, Clone)]</code> 来标记我们的结构体，这样就上面的代码就可以编译通过了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Label</span> &#123;</span><br><span class="line">        number: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(l: Label) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;STAMP: &#123;&#125;&quot;</span>, l.number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Label &#123; number: <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print</span>(l);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;My label number is: &#123;&#125;&quot;</span>, l.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们的结构体内部包含 <code>String</code> 字段，还是会编译失败，原因是 <code>String</code> 类型没有实现 <code>Copy</code>，不能复制：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Label</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(l: Label) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;STAMP: &#123;&#125;&quot;</span>, l.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Label &#123;</span><br><span class="line">        name: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print</span>(l);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;My label number is: &#123;&#125;&quot;</span>, l.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>error[E0204]: the trait `Copy` may not be implemented for this type
--&gt; src/main.rs:2:14
|
2 |     #[derive(Copy, Clone)]
|              ^^^^
3 |     struct Label {
4 |         name: String,
|         ------------ this field does not implement `Copy`
|
</code></pre>
</div>


<p>复制类型更灵活，因为他不会导致值原来的所有者处于未初始化状态。但是这对于一个类型的开发者来说恰好相反，更希望类型的负影响更小，而且 <code>Copy</code> 类型可以包含的类型非常有限，非复制类型可以使用堆分配内存并且拥有其他类型。</p>
<h3 id="Rc-和-Arc：共享所有权"><a href="#Rc-和-Arc：共享所有权" class="headerlink" title="Rc 和 Arc：共享所有权"></a><code>Rc</code> 和 <code>Arc</code>：共享所有权</h3><p>尽管在 <code>Rust</code> 中，大多数情况下，每个值都拥有唯一的所有者，但是在某些情况下，我们可能希望某个值在所有人都不用的情况下再去释放它。为了应对这种情况，<code>Rust</code> 提供了 <code>Rc</code> 和 <code>Arc</code> 两种引用计数类型。<code>Rc</code> 和 <code>Arc(Atomic Reference Count)</code> 的唯一区别是，<code>Arc</code> 是线程安全的，支持多线程，但是性能有影响，所以，如果不需要线程共享，应该使用 <code>Rc</code>。</p>
<p>我们来看下面这个示例，和 <code>Python</code> 很像，对于任何类型 <code>T</code>，<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 的值是一个指向堆内存的指针和一个引用计数。<code>clone</code> 操作不会复制 <code>T</code>，而是简单地创建一个指针指向堆中的内存，并且增加引用计数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Rust can infer all these types; written out for clarity</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: Rc&lt;<span class="type">String</span>&gt; = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;shirataki&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span>: Rc&lt;<span class="type">String</span>&gt; = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span>: Rc&lt;<span class="type">String</span>&gt; = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的内存布局如下图所示，这里的 <code>s</code>，<code>t</code>，<code>u</code> 都指向了相同的内存块，当它们的最后一个离开作用域时，堆中的内存被释放掉：</p>
<img data-src="/2022/06/27/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/rc-arc-value-mme-layout.png" class="">

<p>可以直接使用 <code>T</code> 类型的方法，这里我们可以用 <code>String</code> 的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Rust can infer all these types; written out for clarity</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: Rc&lt;<span class="type">String</span>&gt; = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;shirataki&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span>: Rc&lt;<span class="type">String</span>&gt; = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span>: Rc&lt;<span class="type">String</span>&gt; = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(s.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;shira&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(t.<span class="title function_ invoke__">find</span>(<span class="string">&quot;taki&quot;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; are quite chewy, almost bouncy, but lack flavor&quot;</span>, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>Rc&lt;T&gt;</code> 持有的指针是不可变的，所以我们不能更改所包含的字符串：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; noodles&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码在编译时会出现错误：</p>
<pre><code>error[E0596]: cannot borrow data in an `Rc` as mutable
--&gt; src/main.rs:11:5
|
11 |     s.push_str(&quot; noodles&quot;);
|     ^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable
|
= help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Rc&lt;String&gt;`
</code></pre>
<p>这是因为 <code>Rust</code> 的内存安全策略是：共享可读和可修改只能同时存在一个，而 <code>Rc</code> 就是为了多人共享而存在。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>所有权</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】引用</title>
    <url>/2022/06/26/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在 <code>Rust</code> 中，指针按是否有所有权属性可以分为两类，例如 <code>Box&lt;T&gt;</code>，<code>String</code>，或者 <code>Vec</code> 具有所有权属性的指针（<code>owning pointers</code>），可以说它们拥有指向的内存，当它们被删除时，指向的内存也会被被释放掉。但是，也有一种非所有权指针，叫做引用<code>(references)</code>，它们的存在不会影响指向值的生命周期，在 <code>Rust</code> 中创建引用的行为称之为对值的借用。</p>
<p>要注意的是，引用决不能超过其引用的值的生命周期。必须在代码中明确指出，任何引用都不可能超过它所指向的值的寿命。为了强调这一点，<code>Rust</code> 将创建对某个值的引用称为<strong>借用</strong>：你所借的东西，最终必须归还给它的所有者。</p>
<h3 id="引用值"><a href="#引用值" class="headerlink" title="引用值"></a>引用值</h3><p>在《【Rust】所有权》章节中，我们说到函数传值会转移值得所有权，<code>for</code> 循环也会，例如，对下面的代码，我们在将 <code>table</code> 传递给 <code>show</code> 函数之后，<code>table</code> 就处于未初始化状态：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Table</span> = HashMap&lt;<span class="type">String</span>, <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show</span>(table: Table) &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (artist, works) <span class="keyword">in</span> table &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;works by &#123;&#125;:&quot;</span>, artist); <span class="keyword">for</span> <span class="variable">work</span> <span class="keyword">in</span> works &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;  &#123;&#125;&quot;</span>, work);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">table</span> = Table::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Gesualdo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                 <span class="built_in">vec!</span>[<span class="string">&quot;many madrigals&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                      <span class="string">&quot;Tenebrae Responsoria&quot;</span>.<span class="title function_ invoke__">to_string</span>()]);</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Caravaggio&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                 <span class="built_in">vec!</span>[<span class="string">&quot;The Musicians&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                      <span class="string">&quot;The Calling of St. Matthew&quot;</span>.<span class="title function_ invoke__">to_string</span>()]);</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Cellini&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                 <span class="built_in">vec!</span>[<span class="string">&quot;Perseus with the head of Medusa&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                      <span class="string">&quot;a salt cellar&quot;</span>.<span class="title function_ invoke__">to_string</span>()]);</span><br><span class="line">    <span class="title function_ invoke__">show</span>(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>如果在 <code>show</code> 函数之后，我们再想使用 <code>table</code> 变量就会报错，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="title function_ invoke__">show</span>(table);</span><br><span class="line"><span class="built_in">assert_eq!</span>(table[<span class="string">&quot;Gesualdo&quot;</span>][<span class="number">0</span>], <span class="string">&quot;many madrigals&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 编译器提示变量 <code>table</code> 已经不可用，<code>show</code> 函数的调用已经转移 <code>table</code> 的所有权：</p>
<pre><code>error[E0382]: borrow of moved value: `table`
--&gt; src/main.rs:24:16
|
13 |     let mut table = Table::new();
|         --------- move occurs because `table` has type `HashMap&lt;String, Vec&lt;String&gt;&gt;`, which does not implement the `Copy` trait
...
23 |     show(table);
|          ----- value moved here
24 |     assert_eq!(table[&quot;Gesualdo&quot;][0], &quot;many madrigals&quot;);
|                ^^^^^ value borrowed here after move
</code></pre>
</div>

<span id="more"></span>

<p>正确处理这个问题的方法是使用引用，使用引用不会改变值得所有者，引用有两种类型：</p>
<ul>
<li><p><code>shared reference</code>：可以读引用的值，但不能改变它。而且同时可以有多个<code>shared reference</code>。表达式 <code>&amp;e</code> 会生成 <code>e</code> 的<code>shared reference</code>。如果 <code>e</code> 的类型是 <code>T</code>，那么 <code>&amp;e</code> 的类型是 <code>&amp;T</code>，读作 <code>ref T</code>，**<code>shared reference</code>是可以复制的**；共享引用借用的值是只读的，在共享引用的整个生命周期中，它的引用对象或从该引用对象可到达的任何东西都不能被改变，就像加了读锁，被冻结了；</p>
</li>
<li><p><code>mutable reference</code>：可读可写所引用的值，不能拥有其他任何 <code>shared reference</code> 或者 <code>mutable reference</code>。表达式 <code>&amp;mut e</code> 生成 <code>e</code> 的 <code>mutable reference</code>。如果 <code>e</code> 的类型是 <code>T</code>，那么 <code>&amp;mut e</code> 的类型是 <code>&amp;mut T</code>，读作 <code>ref mute T</code>。 <strong><code>mutable reference</code>是不可以复制的</strong>。可变引用借用的值只能通过该引用访问，在可变引用的整个生命周期中，没有其他可用路径可以到达其引用对象；</p>
</li>
</ul>
<p>因此，我们可以对上面的 <code>show</code> 函数作如下修改，就可以使得代码编译通过。在 <code>show</code> 函数中，<code>table</code> 的类型是 <code>&amp;Table</code>，那么 <code>artist</code> 和 <code>works</code> 的类型就是 <code>&amp;String</code> 和 <code>&amp;Vec&lt;String&gt;</code>，内部的 <code>for</code> 循环中 <code>work</code> 的类型也就变成了 <code>&amp;String</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Table</span> = HashMap&lt;<span class="type">String</span>, <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show</span>(table: &amp;Table) &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (artist, works) <span class="keyword">in</span> table &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;works by &#123;&#125;:&quot;</span>, artist);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">work</span> <span class="keyword">in</span> works &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;  &#123;&#125;&quot;</span>, work);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">table</span> = Table::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(</span><br><span class="line">        <span class="string">&quot;Gesualdo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;many madrigals&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;Tenebrae Responsoria&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(</span><br><span class="line">        <span class="string">&quot;Caravaggio&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;The Musicians&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;The Calling of St. Matthew&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(</span><br><span class="line">        <span class="string">&quot;Cellini&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;Perseus with the head of Medusa&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;a salt cellar&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">    <span class="title function_ invoke__">show</span>(&amp;table);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(table[<span class="string">&quot;Gesualdo&quot;</span>][<span class="number">0</span>], <span class="string">&quot;many madrigals&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们 <code>table</code> 中的值进行排序，<code>shared reference</code> 肯定不能满足要求，因为它不允许改变值，所以我们需要一个 <code>mutable reference</code>。可变借用使得 <code>sort_works</code> 有能力读和修改 <code>works</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sort_works</span>(table: &amp;<span class="keyword">mut</span> Table) &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (_artist, works) <span class="keyword">in</span> table &#123;</span><br><span class="line">        works.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_ invoke__">sort_works</span>(&amp;<span class="keyword">mut</span> table);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们将一个值传递给函数时，可以说是将值的所有权转移给了函数，称之为按值传参。但是，如果我们将引用传给函数，我们可以称之为按引用传参，它没有改变值的所有权，只是借用了值。</p>
<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>在 <code>Rust</code> 中，我们可以通过 <code>&amp;</code> 或者 <code>&amp;mut</code> 创建 <code>shared reference</code> 或者 <code>mutable reference</code>，在机器级别，它们就是个地址。解引用可以通过 <code>*</code> 操作符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Back to Rust code from this point onward.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x; <span class="comment">// &amp;x is a shared reference to x</span></span><br><span class="line">    <span class="built_in">assert!</span>(*r == <span class="number">10</span>); <span class="comment">// explicitly dereference r</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span>=<span class="number">32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = &amp;<span class="keyword">mut</span> y; <span class="comment">// &amp;mut y is a mutable reference to y</span></span><br><span class="line">    *m += <span class="number">32</span>; <span class="comment">// explicitly dereference m to set y&#x27;s value</span></span><br><span class="line">    <span class="built_in">assert!</span>(*m == <span class="number">64</span>); <span class="comment">// and to see y&#x27;s new value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每次访问引用指向的值，都需要 <code>*</code> 操作符，在访问结构体字段的时候，不难想象，体验有点糟糕。所在，在 <code>Rust</code> 中，可以通过 <strong><code>.</code></strong> 操作符隐式地解引用它的左操作数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Anime</span> &#123;</span><br><span class="line">        name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">        bechdel_pass: <span class="type">bool</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">aria</span> = Anime &#123;</span><br><span class="line">        name: <span class="string">&quot;Aria: The Animation&quot;</span>,</span><br><span class="line">        bechdel_pass: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">anime_ref</span> = &amp;aria;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(anime_ref.name, <span class="string">&quot;Aria: The Animation&quot;</span>);</span><br><span class="line">    <span class="comment">// Equivalent to the above, but with the dereference written out:</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((*anime_ref).name, <span class="string">&quot;Aria: The Animation&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，**<code>.</code>** 操作符还可以隐式地从它的左操作数创建引用，因此下面两个操作使等价的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1973</span>, <span class="number">1968</span>];</span><br><span class="line">    v.<span class="title function_ invoke__">sort</span>(); <span class="comment">// implicitly borrows a mutable reference to v</span></span><br><span class="line">    (&amp;<span class="keyword">mut</span> v).<span class="title function_ invoke__">sort</span>(); <span class="comment">// equivalent, but more verbose</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用更新"><a href="#引用更新" class="headerlink" title="引用更新"></a>引用更新</h3><p>在 <code>C++</code> 中，一旦一个引用被初始化，是不能更改其指向的。但是在 <code>Rust</code> 中是完全允许的，例如下面的代码中，一开始 <code>r</code> 借用了 <code>x</code>，后面又借用了 <code>y</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = &amp;x;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*r, <span class="number">10</span>);</span><br><span class="line">    r = &amp;y;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*r, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用的引用"><a href="#引用的引用" class="headerlink" title="引用的引用"></a>引用的引用</h3><p>在 <code>C</code> 语言中我们经常听到指向指针的指针，在 <code>Rust</code> 中也是允许的，如下所示，为了清晰，我们写出了每个变量的类型，实际上我们完全可以省略，由 <code>Rust</code> 来推断。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">1000</span>, y: <span class="number">729</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>: &amp;Point = &amp;point;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rr</span>: &amp;&amp;Point = &amp;r;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rrr</span>: &amp;&amp;&amp;Point = &amp;rr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(rrr.y, <span class="number">729</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，**<code>.</code>** 操作符可以一直向前寻找，直到找到最终的值。这些变量在内存中的分布如下图所示：</p>
<img data-src="/2022/06/26/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/ref-to-ref.png" class="">

<h3 id="引用比较"><a href="#引用比较" class="headerlink" title="引用比较"></a>引用比较</h3><p>同 <strong><code>.</code></strong> 操作符一样，比较运算符也有这样的效果，能连续解引用直到找到最终的值，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ry</span> = &amp;y;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rrx</span> = &amp;rx;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rry</span> = &amp;ry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(rrx &lt;= rry);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(rrx, rry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在大多数情况下应该是我们想要的效果，但是如果我们确实想知道两个引用它们指向的内存地址是否相同，我们可以使用 <code>std::ptr::eq</code>，仅仅比较地址而不是指向的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(rx, ry);</span><br><span class="line"><span class="built_in">assert!</span>(!std::ptr::<span class="title function_ invoke__">eq</span>(rx, ry));</span><br></pre></td></tr></table></figure>

<p>但是，无论如何，比较操作符左右两侧的操作数必须要有相同的类型，例如，下面的代码编译失败：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(rx == rrx); <span class="comment">// error: type mismatch: `&amp;i32` vs `&amp;&amp;i32` </span></span><br><span class="line"><span class="built_in">assert!</span>(rx == *rrx); <span class="comment">// this is okay</span></span><br></pre></td></tr></table></figure></div>

<h3 id="引用永不为空"><a href="#引用永不为空" class="headerlink" title="引用永不为空"></a>引用永不为空</h3><p><code>Rust</code> 中的引用永远不会为空。没有类似于<code>C</code>的<code>NULL</code>或<code>C++</code>的<code>nullptr</code>。引用没有默认初始值（因为任何变量在初始化之前，无论其类型如何，都不能使用），<code>Rust</code> 不会将整数转换为引用（安全代码中），因此无法将<code>0</code>转换为引用。</p>
<p><code>C</code> 和 <code>C++</code> 代码中使用空指针表示没有值，例如，<code>malloc</code> 函数要么返回一个指向内存块的指针，要么返回 <code>null</code> 表示内存申请失败。</p>
<p>在 <code>Rust</code> 中，如果你需要用一个值表示引用某个变量的内存，或者没有，可以使用 <code>Option&lt;&amp;T&gt;</code>。在机器层面，<code>Rust</code>将其表示为代表空指针的<code>None</code>或者<code>Some(r)</code>，其中<code>r</code>是<code>&amp;T</code>值，表示为非零地址，因此<code>Option&lt;&amp;T&gt;</code>与<code>C</code>或<code>C++</code>中的可空指针一样有效，但是它更安全：<code>Option</code>类型要求在使用它之前检查它是否为<code>None</code>。</p>
<h3 id="从任何表达式借用引用"><a href="#从任何表达式借用引用" class="headerlink" title="从任何表达式借用引用"></a>从任何表达式借用引用</h3><p>在<code>C</code>、<code>C++</code>或者其他大多数语言中，我们都是从变量获取引用，也就是 <code>&amp;</code> 运算符后面一般都是紧跟某个变量。但是在 <code>Rust</code> 中，我们可以从任何表达式借用引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="title function_ invoke__">factorial</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// Arithmetic operators can see through one level of references.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(r + &amp;<span class="number">1009</span>, <span class="number">1729</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">factorial</span>(n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (<span class="number">1</span>..n + <span class="number">1</span>).<span class="title function_ invoke__">product</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，<code>Rust</code> 会创建一个持有表达式值的匿名变量，然后再从匿名变量创建一个引用。匿名表达式的生命周期取决于我们怎么使用这个引用：</p>
<ul>
<li><p>如果我们是将这个引用用在赋值语句 <code>let</code>，结构体字段或者数组中，那么这个匿名变量的生命周期和我们 <code>let</code> 语句初始化的变量一样，例如上面的 <code>r</code>；</p>
</li>
<li><p>否则，这个匿名变量在当前语句结束就会被释放掉，例如上面为 <code>1009</code> 创建的匿名变量在 <code>assert_eq!</code> 结束就会被丢掉；</p>
</li>
</ul>
<h3 id="胖指针"><a href="#胖指针" class="headerlink" title="胖指针"></a>胖指针</h3><p>胖指针，即 <code>fat pointers</code>，指哪些不仅仅是包含了地址的指针，就像 <code>&amp;[T]</code>，引用自 <code>slice</code> 的指针除了包含首元素的地址之外，还包括 <code>slice</code> 的数量；</p>
<p>另一种胖指针是 <code>trait</code> 类型，详细请看 <a href="/2022/04/26/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/#trait-%E5%AF%B9%E8%B1%A1"><code>Trait</code> 对象</a>。</p>
<h3 id="引用安全性"><a href="#引用安全性" class="headerlink" title="引用安全性"></a>引用安全性</h3><p>截止到目前为止，我们看到的指针都和C中差不多，但是既然这样，我们又如何保证安全性呢？为了保证引用使用的安全性，<code>Rust</code> 为每个应用都会分配一个生命周期，更多请看<a href="/2021/09/14/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">【Rust】生命周期</a>。</p>
<h4 id="引用局部变量"><a href="#引用局部变量" class="headerlink" title="引用局部变量"></a>引用局部变量</h4><p>如果我们引用的是一个局部变量，并且我们的引用比局部变量的作用域更大，也就是局部变量释放了之后，我们的程序会如何，来看下面的示例：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*r, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码编译会失败的，编译器提示：我们引用的值没有引用活得久，因为 <code>x</code> 在内部的括号之后就被释放了，导致 <code>r</code>  成了一个悬垂指针：</p>
<pre><code>error[E0597]: `x` does not live long enough
--&gt; src/main.rs:5:13
|
5 |         r = &amp;x;
|             ^^ borrowed value does not live long enough
6 |     }
|     - `x` dropped here while still borrowed
7 |     assert_eq!(*r, 1);
|     ----------------- borrow later used here
</code></pre>
</div>

<p><code>Rust</code> 编译器是如何确保每个引用都是有效的呢？ <code>Rust</code> 为每个引用都赋予了一个满足其使用范围的 <strong>生命周期</strong>。生命周期是程序的一部分，可以被安全地用于语句，表达式或者变量。但是生命周期完全是<code>Rust</code>编译时虚构的。在运行时，引用只不过是一个地址，其生命周期是其类型的一部分，没有运行时表示。</p>
<p>在上面的例子中，有三个生命周期，变量 <code>x</code>和 <code>r</code> 的生命周期是从它们初始化到编译器认为它们不再使用为止。第三个生命周期是一个引用类型，我们引用自<code>x</code>并且存储在 <code>r</code> 中。</p>
<p>正如我们上面看到的，生命周期有一个很明显的约束，就是它不能比它引用的值活的久。因为如果这里 <code>x</code> 出了内部的括号，就会被释放，所有来自于它的引用都会变成一个悬垂指针，所以，<code>Rust</code> 规定 <strong>约束1：值的生命周期必须大于它的引用的生命周期</strong>，上面的示例中，<code>x</code>的生命周期就小于它的引用的生命周期：</p>
<img data-src="/2022/06/26/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/local-r-lifetime.png" class="">

<p>还有另外一个约束，<strong>约束2：如果我们将引用存储在一个变量中，那么这个引用必须要覆盖这个变量的整个生命周期，从它的初始化到最后一次使用为止</strong>。上面示例中，<code>x</code> 引用的生命周期没有覆盖到<code>r</code>的使用范围：</p>
<img data-src="/2022/06/26/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/local-x-lifetime.png" class="">

<p>第一个约束限制了生命周期的上限，也就是它最大是多大；第二个约束限制了它的下限，也就是它最小应该是多少；<code>Rust</code> 的编译器必须能找到一个能满足所有约束的生命周期，也就是从上限开始到下限为止。然而遗憾的是，我们的示例中，没有这样的生命周期，所以编译失败：</p>
<img data-src="/2022/06/26/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/lifetime-high-and-low.png" class="">

<div class="note success"><p>对于我们上面的示例，稍作修改，就可以找到满足的生命周期：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>x</code> 引用的生命周期满足我们的使用：</p>
<img data-src="/2022/06/26/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/lifetime-satisfy-situation.png" class="">
</div>

<h4 id="更新全局引用变量"><a href="#更新全局引用变量" class="headerlink" title="更新全局引用变量"></a>更新全局引用变量</h4><p>当我们传递一个引用给函数时，<code>Rust</code> 如何保证安全使用呢？假设我们有一个函数 <code>f</code>，接受一个引用作为参数，并且把它存储在全局变量中，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能编译</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> STASH: &amp;<span class="type">i32</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(p:&amp;<span class="type">i32</span>)&#123; </span><br><span class="line">    STASH=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Rust</code> 的全局变量时静态创建的，贯穿应用程序的整个生命周期。像任何其他声明一样，<code>Rust</code>的模块系统控制静态变量在什么地方可见，所以它们仅仅是在生命周期里是全局的，而不是可见性。上面的代码是有一些问题的，没有遵循两个规则：</p>
<ul>
<li><p>所有的静态变量必须被初始化；</p>
</li>
<li><p>可变的静态变量不是线程安全的，因为任何线程任何时候都可以访问静态变量，即使单线程也会引发某些未知的异常；出于这些原因，我们需要放在 <code>unsafe</code> 块中才能访问全局可变静态变量；</p>
</li>
</ul>
<p>根据这两个规则，我们将上面的代码改成下面这个样子：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> STASH: &amp;<span class="type">i32</span> = &amp;<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(p: &amp;<span class="type">i32</span>) &#123;</span><br><span class="line">   <span class="keyword">unsafe</span> &#123;</span><br><span class="line">       STASH = p;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了让代码更加完善，我们需要手动函数参数的生命周期，这里 <code>&#39;a</code> 读作 <code>tick A</code>，我们将 <code>&lt;&#39;a&gt;</code> 读作 <code>for any lifetime &#39;a</code>。所以下面的代码定义了一个接受具有任意生命周期 <code>&#39;a</code> 参数 <code>p</code> 的函数 <code>f</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(p: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>STASH</code> 的生命周期和应用程序一样，所以我们必须赋予它一个具有相同生命周期的引用，<code>Rust</code> 将这种生命周期称之为 <code>&#39;static lifetime</code>，静态生命周期，所以如果参数的 <code>p</code> 的声明是 <code>&#39;a</code>，是不允许的。编译器直接拒绝编译我们的代码：</p>
<pre><code>error[E0312]: lifetime of reference outlives lifetime of borrowed content...
--&gt; src/main.rs:5:16
|
5 |        STASH = p;
|                ^
|
= note: ...the reference is valid for the static lifetime...
note: ...but the borrowed content is only valid for the lifetime `&#39;a` as defined here
</code></pre>
<p>编译器的提示很明显，<code>f</code> 需要一个具有静态生命周期的参数 <code>p</code>，因此我们现在可以将代码修改成如下的样子：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> STASH: &amp;<span class="type">i32</span> = &amp;<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> WORTH_POINTING_AT: <span class="type">i32</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(p: &amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        STASH = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(&amp;WORTH_POINTING_AT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从一开始的 <code>f(p: &amp;i32)</code> 到结束时的 <code>f(p: &amp;&#39;static i32)</code>，如果不在函数的签名中反映该意图，我们就无法编写一个将引用固定在全局变量中的函数，我们必须指出引用的生命周期，满足<strong>约束2：如果我们将引用存储在一个变量中，那么这个引用必须要覆盖这个变量的整个生命周期，从它的初始化到最后一次使用为止</strong>。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】生命周期</title>
    <url>/2023/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><code>Rust</code> 中的每一个引用都有其<strong>生命周期（lifetime）</strong>，也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。但有些时候，<code>Rust</code> 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p>
<img data-src="/2023/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/background.jpg" class="" title="生命周期">

<span id="more"></span>


<h3 id="避免悬垂应用"><a href="#避免悬垂应用" class="headerlink" title="避免悬垂应用"></a>避免悬垂应用</h3><p>rust 的编译器拥有一个<strong>借用检查器</strong>，通过比较作用域来确保所有的借用是否有效。如下的示例中，这段代码是<mark class="label danger">不能工作的</mark>，<code>&#39;a</code> 和 <code>&#39;b</code> 被称作<strong>生命周期注解</strong>，很明显看出变量 <code>r</code> 的生命周期大于 <code>x</code>，那么如果在 <code>x</code> 生命周期结束的时候，<code>r</code> 依然保留对 <code>x</code> 的引用，就会引发程序异常，所以 rust 拒绝这段代码的编译，根据编译器的提示，因为变量 <code>x</code> 获得不够长，编译通过借用检查器，就能有效地避免悬垂指针。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2023/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/life-failed-example.png" class=""></div><div class="group-picture-column"><img data-src="/2023/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/life-failed-example-compiler.png" class=""></div></div></div>

<h3 id="生命周期注解语法"><a href="#生命周期注解语法" class="headerlink" title="生命周期注解语法"></a>生命周期注解语法</h3><p>生命周期注解并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。</p>
<p>生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（<code>&#39;</code>）开头，其名称通常全是小写，类似于泛型其名称非常短。<code>&#39;a</code> 是大多数人默认使用的名称。生命周期参数注解位于引用的 <code>&amp;</code> 之后，并有一个<code>空格</code>来将引用类型与生命周期注解分隔开。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>

<h3 id="函数签名中的生命周期注解"><a href="#函数签名中的生命周期注解" class="headerlink" title="函数签名中的生命周期注解"></a>函数签名中的生命周期注解</h3><p>来看个例子，编写一个函数，根据两个字符串的长度，返回较长的那一个，意想不到的是编译错误了，因为就这段代码来说，两个分支都有可能进入，但是rust要保证引用的有效性，就得比较两个参数的生命周期，他们的生命周期只有相同的时候才是有效的，rust 的编译器也提示我们添加生命周期注解：</p>
<div class="tabs" id="函数中的生命周期注解"><ul class="nav-tabs"><li class="tab active"><a href="#函数中的生命周期注解-1">代码</a></li><li class="tab"><a href="#函数中的生命周期注解-2">编译错误</a></li></ul><div class="tab-content"><div class="tab-pane active" id="函数中的生命周期注解-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数中的生命周期注解-2"><img data-src="/2023/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/func-lifetime-compile0failed.png" class=""></div></div></div>

<p>改进之后，给函数的参数添加生命周期注解之后，函数<mark class="label success">编译通过</mark>，我们指定两个参数 <code>s1</code> 和 <code>s2</code> 的生命周期是相同的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们传入的两个参数的生命周期不同的时候，因为 <code>string2</code> 没有 <code>string1</code> 活得长，当我们最后要打印的时候，<code>string2</code> 已经不存在了，所以编译器是会<mark class="label danger">拒绝编译的</mark>。</p>
<div class="tabs" id="函数中的生命周期注解2"><ul class="nav-tabs"><li class="tab active"><a href="#函数中的生命周期注解2-1">代码</a></li><li class="tab"><a href="#函数中的生命周期注解2-2">编译错误</a></li></ul><div class="tab-content"><div class="tab-pane active" id="函数中的生命周期注解2-1"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数中的生命周期注解2-2"><img data-src="/2023/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/func-lifetime-compile-success.png" class=""></div></div></div>

<p>如果将打印位置放在 <code>&#123;&#125;</code> 内，是没有问题的，返回值的作用小于参数的作用域，<code>result</code> &lt; <code>string2</code> &lt; <code>string1</code>。</p>
<h3 id="结构体中的生命周期注解"><a href="#结构体中的生命周期注解" class="headerlink" title="结构体中的生命周期注解"></a>结构体中的生命周期注解</h3><p>结构体包含引用时，需要为结构体添加一个生命周期注解。这个结构体有一个字段，<code>part</code>，它存放了一个字符串 <code>slice</code>，这是一个引用。类似于泛型参数类型，必须在结构体名称后面的尖括号中添加泛型生命周期参数，以便在结构体定义中使用生命周期参数。这个注解意味着 <code>ImportantExcerpt</code> 的实例不能比其 <code>part</code> 字段中的引用存在的更久，也就是说<code>ImportantExcerpt</code> 的实例的生命周期范围小于<code>part</code> 字段中的引用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i.part);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期省略"><a href="#生命周期省略" class="headerlink" title="生命周期省略"></a>生命周期省略</h3><p>每一个引用都有一个生命周期，我们需要为那些使用了引用的函数或结构体指定生命周期。但是如果每一个有引用参数的函数都需要声明参数周期，那将是惨绝人寰的编程体验。但是像下面这样的代码编译确实没有任何问题的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在早期版本（pre-1.0）的 Rust 中，这的确是不能编译的。每一个引用都必须有明确的生命周期。那时的函数签名将会写成这样：</p>
<blockquote>
<p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;’a str {</p>
</blockquote>
<p>在rust开发团队编写了很多 rust 代码之后，发现总是重复地写着相同的生命周期注解，为了让生活更美好，抽象出了 <strong>生命周期省略规则（lifetime elision rules）</strong>，只要我们编写的代码符合这些规则，就不用写生命周期注解了。</p>
<p>函数或方法的参数的生命周期被称为<strong>输入生命周期（input lifetimes）</strong>，而返回值的生命周期被称为<strong>输出生命周期（output lifetimes）</strong>。编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块。</p>
<h4 id="Rule1"><a href="#Rule1" class="headerlink" title="Rule1"></a>Rule1</h4><p>每一个是引用的参数都有它自己的生命周期。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>，依此类推。</p>
<h4 id="Rule2"><a href="#Rule2" class="headerlink" title="Rule2"></a>Rule2</h4><p>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code>。</p>
<h4 id="Rule3"><a href="#Rule3" class="headerlink" title="Rule3"></a>Rule3</h4><p>如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>, 那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。这条规则使得方法更容易读写，因为只需更少的符号。</p>
<h4 id="规则使用示例"><a href="#规则使用示例" class="headerlink" title="规则使用示例"></a>规则使用示例</h4><p>对于我们本节开头的示例，我们应用规则1之后得到：</p>
<blockquote>
<p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;str {</p>
</blockquote>
<p>接着我们应用规则2，这样编译器就能懂了，我们也就不用写了：</p>
<blockquote>
<p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;’a str {</p>
</blockquote>
<p>但是对于比较字符串长度的函数：</p>
<blockquote>
<p>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</p>
</blockquote>
<p>我们在应用规则1之后得到：</p>
<blockquote>
<p>fn longest&lt;’a, ‘b&gt;(x: &amp;’a str, y: &amp;’b str) -&gt; &amp;str {</p>
</blockquote>
<p>但是在应用规则2的时候，发现不适用，这样对于输出参数的生命周期，编译器不能推断出来，只能报错，由开发者指定。</p>
<h3 id="方法中的生命周期注解"><a href="#方法中的生命周期注解" class="headerlink" title="方法中的生命周期注解"></a>方法中的生命周期注解</h3><p>当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段或方法参数和返回值相关。</p>
<p>实现方法时结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p>
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。</p>
<p>如下示例，这里有一个方法 <code>level</code>。其唯一的参数是 <code>self</code> 的引用，而且返回值只是一个 <code>i32</code>，并不引用任何值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。下面是一个适用于第三条生命周期省略规则的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 <code>&amp;self</code> 和 <code>announcement</code> 他们各自的生命周期。接着，因为其中一个参数是 <code>&amp;self</code>，返回值类型被赋予了 <code>&amp;self</code> 的生命周期，这样所有的生命周期都被计算出来了。</p>
<h3 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h3><p>这里有一种特殊的生命周期值得讨论：<code>&#39;static</code>，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 <code>&#39;static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 <code>&#39;static</code> 的。</p>
<h3 id="结合泛型参数、Trait-Bound"><a href="#结合泛型参数、Trait-Bound" class="headerlink" title="结合泛型参数、Trait Bound"></a>结合泛型参数、Trait Bound</h3><p>如下是一个在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HRTB-higher-ranked-trait-bounds"><a href="#HRTB-higher-ranked-trait-bounds" class="headerlink" title="HRTB (higher ranked trait bounds)"></a><code>HRTB (higher ranked trait bounds)</code></h3><p><code>HRTB</code>，中文名为高阶生命周期参数，可以用来实现动态生命周期，举几个例子说明情况。</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>假如我们有下面这样的示例：</p>
<div class="tabs" id="hrbt-示例一"><ul class="nav-tabs"><li class="tab active"><a href="#hrbt-示例一-1">错误示例</a></li><li class="tab"><a href="#hrbt-示例一-2">正确示例</a></li></ul><div class="tab-content"><div class="tab-pane active" id="hrbt-示例一-1"><p>第一次调用 <code>f(&amp;x)</code> 时生命周期 <code>&#39;a</code> 等于变量 <code>x</code> 的生命周期；而在第二次调用 <code>f(&amp;y)</code> 时，生命周期 <code>&#39;a </code>又等于了变量 <code>y</code> 的生命周期；而变量 <code>x</code> 和变量 <code>y</code> 的生命周期显然是不同的。因此无法用一个静态的生命周期来描述 <code>&#39;a</code> ，我们希望的是，闭包 <code>f</code> 在具体调用时绑定具体的生命周期，比如调用 <code>f(&amp;x)</code> 时绑定的是 <code>x</code> 的生命周期，而调用 <code>f(&amp;y)</code> 时绑定的是 <code>y</code> 的生命周期。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;<span class="symbol">&#x27;a</span>&gt;(f: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>)&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(&amp;x);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="title function_ invoke__">f</span>(&amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x: &amp;<span class="type">i32</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="hrbt-示例一-2"><p>这里我们使用 <code>for&lt;&#39;b&gt; Fn(&amp;&#39;b i32)</code> 表示 <code>f</code> 参数的声明周期应该在具体调用的时候和它的入参绑定：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(f: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="keyword">for</span>&lt;<span class="symbol">&#x27;b</span>&gt; <span class="title function_ invoke__">Fn</span>(&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(&amp;x);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="title function_ invoke__">f</span>(&amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x: &amp;<span class="type">i32</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><div class="tabs" id="hrbt-示例二"><ul class="nav-tabs"><li class="tab active"><a href="#hrbt-示例二-1">错误示例</a></li><li class="tab"><a href="#hrbt-示例二-2">正确示例</a></li></ul><div class="tab-content"><div class="tab-pane active" id="hrbt-示例二-1"><p>这里不能运行的原因是，我们传入 <code>b.do_sth</code> 的生命周期太短了，<code>&#39;a</code> 的生命周期要求是和 <code>main</code> 函数中 <code>&amp;2usize</code> 生命周期一样长：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">DoSomething</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_sth</span>(&amp;<span class="keyword">self</span>, value: T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="built_in">Debug</span>&gt; DoSomething&lt;T&gt; <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_sth</span>(&amp;<span class="keyword">self</span>, value: T) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;<span class="symbol">&#x27;a</span>&gt;(b: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> DoSomething&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">usize</span>&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">usize</span> = <span class="number">10</span>;</span><br><span class="line">    b.<span class="title function_ invoke__">do_sth</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(&amp;<span class="number">2usize</span>);</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="hrbt-示例二-2"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">DoSomething</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_sth</span>(&amp;<span class="keyword">self</span>, value: T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="built_in">Debug</span>&gt; DoSomething&lt;T&gt; <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_sth</span>(&amp;<span class="keyword">self</span>, value: T) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(b: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="keyword">for</span>&lt;<span class="symbol">&#x27;a</span>&gt; DoSomething&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">usize</span>&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">usize</span> = <span class="number">10</span>;</span><br><span class="line">    b.<span class="title function_ invoke__">do_sth</span>(&amp;s) <span class="comment">// error[E0597]: `s` does not live long enough</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(&amp;<span class="number">2usize</span>);</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>对于下面的闭包 <code>f</code>，编译器不能直接推断出它的生命周期如何，因为没有声明周期参数，返回的 <code>x</code> 引用可能是局部变量的：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = |x: &amp;<span class="type">i32</span>| x; <span class="comment">// error</span></span><br><span class="line">                         <span class="comment">// 假如支持下面的语法就方便多了，目前还未支持</span></span><br><span class="line">                         <span class="comment">// let f: for&lt;&#x27;a&gt; Fn(&amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 = |x| x;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = &amp;<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = <span class="title function_ invoke__">f</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>}

<p>由于我们无法直接对 <code>f</code> 的参数使用生命周期参数，所以退而求其次，我们限定 <code>f</code> 的生命周期在其调用的时候和它的参数绑定就可以了：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate</span>&lt;F&gt;(f: F) <span class="punctuation">-&gt;</span> F</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="keyword">for</span>&lt;<span class="symbol">&#x27;a</span>&gt; F: <span class="title function_ invoke__">Fn</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">generate</span>(|x: &amp;<span class="type">i32</span>| x);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = &amp;<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = <span class="title function_ invoke__">f</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者我们使用下面的方式定义 <code>generate</code> 函数也是可以的，限定传入 <code>F</code> 的参数和返回值都具有相同的生命周期 <code>&#39;a</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>, F&gt;(f: F) <span class="punctuation">-&gt;</span> F</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(&amp;<span class="symbol">&#x27;a</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">&#123;</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Checksum</span>&lt;R: Read&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, r: R) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Xor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R: Read&gt; Checksum&lt;R&gt; <span class="keyword">for</span> <span class="title class_">Xor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> r: R) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span>: <span class="type">u8</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0u8</span>; <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">read</span> = r.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> read == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> &amp;buf[..read] &#123;</span><br><span class="line">                res ^= b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vec!</span>[res]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Add</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R: Read&gt; Checksum&lt;R&gt; <span class="keyword">for</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> r: R) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span>: <span class="type">u8</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0u8</span>; <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">read</span> = r.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> read == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> &amp;buf[..read] &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">tmp</span> = res <span class="keyword">as</span> <span class="type">u16</span> + *b <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">                res = tmp <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vec!</span>[res]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0u8</span>; <span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================================================</span></span><br><span class="line">    <span class="comment">// 尝试去掉 Box&lt;dyn for&lt;&#x27;t&gt; Checksum&lt;&amp;&#x27;t [u8]&gt;&gt; 中的 for&lt;&#x27;t&gt; 试试</span></span><br><span class="line">    <span class="comment">// ================================================================</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">checker</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="keyword">for</span>&lt;<span class="symbol">&#x27;t</span>&gt; Checksum&lt;&amp;<span class="symbol">&#x27;t</span> [<span class="type">u8</span>]&gt;&gt; = <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Initializing Xor Checksum&quot;</span>);</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Xor)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Initializing Add Checksum&quot;</span>);</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Add)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = <span class="string">&quot;Sedm lumpu slohlo pumpu za uplnku&quot;</span>.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">chunk_size</span> = data.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> chunk_size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cs</span> = checker.<span class="title function_ invoke__">calc</span>(&amp;buf[..chunk_size]);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Checksum &#123;&#125; is &#123;:?&#125;&quot;</span>, i, cs);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】异步编程</title>
    <url>/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>如果我们正在开发一个聊天室，并且使用线程处理每个连接，我们的代码可能看起来像下面这个样子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;net, thread&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">listener</span> = net::TcpListener::<span class="title function_ invoke__">bind</span>(address)?;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">socket_result</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket</span> = socket_result?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">groups</span> = chat_group_table.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="title function_ invoke__">log_error</span>(<span class="title function_ invoke__">serve</span>(socket, groups));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个新连接，这都会产生一个运行 <code>serve</code> 函数的新线程，该线程能够专注于管理单个连接的处理。</p>
<p>这很好用，但是如果突然用户达到成千上万时，线程堆栈增长到 <code>100 KiB</code> 或这更多时，这可能要花费几个<code>GB</code>的内存。线程对于在多个处理器之间分配工作是非常好的一种形式，但是它们的内存需求使得我们在使用时要非常小心。</p>
<p>不过可以使用 <code>Rust</code> 异步任务在单个线程或工作线程池上并发运行许多独立活动。异步任务类似于线程，但创建速度更快，并且内存开销比线程少一个数量级。在一个程序中同时运行数十万个异步任务是完全可行的。当然，应用程序可能仍会受到网络带宽、数据库速度、计算或工作固有内存要求等其他因素的限制，但内存开销远没有线程那么多。</p>
<p>一般来说，异步 <code>Rust</code> 代码看起来很像普通的多线程代码，除了涉及到的 <code>I/O</code> 操作，互斥锁等阻塞操作需要稍微的不同处理。之前代码的异步版本如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::&#123;net, task&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">listener</span> = net::TcpListener::<span class="title function_ invoke__">bind</span>(address).<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_connections</span> = listener.<span class="title function_ invoke__">incoming</span>();</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(socket_result) = new_connections.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket</span> = socket_result?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">groups</span> = chat_group_table.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    task::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">log_error</span>(<span class="title function_ invoke__">serve</span>(socket, groups).<span class="keyword">await</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这使用 <a href="https://crates.io/crates/async-std"><code>async_std</code></a> 的<code>net</code>和<code>task</code>模块，并在可能阻塞的调用之后添加 <code>.await</code>。但整体结构与基于线程的版本相同。</p>
<p>本节的目标不仅是帮助编写异步代码，而且还以足够详细的方式展示它的工作原理，以便可以预测它在应用程序中的表现，并了解它最有价值的地方。</p>
<ul>
<li><p>为了展示异步编程的机制，我们列出了涵盖所有核心概念的最小语言特性集：<code>futures</code>、异步函数、<code>await</code> 表达式、<code>task</code> 以及 <code>block_on</code> 和 <code>spawn_local</code> <code>executor</code>；</p>
</li>
<li><p>然后我们介绍异步代码块和 <code>spawn executor</code>。这些对于完成实际工作至关重要，但从概念上讲，它们只是我们刚刚提到的功能的变体。在此过程中，我们会可能会遇到一些异步编程特有的问题，但是需要学习如何处理它们；</p>
</li>
<li><p>为了展示所有这些部分的协同工作，我们浏览了聊天服务器和客户端的完整代码，前面的代码片段是其中的一部分；</p>
</li>
<li><p>为了说明原始 <code>futures</code> 和 <code>executors</code> 是如何工作的，我们提供了 <code>spawn_blocking</code> 和 <code>block_on</code> 的简单但功能性的实现；</p>
</li>
<li><p>最后，我们解释了 <code>Pin</code> 类型，它在异步接口中不时出现，以确保安全使用异步函数和 <code>futures</code>；</p>
</li>
</ul>
<span id="more"></span>

<h3 id="异步世界"><a href="#异步世界" class="headerlink" title="异步世界"></a>异步世界</h3><p>来看一段示例代码，来看它背后会发生什么？它通过一个 <code>TCP</code> 连接到了 <code>Web</code> 服务器，然后发送 <code>HTTP</code> 请求：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cheapo_request</span>(host: &amp;<span class="type">str</span>, port: <span class="type">u16</span>, path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">socket</span> = net::TcpStream::<span class="title function_ invoke__">connect</span>((host, port))?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request</span> = <span class="built_in">format!</span>(<span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost: &#123;&#125;\r\n\r\n&quot;</span>, path, host);</span><br><span class="line">    socket.<span class="title function_ invoke__">write_all</span>(request.<span class="title function_ invoke__">as_bytes</span>())?;</span><br><span class="line">    socket.<span class="title function_ invoke__">shutdown</span>(net::Shutdown::Write)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    socket.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> response)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图显示了该函数随时间的一个执行情况：</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/tcp-to-http-example.png" class="">

<p>此图显示了函数调用堆栈如何随着时间从左到右运行，每个函数调用都是一个方块，放置在其调用者的顶部。显然，<code>cheapo_request</code> 函数贯穿整个执行过程。它调用 <code>Rust</code> 标准库中的函数，例如 <code>TcpStream::connect</code> 和 <code>TcpStream</code> 的 <code>write_all</code> 和 <code>read_to_string </code>实现。它们依次调用其他函数，但最终程序会进行系统调用，例如打开 <code>TCP</code> 连接读取或写入一些数据。</p>
<p>深灰色背景标记程序等待操作系统完成系统调用的时间，这里没有按时间比例回执，否则整个图表将是深灰色：实际上，该函数几乎将所有时间都花在等待操作系统上，前面代码的执行将是系统调用之间的窄条。</p>
<p>当这个函数在等待系统调用返回时，它的单线程被阻塞：在系统调用完成之前它不能做任何事情。一个线程的堆栈大小为数十或数百千字节并不罕见，因此，如果这是某个更大系统的一个片段，许多线程都在从事类似的工作，那么锁定这些线程的资源除了等待之外什么都不做可能会变的很浪费。</p>
<p>为了解决这个问题，线程需要能够在等待系统调用完成时承担其他工作，但如何做到这一点并不简单。例如，我们用来从套接字读取响应的函数的签名是：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_to_string</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这个函数在工作完成或出错之前，此函数不会返回，此函数是同步的：调用者在操作完成后恢复执行。如果我们想在操作系统工作的同时将我们的线程用于其他事情，我们将需要一个新的 <code>I/O</code> 库来提供该函数的异步版本。</p>
<h4 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a><code>Futures</code></h4><p><code>Rust</code> 为了实现异步编程引入了 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Future</code> 表示可以测试是否完成的操作。<code>Future</code> 的 <code>poll</code> 方法从不等待操作完成：它总是立即返回。如果操作完成，<code>poll</code> 返回 <code>Poll::Ready(output)</code>，其中 <code>output</code> 是它的最终结果，否则，它返回待处理。如果 <code>future</code> 可以再次轮询，它将通过调用一个<code>waker</code>（一个在上下文中提供的回调函数） 来让我们知道。</p>
<p>所有现代操作系统都包含其系统调用的变体，我们可以使用这些变体来实现这种轮询接口。例如，在 <code>Unix</code> 和 <code>Windows</code> 上，如果将网络套接字设置为非阻塞模式，则如果它们会阻塞，则读取和写入会返回错误，必须稍后再试。</p>
<p>因此 <code>read_to_string</code> 的异步版本将具有大致如下的签名：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_to_string</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">Result</span>&lt;<span class="type">usize</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>这与我们之前展示的签名相同，除了返回类型：异步版本返回 <code>Future&lt;Output = Result&lt;usize&gt;&gt;</code>。需要轮询这个<code>future</code>，直到你得到一个 <code>Ready(result)</code> ，每次轮询时，都会尽可能读取，最终结果提供成功值或错误值，就像普通的 <code>I/O</code> 操作一样。这是一般模式：任何函数的异步版本都采用与同步版本相同的参数，但返回类型有一个 <code>Future</code> 包裹它。</p>
<p>调用这个版本的 <code>read_to_string</code> 实际上并没有读取任何内容；它的唯一职责是构建并返回一个在将来才能完成的工作。这个 <code>future</code> 必须包含执行请求所需的所有信息。例如，这个 <code>read_to_string</code> 返回的 <code>future</code> 必须记住调用它的输入流，以及它应该将传入数据附加到的 <code>String</code>。事实上，由于 <code>future</code> 持有引用 <code>self</code> 和 <code>buf</code>，<code>read_to_string</code> 的正确签名必须是：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_to_string</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">Result</span>&lt;<span class="type">usize</span>&gt;&gt; + <span class="symbol">&#x27;a</span>;</span><br></pre></td></tr></table></figure>

<p>这增加了生命周期，以表明返回的 <code>future</code> 只能在 <code>self</code> 和 <code>buf</code> 借用的值期间存在。</p>
<p><code>async-std</code> 提供所有 <code>std</code> 的 <code>I/O</code> 工具的异步版本，包括带有 <code>read_to_string</code> 方法的异步 <a href="https://docs.rs/async-std/1.11.0/async_std/io/trait.Read.html"><code>async_std::io::Read</code></a>。 <code>async-std</code> 紧跟 <code>std</code> 的设计，尽可能在自己的接口中重用 <code>std</code> 的类型，因此错误、结果、网络地址和大多数其他相关数据在两个世界之间是兼容的。熟悉 <code>std</code> 有助于使用 <code>async-std</code>，反之亦然。</p>
<p><code>Future</code> 的规则之一是，一旦 <code>future</code> 返回 <code>Poll::Ready</code>，就假设它永远不会被再次轮询。一些 <code>future</code> 如果被过度轮询，就会永远返回 <code>Poll::Pending</code>。（但是，它们不得违反内存或线程安全，或以其他方式导致未定义的行为。） <code>Future</code> 上的 <a href="https://docs.rs/async-std/1.11.0/async_std/stream/trait.StreamExt.html#method.fuse"><code>fuse</code></a> 适配器方法将任何 <code>future</code> 转换为永远返回 <code>Poll::Pending</code> 的 <code>future</code>。但是所有通常的 <code>futrue</code> 消费方式都遵守这条规则，所以通常不需要 <code>fuse</code>。</p>
<p>轮询听起来效率低下，但不要担心，<code>Rust</code> 的异步架构经过精心设计，因此只要基本 <code>I/O</code> 函数（如 <code>read_to_string</code>）正确实现，只会在值得的时候轮询 <code>future</code>，每次调用 <code>poll</code> 时，某个地方应该返回 <code>Ready</code>，或者至少朝着那个目标取得进展。</p>
<p>但是使用 <code>future</code> 似乎是一个挑战：如果进行轮询时，得到 <code>Poll::Pending</code> 时你应该怎么做？给这个线程找点其他的活干，还得回头再来轮询 <code>future</code>。那么整个程序将变得乱七八糟，跟踪哪个 <code>future</code> 还没 <code>Ready</code> ，以及一旦 <code>Ready</code> 应该做什么，这就破坏了程序的简单性。</p>
<h4 id="Async、Await"><a href="#Async、Await" class="headerlink" title="Async、Await"></a><code>Async</code>、<code>Await</code></h4><p>我们更进一步，将 <code>cheapo_request</code> 写成异步函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> async_std::net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">cheapo_request</span>(host: &amp;<span class="type">str</span>, port: <span class="type">u16</span>, path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">socket</span> = net::TcpStream::<span class="title function_ invoke__">connect</span>((host, port)).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request</span> = <span class="built_in">format!</span>(<span class="string">&quot;GET &#123;&#125; HTTP/1.1\r\nHost: &#123;&#125;\r\n\r\n&quot;</span>, path, host);</span><br><span class="line">    socket.<span class="title function_ invoke__">write_all</span>(request.<span class="title function_ invoke__">as_bytes</span>()).<span class="keyword">await</span>?;</span><br><span class="line">    socket.<span class="title function_ invoke__">shutdown</span>(net::Shutdown::Write)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    socket.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> response).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和我们之前的版本目的相同，除了：</p>
<ul>
<li><p>函数以 <code>async fn</code> 开始，而不是 <code>fn</code>；</p>
</li>
<li><p>使用了 <code>async_std</code> 提供的 <code>TcpStream::connect</code>，<code>write_all</code> 和 <code>read_to_string</code> 异步版本，这些都返回了他们所代表结果的 <code>future</code>；</p>
</li>
<li><p>在每个返回 <code>future</code> 的调用之后，代码都会显示 <code>.await</code>。尽管这看起来像是对名为 <code>await</code> 的结构字段的引用，但它实际上是语言中内置的特殊语法，用于等待<code>future</code>准备好。<code>await</code> 表达式的计算结果是<code>future</code>的最终值。这就是函数从 <code>connect</code>、<code>write_all</code> 和 <code>read_to_string</code> 获取结果的方式；</p>
</li>
</ul>
<p>与普通函数不同，当您调用异步函数时，它会在主体开始执行之前立即返回。显然，调用的最终返回值还没有计算出来；你得到的是其最终值的<code>future</code>。因此，如果您执行此代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">cheapo_request</span>(host, port, path);</span><br></pre></td></tr></table></figure>

<p>那么 <code>response</code> 将是 <code>std::io::Result&lt;String&gt;</code> 的 <code>future</code>，<code>cheapo_request</code> 的主体尚未开始执行。你不需要调整异步函数的返回类型；<code>Rust</code> 自动将 <code>async fn f(...) -&gt; T</code> 视为返回 <code>T</code> 的 <code>future</code> 的函数，而不是直接返回 <code>T</code>。</p>
<p>异步函数返回的 <code>future</code> 包含了函数体运行所需的所有信息：函数的参数、局部变量的空间等等。就好像将调用的堆栈帧捕获为普通的 <code>Rust</code> 值一样。因此 <code>response</code> 必须保存 <code>host</code>、<code>port</code>、<code>path</code> 传递的值，因为 <code>cheapo_request</code> 的主体将需要这些值才能运行。</p>
<p><code>Future</code> 的特定类型由编译器根据函数的主体和参数自动生成。这种类型没有名字；你只知道它实现了 <code>Future&lt;Output=R&gt;</code>，其中 <code>R</code> 是异步函数的返回类型。从这个意义上说，异步函数的 <code>future</code> 就像闭包：闭包也有匿名类型，由编译器生成，实现了 <code>FnOnce</code>、<code>Fn</code> 和 <code>FnMut</code>。</p>
<p>当你第一次轮询 <code>cheapo_request</code> 返回的 <code>future</code> 时，执行从函数体的顶部开始，一直运行到 <code>TcpStream::connect</code> 返回的 <code>future</code> 的第一个 <code>await</code>。<code>await</code> 表达式轮询连接的 <code>future</code>，如果它还没有准备好，那么它返回 <code>Poll::Pending</code> 给它自己的调用者：轮询 <code>cheapo_request</code> 的 <code>future</code> 不能继续超过第一个 <code>await</code>，直到对 <code>TcpStream::connect</code> 的 <code>future</code> 的轮询返回 <code>Poll::Ready</code>。因此，表达式 <code>TcpStream::connect(...).await</code> 的大致等价于：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Note: this is pseudocode, not valid Rust</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">connect_future</span> = TcpStream::<span class="title function_ invoke__">connect</span>(...);</span><br><span class="line">    <span class="symbol">&#x27;retry_point</span>:</span><br><span class="line">        <span class="keyword">match</span> connect_future.<span class="title function_ invoke__">poll</span>(cx) &#123;</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(value) =&gt; value,</span><br><span class="line">            Poll::Pending =&gt; &#123;</span><br><span class="line">                <span class="comment">// Arrange for the next `poll` of `cheapo_request`&#x27;s</span></span><br><span class="line">                <span class="comment">// future to resume execution at &#x27;retry_point.</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> Poll::Pending;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>await</code> 表达式获取 <code>future</code> 的所有权，然后对其进行轮询。如果它准备好了，那么 <code>future</code> 的最终值就是 <code>await</code> 表达式的值，然后继续执行。否则，它将 <code>Poll::Pending</code> 返回给它自己的调用者。</p>
<p>但至关重要的是，<code>cheapo_request</code> 的 <code>future</code>的下一次轮询不会再次从函数顶部开始：相反，它会在即将轮询 <code>connect_future</code> 的点恢复执行中间函数。在 <code>futrue</code> 准备好之前，不会进入异步函数的其余部分。</p>
<p>由于<code>cheapo_request</code> 的 <code>future</code> 继续被轮询，它将通过函数体从一个等待到下一个，只有当它等待的子 <code>future</code> 准备好时才会继续。因此，<code>cheapo_request</code> 的 <code>future</code> 必须轮询多少次取决于子 <code>future</code> 的行为和函数自己的控制流。<code>cheapo_request</code> 的 <code>future</code>跟踪下一次轮询应该恢复的点，以及恢复需要的所有本地状态——变量、参数、临时变量。</p>
<p>暂停执行中间函数然后稍后恢复的能力是异步函数所独有的。当一个普通函数返回时，它的堆栈帧就永远消失了。由于 <code>await</code> 表达式依赖于恢复的能力，只能在异步函数中使用它们。</p>
<h4 id="调用异步函数"><a href="#调用异步函数" class="headerlink" title="调用异步函数"></a>调用异步函数</h4><p>从某种意义上说，异步函数只是推卸责任。确实，在异步函数中很容易获得 <code>future</code> 的值：只需等待它。但是异步函数本身返回一个<code>future</code>，所以现在调用者的工作就是以某种方式进行轮询。最终，有人必须实际等待一个值。</p>
<p>我们可以使用 <code>async_std</code> 的 <a href="https://docs.rs/async-std/1.11.0/async_std/task/fn.block_on.html"><code>task::block_on</code></a> 函数从普通的同步函数（例如 <code>main</code>）调用 <code>cheapo_request</code> ，该函数接受一个 <code>future</code> 并轮询它，直到它产生一个值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> async_std::task;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = task::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">cheapo_request</span>(<span class="string">&quot;example.com&quot;</span>, <span class="number">80</span>, <span class="string">&quot;/&quot;</span>))?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>block_on</code> 是一个同步函数，它产生异步函数的最终值，你可以把它看作是从异步世界到同步世界的适配器。但是它的阻塞特性也意味着你永远不应该在异步函数中使用 <code>block_on</code>：它会阻塞整个线程，直到值准备好。</p>
<p>下图展示了 <code>main</code> 的一种可能执行：</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/block-on-async-func.png" class="">

<p>上面的时间线简化视图显示了程序异步调用的抽象视图：<code>cheapo_request</code> 首先调用 <code>TcpStream::connect</code> 以获取套接字，然后在该套接字上调用 <code>write_all</code> 和 <code>read_to_string</code>，然后它返回，这与本节前面的 <code>cheapo_request</code> 同步版本的时间线非常相似。</p>
<p>但是这些异步调用中的每一个都是一个多步骤的过程：创建一个<code>future</code>，然后轮询它，直到它准备好，也许在这个过程中创建和轮询其他子 <code>future</code>，较低的时间线显示了实现此异步行为的实际同步调用，我们来看看这个异步函数的执行过程：</p>
<ul>
<li><p>首先，<code>main</code> 调用 <code>cheapo_request</code>，它返回其最终结果的 <code>Future A</code>。然后 <code>main</code> 将这个 <code>Future</code> 传递给 <code>async_std::block_on</code>，它会轮询它；</p>
</li>
<li><p>轮询 <code>Future A</code> 允许 <code>cheapo_request</code> 的主体开始执行，它调用 <code>TcpStream::connect</code> 以获取套接字的<code>Future B</code>，然后等待。更准确地说，由于 <code>TcpStream::connect</code> 可能会遇到错误，因此 <code>B</code> 是 <code>Result&lt;TcpStream, std::io::Error&gt;</code> 的 <code>future</code>；</p>
</li>
<li><p><code>Future B</code> 被 <code>await</code> 轮询，由于网络连接尚未建立，<code>B.poll</code> 返回 <code>Poll::Pending</code>，但会在套接字准备好后安排唤醒调用任务；</p>
</li>
<li><p>由于 <code>Future B</code> 尚未准备好，<code>A.poll</code> 将 <code>Poll::Pending</code> 返回给它自己的调用者 <code>block_on</code>；</p>
</li>
<li><p>由于 <code>block_on</code> 无事可做，它进入睡眠状态，现在整个线程都被阻塞了；</p>
</li>
<li><p>当 <code>B</code> 的连接准备好使用时，它会唤醒轮询它的任务，这会激发 <code>block_on</code> 的作用，并尝试再次轮询 <code>Future A</code>；</p>
</li>
<li><p>轮询 <code>A</code> 导致 <code>cheapo_request</code> 在其第一次等待中恢复，并再次轮询 <code>B</code>；</p>
</li>
<li><p>这一次，<code>B</code> 准备就绪：套接字创建完成，所以它返回 <code>Poll::Ready(Ok(socket))</code> 给 <code>A.poll</code>；</p>
</li>
<li><p>对 <code>TcpStream::connect</code> 的异步调用现已完成，<code>TcpStream::connect(...).await</code> 表达式的值因此是 <code>Ok(socket)</code>；</p>
</li>
<li><p><code>cheapo_request</code> 的主体的执行正常进行，使用<code>format!</code>构建请求字符串并将其传递给 <code>socket.write_all</code>；</p>
</li>
<li><p>由于 <code>socket.write_all</code> 是一个异步函数，它返回其结果的 <code>future C</code>，<code>cheapo_request</code> 适当地等待；</p>
</li>
</ul>
<p>代码的其余部分是相似的，如上图所示，<code>socket.read_to_string</code> 的 <code>future</code> 在它准备好之前被轮询了<code>4</code>次；这些唤醒中的每一个都从套接字读取一些数据，但 <code>read_to_string</code> 被指定为一直读取到输入的末尾，这需要几个操作。</p>
<p>编写一个一遍又一遍地调用 <code>poll</code> 的循环听起来并不难，但是 <code>async_std::task::block_on</code> 的好处是它知道如何进入睡眠状态，直到 <code>future</code> 实际上值得再次轮询，而不是浪费处理器时间和电池寿命进行数十亿次毫无结果的轮询调用。由基本 <code>I/O</code> 函数，如 <code>connect</code> 和 <code>read_to_string</code>，返回的 <code>future</code> 保留由传递给 <code>poll</code> 的 <code>Context</code> 所提供的<code>waker</code>，并在 <code>block_on</code> 应该唤醒并再次尝试轮询时调用它。</p>
<p>与我们之前介绍的原始同步版本一样，<code>cheapo_request</code> 的这个异步版本几乎将所有时间都花在等待操作完成上。如果按比例绘制时间轴，则该图将几乎完全是深灰色。</p>
<p>通常可以只考虑简化的上部时间线：一些函数调用是同步的，另一些是异步的并且需要等待，但它们都只是函数调用。<code>Rust</code> 异步支持的成功取决于帮助程序员在实践中使用简化视图，而不会被来回的实现分心。</p>
<h4 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h4><p><code>async_std::task::block_on</code> 函数会阻塞到 <code>future</code> 的值准备好。但是在一个 <code>future</code> 上完全阻塞一个线程并不比同步调用好：本节的目标是让线程在等待时做其他工作。</p>
<p>为此，可以使用 <code>async_std::task::spawn_local</code>，这个函数接受一个 <code>future</code> 并将其添加到一个池中。因此，如果将一堆 <code>future</code> 传递给 <code>spawn_local</code>，然后将 <code>block_on</code> 应用于最终结果的 <code>future</code>，那么 <code>block_on</code> 就会轮询每个生成的 <code>future</code>，同时运行整个池，直到结果准备好。</p>
<p>要启用 <code>spawn_local</code>，必须启用 <code>async-std</code> 中的不稳定功能：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">async-std</span> = &#123; version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;unstable&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.rs/async-std/1.11.0/async_std/task/fn.spawn_local.html"><code>spawn_local</code></a> 函数是标准库用于启动线程的 <code>std::thread::spawn</code> 函数的异步实现：</p>
<ul>
<li><p><code>std::thread::spawn(c)</code> 接受一个闭包 <code>c</code> 并启动一个运行它的线程，返回一个 <code>std::thread::JoinHandle</code>，其 <code>join</code> 方法等待线程完成并返回 <code>c</code> 的返回值；</p>
</li>
<li><p><code>async_std::task::spawn_local(f)</code> 获取 <code>future</code> <code>f</code> 并将其添加到池中，以便在当前线程调用 <code>block_on</code> 时进行轮询。<code>spawn_local</code> 返回它自己的 <code>async_std::task::JoinHandle</code> 类型，它本身就是一个<code>future</code>，你可以等待检索 <code>f</code> 的最终值。</p>
</li>
</ul>
<p>例如，假设我们要同时发出一整套 <code>HTTP</code> 请求。这是第一次尝试：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">many_requests</span>(requests: <span class="type">Vec</span>&lt;(<span class="type">String</span>, <span class="type">u16</span>, <span class="type">String</span>)&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;std::io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> async_std::task;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="title function_ invoke__">for</span> (host, port, path) <span class="keyword">in</span> requests &#123;</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(task::<span class="title function_ invoke__">spawn_local</span>(<span class="title function_ invoke__">cheapo_request</span>(&amp;host, port, &amp;path)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        results.<span class="title function_ invoke__">push</span>(handle.<span class="keyword">await</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数对请求的每个元素调用 <code>cheapo_request</code>，将每个调用的 <code>future</code> 传递给 <code>spawn_local</code>，它将生成的 <code>JoinHandles</code> 收集到一个 <code>vector</code> 中，然后等待它们中的每一个完成。可以按任何顺序等待连接句柄：由于请求已经产生，因此只要该线程调用 <code>block_on</code> 并且没有其他的事情可做，就会对所有 <code>handles</code> 进行轮询，所有请求将同时运行。一旦完成，<code>many_requests</code> 会将结果返回给它的调用者。</p>
<p>前面的代码几乎是正确的，但是 <code>Rust</code> 认为 <code>cheapo_request</code> 的参数 <code>host</code> 不太对：</p>
<pre><code>    error: `host` does not live long enough
    handles.push(task::spawn_local(cheapo_request(&amp;host, port, &amp;path)));
    ---------------^^^^^--------------
    | |
    | borrowed value does not
    | live long enough
    argument requires that `host` is borrowed for `&#39;static`
    &#125;
    - `host` dropped here while still borrowed
</code></pre>
<p><code>path</code> 也有类似的错误。自然，如果我们将引用传递给异步函数，它返回的<code>future</code>必须持有这些引用，因此 <code>future</code> 不能安全地比它们借用的值更长寿，这与适用于任何包含引用的值的限制相同。</p>
<p>问题是 <code>spawn_local</code> 不能确定你会在 <code>host</code> 和 <code>path</code> 被删除之前等待任务完成。<strong>事实上，<code>spawn_local</code> 只接受生命周期为<code>&#39;static</code> 的 <code>future</code>，因为可以简单地忽略它返回的 <code>JoinHandle</code>，让任务在程序执行的其余部分继续运行。这并不是异步任务所独有的：如果你尝试使用 <code>std::thread::spawn</code> 来启动一个线程，该线程的闭包捕获了对局部变量的引用，你会得到类似的错误。</strong></p>
<p>解决这个问题的一种方法是创建另一个异步函数，它接受所有权版本的参数：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">cheapo_owning_request</span>(host: <span class="type">String</span>, port: <span class="type">u16</span>, path: <span class="type">String</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">cheapo_request</span>(&amp;host, port, &amp;path).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数接受字符串而不是 <code>&amp;str</code> 引用，所以它的 <code>future</code> 拥有 <code>host</code> 和 <code>path</code> 字符串本身，它的生命周期是 <code>&#39;static</code> 的。借用检查器可以看到它立即等待 <code>cheapo_request</code> 的 <code>future</code>，因此，如果这个 <code>future</code> 正在被轮询，它借用的 <code>host</code> 和 <code>path</code> 变量肯定仍然存在。</p>
<p>使用 <code>cheapo_owning_request</code>，可以像这样生成所有请求：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (host, port, path) <span class="keyword">in</span> requests &#123;</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(task::<span class="title function_ invoke__">spawn_local</span>(<span class="title function_ invoke__">cheapo_owning_request</span>(host, port, path)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以从 <code>main</code> 函数通过 <code>block_on</code> 调用 <code>many_requests</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">requests</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    (<span class="string">&quot;example.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">80</span>, <span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    (<span class="string">&quot;www.red-bean.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">80</span>, <span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    (<span class="string">&quot;en.wikipedia.org&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">80</span>, <span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">results</span> = async_std::task::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">many_requests</span>(requests));</span><br><span class="line"><span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(response) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; eprintln!(<span class="string">&quot;error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码在对 <code>block_on</code> 的调用中同时运行所有 <code>3</code> 个请求，每个都有机会被运行，而且它们都在相同的调用线程上，下图显示了对 <code>cheapo_request</code> 的 <code>3</code> 个调用的一种可能执行：</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/async-task-in-single-thread.png" class="">

<p>对 <code>many_requests</code> 的调用（为简单起见，未显示）产生了 <code>3</code> 个异步任务，我们将它们标记为 <code>A</code>、<code>B</code> 和 <code>C</code>。<code>block_on</code> 从轮询 <code>A</code> 开始，它开始连接到 <code>example.com</code>，一旦返回 <code>Poll::Pending</code>，<code>block_on</code> 就会将注意力转移到下一个任务上，轮询 <code>B</code>，最终轮询 <code>C</code>，每个都开始连接到各自的服务器。当所有可轮询的 <code>future</code> 都返回 <code>Poll::Pending</code> 时，<code>block_on</code> 进入睡眠状态，直到 <code>3</code> 个 <code>TcpStream::connect</code> 的 <code>future</code> 之一反馈连接已经准备好，可以再次轮询。</p>
<p>在本次执行中，服务器 <code>en.wikipedia.org</code> 的响应速度比其他服务器更快，因此该任务首先完成。当一个任务完成时，它会将其值保存在其 <code>JoinHandle</code> 中并将其标记为 <code>Ready</code>，以便 <code>many_requests</code> 在等待它时可以继续。最终，对 <code>cheapo_request</code> 的其他调用要么成功，要么返回错误，并且 <code>many_requests</code> 本身可以返回。最后，<code>main</code> 从 <code>block_on</code> 接收结果<code>vector</code>。</p>
<p>所有这些执行都发生在一个线程上，对 <code>cheapo_request</code> 的 <code>3</code> 个调用通过对它们的 <code>future</code> 的连续轮询相互交错。异步调用看起来像要等到函数运行完成，但这种异步调用是通过对 <code>future</code> 的 <code>poll</code> 方法一系列同步调用来实现的。每个单独的轮询调用快速返回，让出线程，以便另一个异步调用可以轮流。</p>
<p>我们终于实现了我们在本节开头设定的目标：让线程在等待 <code>I/O</code> 完成的同时承担其他工作，这样线程的资源就不会白白浪费。更好的是，这个目标是用看起来很像普通 <code>Rust</code> 代码的代码实现的：一些函数被标记为 <code>async</code>，一些函数调用后跟 <code>.await</code>，我们使用来自 <code>async_std</code> 的函数而不是 <code>std</code>，但除此之外，都是些普通的 <code>Rust</code> 代码。</p>
<p>异步任务和线程之间要记住的一个重要区别是，从一个异步任务切换到另一个异步任务只发生在 <code>await</code> 表达式中，此时正在等待的 <code>future</code> 返回 <code>Poll::Pending</code>。这意味着如果你在 <code>cheapo_request</code> 中放置一个长时间运行的计算，你传递给 <code>spawn_local</code> 的其他任务在它完成之前都没有机会运行。有了线程，这个问题就不会出现：操作系统可以在任何时候挂起任何线程并设置计时器以确保没有线程独占处理器，异步代码取决于共享线程的 <code>future</code> 的自愿合作。</p>
<h4 id="异步代码块"><a href="#异步代码块" class="headerlink" title="异步代码块"></a>异步代码块</h4><p>除了异步函数，<code>Rust</code> 还支持异步代码块。普通块语句返回其最后一个表达式的值，而异步代码块返回其最后一个表达式的值的 <code>future</code> ，你可以在异步代码块中使用 <code>await</code> 表达式。</p>
<p><code>async</code> 块看起来像一个普通的块语句，前面有 <code>async</code> 关键字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">serve_one</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">use</span> async_std::net;</span><br><span class="line">    <span class="comment">// Listen for connections, and accept one.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = net::TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;localhost:8087&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> socket, _addr) = listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="comment">// Talk to client on `socket`.</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这将使用<code>future</code>初始化 <code>serve_one</code>，当被轮询时，它会侦听并处理单个 <code>TCP</code> 连接。在轮询 <code>serve_one</code> 之前，代码块的主体不会开始执行，就像异步函数调用在轮询其<code>future</code>之前不会开始执行一样。</p>
<p>如果将 <code>?</code> 操作符应用到异步代码块中的错误，它只是从块中返回，而不是从周围的函数中返回。例如，如果前面的绑定调用返回错误，则 <code>?</code> 运算符将其作为 <code>serve_one</code> 的最终值返回。同样，<code>return</code> 表达式从 <code>async</code> 块返回，而不是包裹它的函数。</p>
<p>如果一个异步代码块引用了在周围代码中定义的变量，它的 <code>future</code> 会捕获它们的值，就像 <code>move</code> 闭包一样，可以使用 <code>async move</code> 启动块以获取捕获值的所有权，而不仅仅是持有对它们的引用。</p>
<p>异步代码块提供了一种简洁的方法来分离出希望异步运行的一段代码。例如，在上一节中，<code>spawn_local</code> 需要一个 <code>静态 future</code>，因此我们定义了 <code>cheapo_owning_request</code> 包装函数来为我们提供一个拥有其参数所有权的 <code>future</code>，然而只需从异步代码块中调用 <code>cheapo_request</code>，就可以获得相同的效果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">many_requests</span>(requests: <span class="type">Vec</span>&lt;(<span class="type">String</span>, <span class="type">u16</span>, <span class="type">String</span>)&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;std::io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> async_std::task;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="title function_ invoke__">for</span> (host, port, path) <span class="keyword">in</span> requests &#123;</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(task::<span class="title function_ invoke__">spawn_local</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">cheapo_request</span>(&amp;host, port, &amp;path).<span class="keyword">await</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这是一个 <code>async move</code> 代码块，它的 <code>future</code> 将拥有字符串值 <code>host</code> 和 <code>path</code> 的所有权，就像移动闭包一样。然后它传递对<code>cheapo_request</code> 的引用。借用检查器可以看到块的 <code>await</code> 表达式拥有 <code>cheapo_request</code> 的 <code>future</code> 所有权，因此对 <code>host</code> 和 <code>path</code> 的引用不能超过它们借用的捕获变量。<code>async</code> 代码块完成与 <code>cheapo_owning_request</code> 相同的事情，但代码更少。</p>
<p>如何指定异步代码块的返回值吗？初次使用我们可能会写出如下的代码：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">input</span> = async_std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">future</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">line</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// This returns `std::io::Result&lt;usize&gt;`.</span></span><br><span class="line">    input.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> line).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Read line: &#123;&#125;&quot;</span>, line);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译这段代码会遇到下面的错误：</p>
<pre><code>    error: type annotations needed
    |
    | let future = async {
    | ------ consider giving `future` a type
    ...
    | input.read_line(&amp;mut line).await?;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type
</code></pre>
<p><code>Rust</code> 无法判断异步代码块的返回类型应该是什么。<code>read_line</code> 方法返回 <code>Result&lt;(), std::io:Error&gt;</code>，但是因为 <code>?</code> 运算符使用 <code>From</code> 将手头的错误类型转换为任何情况需要的类型，对于实现 <code>From&lt;std::io::Error&gt;</code> 的任何类型 <code>E</code>，异步代码块的返回类型可以是 <code>Result&lt;(), E&gt;</code>。</p>
</div>

<p><code>Future</code> 版本的 <code>Rust</code> 可以添加用于指示异步代码块的返回类型的语法，例如，确定返回类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">future</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Ok::&lt;(), std::io::Error&gt;(())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Result</code> 是一个泛型类型，它期望成功和错误类型作为其参数，因此我们可以在使用 <code>Ok</code> 或 <code>Err</code> 时指定这些类型参数，如上所示。</p>
<h5 id="构造异步函数"><a href="#构造异步函数" class="headerlink" title="构造异步函数"></a>构造异步函数</h5><p>异步代码块为我们提供了另一种方法来获得与异步函数相同的效果，并且具有更多的灵活性。例如，我们可以将我们的 <code>cheapo_request</code> 示例编写为一个普通的同步函数，它返回一个异步代码块的<code>future</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cheapo_request</span>&lt;<span class="symbol">&#x27;a</span>&gt;(host: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, port: <span class="type">u16</span>, path: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt;&gt; + <span class="symbol">&#x27;a</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        ... function body ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您调用此版本的函数时，它会立即返回异步代码块值的 <code>future</code>，这捕获了函数的参数，并且表现得就像异步函数返回的 <code>future</code>一样。由于我们没有使用 <code>async fn</code> 语法，我们需要在返回类型中写出 <code>impl Future</code>，但就调用者而言，这两个定义是相同函数签名的可互换实现。</p>
<p>当想在调用函数时立即进行一些计算，然后再创建其结果的 <code>future</code> 时，第二种方法可能很有用。例如，协调 <code>cheapo_request</code> 和<code>spawn_local</code> 的另一种方法是将它变成一个同步函数，返回一个<code>&#39;static future</code>，捕获其参数的完全拥有的副本：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">cheapo_request</span>(host: &amp;<span class="type">str</span>, port: <span class="type">u16</span>, path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt;&gt; + <span class="symbol">&#x27;static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">host</span> = host.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = path.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        ... <span class="keyword">use</span> &amp;*host, port, and path ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此版本允许异步代码块将 <code>host</code> 和 <code>path</code> 捕获为拥有的字符串值，而不是 <code>&amp;str</code> 引用。由于 <code>future</code> 拥有它运行所需的所有数据，因此它在 <code>&#39;static</code> 生命周期内有效。（我们在前面显示的签名中拼出了 <code>+ &#39;static</code>，但 <code>&#39;static</code> 是 <code>-&gt; impl</code> 返回类型的默认值，因此省略它不会有任何效果。）</p>
<p>由于这个版本的 <code>cheapo_request</code> 返回的是<code>&#39;static future</code>，我们可以将它们直接传递给 <code>spawn_local</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">join_handle</span> = async_std::task::<span class="title function_ invoke__">spawn_local</span>(</span><br><span class="line"> <span class="title function_ invoke__">cheapo_request</span>(<span class="string">&quot;areweasyncyet.rs&quot;</span>, <span class="number">80</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">... other work ...</span><br><span class="line"><span class="keyword">let</span> <span class="variable">response</span> = join_handle.<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure>

<h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><p>当单个线程无法完成较大的计算量时，可以使用 <code>async_std::task::spawn</code> 将 <code>future</code> 分派到一个工作线程池上，该线程池专用于轮询 <code>future</code>。</p>
<p><a href="https://docs.rs/async-std/1.11.0/async_std/task/fn.spawn.html"><code>async_std::task::spawn</code></a> 像 <code>async_std::task::spawn_local</code> 一样使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">for</span> (host, port, path) <span class="keyword">in</span> requests &#123;</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(task::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">cheapo_request</span>(&amp;host, port, &amp;path).<span class="keyword">await</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>与 <code>spawn_local</code> 一样，<code>spawn</code> 返回一个 <code>JoinHandle</code> 值，可以等待以获取 <code>future</code> 的最终值。但与 <code>spawn_local</code> 不同的是，<code>future</code> 不必等到你调用 <code>block_on</code> 才能被轮询，一旦线程池中的一个线程空闲，它将尝试轮询它。</p>
<p>在实践中，<code>spawn</code> 比 <code>spawn_local</code> 使用更广泛，它能够将工作负载分摊到不同的线程之上。</p>
<p>使用 <code>spawn</code> 时要记住的一件事是线程池试图保持忙碌，因此 <code>future</code> 会被首先访问它的线程轮询。异步调用可能在一个线程上开始执行，在<code>await</code> 表达式上阻塞，然后在另一个线程中恢复。因此，虽然将异步函数调用视为单个、连续的代码执行是一种合理的简化（实际上，异步函数和<code>await</code> 表达式的目的是鼓励你这样想），但调用可能实际上是由许多不同的线程来执行的。</p>
<p>如果使用的是线程本地存储，那么在 <code>await</code> 表达式之前放置的数据可能会被完全不同的东西替换，因为任务现在正在由池中的不同线程轮询，但也可以改用 <a href="https://docs.rs/async-std/1.11.0/async_std/macro.task_local.html"><code>async_std::task_local</code></a> 来实现。</p>
<h4 id="Future-实现-Send"><a href="#Future-实现-Send" class="headerlink" title="Future 实现 Send"></a><code>Future</code> 实现 <code>Send</code></h4><p><code>spawn</code> 有一个限制 <code>spawn_local</code> 没有。由于 <code>future</code> 被发送到另一个线程运行，<code>future</code> 必须实现 <code>Send</code>。只有当它包含的所有值都是 <code>Send</code> 时，<code>Future</code> 才是 <code>Send</code>：所有函数参数、局部变量，甚至匿名临时值都必须可以安全移动到另一个线程。</p>
<p>和以前一样，这个要求并不是异步任务所独有的：如果你尝试使用 <code>std::thread::spawn</code> 来启动一个其闭包捕获 <code>non-Send</code> 值的线程，你会得到一个类似的错误。不同之处在于，虽然传递给 <code>std::thread::spawn</code> 的闭包保留在为运行它而创建的线程上，但在线程池上生成的 <code>future</code> 可以在它等待的任何时候从一个线程移动到另一个线程。</p>
<p>这个限制很容易被意外遇到，例如，下面的代码看起来很无辜：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">reluctant</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;ref-counted string&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="title function_ invoke__">some_asynchronous_thing</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Your splendid string: &#123;&#125;&quot;</span>, string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task::<span class="title function_ invoke__">spawn</span>(<span class="title function_ invoke__">reluctant</span>());</span><br></pre></td></tr></table></figure>

<p>异步函数的 <code>future</code> 需要保存足够的信息，以便函数从 <code>await</code> 表达式继续。在这种情况下，<code>reluctant</code> 函数的 <code>future</code> 必须在等待之后使用字符串，所以 <code>future</code> 至少有时会包含一个 <code>Rc&lt;String&gt;</code> 值。由于 <code>Rc</code> 指针不能在线程之间安全地共享，<code>future</code> 本身不能被<code>Send</code>。由于 <code>spawn</code> 只接受 <code>Send</code> 的<code>future</code>，<code>Rust</code> 报错了：</p>
<pre><code>    error: future cannot be sent between threads safely
    |
    | task::spawn(reluctant());
    | ^^^^^^^^^^^ future returned by `reluctant` is not `Send`
    |
    |
    | T: Future + Send + &#39;static,
    | ---- required by this bound in `async_std::task::spawn`
    |
    = help: within `impl Future`, the trait `Send` is not implemented
    for `Rc&lt;String&gt;`
    note: future is not `Send` as this value is used across an await
    |
    | let string = Rc::new(&quot;ref-counted string&quot;.to_string());
    | ------ has type `Rc&lt;String&gt;` which is not `Send`
    |
    | some_asynchronous_thing().await;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    await occurs here, with `string` maybe used later
    ...
    | }
    | - `string` is later dropped here
</code></pre>
<p>错误信息很长，但它有很多帮助信息：</p>
<ul>
<li><p>它解释了为什么需要 <code>future</code> 实现 <code>Send</code>：<code>task::spawn</code> 需要它；</p>
</li>
<li><p>它解释了哪个值不是 <code>Send</code>：局部变量字符串，其类型为<code>Rc&lt;String&gt;</code>；</p>
</li>
<li><p>它解释了为什么字符串会影响 <code>future</code>：它在指定的等待范围内；</p>
</li>
</ul>
</div>

<p>有两种方法可以解决此问题，一种是限制 <code>non-Sennd</code> 的范围，使其不覆盖任何 <code>await</code> 表达式，因此不需要保存在函数的 <code>future</code> ：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">reluctant</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">return_value</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;ref-counted string&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Your splendid string: &#123;&#125;&quot;</span>, string)</span><br><span class="line">        <span class="comment">// The `Rc&lt;String&gt;` goes out of scope here...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ... and thus is not around when we suspend here.</span></span><br><span class="line">    <span class="title function_ invoke__">some_asynchronous_thing</span>().<span class="keyword">await</span>;</span><br><span class="line">    return_value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另一种解决方案是简单地使用 <code>std::sync::Arc</code> 而不是 <code>Rc</code>。<code>Arc</code> 使用原子更新来管理它的引用计数，这使得它有点慢，但 <code>Arc</code> 指针是 <code>Send</code>。尽管最终将学会识别和避免 <code>non-Send</code> 类型，但起初它们可能会有点令人惊讶。例如，旧的 <code>Rust</code> 代码有时会使用这样的通用<code>Result</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GenericError</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GenericResult</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, GenericError&gt;;</span><br></pre></td></tr></table></figure>

<p>此 <code>GenericError</code> 类型使用 <code>Box</code> 对象来保存实现 <code>std::error::Error</code> 的任何类型的值。但它并没有对其施加任何进一步的限制：如果有人有一个实现 <code>Error</code> 的 <code>non-Send</code> 类型，他们可以将该类型的装箱值转换为 <code>GenericError</code>。由于这种可能性，<code>GenericError</code> 不是 <code>Send</code>，以下代码将不起作用：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_fallible_thing</span>() <span class="punctuation">-&gt;</span> GenericResult&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的 future 没有实现 Send</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">unfortunate</span>() &#123;</span><br><span class="line">    <span class="comment">// ... because this call&#x27;s value ...</span></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">some_fallible_thing</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">report_error</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(output) =&gt; &#123;</span><br><span class="line">            <span class="comment">// ... is alive across this await ...</span></span><br><span class="line">            <span class="title function_ invoke__">use_output</span>(output).<span class="keyword">await</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and thus this `spawn` is an error.</span></span><br><span class="line">async_std::task::<span class="title function_ invoke__">spawn</span>(<span class="title function_ invoke__">unfortunate</span>());</span><br></pre></td></tr></table></figure>

<p>与前面的示例一样，来自编译器的错误消息将解释了发生了什么，并指出 <code>Result</code> 类型是罪魁祸首。由于 <code>Rust</code> 认为 <code>some_fallible_thing</code> 的结果存在于整个 <code>match</code> 语句中，包括 <code>await</code> 表达式，它确定 <code>unfortunate</code> 的<code>future</code>不是 <code>Send</code>。这个错误对 <code>Rust</code> 来说是过于谨慎了：虽然 <code>GenericError</code> 确实不能安全地发送到另一个线程，但 <code>await</code> 仅在结果为 <code>Ok</code> 时发生，因此当我们 <code>await use_output</code> 的 <code>future</code> 时，错误值实际上并不存在。</p>
</div>

<p>理想的解决方案是使用更严格的通用错误类型：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GenericError</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GenericResult</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, GenericError&gt;;</span><br></pre></td></tr></table></figure></div>

<p>这个 <code>trait</code> 对象明确需要底层错误类型来实现 <code>Send</code>，如果你的 <code>future</code> 不是 <code>Send</code> 并且不能方便地做到这一点，那么仍然可以使用 <code>spawn_local</code> 在当前线程上运行它。当然，需要确保线程在某个时候调用了 <code>block_on</code>，让它有机会运行，但是这样的话，就不能负载分担了。</p>
<h4 id="yield-now、spawn-blocking"><a href="#yield-now、spawn-blocking" class="headerlink" title="yield_now、spawn_blocking"></a><code>yield_now</code>、<code>spawn_blocking</code></h4><p>为了让 <code>future</code> 能够与其他任务很好地共享它的线程，它的 <code>poll</code> 方法应该总是尽可能快地返回。但是如果正在执行一个长时间的计算，可能需要很长时间才能到达下一个等待，这使得其他异步任务等待的时间比想要的要长。</p>
<p>避免这种情况的一种方法是偶尔等待某些东西。<a href="https://docs.rs/async-std/1.11.0/async_std/task/fn.yield_now.html"><code>async_std::task::yield_now</code></a> 函数返回一个为此设计的简单 <code>future</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="title function_ invoke__">computation_not_done</span>() &#123;</span><br><span class="line">    ... <span class="keyword">do</span> one medium-sized step of computation ...</span><br><span class="line">    async_std::task::<span class="title function_ invoke__">yield_now</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次轮询 <code>yield_now</code> 时，它返回 <code>Poll::Pending</code>，但表示值得很快再次轮询。效果是异步​​调用让出了线程并让其他任务有机会运行，但调用将很快获得另一轮。<code>yield_now</code> 的 <code>future</code> 第二次被轮询，它返回 <code>Poll::Ready(())</code>，<code>async</code> 函数可以恢复执行。</p>
<p>然而，这种方法并不总是可行的。如果使用外部 <code>crate</code> 进行长时间运行的计算或调用 <code>C</code> 或 <code>C++</code>，则将代码更改为更加异步友好可能并不方便，或者可能很难确保通过计算的每条路径都一定会时不时地等待。</p>
<p>对于这种情况，您可以使用 <code>async_std::task::spawn_blocking</code>。这个函数接受一个闭包，启动它在自己的线程上运行，并返回代表其返回值的 <code>future</code>。异步代码可以等待那个 <code>future</code>，将其线程让给其他任务，直到计算准备好。通过将繁重的工作放在单独的线程上，可以让操作系统负责让它很好地共享处理器。</p>
<p>例如，假设我们需要根据我们存储在身份验证数据库中的散列版本检查用户提供的密码。为了安全起见，验证密码需要进行大量计算，这样即使攻击者获得了我们数据库的副本，他们也不能简单地尝试数万亿个可能的密码来查看是否匹配。<a href="https://crates.io/crates/argonautica"><code>argonautica</code></a> 提供了一个专门为存储密码而设计的散列函数：一个正确生成的 <code>argonautica</code> 散列需要很长时间来验证。我们可以在异步应用程序中使用 <code>argonautica</code>，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">verify_password</span>(</span><br><span class="line">    password: &amp;<span class="type">str</span>,</span><br><span class="line">    hash: &amp;<span class="type">str</span>,</span><br><span class="line">    key: &amp;<span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, argonautica::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// Make copies of the arguments, so the closure can be &#x27;static.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">password</span> = password.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = hash.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key</span> = key.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    async_std::task::<span class="title function_ invoke__">spawn_blocking</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        argonautica::Verifier::<span class="title function_ invoke__">default</span>()</span><br><span class="line">            .<span class="title function_ invoke__">with_hash</span>(hash)</span><br><span class="line">            .<span class="title function_ invoke__">with_password</span>(password)</span><br><span class="line">            .<span class="title function_ invoke__">with_secret_key</span>(key)</span><br><span class="line">            .<span class="title function_ invoke__">verify</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果密码与哈希、给定密钥、整个数据库的密钥匹配，则返回 <code>Ok(true)</code>。通过在传递给 <code>spawn_blocking</code> 的闭包中进行验证，我们将昂贵的计算推送到它自己的线程上，确保它不会影响我们对其他用户请求的响应。</p>
<h4 id="异步设计"><a href="#异步设计" class="headerlink" title="异步设计"></a>异步设计</h4><p>在许多方面，<code>Rust</code> 的异步编程方法类似于其他语言所采用的方法。例如，<code>JavaScript</code>、<code>C#</code> 和 <code>Rust</code> 都具有带有 <code>await</code> 表达式的异步函数。所有这些语言都有代表不完整计算的值：<code>Rust</code> 称它们为 <code>futures</code>，<code>JavaScript</code> 称它们为 <code>promises</code>，<code>C#</code> 称它们为<code>tasks</code>，但它们都代表一个可能需要等待的值。</p>
<p>然而，<code>Rust</code> 对轮询的使用是不寻常的，在 <code>JavaScript</code> 和 <code>C#</code> 中，异步函数一被调用就开始运行，并且系统库中内置了一个全局事件循环，当它们等待的值可用时恢复暂停的异步函数调用。然而，在 <code>Rust</code> 中，异步调用什么都不做，除非你将它传递给像 <code>block_on</code>、<code>spawn</code> 或 <code>spawn_local</code> 这样的函数，该函数将轮询它并推动工作完成。这些称为<mark class="label ">`executor`</mark>的函数扮演着其他语言中全局事件循环的角色。</p>
<p>因为 <code>Rust</code> 让开发者选择一个 <code>executor</code> 来轮询 <code>future</code>，<code>Rust</code> 不需要系统中内置的全局事件循环。<code>async-std</code> 提供了到目前为止我们使用的 <code>executor</code> 函数，<a href="https://crates.io/crates/tokio"><code>tokio</code></a> 定义了自己的一组类似的 <code>executor</code> 函数，可以在同一个程序中使用多个 <code>executor</code>。</p>
<h4 id="异步-HTTP-客户端"><a href="#异步-HTTP-客户端" class="headerlink" title="异步 HTTP 客户端"></a>异步 <code>HTTP</code> 客户端</h4><p>下面是使用 <a href="https://crates.io/crates/surf"><code>surf</code></a> 实现一个异步客户端，也可以选择 <a href="https://crates.io/crates/reqwest"><code>reqwest</code></a> 这是对之前的 <code>many_requests</code> 的重写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code, unused_imports)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> async_std::net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">many_requests</span>(urls: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">Result</span>&lt;<span class="type">String</span>, surf::Exception&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = surf::Client::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">url</span> <span class="keyword">in</span> urls &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">request</span> = client.<span class="title function_ invoke__">get</span>(&amp;url).<span class="title function_ invoke__">recv_string</span>();</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(async_std::task::<span class="title function_ invoke__">spawn</span>(request));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        results.<span class="title function_ invoke__">push</span>(handle.<span class="keyword">await</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">requests</span> = &amp;[</span><br><span class="line">        <span class="string">&quot;https://www.baidu.com&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;https://crates.io/&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;https://github.com/gamelife1314&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = async_std::task::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">many_requests</span>(requests));</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(response) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;*** &#123;&#125;\n&quot;</span>, response),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(err) =&gt; eprintln!(<span class="string">&quot;error: &#123;&#125;\n&quot;</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用单个 <code>surf::Client</code> 发出我们的所有请求，如果其中几个请求指向同一服务器，我们可以重用 HTTP 连接。并且不需要异步代码块：因为 <code>recv_string</code> 是一个异步方法，它返回一个实现了 <code>Send + &#39;static</code> 的 <code>future</code>，我们可以将它直接传递给 <code>spawn</code>。</p>
<h3 id="异步示例"><a href="#异步示例" class="headerlink" title="异步示例"></a>异步示例</h3><p>本节实现一个简单的异步聊天服务器和客户端，能避免因单个客户端的网络连接速度很慢而影响其他客户端的场景，使用下面的命令创建我们的工程：</p>
<blockquote>
<p>cargo new –lib –vcs none  async-chat</p>
</blockquote>
<p>并且添加以下依赖：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line"><span class="keyword">async</span>-std = &#123; version = <span class="string">&quot;1.7&quot;</span>, features = [<span class="string">&quot;unstable&quot;</span>] &#125;</span><br><span class="line">tokio = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;sync&quot;</span>] &#125;</span><br><span class="line">serde = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>, <span class="string">&quot;rc&quot;</span>] &#125;</span><br><span class="line">serde_json = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个时候我们的目录看起来如下所示：</p>
<pre><code>/Users/fudenglong/WORKDIR/rust/async-chat
├── Cargo.lock
├── Cargo.toml
└── src
|  └── lib.rs
</code></pre>
<p>完整的代码请看 <a href="https://github.com/ProgrammingRust/async-chat">https://github.com/ProgrammingRust/async-chat</a>。</p>
<h4 id="定义-Error-和-Result"><a href="#定义-Error-和-Result" class="headerlink" title="定义 Error 和 Result"></a>定义 <code>Error</code> 和 <code>Result</code></h4><p>我们增加一个新文件，<code>src/utils.rs</code> 包含我们的 <code>Error</code> 和 <code>Result</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">ChatError</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">ChatResult</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, ChatError&gt;;</span><br></pre></td></tr></table></figure>

<p>这些是通用错误类型。<code>async_std</code>、<code>serde_json</code> 和 <code>tokio</code> 都定义了自己的错误类型，但是它们都实现了标准库的 <code>From</code>，<code>?</code> 运算符可以自动将它们全部转换为 <code>ChatError</code>，可以将任何合适的错误类型转换为 <code>Box&lt;dyn Error + Send + Sync + &#39;static&gt;</code>。<code>Send</code> 和 <code>Sync</code> 边界确保如果分发到另一个线程的任务失败，它可以安全地将错误报告给主线程。</p>
<p>在实际应用中，考虑使用 <a href="https://crates.io/crates/anyhow"><code>anyhow</code></a>，它提供了与这些类似的 <code>Error</code> 和 <code>Result</code> 类型。 <code>anyhow</code> 易于使用，并提供了一些不错的功能，超出了我们的 <code>ChatError</code> 和 <code>ChatResult</code> 可以提供的功能。</p>
<h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a><code>Protocol</code></h4><p><code>library</code> <code>crate</code> 以这两种类型捕获了我们的整个聊天协议，在 <code>src/lib.rs</code> 中定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize, Serialize, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">FromClient</span> &#123;</span><br><span class="line">    Join &#123;</span><br><span class="line">        group_name: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Post &#123;</span><br><span class="line">        group_name: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">        message: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize, Serialize, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">FromServer</span> &#123;</span><br><span class="line">    Message &#123;</span><br><span class="line">        group_name: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">        message: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Error</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_fromclient_json</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::sync::Arc;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">from_client</span> = FromClient::Post &#123;</span><br><span class="line">        group_name: Arc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Dogs&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        message: Arc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Samoyeds rock!&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">json</span> = serde_json::<span class="title function_ invoke__">to_string</span>(&amp;from_client).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        json,</span><br><span class="line">        <span class="string">r#&quot;&#123;&quot;Post&quot;:&#123;&quot;group_name&quot;:&quot;Dogs&quot;,&quot;message&quot;:&quot;Samoyeds rock!&quot;&#125;&#125;&quot;#</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        serde_json::from_str::&lt;FromClient&gt;(&amp;json).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        from_client</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FromClient</code> 代表客户端可以发送到服务器的数据包：它可以请求加入一个房间并将消息发布到它已加入的任何房间。<code>FromServer</code> 表示服务器可以发回的内容：发布到某个组的消息和错误消息。使用引用计数的 <code>Arc&lt;String&gt;</code> 而不是普通的 <code>String</code> 有助于服务器在管理组和分发消息时避免复制字符串。</p>
<p><code>#[derive]</code> 属性告诉 <code>serde</code> 为 <code>FromClient</code> 和 <code>FromServer</code> 生成其 <code>Serialize</code> 和 <code>Deserialize</code> 的实现。 这让我们可以调用 <code>serde_json::to_string</code> 将它们转换为 <code>JSON</code> 值，通过网络发送它们，最后调用 <code>serde_json::from_str</code> 将它们转换回 <code>Rust</code> 形式。</p>
<p><code>test_fromclient_json</code> 单元测试说明了它是如何使用的。给定由 <code>serde</code> 派生的 <code>Serialize</code> 实现，我们可以调用 <code>serde_json::to_string</code> 将给定的 <code>FromClient</code> 值转换为这个 <code>JSON</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Post&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;group_name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Dogs&quot;</span><span class="punctuation">,</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;Samoyeds rock!&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后派生的 <code>Deserialize</code> 实现将其解析回等效的 <code>FromClient</code> 值。请注意，<code>FromClient</code> 中的 <code>Arc</code> 指针对序列化形式没有影响：引用计数的字符串直接显示为 <code>JSON</code> 对象成员值。</p>
<h4 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h4><p>我们聊天客户端的首要职责是读取用户的命令，并将相应的数据包发送到服务器。我们将做最简单可行的事情：直接从标准输入读取行。我们新建一个可执行文件：<code>src/bin/client.rs</code>，包含我们的客户端代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_chat::utils::&#123;<span class="keyword">self</span>, ChatResult&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_std::io;</span><br><span class="line"><span class="keyword">use</span> async_std::net;</span><br><span class="line"><span class="keyword">use</span> async_std::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">send_commands</span>(<span class="keyword">mut</span> to_server: net::TcpStream) <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Commands:\n\</span></span><br><span class="line"><span class="string"> join GROUP\n\</span></span><br><span class="line"><span class="string"> post GROUP MESSAGE...\n\</span></span><br><span class="line"><span class="string"> Type Control-D (on Unix) or Control-Z (on Windows) \</span></span><br><span class="line"><span class="string"> to close the connection.&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">command_lines</span> = io::BufReader::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>()).<span class="title function_ invoke__">lines</span>();</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(command_result) = command_lines.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">command</span> = command_result?;</span><br><span class="line">        <span class="comment">// See the GitHub repo for the definition of `parse_command`.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">request</span> = <span class="keyword">match</span> <span class="title function_ invoke__">parse_command</span>(&amp;command) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(request) =&gt; request,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        utils::<span class="title function_ invoke__">send_as_json</span>(&amp;<span class="keyword">mut</span> to_server, &amp;request).<span class="keyword">await</span>?;</span><br><span class="line">        to_server.<span class="title function_ invoke__">flush</span>().<span class="keyword">await</span>?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会调用 <code>async_std::io::stdin</code> 来获取客户端标准输入的异步句柄，将其包装在 <code>async_std::io::BufReader</code> 中，然后调用 <code>lines</code> 逐行处理用户的输入。它尝试将每一行解析为对应于某个 <code>FromClient</code> 值的命令，如果成功，则将该值发送到服务器。如果用户输入了无法识别的命令，则 <code>parse_command</code> 会打印错误消息并返回 <code>None</code>，因此 <code>send_commands</code> 可以再次绕过循环。如果用户键入文件结束指示，则返回 <code>None</code>，并且 <code>send_commands</code> 返回。这与在普通同步程序中编写的代码非常相似，只是它使用了 <code>async_std</code> 版本的库功能。</p>
<p>异步 <code>BufReader</code> 的 <code>lines</code> 方法很有趣，它不能像标准库那样返回迭代器：<code>Iterator::next</code> 方法是一个普通的同步函数，所以调用 <code>commands.next()</code> 会阻塞线程，直到下一行准备好，相反，<code>lines</code> 返回一个 <code>Result&lt;String&gt;</code> 流。流是迭代器的异步模拟：它以异步友好的方式按需生成一系列值。这是来自 <code>async_std::stream</code> 模块的 <a href="https://docs.rs/async-std/1.11.0/async_std/stream/trait.Stream.html"><code>Stream</code></a> 的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_next</span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, </span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">size_hint</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">Option</span>&lt;<span class="type">usize</span>&gt;) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将其视为 <code>Iterator</code> 和 <code>Future</code> 的混合体。与迭代器一样，<code>Stream</code> 具有关联的 <code>Item</code> 类型并使用 <code>Option</code> 来指示序列何时结束。但就像<code>future</code>一样，必须对流进行轮询：要获取下一项（或得知流已结束），必须调用 <code>poll_next</code> 直到它返回 <code>Poll::Ready</code>。流的 <code>poll_next</code> 实现应该总是快速返回，没有阻塞。如果一个流返回 <code>Poll::Pending</code>，它必须在值得通过 <code>Context</code> 再次轮询时通知调用者。</p>
<p><code>poll_next</code> 方法很难直接使用，但通常不需要这样做。与迭代器一样，流具有广泛的实用方法集合，例如过滤器和映射。其中有一个 <code>next</code> 方法，它返回流的下一个 <code>Option&lt;Self::Item&gt;</code> 的<code>future</code>。可以调用 <code>next</code> 并等待它返回的<code>future</code>，而不是显式轮询流。</p>
<p>将这些部分放在一起，<code>send_commands</code> 通过使用 <code>next</code> 和 <code>while let</code> 循环流产生的值来消费输入流中的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = stream.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    ... <span class="keyword">use</span> item ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在它返回 <code>Poll::Ready(None)</code> 时就像在一个迭代器返回 <code>None</code> 之后在它上调用 <code>next</code>。与 <code>futures</code> 和 <code>Iterator</code>一样，流也有一个 <code>fuse</code> 方法来确保此类调用在需要时表现得可预测。使用流，必须包含导入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::prelude::*;</span><br></pre></td></tr></table></figure>

<p>这是因为 <code>Stream</code> 的实用方法，如 <code>next、map、filter</code> 等，实际上并未在 <code>Stream</code> 本身上定义。相反，它们是一个单独的 <code>StreamExt</code> 的默认方法，它为所有 <code>Streams</code> 自动实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">StreamExt</span>: Stream &#123;</span><br><span class="line"> ... define utility methods <span class="keyword">as</span> default methods ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Stream&gt; StreamExt <span class="keyword">for</span> <span class="title class_">T</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="发包"><a href="#发包" class="headerlink" title="发包"></a>发包</h4><p>为了在网络套接字上传输数据包，我们的客户端和服务器使用我们库 <code>crate</code> 的 <code>utils</code> 模块中的 <code>send_as_json</code> 函数，我们在 <code>src/utils.rs</code> 中增加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::prelude::*;</span><br><span class="line"><span class="keyword">use</span> serde::Serialize;</span><br><span class="line"><span class="keyword">use</span> std::marker::Unpin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">send_as_json</span>&lt;S, P&gt;(outbound: &amp;<span class="keyword">mut</span> S, packet: &amp;P) <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: async_std::io::Write + Unpin,</span><br><span class="line">    P: Serialize,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">json</span> = serde_json::<span class="title function_ invoke__">to_string</span>(&amp;packet)?;</span><br><span class="line">    json.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    outbound.<span class="title function_ invoke__">write_all</span>(json.<span class="title function_ invoke__">as_bytes</span>()).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数将数据包的 <code>JSON</code> 表示构建为字符串，在末尾添加换行符，然后将其全部写入 <code>outbound</code>。</p>
<p>从它的 <code>where</code> 子句中，可以看到 <code>send_as_json</code> 非常灵活。要发送的数据包类型 <code>P</code> 可以是任何实现 <code>serde::Serialize</code> 的东西。输出流 <code>S</code> 可以是任何实现 <code>async_std::io::Write</code> 的东西，它是输出流的 <code>std::io::Write</code> 的异步版本。这足以让我们在异步 <code>TcpStream</code> 上发送 <code>FromClient</code> 和 <code>FromServer</code> 值。使用 <code>write_all</code> 方法需要对 <code>S</code> 进行<code> Unpin</code> 约束。</p>
<p><code>send_as_json</code> 不是将数据包直接序列化到 <code>outbound</code>，而是将其序列化为临时字符串，然后将其写入<code>outbound</code>。<code>serde_json</code> 确实提供了将值直接序列化到输出流的函数，但这些函数仅支持同步流。写入异步流需要对 <code>serde_json</code> 和 <code>serde</code> 进行根本更改，因为它们设计的<code>Trait</code>具有同步方法。</p>
<p>与流一样，<code>async_std</code> 的 <code>I/O</code> 许多方法实际上是在<code>Ext Trait</code>上定义的，因此请务必记住在使用它们时使用 <code>async_std::prelude::*</code>。</p>
<h4 id="收包"><a href="#收包" class="headerlink" title="收包"></a>收包</h4><p>为了接收数据包，我们的服务器和客户端将使用 <code>utils</code> 模块中的这个函数从异步缓冲 <code>TCP</code> 套接字 <code>async_std::io::BufReader&lt;TcpStream&gt;</code> 接收 <code>FromClient</code> 和 <code>FromServer</code> 值，我们在 <code>src/utils.rs</code> 中继续增加以下函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::de::DeserializeOwned;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive_as_json</span>&lt;S, P&gt;(inbound: S) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Stream</span>&lt;Item = ChatResult&lt;P&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: async_std::io::BufRead + Unpin,</span><br><span class="line">    P: DeserializeOwned,</span><br><span class="line">&#123;</span><br><span class="line">    inbound.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">map</span>(|line_result| <span class="punctuation">-&gt;</span> ChatResult&lt;P&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line_result?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">parsed</span> = serde_json::from_str::&lt;P&gt;(&amp;line)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(parsed)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>send_as_json</code> 一样，此函数是泛型的：</p>
<ul>
<li><p>流类型 <code>S</code> 必须实现<code>async_std::io::BufRead</code>，它是<code>std::io::BufRead</code> 的异步模拟，表示缓冲的输入字节流；</p>
</li>
<li><p>数据包类型 <code>P</code> 必须实现 <code>DeserializeOwned</code>，这是 <code>serde</code> 的 <code>Deserialize</code> 的更严格的变体。为了提高效率，<code>Deserialize</code> 可以生成 <code>&amp;str</code> 和 <code>&amp;[u8]</code> 值，这些值直接从它们被反序列化的缓冲区借用它们的内容，以避免复制数据。然而，在我们的例子中，这并不好：我们需要将反序列化的值返回给我们的调用者，所以它们必须能够比我们从中解析它们的缓冲区更长寿。实现 <code>DeserializeOwned</code> 的类型始终独立于反序列化的缓冲区。</p>
</li>
</ul>
<p>调用 <code>inbound.lines()</code> 给我们一个 <code>std::io::Result&lt;String&gt;</code> 值的流。然后，我们使用流的 <code>map</code> 适配器对每个项目应用闭包，处理错误并将每一行解析为 <code>P</code> 类型值的 <code>JSON</code> 形式。这为我们提供了 <code>ChatResult&lt;P</code>&gt; 值的流，我们直接返回，函数的返回类型是：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Stream</span>&lt;Item = ChatResult&lt;P&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这表明我们返回了一些异步生成一系列 <code>ChatResult&lt;P&gt;</code> 值的类型，但我们的调用者无法准确判断它是哪种类型。由于我们传递给 <code>map</code> 的闭包都是匿名类型，这是 <code>receive_as_json</code> 可能返回的最具体的类型。请注意，<code>receive_as_json</code> 本身并不是一个异步函数。它是一个返回异步值的普通函数。</p>
<p>要查看 <code>receive_as_json</code> 是如何使用的，这里是我们聊天客户端的 <code>handle_replies</code> 函数，来自 <code>src/bin/client.rs</code>，它从网络接收 <code>FromServer</code> 值流并将它们打印出来供用户查看（我们需要在 <code>src/bin/client.rs</code> 增加如下代码）:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_chat::FromServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handle_replies</span>(from_server: net::TcpStream) <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buffered</span> = io::BufReader::<span class="title function_ invoke__">new</span>(from_server);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reply_stream</span> = utils::<span class="title function_ invoke__">receive_as_json</span>(buffered);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(reply) = reply_stream.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> reply? &#123;</span><br><span class="line">            FromServer::Message &#123;</span><br><span class="line">                group_name,</span><br><span class="line">                message,</span><br><span class="line">            &#125; =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;message posted to &#123;&#125;: &#123;&#125;&quot;</span>, group_name, message);</span><br><span class="line">            &#125;</span><br><span class="line">            FromServer::<span class="title function_ invoke__">Error</span>(message) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;error from server: &#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个从服务器接收数据的套接字，在它周围包裹一个 <code>async_std::io::BufReader</code>，然后将它传递给 <code>receive_as_json</code> 以获取传入的 <code>FromServer</code> 值流。然后它使用 <code>while let</code> 循环来处理传入的回复，检查错误结果并打印每个服务器回复以供用户查看。</p>
<h4 id="Client-主函数"><a href="#Client-主函数" class="headerlink" title="Client 主函数"></a><code>Client</code> 主函数</h4><p>在 <code>src/bin/client.rs</code> 添加如下内容实现我们的主函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Usage: client ADDRESS:PORT&quot;</span>);</span><br><span class="line">    task::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">socket</span> = net::TcpStream::<span class="title function_ invoke__">connect</span>(address).<span class="keyword">await</span>?;</span><br><span class="line">        socket.<span class="title function_ invoke__">set_nodelay</span>(<span class="literal">true</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">to_server</span> = <span class="title function_ invoke__">send_commands</span>(socket.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">from_server</span> = <span class="title function_ invoke__">handle_replies</span>(socket);</span><br><span class="line">        from_server.<span class="title function_ invoke__">race</span>(to_server).<span class="keyword">await</span>?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从命令行获取服务器地址后，<code>main</code> 有一系列要调用的异步函数，因此它将函数的其余部分包装在一个异步块中，并将该块的<code>future</code>传递给 <code>async_std::task::block_on</code> 以运行。</p>
<p>建立连接后，我们希望 <code>send_commands</code> 和 <code>handle_replies</code> 函数串联运行，这样我们就可以在输入时看到其他人的消息到达。如果我们输入<code>EOF</code>或与服务器的连接断开，程序应该退出。</p>
<p>鉴于我们在本节其他地方所做的，你可能会期望这样的代码：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">to_server</span> = task::<span class="title function_ invoke__">spawn</span>(<span class="title function_ invoke__">send_commands</span>(socket.<span class="title function_ invoke__">clone</span>()));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">from_server</span> = task::<span class="title function_ invoke__">spawn</span>(<span class="title function_ invoke__">handle_replies</span>(socket));</span><br><span class="line">to_server.<span class="keyword">await</span>?;</span><br><span class="line">from_server.<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure></div>

<p>但是由于我们等待两个连接句柄，这给了我们一个程序，一旦两个任务完成就退出。我们希望在任何一个完成后立即退出。<code>future</code> 的 <code>race</code> 方法完成了这一点。调用 <code>from_server.race(to_server)</code> 返回一个新的 <code>future</code>，该 <code>future</code> 会轮询 <code>from_server</code> 和 <code>to_server</code> 并在它们中的任何一个准备好后立即返回 <code>Poll::Ready(v)</code>。两个<code>future</code> 必须具有相同的输出类型：最终值是最先完成的<code>future</code> 的值，未完成的 <code>future</code> 被丢弃。</p>
<p><code>race</code>方法以及许多其他方便的实用程序是在 <code>async_std::prelude::FutureExt</code> 特征上定义的，<code>async_std::prelude</code> 使我们可以看到它。</p>
<p>至于未实现的 <code>parse_command()</code> 及其剩余部分请看：<a href="https://github.com/ProgrammingRust/async-chat/blob/abbd763289a1cf367b1c2183e7d432de83b1c650/src/bin/client.rs#L72"><code>github parse_command</code></a>。</p>
<h4 id="Server-主函数"><a href="#Server-主函数" class="headerlink" title="Server 主函数"></a><code>Server</code> 主函数</h4><p>下面是完整的 <code>Server</code> <code>main</code> 函数的实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Asynchronous chat server.</span></span><br><span class="line"><span class="meta">#![warn(rust_2018_idioms)]</span></span><br><span class="line"><span class="meta">#![allow(elided_lifetimes_in_paths)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_std::prelude::*;</span><br><span class="line"><span class="keyword">use</span> async_chat::utils::ChatResult;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> connection;</span><br><span class="line"><span class="keyword">mod</span> group;</span><br><span class="line"><span class="keyword">mod</span> group_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> connection::serve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Usage: server ADDRESS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">chat_group_table</span> = Arc::<span class="title function_ invoke__">new</span>(group_table::GroupTable::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line">    async_std::task::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">// This code was shown in the chapter introduction.</span></span><br><span class="line">        <span class="keyword">use</span> async_std::&#123;net, task&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">listener</span> = net::TcpListener::<span class="title function_ invoke__">bind</span>(address).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_connections</span> = listener.<span class="title function_ invoke__">incoming</span>();</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(socket_result) = new_connections.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">socket</span> = socket_result?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">groups</span> = chat_group_table.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            task::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">log_error</span>(<span class="title function_ invoke__">serve</span>(socket, groups).<span class="keyword">await</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">log_error</span>(result: ChatResult&lt;()&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(error) = result &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器的主要功能类似于客户端的：它做一些设置，然后调用 <code>block_on</code> 来运行一个异步代码块来完成真正的工作。为了处理来自客户端的传入连接，它创建一个 <code>TcpListener</code> 套接字，其传入方法返回 <code>std::io::Result&lt;TcpStream&gt;</code> 值流。</p>
<p>对于每个传入的连接，我们生成一个运行 <code>connection::serve</code> 函数的异步任务。每个任务还接收到一个 <code>GroupTable</code> 值的引用，该值表示我们服务器的当前聊天组列表，由所有连接通过 <code>Arc</code> 引用计数指针共享。如果 <code>connection::serve</code> 返回错误，我们将消息记录到标准错误输出并让任务退出，其他连接继续照常运行。</p>
<h4 id="处理客户端连接"><a href="#处理客户端连接" class="headerlink" title="处理客户端连接"></a>处理客户端连接</h4><p>该部分的代码在 <code>src/bin/server/connection.rs</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Handle a single client&#x27;s connection.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_chat::&#123;FromClient, FromServer&#125;;</span><br><span class="line"><span class="keyword">use</span> async_chat::utils::&#123;<span class="keyword">self</span>, ChatResult&#125;;</span><br><span class="line"><span class="keyword">use</span> async_std::prelude::*;</span><br><span class="line"><span class="keyword">use</span> async_std::io::BufReader;</span><br><span class="line"><span class="keyword">use</span> async_std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> async_std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::group_table::GroupTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">serve</span>(socket: TcpStream, groups: Arc&lt;GroupTable&gt;)</span><br><span class="line">                   <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">outbound</span> = Arc::<span class="title function_ invoke__">new</span>(Outbound::<span class="title function_ invoke__">new</span>(socket.<span class="title function_ invoke__">clone</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buffered</span> = BufReader::<span class="title function_ invoke__">new</span>(socket);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">from_client</span> = utils::<span class="title function_ invoke__">receive_as_json</span>(buffered);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(request_result) = from_client.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">request</span> = request_result?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">match</span> request &#123;</span><br><span class="line">            FromClient::Join &#123; group_name &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">group</span> = groups.<span class="title function_ invoke__">get_or_create</span>(group_name);</span><br><span class="line">                group.<span class="title function_ invoke__">join</span>(outbound.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FromClient::Post &#123; group_name, message &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">match</span> groups.<span class="title function_ invoke__">get</span>(&amp;group_name) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(group) =&gt; &#123;</span><br><span class="line">                        group.<span class="title function_ invoke__">post</span>(message);</span><br><span class="line">                        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                        <span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Group &#x27;&#123;&#125;&#x27; does not exist&quot;</span>, group_name))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(message) = result &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">report</span> = FromServer::<span class="title function_ invoke__">Error</span>(message);</span><br><span class="line">            outbound.<span class="title function_ invoke__">send</span>(report).<span class="keyword">await</span>?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Outbound</span>(Mutex&lt;TcpStream&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Outbound</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(to_client: TcpStream) <span class="punctuation">-&gt;</span> Outbound &#123;</span><br><span class="line">        <span class="title function_ invoke__">Outbound</span>(Mutex::<span class="title function_ invoke__">new</span>(to_client))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, packet: FromServer) <span class="punctuation">-&gt;</span> ChatResult&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>;</span><br><span class="line">        utils::<span class="title function_ invoke__">send_as_json</span>(&amp;<span class="keyword">mut</span> *guard, &amp;packet).<span class="keyword">await</span>?;</span><br><span class="line">        guard.<span class="title function_ invoke__">flush</span>().<span class="keyword">await</span>?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这很像客户端的 <code>handle_replies</code> 函数：大部分代码是一个循环处理传入的 <code>FromClient</code> 流，由带有 <code>receive_as_json</code> 的缓冲 <code>TCP</code> 流构建。如果发生错误，我们会生成一个 <code>FromServer::Error</code> 数据包，将错误消息传回给客户端。</p>
<p>除了错误消息，客户端还希望从他们加入的聊天组接收消息，因此需要与每个组共享与客户端的连接。我们可以简单地给每个人一个 <code>TcpStream</code> 的克隆，但是如果其中两个源尝试同时向套接字写入一个数据包，它们的输出可能会交错，并且客户端最终会收到乱码的 <code>JSON</code>，我们需要处理对连接的安全并发访问。</p>
<p><code>Outbound</code> 创建时，<code>Outbound</code> 值获取 <code>TcpStream</code> 的所有权并将其包装在 <code>Mutex</code> 中，以确保一次只有一个任务可以使用它。<code>serve</code> 函数将每个 <code>Outbound</code> 包装在 <code>Arc</code> 引用计数指针中，以便客户端加入的所有组都可以指向相同的共享 <code>Outbound</code> 实例。</p>
<p>对 <code>Outbound::send</code> 的调用首先获取锁，返回一个解除对内部 <code>TcpStream</code> 引用的保护值。我们使用 <code>send_as_json</code> 来传输数据包，最后我们调用 <code>guard.flush()</code> 以确保它不会在某个缓冲区中传输一半。</p>
<p>表达式 <code>&amp;mut *guard</code> 让我们可以解决 <code>Rust</code> 不会应用 <code>deref</code> 强制来满足 <code>trait</code> 边界的问题。相反，我们显式地取消引用互斥锁，然后借用一个可变引用到它所保护的 <code>TcpStream</code>，生成 s<code>end_as_json</code> 需要的 <code>&amp;mut TcpStream</code>。</p>
<p>请注意，<code>Outbound </code>使用 <code>async_std::sync::Mutex</code> 类型，而不是标准库的<code> Mutex</code>，这有 <code>3</code> 个原因：</p>
<ol>
<li><p>首先，如果在持有互斥锁的情况下暂停任务，标准库的互斥锁可能会出现异常行为。如果已经运行该任务的线程选择了另一个尝试锁定同一个 <code>Mutex</code> 的任务，那么问题就来了：从 <code>Mutex</code> 的角度来看，已经拥有它的线程正在尝试再次锁定它。标准的 <code>Mutex</code> 不能处理这种情况，因此它会出现<code>panic</code>或死锁。由于 <code>Outbound::send</code> 在等待 <code>send_as_json</code> 和 <code>guard.flush</code> 的 <code>future</code> 时需要持有锁，所以它必须使用 <code>async_std::sync::Mutex</code>；</p>
</li>
<li><p>其次，异步 <code>Mutex</code> 的 <code>lock</code> 方法返回的 <code>guard</code> 是 <code>future</code>，因此等待锁定 <code>mutex</code> 的任务会让出其线程供其他任务使用，直到 <code>mutex</code> 准备好。另一方面，标准互斥锁的<code>lock</code>方法在等待获取锁时锁定整个线程，由于前面的代码在通过网络传输数据包时持有互斥锁，这可能需要相当长的时间；</p>
</li>
<li><p>最后，标准互斥锁只能由锁定它的同一线程解锁。为了强制执行这一点，标准互斥锁的保护类型没有实现 <code>Send</code>：它不能被传输到其他线程。这意味着持有这种保护的 <code>future</code> 本身并不实现 <code>Send</code>，并且不能传递给 <code>spawn</code> 以在线程池上运行；它只能与 <code>block_on</code> 或 <code>spawn_local</code> 一起运行。 <a href="https://docs.rs/async-std/1.11.0/async_std/sync/struct.MutexGuard.html"><code>async_std::sync::MutexGuard</code></a> 实现了 <code>Send</code>，因此在衍生任务中使用它没有问题；</p>
</li>
</ol>
<h4 id="聊天组-Hash-表"><a href="#聊天组-Hash-表" class="headerlink" title="聊天组 Hash 表"></a>聊天组 <code>Hash</code> 表</h4><p>通常在持有互斥锁时不需要等待任何东西，并且锁不会长时间持有。在这种情况下，标准库的 <code>Mutex</code> 会更加高效。我们的聊天服务器的 <code>GroupTable</code> 类型说明了这种情况。以下是 <code>src/bin/server/group_table.rs</code> 的完整内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::group::Group;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GroupTable</span>(Mutex&lt;HashMap&lt;Arc&lt;<span class="type">String</span>&gt;, Arc&lt;Group&gt;&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GroupTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> GroupTable &#123;</span><br><span class="line">        <span class="title function_ invoke__">GroupTable</span>(Mutex::<span class="title function_ invoke__">new</span>(HashMap::<span class="title function_ invoke__">new</span>()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;Group&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">get</span>(name).<span class="title function_ invoke__">cloned</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_or_create</span>(&amp;<span class="keyword">self</span>, name: Arc&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Arc&lt;Group&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">            .<span class="title function_ invoke__">entry</span>(name.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">            .<span class="title function_ invoke__">or_insert_with</span>(|| Arc::<span class="title function_ invoke__">new</span>(Group::<span class="title function_ invoke__">new</span>(name)))</span><br><span class="line">            .<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GroupTable</code> 只是一个受互斥锁保护的哈希表，将聊天组名称映射到实际组，两者都使用引用计数指针进行管理。<code>get</code> 和 <code>get_or_create</code> 获取锁，执行一些哈希表操作，也许是一些分配，然后返回。</p>
<p>在 <code>GroupTable</code> 中，我们使用普通的旧 <code>std::sync::Mutex</code>。此模块中根本没有异步代码，因此无需避免等待。事实上，如果我们想在这里使用 <code>async_std::sync::Mutex</code>，我们需要将 <code>get</code> 和 <code>get_or_create</code> 变成异步函数，这会引入 <code>future</code> 创建、暂停和恢复的开销，但几乎没有什么好处：互斥锁仅被锁定执行一些 <code>hash</code> 操作，也许还有一些分配。</p>
<p>如果我们的聊天服务器发现自己拥有数百万用户，而 <code>GroupTable</code> 互斥锁确实成为了瓶颈，那么使其异步无法解决这个问题。使用某种专门用于并发访问的集合类型而不是 <code>HashMap</code> 可能会更好，例如 <a href="https://crates.io/crates/dashmap"><code>dashmap</code></a>。</p>
<h4 id="聊天组"><a href="#聊天组" class="headerlink" title="聊天组"></a>聊天组</h4><p><code>group::Group</code> 类型代表一个聊天组。该类型只需要支持 <code>connection::serve</code> 调用的两种方法：<code>join</code>（添加新成员），<code>post</code>（发布消息），发布的每条消息都需要分发给所有成员。</p>
<p>这就是我们解决前面提到的背压挑战的地方，这要求：</p>
<ul>
<li><p>如果一名成员无法跟上发布到群组的消息（例如，如果他们的网络连接速度较慢），则群组中的其他成员不应受到影响；</p>
</li>
<li><p>即使成员落后，他们也应该有办法重新加入对话并继续以某种方式参与；</p>
</li>
<li><p>用于缓冲消息的内存不应无限制地增长；</p>
</li>
</ul>
<p>因为在实现多对多通信模式时这些挑战很常见，所以 <code>tokio</code> 提供了一种广播通道类型，它实现了一组合理的权衡。<code>tokio</code> 广播通道是一个值队列（在我们的例子中是聊天消息），它允许任意数量的不同线程或任务发送和接收值。它被称为广播通道，因为每个消费者都会获得自己发送的每个值的副本，值类型必须实现 Clone。</p>
<p>通常，广播通道会在队列中保留一条消息，直到每个消费者都得到他们的副本。但是如果队列的长度超过了通道创建时指定的最大容量，那么最旧的消息就会被丢弃。任何跟不上的消费者在下次尝试获取下一条消息时都会收到错误消息，但是它们可以继续从当前队列最旧的消息开始获取。</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/tokio-broadcast-channel.png" class="">

<p>有两个发送者将消息入队，四个接收者将消息出队——或者更准确地说，是从队列中复制消息。接收者 <code>B</code> 仍有 <code>14</code> 条消息要接收，接收者 <code>C</code> 有 <code>7</code> 条消息，接收者 <code>D</code> 已完全赶上。接收者 <code>A</code> 落后了，<code>11</code> 条消息在它看到之前就被丢弃了。它下一次接收消息的尝试将失败，返回一个指示该情况的错误，并且它将被赶到队列的当前末尾。</p>
<p>我们的聊天服务器将每个聊天组表示为一个带有 <code>Arc&lt;String&gt;</code> 值的广播通道：向该组发布消息会将其广播给所有当前成员。下面是 <code>group::Group</code> 类型的定义，在 <code>src/bin/server/group.rs</code> 中定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! A chat group.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">use</span> crate::connection::Outbound;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::broadcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    name: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    sender: broadcast::Sender&lt;Arc&lt;<span class="type">String</span>&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: Arc&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Group &#123;</span><br><span class="line">        <span class="keyword">let</span> (sender, _receiver) = broadcast::<span class="title function_ invoke__">channel</span>(<span class="number">1000</span>);</span><br><span class="line">        Group &#123; name, sender &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">join</span>(&amp;<span class="keyword">self</span>, outbound: Arc&lt;Outbound&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = <span class="keyword">self</span>.sender.<span class="title function_ invoke__">subscribe</span>();</span><br><span class="line"></span><br><span class="line">        task::<span class="title function_ invoke__">spawn</span>(<span class="title function_ invoke__">handle_subscriber</span>(<span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                                      receiver,</span><br><span class="line">                                      outbound));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">post</span>(&amp;<span class="keyword">self</span>, message: Arc&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// This only returns an error when there are no subscribers. A</span></span><br><span class="line">        <span class="comment">// connection&#x27;s outgoing side can exit, dropping its subscription,</span></span><br><span class="line">        <span class="comment">// slightly before its incoming side, which may end up trying to send a</span></span><br><span class="line">        <span class="comment">// message to an empty group.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_ignored</span> = <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> async_chat::FromServer;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::broadcast::error::RecvError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handle_subscriber</span>(group_name: Arc&lt;<span class="type">String</span>&gt;,</span><br><span class="line">                           <span class="keyword">mut</span> receiver: broadcast::Receiver&lt;Arc&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">                           outbound: Arc&lt;Outbound&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">packet</span> = <span class="keyword">match</span> receiver.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(message) =&gt; FromServer::Message &#123;</span><br><span class="line">                group_name: group_name.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                message: message.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Err</span>(RecvError::<span class="title function_ invoke__">Lagged</span>(n)) =&gt; FromServer::<span class="title function_ invoke__">Error</span>(</span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;Dropped &#123;&#125; messages from &#123;&#125;.&quot;</span>, n, group_name)</span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Err</span>(RecvError::Closed) =&gt; <span class="keyword">break</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> outbound.<span class="title function_ invoke__">send</span>(packet).<span class="keyword">await</span>.<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Group</code> 结构体包含聊天组的名称，以及表示广播通道发送端的 <code>broadcast::Sender</code>。<code>Group::new</code> 方法调用 <code>broadcast::channel</code> 创建一个最大容量为 <code>1000</code> 条消息的广播通道。通道函数返回发送者和接收者，但此时我们不需要接收者，因为该组还没有任何成员。</p>
<p>要将新成员添加到组中，<code>Group::join</code> 方法会调用发送者的 <code>subscribe</code> 方法来为通道创建新的接收者。然后它生成一个新的异步任务来监视该接收者的消息并将它们写回客户端，在 <code>handle_subscribe</code> 函数中。</p>
<p>有了这些细节，<code>Group::post</code> 方法就很简单了：它只是将消息发送到广播通道。由于通道携带的值是 <code>Arc&lt;String&gt;</code> 值，因此为每个接收者提供自己的消息副本只会增加消息的引用计数，而无需任何副本或堆分配。一旦所有订阅者都发送了消息，引用计数就会下降到零，消息就会被释放。</p>
<p>至于 <code>handle_subscriber</code>，虽然细节不同，但这个函数的形式很熟悉：它是一个循环，从广播通道接收消息并通过共享的 <code>Outbound</code> 值将它们传输回客户端。如果循环跟不上广播通道，它会收到一个滞后错误，并报告给客户端。</p>
<p>如果将数据包发送回客户端完全失败，可能是因为连接已关闭，<code>handle_subscriber</code> 退出其循环并返回，导致异步任务退出。这会删除广播通道的接收者，从通道中取消订阅。这样，当一个连接断开，并且在它加入的组向它发送消息时，太会从组中被删除。</p>
<p>我们的聊天组永远不会关闭，因为我们永远不会从组表中删除组，但只是为了完整性，<code>handle_subscriber</code> 已准备好通过退出任务来处理已关闭的错误。</p>
<p>请注意，我们正在为每个客户端的每个组成员创建一个新的异步任务。这是可行的，因为异步任务使用的内存比线程少得多，而且在进程中从一个异步任务切换到另一个异步任务非常高效。</p>
<p>这就是聊天服务器的完整代码。它有点简陋，在 <code>async_std</code>、<code>tokio</code> 和 <code>futures</code> 中还有很多有价值的特性，理想情况下，这个扩展示例设法说明了异步生态系统的一些特性如何协同工作：任务、流、异步 <code>I/O</code>、通道和两种风格的互斥锁。</p>
<h3 id="实现执行器"><a href="#实现执行器" class="headerlink" title="实现执行器"></a>实现执行器</h3><p>聊天服务器展示了我们如何使用诸如 <code>TcpListener</code> 和广播通道之类的异步原语编写代码，并使用诸如 <code>block_on</code> 和 <code>spawn</code> 之类的<code>executor</code> 来驱动它们的执行，现在我们可以看看这些东西是如何实现的。关键问题是，当 <code>future</code> 返回 <code>Poll::Pending</code> 时，它如何与 <code>executor</code> 协调以在正确的时间再次对其进行轮询？想想当我们从聊天客户端的 <code>main</code> 函数中运行这样的代码时会发生什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">task::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket</span> = net::TcpStream::<span class="title function_ invoke__">connect</span>(address).<span class="keyword">await</span>?;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第一次 <code>block_on</code> 轮询异步块的 <code>future</code> 时，网络连接几乎肯定没有立即准备好，所以 <code>block_on</code> 进入睡眠状态。但是什么时候应该醒来？不知何故，一旦网络连接准备好，<code>TcpStream</code> 需要告诉 <code>block_on</code> 它应该再次尝试轮询异步块的<code>future</code>，因为它知道这一次，等待将完成，并且异步块的执行可以进行。</p>
<p>当像 <code>block_on</code> 这样的 <code>executor</code> 轮询 <code>future</code> 时，它必须传入一个称为 <code>waker</code> 的回调。如果 <code>future</code> 还没有准备好，<code>Future</code> 的规则说它现在必须返回 <code>Poll::Pending</code>，并安排 <code>waker</code> 稍后被调用，如果 <code>future</code> 值得再次轮询。因此，<code>Future</code> 的实现通常看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::task::Waker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrimitiveFuture</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    waker: <span class="type">Option</span>&lt;Waker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">MyPrimitiveFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;...&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ... future is ready ... &#123;</span><br><span class="line">            <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(final_value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the waker for later.</span></span><br><span class="line">        <span class="keyword">self</span>.waker = <span class="title function_ invoke__">Some</span>(cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        Poll::Pending</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说，如果 <code>future</code> 的值已经准备好，则返回它。否则，将 <code>Context</code> 的 <code>waker</code> 的克隆存储在某处，并返回 <code>Poll::Pending</code>。当<code>future</code> 值得再次轮询时，<code>future</code> 必须通过调用它的 <code>waker</code> 来通知最后一个轮询它的 <code>executor</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have a waker, invoke it, and clear `self.waker`.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waker) = <span class="keyword">self</span>.waker.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">    waker.<span class="title function_ invoke__">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理想情况下，<code>executor</code> 和 <code>future</code> 轮流轮询和唤醒：<code>executor</code> 轮询 <code>future</code> 并进入睡眠状态，然后 <code>future</code> 调用 <code>waker</code>，因此 <code>executor</code> 唤醒并再次轮询<code>future</code>。</p>
<p>异步函数和异步代码块的 <code>future</code> 不处理 <code>waker</code> 本身，它们只是将获得的上下文传递给他们等待的子 <code>future</code> ，将保存和调用 <code>waker</code> 的义务委托给他们。在我们的聊天客户端中，异步代码块 <code>future</code> 的第一次轮询只是在它等待 <code>TcpStream::connect</code> 的<code>future</code>时传递上下文，随后的类似地将其上下文传递到接下来等待的任何<code>future</code>。</p>
<p><code>TcpStream::connect</code> 的<code>future</code>句柄被轮询，如前面的示例所示：它将<code>waker</code>交给一个辅助线程，该线程等待连接准备好然后调用它。</p>
<p><code>Waker</code> 实现了 <code>Clone</code> 和 <code>Send</code>，因此 <code>Future</code> 可以随时创建自己的 <code>Waker</code> 副本，并根据需要将其发送到其他线程。<code>Waker::wake</code> 方法使用<code>waker</code>。</p>
<p><code>executor</code> 对 <code>future</code> 进行过度轮询是无害的，只是效率低下。然而，<code>Futures</code> 应该小心，只有在轮询会取得实际进展时才调用<code>waker</code>：虚假唤醒和轮询的循环可能会阻止 <code>executor</code> 完全休眠，从而可能使处理器对其他任务的响应能力降低。</p>
<p>现在我们已经展示了 <code>executor</code> 和原始 <code>future</code> 如何通信，我们将自己实现原始 <code>future</code>，然后介绍 <code>block_on</code> 执行器的实现。</p>
<h4 id="调用-Waker"><a href="#调用-Waker" class="headerlink" title="调用 Waker"></a>调用 <code>Waker</code></h4><p>在本节前面，我们描述了 <code>spawn_blocking</code> 函数，它启动新的线程运行给定闭包并返回其返回值的 <code>future</code>。我们现在拥有了我们自己实现 <code>spawn_blocking</code> 所需的所有部分。为了简单起见，我们的版本为每个闭包创建一个新线程，而不是像 <code>async_std</code> 的版本那样使用线程池。</p>
<p>虽然 <code>spawn_blocking</code> 返回一个 <code>future</code>，但我们不会将它写成异步 <code>fn</code>。相反，它将是一个普通的同步函数，它返回一个结构 <code>SpawnBlocking</code>，我们将在其上自己实现 <code>Future</code>。</p>
<p>我们的 <code>spawn_blocking</code> 的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn_blocking</span>&lt;T, F&gt;(closure: F) <span class="punctuation">-&gt;</span> SpawnBlocking&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T,</span><br><span class="line"> F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line"> T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br></pre></td></tr></table></figure>

<p>由于我们需要将闭包发送到另一个线程并带回返回值，因此闭包 <code>F</code> 及其返回值 <code>T</code> 都必须实现 <code>Send</code>。 而且由于我们不知道线程将运行多长时间，因此它们也必须是 <code>&#39;static</code> 的，这些与 <code>std::thread::spawn</code> 本身施加的界限相同，<code>SpawnBlocking&lt;T&gt;</code> 是闭包返回值的<code>future</code>，这是它的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::task::Waker;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpawnBlocking</span>&lt;T&gt;(Arc&lt;Mutex&lt;Shared&lt;T&gt;&gt;&gt;);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shared</span>&lt;T&gt; &#123;</span><br><span class="line">    value: <span class="type">Option</span>&lt;T&gt;,</span><br><span class="line">    waker: <span class="type">Option</span>&lt;Waker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Shared</code> 结构体必须充当 <code>future</code> 和运行闭包的线程之间的集合点，因此它由 <code>Arc</code> 拥有并由 <code>Mutex</code> 保护（这里可以使用同步互斥锁） 轮询 <code>future</code> 检查值是否存在，如果不存在，则将 <code>Waker</code> 保存在 <code>waker</code> 中。运行闭包的线程将其返回值保存在 <code>value</code> 中，然后调用 <code>waker</code>（如果存在）。</p>
<p>这是 <code>spawn_blocking</code> 的完整定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn_blocking</span>&lt;T, F&gt;(closure: F) <span class="punctuation">-&gt;</span> SpawnBlocking&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inner</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(Shared &#123;</span><br><span class="line">        value: <span class="literal">None</span>,</span><br><span class="line">        waker: <span class="literal">None</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">    std::thread::<span class="title function_ invoke__">spawn</span>(&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inner</span> = inner.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">closure</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">maybe_waker</span> = &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = inner.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                guard.value = <span class="title function_ invoke__">Some</span>(value);</span><br><span class="line">                guard.waker.<span class="title function_ invoke__">take</span>()</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waker) = maybe_waker &#123;</span><br><span class="line">                waker.<span class="title function_ invoke__">wake</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_ invoke__">SpawnBlocking</span>(inner)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>Shared</code> 值后，这会产生一个线程来运行闭包，将结果存储在 <code>Shared</code> 的 <code>value</code> 字段中，并调用唤醒器（如果有）。我们可以为 <code>SpawnBlocking</code> 实现 <code>Future</code>，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; Future <span class="keyword">for</span> <span class="title class_">SpawnBlocking</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = guard.value.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        guard.waker = <span class="title function_ invoke__">Some</span>(cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        Poll::Pending</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>轮询 <code>SpawnBlocking</code> 检查闭包的值是否已准备就绪，如果是，则获取所有权并返回它。否则，<code>future</code> 仍然处于未就绪状态，因此它会在 <code>future</code> 的 <code>Waker</code> 字段中保存上下文唤醒器的克隆。一旦 <code>Future</code> 返回 <code>Poll::Ready</code>，你就不应该再次轮询它。使用<code>Future</code>的常用方式，如 <code>await</code> 和 <code>block_on</code>，都遵守这条规则。</p>
<h4 id="实现-block-on"><a href="#实现-block-on" class="headerlink" title="实现 block_on"></a>实现 <code>block_on</code></h4><p>在本节中，我们将编写自己的 <code>block_on</code> 版本。它会比 <code>async_std</code> 的版本简单很多。例如，它不支持 <code>spawn_local</code>、任务局部变量或嵌套调用，但是运行我们的聊天客户端和服务器就足够了。</p>
<p>这是代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crossbeam::sync::Parker; <span class="comment">// Cargo.toml: crossbeam = &quot;0.8&quot;</span></span><br><span class="line"><span class="keyword">use</span> futures_lite::pin; <span class="comment">// Cargo.toml: futures-lite = &quot;1.11&quot;</span></span><br><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> waker_fn::waker_fn; <span class="comment">// Cargo.toml: waker-fn = &quot;1.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">block_on</span>&lt;F: Future&gt;(future: F) <span class="punctuation">-&gt;</span> F::Output &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parker</span> = Parker::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unparker</span> = parker.<span class="title function_ invoke__">unparker</span>().<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">waker</span> = <span class="title function_ invoke__">waker_fn</span>(<span class="keyword">move</span> || unparker.<span class="title function_ invoke__">unpark</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">context</span> = Context::<span class="title function_ invoke__">from_waker</span>(&amp;waker);</span><br><span class="line">    pin!(future);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> context) &#123;</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(value) =&gt; <span class="keyword">return</span> value,</span><br><span class="line">            Poll::Pending =&gt; parker.<span class="title function_ invoke__">park</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">parker</span> = Parker::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">unparker</span> = parker.<span class="title function_ invoke__">unparker</span>().<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure>

<p><a href="https://crates.io/crates/crossbeam"><code>crossbeam</code></a> 的 <a href="https://docs.rs/crossbeam/0.8.1/crossbeam/sync/struct.Parker.html"><code>Parker</code></a> 类型是一个简单的阻塞原语：调用 <code>parker.park()</code> 会阻塞线程，直到其他人在相应的 <a href="https://docs.rs/crossbeam/0.8.1/crossbeam/sync/struct.Unparker.html"><code>Unparker</code></a> 上调用 <code>.unpark()</code>，可以通过调用 <code>parker.unparker()</code> 预先获得它。 如果你 <code>unpark</code> 一个未 <code>parked</code> 的线程，它的下一次 <code>park()</code> 调用会立即返回，而不会阻塞。这里的 <code>block_on</code> 将使用 <code>Parker</code> 在 <code>future</code> 未准备好时等待，我们传递给 <code>futures</code> 的唤醒器将 <code>unpark</code> 它。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">waker</span> = <span class="title function_ invoke__">waker_fn</span>(<span class="keyword">move</span> || unparker.<span class="title function_ invoke__">unpark</span>());</span><br></pre></td></tr></table></figure>

<p><a href="https://crates.io/crates/waker-fn"><code>waker_fn</code></a> 函数，来自同名的 <code>crate</code>，从给定的闭包创建一个 <code>Waker</code>。在这里，我们创建了一个 <code>Waker</code>，当被调用时，它会调用闭包 <code>move || unparker.unpark()</code>。可以仅使用标准库创建唤醒器，但 <code>waker_fn</code> 更方便一些。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">pin!(future);</span><br></pre></td></tr></table></figure>

<p>给定一个持有 <code>F</code> 类型的 <code>future</code> 变量，<code>pin</code> 宏获得<code>future</code>的所有权并声明一个同名的新变量，其类型为 <code>Pin&lt;&amp;mut F&gt;</code> 并借用 <code>future</code>，这为我们提供了 <code>poll</code> 方法所需的 <code>Pin&lt;&amp;mut Self&gt;</code>，将在下一节中解释的原因，异步函数和块的 <code>future</code> 必须通过 <code>Pin</code> 引用，然后才能被轮询。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> context) &#123;</span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>(value) =&gt; <span class="keyword">return</span> value,</span><br><span class="line">        Poll::Pending =&gt; parker.<span class="title function_ invoke__">park</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，轮询循环非常简单。传递一个带有我们唤醒器的上下文，我们轮询<code>future</code>，直到它返回 <code>Poll::Ready</code>。 如果它返回 <code>Poll::Pending</code>，我们将暂停线程，该线程会一直阻塞，直到调用 <code>Waker</code>，然后我们再试一次。<code>as_mut</code> 调用让我们可以在不放弃所有权的情况下轮询 <code>future</code>，我们将在下一节中对此进行更多解释。</p>
<h3 id="Pinning"><a href="#Pinning" class="headerlink" title="Pinning"></a><code>Pinning</code></h3><p>尽管异步函数和异步代码块对于编写清晰的异步代码是必不可少的，但处理它们的 <code>future</code> 需要小心。<code>Pin</code> 类型帮助 <code>Rust</code> 确保它们被安全使用。</p>
<p>在本节中，我们将展示为什么不能像普通的 <code>Rust</code> 值那样自由地处理异步函数调用和块的 <code>future</code>。然后，将展示 <code>Pin</code> 如何充当指针的<code>&quot;seal of approval&quot;</code>，可以依靠这些指针来安全地管理此类 <code>future</code>。最后，展示一些使用 <code>Pin</code> 值的方法。</p>
<h4 id="Future-的两个生命阶段"><a href="#Future-的两个生命阶段" class="headerlink" title="Future 的两个生命阶段"></a><code>Future</code> 的两个生命阶段</h4><p>我们来看下面代码的实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> async_std::&#123;io, net&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fetch_string</span>(address: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    ❶</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">socket</span> = net::TcpStream::<span class="title function_ invoke__">connect</span>(address).<span class="keyword">await</span>❷?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    socket.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span>❸?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将打开到给定地址的 <code>TCP</code> 连接，并以字符串形式返回服务器想要发送的任何内容。标记为❶、❷和❸的点是恢复点，即异步函数代码中可能暂停执行的点。</p>
<p>一旦你向下面这样调用，而不等待其结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">fetch_string</span>(<span class="string">&quot;localhost:6502&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在 <code>response</code> 是一个 <code>future</code>，准备通过给定的参数执行 <code>fetch_string</code>，在内存中，<code>future</code> 如下图所示:</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/future-structured-foracallto-fetchstring.png" class="">

<p>由于我们刚刚创建了这个 <code>future</code>，它说执行应该从函数体顶部的恢复点 ❶ 开始。在这种状态下，<code>future</code> 需要处理的唯一值是函数参数。现在假设你轮询了几次响应，它到达了函数体中的这一点：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">socket.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span>❸?;</span><br></pre></td></tr></table></figure>

<p>进一步假设 <code>read_to_string</code> 的结果还没有准备好，所以 <code>poll</code> 返回 <code>Poll::Pending</code>。此时，<code>future</code>看起来如下图所示：</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/future-structured-foracallto-fetchstring-await.png" class="">

<p><code>future</code> 必须始终保存下一次轮询时恢复执行所需的所有信息，在这种情况下是：</p>
<ul>
<li><p>恢复点❸，表示应在等待轮询<code>read_to_string</code> 的<code>future</code>恢复执行；</p>
</li>
<li><p>在该恢复点处于活动状态的变量：<code>socket</code> 和 <code>buf</code>。<code>address</code> 的值将来不再存在，因为函数不再需要它；</p>
</li>
<li><p><code>read_to_string</code> <code>future</code>，<code>await</code>表达式正在轮询中；</p>
</li>
</ul>
<p>请注意，对 <code>read_to_string</code> 的调用借用了对 <code>socket</code> 和 <code>buf</code> 的引用。在同步函数中，所有局部变量都存在于堆栈中，但在异步函数中，在等待期间处于活动状态的局部变量必须位于 <code>future</code>，因此当再次轮询时它们将可用，借用此类变量的引用会借用<code>future</code>的一部分。</p>
<p>但是，<code>Rust</code> 要求在借用值时不要移动它们，假设要将这个 <code>future</code> 移动到一个新位置：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">new_variable</span> = response;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 无法找到所有活动的引用并相应地调整它们，在还未初始化的响应中，引用继续指向它们的旧位置，而不是指向新位置的 <code>socket</code> 和 <code>buf</code>。它们变成了悬空指针，如下图所示。</p>
<img data-src="/2022/04/26/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/future-structured-foracallto-fetchstring-moved.png" class="">

<p>防止借用值被移动通常是借用检查器的责任。借用检查器将变量视为所有权树的根，但与存储在堆栈中的变量不同，如果<code>future</code>本身移动，存储在<code>future</code>中的变量也会移动。<strong>异步函数的 <code>future</code> 是借用检查器的盲点，如果 <code>Rust</code> 想要保持其内存安全承诺，它必须以某种方式做到</strong>。</p>
<p><code>Rust</code> 对这个问题的解决方案基于这样的见解，即 <code>future</code> 在首次创建时始终可以安全移动，并且只有在轮询时才会变得不安全。刚刚通过调用异步函数创建的 <code>future</code> 只包含一个恢复点和参数值。这些仅在尚未开始执行的异步函数主体的范围内，只有轮询<code>future</code>才能借用其内容。</p>
<p>由此可见，每一个 <code>futue</code> 都有两个生命阶段：</p>
<ul>
<li><p>第一阶段从创建 <code>future</code> 开始。因为函数体还没有开始执行，所以它的任何部分都不可能被借用，在这个时间点，它可以安全地移动；</p>
</li>
<li><p>第二阶段在第一次轮询 <code>future</code> 时开始。一旦函数的主体开始执行，它可以借用存储在<code>future</code>的变量的引用，然后<code>await</code>，留下 <code>future</code> 的那部分借用。从第一次 <code>poll</code> 开始，我们必须假设 <code>future</code> 可能不安全；</p>
</li>
</ul>
<p>第一个生命阶段的灵活性让我们可以将 <code>futures</code> 传递给 <code>block_on</code> 和 <code>spawn</code> 并调用诸如 <code>race</code> 和 <code>fuse</code> 之类的适配器方法，所有这些都通过值来获取 <code>futures</code>。事实上，即使是最初创建 <code>future</code> 的异步函数调用也必须将其返回给调用者，这也是一个 <code>move</code> 操作。</p>
<p><strong>要进入它的第二个生命阶段，必须对 <code>future</code> 进行<code>poll</code>。<code>poll</code> 方法要求将 <code>future</code> 作为 <code>Pin&lt;&amp;mut Self&gt;</code> 值传递。<code>Pin</code> 是指针类型（如 <code>&amp;mut Self</code>）的包装器，它限制指针的使用方式，确保它们的所指对象（如 <code>Self</code>）不能再次移动。因此，必须先生成一个指向未来的 <code>Pin</code> 包装指针，然后才能对其进行轮询。</strong></p>
<p>那么，这就是 <code>Rust</code> 保证 <code>futures</code> 安全的策略：<code>future</code> 在被轮询之前不会变得危险；在构建指向它的 <code>Pin-wrapped</code> 指针之前，无法轮询<code>future</code>，一旦你做到了，<code>future</code> 就不能被 <code>move</code>。</p>
<p><strong>一个你不能移动的值</strong> 听起来是不可能的：在 <code>Rust</code> 中 <code>move</code> 无处不在，我们将在下一节中准确解释 <code>Pin</code> 如何保护 <code>future</code>。</p>
<p>尽管本节讨论了异步函数，但这里的所有内容也适用于异步代码块。一个新创建的异步代码块的 <code>future</code> 只是从周围的代码中捕获它将使用的变量，就像一个闭包。只有轮询 <code>future</code> 才能创建对其内容的引用，使其无法安全移动。</p>
<p>请记住，这种移动的脆弱性仅限于编译器为异步函数和代码块的 <code>future</code> 生成的特殊实现。如果为自己的类型手动实现 <code>Future</code>，<code>future</code>在它们被轮询之前和之后移动都是完全安全的。在任何手写的 <code>poll</code> 中，借用检查器确保在 <code>poll</code> 返回时，借用的任何对 <code>self</code> 部分的引用都已消失。只是因为异步函数和块有能力在函数调用过程中暂停执行，并且正在进行借用，所以我们必须小心处理它们的 <code>future</code> 。</p>
<h4 id="Pinned-Pointers"><a href="#Pinned-Pointers" class="headerlink" title="Pinned Pointers"></a><code>Pinned Pointers</code></h4><p><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> 类型是指向 <code>future</code> 的指针的包装器，它限制如何使用指针来确保<code>future</code> 一旦被轮询就不能移动。对于不介意被移动的<code>future</code>，可以取消这些限制，但它们对于安全地轮询异步函数和块的 <code>future</code> 至关重要。</p>
<p>指针是指任何实现 <code>Deref</code> 的类型，也可能是 <code>DerefMut</code>。包裹在指针周围的 <code>Pin</code> 称为固定指，例如 <code>Pin&lt;&amp;mut T&gt;</code> 和 <code>Pin&lt;Box&lt;T&gt;&gt;</code>。标准库中 <code>Pin</code> 的定义很简单：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pin</span>&lt;P&gt; &#123;</span><br><span class="line">    pointer: P,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，指针字段不是 <code>pub</code>。这意味着构造或使用 <code>Pin</code> 的唯一方法是通过类型提供的精心选择的方法。给定异步函数或代码块的<code>future</code>，只有几种方法可以获得指向它的固定指针：</p>
<ul>
<li><p><code>pin!</code>，来自 <a href="https://crates.io/crates/futures-lite">futures-lite</a> 的宏，用一个<code>Pin&lt;&amp;mut T&gt;</code> 类型的新变量屏蔽了一个 <code>T</code> 类型的变量。新变量指向原始值，原始值值已移动到堆栈上的匿名临时位置。当新变量超出范围时，该值将被删除。在前面的 <code>block_on</code> 实现中用了 <code>pin!</code> 固定我们想要轮询的<code>future</code>。</p>
</li>
<li><p>标准库的 <code>Box::pin</code> 构造函数获取任何类型 <code>T</code> 的值的所有权，将其移动到堆中，并返回 <code>Pin&lt;Box&lt;T&gt;&gt;</code>；</p>
</li>
<li><p><code>Pin&lt;Box&lt;T&gt;&gt;</code> 实现了 <code>From&lt;Box&lt;T&gt;&gt;</code>，因此<code>Pin::from(boxed)</code> 获得 <code>boxed</code> 的所有权，并返回一个指向堆上相同 <code>T</code> 的 <code>pinned box</code>；</p>
</li>
</ul>
<p>获得指向这些 <code>future</code> 的固定指针的每一种方法都需要放弃对 <code>future</code> 的所有权，并且没有办法将其收回。当然，固定指针本身可以以任何你喜欢的方式移动，但是移动指针并不会移动它的所指对象。因此，拥有指向 <code>future</code> 的固定指针可以证明已经永久放弃了移动该 <code>future</code> 的能力，但因此它可以被安全地轮询。</p>
<p>一旦你固定了一个 <code>future</code>，如果你想对其进行轮询，所有 <code>Pin&lt;pointer to T&gt;</code> 类型都有一个 <code>as_mut</code> 方法，该方法解引用指针并返回轮询所需的 <code>Pin&lt;&amp;mut T&gt;</code>。<code>as_mut</code> 方法还可以帮助在不放弃所有权的情况下轮询<code>future</code>，前面的 <code>block_on</code> 实现中使用了它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">pin!(future);</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> context) &#123;</span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>(value) =&gt; <span class="keyword">return</span> value,</span><br><span class="line">        Poll::Pending =&gt; parker.<span class="title function_ invoke__">park</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>pin!</code> 宏已将 <code>future</code> 重新声明为 <code>Pin&lt;&amp;mut F&gt;</code>，因此我们可以将其传递给 <code>poll</code>。但是可变引用不是 <code>Copy</code>，因此 <code>Pin&lt;&amp;mut F&gt;</code> 也不能是 <code>Copy</code>，这意味着直接调用 <code>future.poll()</code> 将获得<code>future</code>的所有权，从而为循环的下一次迭代留下一个未初始化的变量。为了避免这种情况，我们调用 <code>future.as_mut()</code> 为每次循环迭代重新借用一个新的 <code>Pin&lt;&amp;mut F&gt;</code>。</p>
<p>没有办法获得对 <code>pinned future</code> 的 <code>&amp;mut</code> 引用：如果你想，可以使用 <code>std::mem::replace</code> 或 <code>std::mem::swap</code> 将其移出并放置一个不同的<code>future</code>。</p>
<p>我们不必担心在普通异步代码中 <code>pinned future</code> 的原因是，获取<code>future</code>值的最常见方法是通过<code>await</code>或传递给执行器，它们都拥有<code>future</code> 的所有权并在内部将它固定。例如，我们的 <code>block_on</code> 实现获得了<code>future</code>的所有权并使用了 <code>pin！</code>来生成轮询所需的 <code>Pin&lt;&amp;mut F&gt;</code>，<code>await</code> 表达式也拥有<code>future</code>的所有权，并使用类似于 <code>pin!</code> 的内部宏。</p>
<h4 id="UnPin"><a href="#UnPin" class="headerlink" title="UnPin"></a><code>UnPin</code></h4><p>但是，并非所有 <code>future</code> 都需要这种谨慎处理。对于普通类型的 <code>Future</code> 的任何手写实现，例如前面提到的 <code>SpawnBlocking</code> 类型，对构造和使用<code>pinned pointer</code>的限制是不必要的。这种类型实现了 <a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html"><code>Unpin</code></a> 标记特性：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Unpin</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 中的几乎所有类型都使用编译器中的特殊支持自动实现 <code>Unpin</code>。异步函数和代码块的<code>future</code>例外。对于 <code>Unpin</code> 类型，<code>Pin</code> 没有任何限制。可以使用 <code>Pin::new</code> 从普通指针创建一个固定指针，然后使用 <code>Pin::into_inner</code> 将指针取出。<code>Pin</code> 本身传递指针自己的 <code>Deref</code> 和 <code>DerefMut</code> 实现。</p>
<p>比如<code>String</code>实现了<code>Unpin</code>，那么我们可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string</span> = <span class="string">&quot;Pinned?&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">pinned</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="type">String</span>&gt; = Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> string);</span><br><span class="line">pinned.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; Not&quot;</span>);</span><br><span class="line">Pin::<span class="title function_ invoke__">into_inner</span>(pinned).<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; so much.&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_home</span> = string;</span><br><span class="line"><span class="built_in">assert_eq!</span>(new_home, <span class="string">&quot;Pinned? Not so much.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>即使在创建了 <code>Pin&lt;&amp;mut String&gt;</code> 之后，我们也可以完全可变地访问字符串，并且一旦 <code>Pin</code> 被 <code>into_inner</code> 消耗并且可变引用消失，我们就可以将其移动到新变量中。因此，对于 <code>Unpin</code> 类型（几乎是所有类型）而言，<code>Pin</code> 是指向该类型的指针的无聊包装器。</p>
<p>这意味着当为自己的 <code>Unpin</code> 类型实现 <code>Future</code> 时，<code>poll</code> 实现可以将 <code>self</code> 视为 <code>&amp;mut Self</code>，而不是 <code>Pin&lt;&amp;mut Self&gt;</code>。</p>
<p>得知 <code>Pin&lt;&amp;mut F&gt;</code> 和 <code>Pin&lt;Box&lt;F&gt;&gt;</code> 实现了 <code>Unpin</code>，即使 <code>F</code> 没有实现，这可能会令人惊讶。因为即使 <code>F</code> 一旦被轮询就不能安全移动，指向它的指针总是可以安全移动，无论是否轮询。</p>
<p>这对于了解何时要将异步函数或代码块的 <code>future</code> 传递给只接受 <code>Unpin futures</code> 的函数很有用，<code>Pin&lt;Box&lt;F&gt;&gt;</code> 是 <code>Unpin</code>，即使 <code>F</code> 不是，因此将 <code>Box::pin</code> 应用于异步函数或代码块<code>future</code>会给你一个未来您可以在任何地方使用，但要以堆分配为代价。</p>
<p>有多种使用 <code>Pin</code> 的不安全方法可以让您对指针及其目标执行任何喜欢的操作，即使对于不是 <code>Unpin</code> 的目标类型也是如此。</p>
<h3 id="何时使用异步"><a href="#何时使用异步" class="headerlink" title="何时使用异步"></a>何时使用异步</h3><p>异步代码比多线程代码更难编写，因为必须使用正确的 <code>I/O</code> 和同步原语，手动分解长时间运行的计算或将它们分离到其他线程上，并处理多线程代码中不会出现的其他细节，例如 <code>pinning</code>。那么异步代码提供了哪些具体优势呢？</p>
<p>经常听到的两种说法经不起仔细检查：</p>
<ul>
<li><p><strong>异步代码非常适合 I&#x2F;O</strong>，这并不完全正确。如果的应用程序花费时间等待 <code>I/O</code>，使其异步不会使 <code>I/O</code> 运行得更快。当今普遍使用的异步 <code>I/O</code> 接口没有什么比同步接口更高效，无论哪种方式，操作系统都有相同的工作要做。（事实上​​，未准备好的异步 <code>I/O</code> 操作必须稍后再试一次，因此需要两次系统调用才能完成，而不是一次。）</p>
</li>
<li><p><strong>异步代码比多线程代码更容易编写</strong>。在 <code>JavaScript</code> 和 <code>Python</code> 等语言中，这很可能是真的。在那些语言中，程序员使用 <code>async/await</code> 作为表现良好的并发形式：有一个执行线程，并且中断只发生在 <code>await</code> 表达式中。当任务切换仅在我们明确许可的情况下发生时，更容易理解您的代码。</p>
<p>  但是这个论点并没有延续到 <code>Rust</code>，线程没有那么麻烦。一旦程序编译完成，它就没有数据竞争了。非确定性行为仅限于同步功能，如互斥锁、通道、原子等，这些功能旨在应对这种情况。因此，异步代码没有独特的优势，这在所有安全的 Rust 代码中都很清楚。</p>
<p>  当然，当与线程结合使用时，<code>Rust</code> 的异步支持真的很出色，放弃它会很可惜。</p>
</li>
</ul>
<p>那么，异步代码的真正优势是什么？</p>
<ul>
<li><p>异步任务可以使用更少的内存。在 <code>Linux</code> 上，线程的内存使用量从 <code>20 KiB</code> 开始，包括用户和内核空间。<code>Futures</code> 可以小得多：我们的聊天服务器的 <code>futures</code> 大小只有几百字节，并且随着 <code>Rust</code> 编译器的改进而变得越来越小；</p>
</li>
<li><p>异步任务的创建速度更快。在 Linux 上，创建一个线程大约需要 <code>15 µs</code>。生成一个异步任务大约需要 <code>300 ns</code>，大约是五十分之一的时间；</p>
</li>
<li><p>异步任务之间的上下文切换比操作系统线程之间的切换要快，<code>0.2 µs vs 1.7 µs</code>。但是，这些是每个任务的最佳情况数字：如果切换是由于 <code>I/O</code> 准备就绪，则两种成本都会增加至 <code>1.7 µs</code>。切换是在不同处理器内核上的线程还是任务之间切换也有很大的不同：内核之间的通信非常慢；</p>
</li>
</ul>
<p>这给了我们一个关于异步代码可以解决什么样的问题的提示。例如，异步服务器每个任务可能使用更少的内存，因此能够处理更多的同时连接。（这可能是异步代码以“适合 I&#x2F;O”而闻名的地方。）或者，如果您的设计自然地组织为许多相互通信的独立任务，那么每个任务的成本低、创建时间短，并且快速上下文切换都是重要的优势。这就是为什么聊天服务器是异步编程的经典示例，但多人游戏和网络路由器也可能是很好的用途。</p>
<p>在其他情况下，使用异步的情况不太清楚。如果程序有一个线程池正在执行大量计算或处于空闲状态等待 <code>I/O</code> 完成，那么前面列出的优点可能不会对其性能产生很大影响。而是必须优化计算，找到一个更快的网络连接，或者做一些实际影响限制因素的事情。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】结构体</title>
    <url>/2022/06/22/%E3%80%90Rust%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p><code>Rust</code> 中也有结构体，类似 <code>C/C++</code> 中的结构体，<code>python</code> 中的 <code>class</code> 以及 <code>javascript</code> 中的对象。<code>Rust</code> 中除了常规的结构体之外，还有 <code>tuple</code> 结构体，单元结构体。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p><code>Rust</code> 中约定包括结构体在内的所有类型都采用驼峰法命名，并且首字母大写，而方法和字段采用蛇形命名，即 <code>_</code> 连接小写单词。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A rectangle of eight-bit grayscale pixels.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GrayscaleMap</span> &#123;</span><br><span class="line">    pixels: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    size: (<span class="type">usize</span>, <span class="type">usize</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体初始化：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">width</span> = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">height</span> = <span class="number">576</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">image</span> = GrayscaleMap &#123;</span><br><span class="line">    pixels: <span class="built_in">vec!</span>[<span class="number">0</span>; width * height],</span><br><span class="line">    size: (width, height)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果局部变量或者函数参数和字段名称同名，还可以省略字段名称，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">new_map</span>(size: (<span class="type">usize</span>, <span class="type">usize</span>), pixels: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> GrayscaleMap &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(pixels.<span class="title function_ invoke__">len</span>(), size.<span class="number">0</span> * size.<span class="number">1</span>);</span><br><span class="line">    GrayscaleMap &#123; pixels, size &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段访问采用 <code>.</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(image.size, (<span class="number">1024</span>, <span class="number">576</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(image.pixels.<span class="title function_ invoke__">len</span>(), <span class="number">1024</span> * <span class="number">576</span>);</span><br></pre></td></tr></table></figure>

<p>结构体默认只能在当前模块和子模块中使用，如果想要导出结构体需要使用 <code>pub</code> 标识，字段也是同样的道理，如果字段都是私有的，那么只能使用类似 <code>Vec::new</code> 的构造方法来初始化字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A rectangle of eight-bit grayscale pixels.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GrayscaleMap</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pixels: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> size: (<span class="type">usize</span>, <span class="type">usize</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用相同类型的结构变量去初始化另外一个，使用 <code>..</code> 运算符，自动填充未显示赋值的字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">    sex: <span class="type">char</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">28</span>,</span><br><span class="line">        sex: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;skye&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        ..p1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p1: &#123;:?&#125;, pw: &#123;:?&#125;&quot;</span>, p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>p2</code> 除了 <code>name</code> 字段是显示赋值的，其他两个字段都是来源于 <code>p1</code>，这段代码运行之后将输出：</p>
<pre><code>p1: Person &#123; name: &quot;michael&quot;, age: 28, sex: &#39;男&#39; &#125;, pw: Person &#123; name: &quot;skye&quot;, age: 28, sex: &#39;男&#39; &#125;
</code></pre>
<span id="more"></span>


<h3 id="tuple-结构体"><a href="#tuple-结构体" class="headerlink" title="tuple 结构体"></a><code>tuple</code> 结构体</h3><p>之所以叫<code>tuple</code>结构体是因为它长得像，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bounds</span>(<span class="type">usize</span>, <span class="type">usize</span>);</span><br></pre></td></tr></table></figure>

<p>构造<code>tuple</code>结构体就像构造 <code>tuple</code>，只是需要写一个类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">image_bounds</span> = <span class="title function_ invoke__">Bounds</span>(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就连字段访问方式也是一样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(image_bounds.<span class="number">0</span> * image_bounds.<span class="number">1</span>, <span class="number">786432</span>);</span><br></pre></td></tr></table></figure>

<p>内部字段也可以设置访问权限，即是否导出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Bounds</span>(<span class="keyword">pub</span> <span class="type">usize</span>, <span class="keyword">pub</span> <span class="type">usize</span>);</span><br></pre></td></tr></table></figure>

<p>表达式 <code>Bounds(1024, 768)</code> 看起来像一个函数调用，实际上它就是，定义类型的同时也隐式定义了一个函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">Bounds</span>(elem0: <span class="type">usize</span>, elem1: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Bounds &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>tuple</code> 结构体和常规的结构体基本上是类似的，使用哪个取决于易读性和简洁性。</p>
<h3 id="Unit-结构体"><a href="#Unit-结构体" class="headerlink" title="Unit 结构体"></a><code>Unit</code> 结构体</h3><p><code>Unit 结构体</code> 没有字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Onesuch</span>;</span><br></pre></td></tr></table></figure>

<p>这种类型的值不占用内存，很像单元类型<code>()</code>，只是它有自己的类型名称，但它的值只能有一个：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">o</span> = Onesuch;</span><br></pre></td></tr></table></figure>

<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>常规结构体和 <code>tuple</code> 结构体在内存中的是一样的，它们都包含一系列的值，可能同类型也可能混合类型，例如我们上面定义的结构体：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GrayscaleMap</span> &#123;</span><br><span class="line"> pixels: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line"> size: (<span class="type">usize</span>, <span class="type">usize</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>C</code> 和 <code>C++</code> 不同，<code>Rust</code> 没有就如何在内存中对结构的字段或元素进行排序做出具体承诺，<code>Rust</code> 可能为了内存对齐进行调整字段顺序，所以下图仅显示了一种可能的布局：</p>
<img data-src="/2022/06/22/%E3%80%90Rust%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/struct-layout.png" class="">

<p>但是，<code>Rust</code> 确实承诺将字段的值直接存储在结构的内存块中。 <code>JavaScript</code>、<code>Python</code> 和 <code>Java</code> 会将 <code>pixels</code> 和 <code>size</code> 值分别放在它们自己的堆分配块中，并让 <code>GrayscaleMap</code> 的字段指向它们，而 <code>Rust</code> 将 <code>pixels</code> 和 <code>size</code> 直接嵌入到 <code>GrayscaleMap</code> 值中， 只有 <code>pixels</code> 向量拥有的堆分配缓冲区保留在其自己的块中。</p>
<p>您可以使用 <a href="(https://doc.rust-lang.org/stable/reference/type-layout.html#representations)"><code>#[repr(C)]</code></a> 属性要求 <code>Rust</code> 以与 <code>C</code> 和 <code>C++</code> 兼容的方式布局结构体。</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Rust</code> 方法不像在 <code>C</code>，<code>Go</code> 或者 <code>Java</code> 中那样出现在结构体定义中，而是出现在单独的 <code>impl</code> 块中。一个 <code>impl</code> 块只是 <code>fn</code> 定义的集合，每个定义都成为块顶部命名的结构类型上的一个方法。在这里，例如，我们定义一个 <code>public struct Queue</code>，然后给它两个 <code>public</code> 方法，<code>push</code> 和 <code>pop</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// A first-in, first-out queue of characters.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    older: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt;, <span class="comment">// older elements, eldest last.</span></span><br><span class="line">    younger: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; <span class="comment">// younger elements, youngest last.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// Push a character onto the back of a queue.</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, c: <span class="type">char</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.younger.<span class="title function_ invoke__">push</span>(c);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// Pop a character off the front of a queue. Return `Some(c)` if there</span></span><br><span class="line"> <span class="comment">/// was a character to pop, or `None` if the queue was empty.</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.older.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.younger.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bring the elements in younger over to older, and put them in</span></span><br><span class="line">        <span class="comment">// the promised order.</span></span><br><span class="line">        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">        <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.older, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.younger);</span><br><span class="line">        <span class="keyword">self</span>.older.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now older is guaranteed to have something. Vec&#x27;s pop method</span></span><br><span class="line">    <span class="comment">// already returns an Option, so we&#x27;re set.</span></span><br><span class="line">    <span class="keyword">self</span>.older.<span class="title function_ invoke__">pop</span>()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在 <code>impl</code> 块中的称之为关联函数，因为和特定的类型有关，相反，没有定义在 <code>impl</code> 中称之为自由函数。</p>
<p><code>Rust</code> 将调用它的值作为第一个参数传递给方法，该参数必须具有特殊名称 <code>self</code>，<code>self</code> 的类型可以省略，所以 <code>self</code>，<code>&amp;self</code> 或者 <code>&amp;mut self</code> 实际上是 <code>self: Queue</code>， <code>self: &amp;Queue</code>， 或者 <code>self: &amp;mut Queue</code> 的简写。</p>
<p>在我们的示例中，<code>push</code> 和 <code>pop</code> 在内部使用 <code>self</code> 访问内部成员，这与 <code>C++</code> 和 <code>Java</code> 不同，<code>this</code> 对象的成员在方法中直接可见，而 <code>Rust</code> 必须要使用 <code>self</code> 来访问。</p>
<p>这里由于 <code>push</code> 和 <code>pop</code> 都需要修改 <code>Queue</code>，所以它们的取值都是 <code>&amp;mut self</code>，但是我们调用时没必要显示借用可变引用，<code>Rust</code> 会为我们隐式进行转换，例如，<code>q.push</code> 等价于 <code>(&amp;mut q).push()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = Queue &#123; older: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(), younger: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>() &#125;;</span><br><span class="line">q.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">q.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(q.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"></span><br><span class="line">q.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;∞&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(q.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;1&#x27;</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(q.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;∞&#x27;</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(q.<span class="title function_ invoke__">pop</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>如果不需要改变 <code>self</code>，那我们可以只获取一个共享引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_empty</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.older.<span class="title function_ invoke__">is_empty</span>() &amp;&amp; <span class="keyword">self</span>.younger.<span class="title function_ invoke__">is_empty</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想获取所有权，那么使用 <code>self</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">split</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">Vec</span>&lt;<span class="type">char</span>&gt;, <span class="type">Vec</span>&lt;<span class="type">char</span>&gt;) &#123;</span><br><span class="line">        (<span class="keyword">self</span>.older, <span class="keyword">self</span>.younger)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针诸如 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 以及 <code>Arc&lt;T&gt;</code> 都可以调用 <code>self</code> 类型的方法，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bq</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Queue::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Queue::push` expects a `&amp;mut Queue`, but `bq` is a `Box&lt;Queue&gt;`.</span></span><br><span class="line"><span class="comment">// This is fine: Rust borrows a `&amp;mut Queue` from the `Box` for the</span></span><br><span class="line"><span class="comment">// duration of the call.</span></span><br><span class="line">bq.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;■&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们也可以将方法的第一个参数类型改成 <code>Rc&lt;Self&gt;</code>，下面的例子中，我们将一个节点添加到父节点中，但是保留 <code>shared_node</code> 的所有权，以在 <code>main</code> 函数中仍然可用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    tag: <span class="type">String</span>,</span><br><span class="line">    children: <span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(tag: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Node &#123;</span><br><span class="line">        Node &#123;</span><br><span class="line">            tag: tag.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            children: <span class="built_in">vec!</span>[],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">append_to</span>(<span class="keyword">self</span>: Rc&lt;<span class="keyword">Self</span>&gt;, parent: &amp;<span class="keyword">mut</span> Node) &#123;</span><br><span class="line">        parent.children.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parent</span> = Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;tag&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shared_node</span> = Rc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">    shared_node.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">append_to</span>(&amp;<span class="keyword">mut</span> parent);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>Rc&lt;Self&gt;</code> 作为方法的参数，这意味着：</p>
<ul>
<li><p>我们可以转移 <code>Rc&lt;Self&gt;</code> 的所有权，例如，上面的例子我们可以直接调用：<code>shared_node.append_to(&amp;mut parent);</code>，只是这样，父函数中 <code>shared_node</code> 就不可用了；</p>
</li>
<li><p>如果它需要保留 <code>Rc</code> 的所有权，可以像上面这样通过增加引用计数的方式实现；</p>
</li>
</ul>
<p><a href="https://stackoverflow.com/questions/25462935/what-types-are-valid-for-the-self-parameter-of-a-method">这里有更多的例子</a>。</p>
<h3 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h3><p><code>impl</code> 中定义的函数也可以不将 <code>self</code> 作为它们的参数，这个时候称之为类型方法，就像 <code>Vec::new</code>，经常被用于去实现构造函数，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Queue &#123;</span><br><span class="line">        Queue &#123; older: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(), younger: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Rust</code> 中，将构造函数命名为 <code>new</code> 是惯例，我们已经看到了 <code>Vec::new</code>、<code>Box::new</code>、<code>HashMap::new</code> 等，但是<code>new</code>这个名字并没有什么特别之处，它不是关键字，并且类型通常具有其他关联的函数作为构造函数，例如 <code>Vec::with_capacity</code>。</p>
<p><strong>尽管可以为单个类型拥有许多单独的 <code>impl</code> 块，但它们必须都位于定义该类型的同一个 <code>crate</code> 中。</strong></p>
<h3 id="关联常量"><a href="#关联常量" class="headerlink" title="关联常量"></a>关联常量</h3><p>顾名思义，关联的 <code>const</code> 是常量值，它们通常用于指定类型的常用值。例如，可以定义一个用于线性代数的二维向量以及相关的单位向量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ZERO: Vector2 = Vector2 &#123; x: <span class="number">0.0</span>, y: <span class="number">0.0</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> UNIT: Vector2 = Vector2 &#123; x: <span class="number">1.0</span>, y: <span class="number">0.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与关联函数非常相似，它们通过命名它们关联的类型来访问：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">scaled</span> = Vector2::UNIT.<span class="title function_ invoke__">scaled_by</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>关联的 <code>const</code> 也不必与它关联的类型具有相同的类型; 我们可以使用此功能为类型添加 <code>ID</code> 或名称：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NAME: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;Vector2&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> ID: <span class="type">u32</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型结构体"><a href="#泛型结构体" class="headerlink" title="泛型结构体"></a>泛型结构体</h3><p><code>Rust</code> 支持泛型，泛型可以用于处理逻辑相同，但类型不同的场景，例如，我们可以对之前的 <code>Queue</code> 结构体修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Queue</span>&lt;T&gt; &#123;</span><br><span class="line">    older: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">    younger: <span class="type">Vec</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将 <code>Queue&lt;T&gt;</code> 中的 <code>&lt;T&gt;</code> 解读为 <code>对于任何元素类型 T...</code>，所以这个定义解读为：<code>对于任何类型 T，一个 Queue&lt;T&gt; 是两个 Vec&lt;T&gt; 类型的字段</code>。例如，在 <code>Queue&lt;String&gt;</code> 中，<code>T</code> 是 <code>String</code>，因此 <code>older</code> 和 <code>younger</code> 的类型为 <code>Vec&lt;String&gt;</code>。在 <code>Queue&lt;char&gt;</code> 中，<code>T</code> 是 <code>char</code>，事实上，<code>Vec</code> 本身就是一个泛型结构体。</p>
<p>在泛型结构定义中，<code>&lt;&gt;</code> 中使用的类型名称称为<code>类型参数</code>。泛型结构的 <code>impl</code> 块如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Queue&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Queue&lt;T&gt; &#123;</span><br><span class="line">        Queue &#123; older: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(), younger: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, t: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.younger.<span class="title function_ invoke__">push</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_empty</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.older.<span class="title function_ invoke__">is_empty</span>() &amp;&amp; <span class="keyword">self</span>.younger.<span class="title function_ invoke__">is_empty</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将 <code>impl&lt;T&gt; Queue&lt;T&gt;</code> 解读为 <code>对于任何类型的 T，以下是 Queue&lt;T&gt; 上可用的一些关联函数</code>。然后，可以使用类型参数 <code>T</code> 作为关联函数定义中的类型。</p>
<p>语法可能看起来有点多余，但 <code>impl&lt;T&gt;</code> 清楚地表明 <code>impl</code> 块涵盖任何类型 <code>T</code>，这将它与为一种特定类型的 <code>Queue</code> 编写的 <code>impl</code> 块区分开来，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Queue</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的意思是，这有一些专门为 <code>Queue&lt;f64&gt;</code> 实现的关联函数，其他类型不可用。</p>
<p>我们在前面的代码中使用了 <code>Rust</code> 的 <code>self</code> 参数简写，因为到处写出 <code>Queue&lt;T&gt;</code> 也很啰嗦，所以有了另一种简写，每个 <code>impl</code> 块，无论是否通用，都将特殊类型参数 <code>Self</code> 定义为我们要添加方法的任何类型。在前面的代码中，<code>Self</code> 是 <code>Queue&lt;T&gt;</code>，所以我们可以进一步简化 <code>Queue::new</code> 的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    Queue &#123; older: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(), younger: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>new</code> 函数中，我们的构造表达式没有任何类型，只写了 <code>Queue&#123; ... &#125;</code>，是因为 <code>Rust</code> 可以函数的签名推断，因为这里只有一种类型 <code>Self，即 Queue&lt;T&gt;</code> 用于函数的返回值。我们也可以使用 <code>Self &#123; ... &#125;</code> 代替上面的 <code>Queue&#123; ... &#125;</code>。</p>
<p>对于关联函数的调用，我们需要使用 <code>tuborfish</code> 运算符：<code>::&lt;&gt;</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = Queue::&lt;<span class="type">char</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>
<p>但是实际应用中，经常交由 <code>Rust</code> 进行推断：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = Queue::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = Queue::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">q.<span class="title function_ invoke__">push</span>(<span class="string">&quot;CAD&quot;</span>); <span class="comment">// apparently a Queue&lt;&amp;&#x27;static str&gt;</span></span><br><span class="line">r.<span class="title function_ invoke__">push</span>(<span class="number">0.74</span>); <span class="comment">// apparently a Queue&lt;f64&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体生命周期参数"><a href="#结构体生命周期参数" class="headerlink" title="结构体生命周期参数"></a>结构体生命周期参数</h3><p>如果结构体类型包含引用，则必须声明这些引用的生命周期。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Extrema</span>&lt;<span class="symbol">&#x27;elt</span>&gt; &#123;</span><br><span class="line">    greatest: &amp;<span class="symbol">&#x27;elt</span> <span class="type">i32</span>,</span><br><span class="line">    least: &amp;<span class="symbol">&#x27;elt</span> <span class="type">i32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>struct Extrema&lt;&#39;elt&gt;</code> 意味着，给定任何特定的生命周期 <code>&#39;elt</code>，你可以创建一个 <code>Extrema&lt;&#39;elt&gt;</code> 来保存具有该生命周期的引用。这是一个扫描切片并返回最大最小值的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_extrema</span>&lt;<span class="symbol">&#x27;s</span>&gt;(slice: &amp;<span class="symbol">&#x27;s</span> [<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> Extrema&lt;<span class="symbol">&#x27;s</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">greatest</span> = &amp;slice[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">least</span> = &amp;slice[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..slice.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> slice[i] &lt; *least &#123; least = &amp;slice[i]; &#125;</span><br><span class="line">        <span class="keyword">if</span> slice[i] &gt; *greatest &#123; greatest = &amp;slice[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Extrema &#123; greatest, least &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，由于 <code>find_extrema</code> 借用了 <code>slice</code> 的元素，它具有生命周期 <code>&#39;s</code>，所以我们返回的 <code>Extrema</code> 结构体也使用 <code>&#39;s</code> 作为其引用的生命周期。<code>Rust</code> 总是会推断函数调用的生命周期参数，因此对 <code>find_extrema</code> 的调用不需要提及它们：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">0</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">48</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">e</span> = <span class="title function_ invoke__">find_extrema</span>(&amp;a);</span><br><span class="line"><span class="built_in">assert_eq!</span>(*e.least, -<span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(*e.greatest, <span class="number">48</span>);</span><br></pre></td></tr></table></figure>

<p>因为返回类型与参数使用相同的生命周期是很常见的，所以当有一个明显的候选者时，<code>Rust</code> 允许我们省略生命周期。我们也可以这样写 <code>find_extrema</code> 的签名，但含义不变：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_extrema</span>(slice: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> Extrema &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用-Trait-派生"><a href="#常用-Trait-派生" class="headerlink" title="常用 Trait 派生"></a>常用 <code>Trait</code> 派生</h3><p>通常我们自己的定义的结构体是不支持 <code>&#123;:?&#125;</code> 打印，比较，深拷贝的，如果我们像这样做，就得实现 <code>Copy</code>，<code>Debug</code>，以及 <code>PartialEq</code>，但如果每一次都手动实现，就显得有点痛苦了，好在 <code>Rust</code> 提供了 <code>#[derive]</code> 属性来自动帮我们实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果结构体的每个字段都实现了该 <code>trait</code>，则这些 <code>trait</code> 中的每一个都可以为结构体自动实现。我们可以要求 <code>Rust</code> 为 <code>Point</code> 派生 <code>PartialEq</code>，因为它的两个字段都是 <code>f64</code> 类型，它已经实现了 <code>PartialEq</code>。</p>
<h3 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h3><p>内部可变性，简单说就是我们想改变一个不可变的数据，常规做法肯定是行不通的，但是在我们引入两个：<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> 和 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> 之后就能解决了。</p>
<p>我们来看一个例子，假设我们要做一个数据采集系统，采集不同类型的站点，但是它们都有一个共同的配置以及某些文件操作句柄用于处理日志等，我们在程序启动的时候，可能就初始化它了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpiderRobot</span> &#123;</span><br><span class="line">    species: <span class="type">String</span>,</span><br><span class="line">    web_enabled: <span class="type">bool</span>,</span><br><span class="line">    leg_devices: [fd::FileDesc; <span class="number">8</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，假设我们在采集某个类型的系统时，拥有下面这样的结构体，包含了公共的配置：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpiderSenses</span> &#123;</span><br><span class="line">    robot: Rc&lt;SpiderRobot&gt;, <span class="comment">// &lt;-- pointer to settings and I/O</span></span><br><span class="line">    eyes: [Camera; <span class="number">32</span>],</span><br><span class="line">    motion: Accelerometer,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 <code>Rc</code> 是一个通过计数实现的只读智能指针，但是我们想在 <code>SpiderRobot</code> 中保留一个文件句柄，它是标准的 <code>File</code> 类型，用来写日志，不过有个问题是，<code>File</code> 必须是 <code>Muteable</code>，因为它所有的方法都要求一个可变引用。</p>
<p>这种情况非常常见，这叫做内部可变性，<code>Rust</code> 为此专门提供了几种类型来解决问题，我们这里先介绍 <code>Cell&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code>。</p>
<h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell&lt;T&gt;"></a><code>Cell&lt;T&gt;</code></h4><p><code>Cell&lt;T&gt;</code> 是一个结构体，它包含一个类型为 <code>T</code> 的私有字段。<code>Cell</code> 的唯一特殊之处在于，即使 <code>Cell</code> 本身没有 <code>mut</code> 访问权限，您也可以获取和设置字段：</p>
<ul>
<li><p><code>Cell::new(value)</code>：创建新的 <code>Cell</code>，并且将给定的 <code>value</code> 移动到里面去；</p>
</li>
<li><p><code>cell.get()</code>： 返回 <code>Cell</code> 中 <code>value</code> 的副本；</p>
</li>
<li><p><code>cell.set(value)</code>：将给定的 <code>value</code> 存储到 <code>cell</code> 中，丢掉原先的值，这个方法不许 <code>cell</code> 可变，它的实现如下：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">self</span>, val: T) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">replace</span>(val);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当然，这对于名为 <code>set</code> 的方法来说是不寻常的。因为从之前的学习来说，如果我们想要对数据进行更改，我们需要 <code>mut</code> 访问。但出于同样的原因，这一不寻常的细节是 <code>Cell</code> 的全部意义所在，具体背景可参考 <code>Cell</code> 的源代码实现。</p>
</li>
</ul>
<p>通过，<code>Cell</code> 我们可以在 <code>SpiderRobot</code> 中统计错误数量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpiderRobot</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    hardware_error_count: Cell&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，即使 <code>SpiderRobot</code> 的非 <code>mut</code> 方法也可以使用 <code>.get()</code> 和 <code>.set()</code> 方法访问该 <code>u32</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">SpiderRobot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Increase the error count by 1.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_hardware_error</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = <span class="keyword">self</span>.hardware_error_count.<span class="title function_ invoke__">get</span>();</span><br><span class="line">        <span class="keyword">self</span>.hardware_error_count.<span class="title function_ invoke__">set</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// True if any hardware errors have been reported.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">has_hardware_errors</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.hardware_error_count.<span class="title function_ invoke__">get</span>() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>Cell</code> 不能让我们调用值得 <code>mut</code> 方法，因为 <code>get</code> 返回的是一个副本，所以它仅仅只能用于实现了 <code>Copy</code> 的类型。</p>
<h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h4><p><code>RefCell&lt;T&gt;</code> 和 <code>Cell&lt;T&gt;</code> 不同的是，他可以返回内部值得引用：</p>
<ul>
<li><p><code>RefCell::new(value)</code>：创建新的 <code>RefCell</code>；</p>
</li>
<li><p><code>ref_cell.borrow()</code>：返回一个 <a href="https://doc.rust-lang.org/std/cell/struct.Ref.html"><code>Ref&lt;T&gt;</code></a>，这本质上只是对存储在 ref_cell 中的值的共享引用；</p>
</li>
<li><p><code>ref_cell.borrow_mut()</code>：返回 <a href="https://doc.rust-lang.org/std/cell/struct.RefMut.html"><code>RefMut&lt;T&gt;</code></a>，本质上是对 <code>ref_cell</code> 中值的可变引用。 如果该值已被借用，则此方法会<code>panic</code>； </p>
</li>
<li><p><code>ref_cell.try_borrow(), ref_cell.try_borrow_mut()</code>：很像 <code>borrow</code> 和 <code>borrow_mut</code>，但是返回 <code>Result</code>。所以当值已经被借用之后，不会 <code>panic</code>，而是返回 <code>Err</code>。</p>
</li>
</ul>
<p>只有当你试图打破 <code>mut</code> 引用是独占引用的 <code>Rust</code> 规则时，这两个借用方法才会 <code>panic</code>。例如，这会 <code>panic</code>：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref_cell</span>: RefCell&lt;<span class="type">String</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = ref_cell.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// ok, returns a Ref&lt;String&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = r.<span class="title function_ invoke__">len</span>(); <span class="comment">// ok, returns &quot;hello&quot;.len()</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(count, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = ref_cell.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// panic: already borrowed</span></span><br><span class="line">w.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="回归正途"><a href="#回归正途" class="headerlink" title="回归正途"></a>回归正途</h4><p>现在，我们使用 <code>RefCell&lt;T&gt;</code> 来完成我们打印日志的功能：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpiderRobot</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    log_file: RefCell&lt;File&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SpiderRobot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Write a line to the log file.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">log</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="keyword">self</span>.log_file.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">        <span class="comment">// `writeln!` is like `println!`, but sends</span></span><br><span class="line">        <span class="comment">// output to the given file.</span></span><br><span class="line">        <span class="built_in">writeln!</span>(file, <span class="string">&quot;&#123;&#125;&quot;</span>, message).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 <code>file</code> 的类型为 <code>RefMut&lt;File&gt;</code>，它可以像对 <code>File</code> 的可变引用一样使用。</p>
<p><code>Cell</code> 易于使用， 必须调用 <code>.get()</code> 和 <code>.set()</code> 或 <code>.borrow()</code> 和 <code>.borrow_mut()</code> 有点尴尬，但这只是我们为违反规则而付出的代价。 另一个缺点不太明显但更严重：<code>Cell</code> 以及包含它们的任何类型都不是线程安全的，因此，<code>Rust</code> 不允许多个线程同时访问它们。这种情况应该使用 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/">Models of Generics and Metaprogramming: Go, Rust, Swift, D and More</a></li>
</ol>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】枚举和模式匹配</title>
    <url>/2022/06/21/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>在 <code>Rust</code> 中，枚举也可以包含数据，甚至是不同类型的数据。例如，<code>Rust</code> 的 <code>Result&lt;String, io::Error&gt;</code> 类型是一个枚举，这样的值要么是包含字符串的 <code>Ok</code>值，要么是包含 <code>io::Error</code> 的 <code>Err</code> 值。</p>
<p>只要 <code>value</code> 只有一种可能，枚举就很有用。使用它们的代价是你必须安全地访问数据，使用模式匹配就可以完成。<code>Rust</code> 模式有点像正则表达式，它们用于检测一个值是否是想要的，他们也可以将结构体或<code>tuple</code>中的多个字段提取到局部变量中。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>来看一个标准库中枚举示例 <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>std::cmp::Ordering</code></a>，它有三种可能的值：<code>Ordering::Less</code>， <code>Ordering::Equal</code> 和 <code>Ordering::Greater</code>，称为变量或者构造函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[repr(i8)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Ordering</span> &#123;</span><br><span class="line">    Less,</span><br><span class="line">    Equal,</span><br><span class="line">    Greater,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在使用的时候可以直接导入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering::&#123;<span class="keyword">self</span>, *&#125;;</span><br></pre></td></tr></table></figure>

<p>如果导入当前模块的枚举的构造函数可以使用 <code>self</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    Orca,</span><br><span class="line">    Giraffe,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::Pet::*;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在内存中，<code>C</code> 风格的枚举值存储为整数，默认情况下，<code>Rust</code> 使用可以容纳它们的最小内置整数类型来存储 <code>C</code> 风格的枚举，大多是 <code>1</code> 字节，从 <code>0</code> 开始，但是也可以指定：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpStatus</span> &#123;</span><br><span class="line">    <span class="literal">Ok</span> = <span class="number">200</span>,</span><br><span class="line">    NotModified = <span class="number">304</span>,</span><br><span class="line">    NotFound = <span class="number">404</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是像上面的 <code>404</code>，<code>1 byte</code> 就不能容纳了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of;</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;Ordering&gt;(), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;HttpStatus&gt;(), <span class="number">2</span>); <span class="comment">// 404 doesn&#x27;t fit in a u8</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <a href="https://doc.rust-lang.org/stable/reference/type-layout.html#representations"><code>#[repr]</code></a> 属性覆盖 <code>Rust</code> 的选择，就像上面的 <code>Ordering</code>。</p>
<p>允许转换一个 <code>C</code> 风格的枚举值为整数，但是不能从整数转换为枚举值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(HttpStatus::<span class="literal">Ok</span> <span class="keyword">as</span> <span class="type">i32</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>与 <code>C</code> 和 <code>C++</code> 不同，<code>Rust</code> 保证枚举值只是枚举声明中拼写的值之一。从整数类型到枚举类型的未经检查的强制转换可能会破坏此保证，因此是不允许的。可以编写自己的转换函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">http_status_from_u32</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;HttpStatus&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        <span class="number">200</span> =&gt; <span class="title function_ invoke__">Some</span>(HttpStatus::<span class="literal">Ok</span>),</span><br><span class="line">        <span class="number">304</span> =&gt; <span class="title function_ invoke__">Some</span>(HttpStatus::NotModified),</span><br><span class="line">        <span class="number">404</span> =&gt; <span class="title function_ invoke__">Some</span>(HttpStatus::NotFound),</span><br><span class="line">        ...</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 <a href="https://crates.io/crates/enum_primitive"><code>enum_primitive</code></a>。</p>
<p>像结构体一样，可以让 <code>enum</code> 自动派生内置 <code>trait</code>，实现比较等运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TimeUnit</span> &#123;</span><br><span class="line">    Seconds, Minutes, Hours, Days, Months, Years,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他语言不同的是，<code>Enums</code> 可以有自己的方法，就像结构体：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TimeUnit</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the plural noun for this time unit.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">plural</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            TimeUnit::Seconds =&gt; <span class="string">&quot;seconds&quot;</span>,</span><br><span class="line">            TimeUnit::Minutes =&gt; <span class="string">&quot;minutes&quot;</span>,</span><br><span class="line">            TimeUnit::Hours =&gt; <span class="string">&quot;hours&quot;</span>,</span><br><span class="line">            TimeUnit::Days =&gt; <span class="string">&quot;days&quot;</span>,</span><br><span class="line">            TimeUnit::Months =&gt; <span class="string">&quot;months&quot;</span>,</span><br><span class="line">            TimeUnit::Years =&gt; <span class="string">&quot;years&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the singular noun for this time unit.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">singular</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">plural</span>().<span class="title function_ invoke__">trim_end_matches</span>(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举数据"><a href="#枚举数据" class="headerlink" title="枚举数据"></a>枚举数据</h3><p>枚举值可以带带参数，第一种就像 <code>tuple</code>结构体，这些枚举值就像构造函数一样可以创建枚举变量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RoughTime</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">InThePast</span>(TimeUnit, <span class="type">u32</span>),</span><br><span class="line">    JustNow,</span><br><span class="line">    <span class="title function_ invoke__">InTheFuture</span>(TimeUnit, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">four_score_and_seven_years_ago</span> = RoughTime::<span class="title function_ invoke__">InThePast</span>(TimeUnit::Years, <span class="number">4</span> * <span class="number">20</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">three_hours_from_now</span> = RoughTime::<span class="title function_ invoke__">InTheFuture</span>(TimeUnit::Hours, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>第二种枚举值就像结构体，参数可命名：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Sphere &#123; center: Point3d, radius: <span class="type">f32</span> &#125;,</span><br><span class="line">    Cuboid &#123; corner1: Point3d, corner2: Point3d &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">unit_sphere</span> = Shape::Sphere &#123;</span><br><span class="line">    center: ORIGIN,</span><br><span class="line">    radius: <span class="number">1.0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总之，<code>Rust</code> 有 <code>3</code> 种枚举，与 <code>3</code> 种 <code>struct</code> 相呼应，没有数据的枚举对应于类似 <code>unit</code> 结构体。单个枚举可以同时拥有这<code>3</code>种类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RelationshipStatus</span> &#123;</span><br><span class="line">    Single,</span><br><span class="line">    InARelationship,</span><br><span class="line">    <span class="title function_ invoke__">ItsComplicated</span>(<span class="type">Option</span>&lt;<span class="type">String</span>&gt;),</span><br><span class="line">    ItsExtremelyComplicated &#123;</span><br><span class="line">        car: DifferentialEquation,</span><br><span class="line">        cdr: EarlyModernistPoem,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存表示"><a href="#内存表示" class="headerlink" title="内存表示"></a>内存表示</h3><p>在内存中，带有数据的枚举被存储为一个小的整数标签，加上足够的内存来保存最大变体的所有字段。<code>tag</code> 字段供 <code>Rust</code> 内部使用，它告诉哪个构造函数创建了该值以及它具有哪些字段。</p>
<img data-src="/2022/06/21/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/enum-with-data-in-memory.png" class="">

<p>然而，<code>Rust</code> 没有对枚举布局做出任何承诺，以便为未来的优化敞开大门。在某些情况下，打包枚举的效率可能比图中所示的要高。</p>
<h3 id="Json-示例"><a href="#Json-示例" class="headerlink" title="Json 示例"></a><code>Json</code> 示例</h3><p>我们来看如何在代码中表示 <code>JSON</code> 数据，<code>JSON</code> 一共有 <code>6</code> 中数据类型：<code>NULL</code>，<code>Boolean(bool)</code>，<code>Number(f64)</code>，<code>String(String)</code>，<code>Array(Vec&lt;Json&gt;)</code>，和 <code>Object(Box&lt;HashMap&lt;String, Json&gt;&gt;)</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Json</span> &#123;</span><br><span class="line">    Null,</span><br><span class="line">    <span class="title function_ invoke__">Boolean</span>(<span class="type">bool</span>),</span><br><span class="line">    <span class="title function_ invoke__">Number</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">String</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Array</span>(<span class="type">Vec</span>&lt;Json&gt;),</span><br><span class="line">    <span class="title function_ invoke__">Object</span>(<span class="type">Box</span>&lt;HashMap&lt;<span class="type">String</span>, Json&gt;&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>json</code> 解析，可以查看 <a href="https://docs.serde.rs/serde_json/">serde_json</a>，<code>crates.io</code> 上最流行的库。</p>
<p>代表 <code>Object</code> 的 <code>HashMap</code> 周围的 <code>Box</code> 仅用于使所有 <code>Json</code> 值更紧凑，在内存中，<code>Json</code> 类型的值占用了 <code>4</code> 个机器字。 <code>String</code> 和 <code>Vec</code> 值是<code>3</code>个字节，<code>Rust</code> 增加了<code>1</code>个标记字节。<code>Null</code> 和 <code>Boolean</code> 值中没有足够的数据来用完所有空间，但所有 <code>Json</code> 值必须具有相同的大小，多余的空间未被使用。下图展示了 <code>Json</code> 值在内存中的布局，<code>Box&lt;HashMap&gt;</code> 是一个字：它只是一个指向堆分配数据的指针，我们通过 <code>Box</code> 使 <code>Json</code> 更加紧凑。</p>
<img data-src="/2022/06/21/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/json-enum-with-data-in-memory.png" class="">

<h3 id="泛型枚举"><a href="#泛型枚举" class="headerlink" title="泛型枚举"></a>泛型枚举</h3><p>枚举也可以是泛型的，这里有两个常用的例子 <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> 和 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>，和结构体的语法比较相似：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类型 <code>T</code> 是引用、<code>Box</code> 或其他智能指针类型时，<code>Rust</code> 可以消除 <code>Option&lt;T&gt;</code> 的 <code>tag</code> 字段。 由于这些指针类型都不允许为零，<code>Rust</code> 可以将 <code>Option&lt;Box&lt;i32&gt;&gt;</code> 表示为单个机器字：<code>0</code> 表示无，非零表示 <code>Some</code> 指针。这使得此类 <code>Option</code> 类型非常类似于可能为空的 <code>C</code> 或 <code>C++</code> 指针值。不同之处在于，<code>Rust</code> 的类型系统要求在使用其内容之前检查选项是否为 <code>Some</code>，这就避免了解引用空指针。</p>
<p>只需几行代码即可构建通用数据结构：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// An ordered collection of `T`s.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">BinaryTree</span>&lt;T&gt; &#123;</span><br><span class="line">    Empty,</span><br><span class="line">    <span class="title function_ invoke__">NonEmpty</span>(<span class="type">Box</span>&lt;TreeNode&lt;T&gt;&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A part of a BinaryTree.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    element: T,</span><br><span class="line">    left: BinaryTree&lt;T&gt;,</span><br><span class="line">    right: BinaryTree&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Ord</span>&gt; BinaryTree&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: T) &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            BinaryTree::Empty =&gt; &#123;</span><br><span class="line">                *<span class="keyword">self</span> = BinaryTree::<span class="title function_ invoke__">NonEmpty</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(TreeNode &#123;</span><br><span class="line">                    element: value,</span><br><span class="line">                    left: BinaryTree::Empty,</span><br><span class="line">                    right: BinaryTree::Empty,</span><br><span class="line">                &#125;))</span><br><span class="line">            &#125;</span><br><span class="line">            BinaryTree::<span class="title function_ invoke__">NonEmpty</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> node) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> value &lt;= node.element &#123;</span><br><span class="line">                    node.left.<span class="title function_ invoke__">add</span>(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.right.<span class="title function_ invoke__">add</span>(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这几行代码定义了一个可以存储任意数量的 <code>T</code> 类型值的 <code>BinaryTree</code>，每个 <code>BinaryTree</code> 要么为空要么不为空。如果是空的，那么什么数据都不包，如果不为空，那么它有一个 <code>Box</code>，包含一个指向堆数据的指针。</p>
<p>每个 <code>TreeNode</code> 值包含一个实际元素，以及另外两个 <code>BinaryTree</code> 值。这意味着树可以包含子树，因此 <code>NonEmpty</code> 树可以有任意数量的后代。<code>BinaryTree&lt;&amp;str&gt;</code> 类型值的示意图如下图所示。与 <code>Option&lt;Box&lt;T&gt;&gt;</code> 一样，<code>Rust</code> 消除了 <code>tag</code> 字段，因此 <code>BinaryTree</code> 值只是一个机器字。</p>
<img data-src="/2022/06/21/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/binarytree-with-data-in-memory.png" class="">

<p>构建这样一棵树可以用如下代码完成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> self::BinaryTree::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">jupiter_tree</span> = <span class="title function_ invoke__">NonEmpty</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(TreeNode &#123;</span><br><span class="line">    element: <span class="string">&quot;Jupiter&quot;</span>,</span><br><span class="line">    left: Empty,</span><br><span class="line">    right: Empty,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大树可以由小树构成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mars_tree</span> = <span class="title function_ invoke__">NonEmpty</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(TreeNode &#123;</span><br><span class="line">    element: <span class="string">&quot;Mars&quot;</span>,</span><br><span class="line">    left: jupiter_tree,</span><br><span class="line">    right: mercury_tree,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>枚举的缺点是访问里面的数据必须使用 <code>match</code> 模式匹配。</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>假设有一个 <code>RoughTime</code> 值，需要访问值内的 <code>TimeUnit</code> 和 <code>u32</code> 字段。<code>Rust</code> 不允许直接 <code>rough_time.0</code> 和 <code>rough_time.1</code> 直接访问它们，因为值可能是 <code>RoughTime::JustNow</code>，必须使用 <code>match</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RoughTime</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">InThePast</span>(TimeUnit, <span class="type">u32</span>),</span><br><span class="line">    JustNow,</span><br><span class="line">    <span class="title function_ invoke__">InTheFuture</span>(TimeUnit, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rough_time_to_english</span>(rt: RoughTime) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> rt &#123;</span><br><span class="line">        RoughTime::<span class="title function_ invoke__">InThePast</span>(units, count) =&gt;</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; ago&quot;</span>, count, units.<span class="title function_ invoke__">plural</span>()),</span><br><span class="line">        RoughTime::JustNow =&gt;</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;just now&quot;</span>),</span><br><span class="line">        RoughTime::<span class="title function_ invoke__">InTheFuture</span>(units, count) =&gt;</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; from now&quot;</span>, count, units.<span class="title function_ invoke__">plural</span>()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配枚举、结构体或元组就像 <code>Rust</code> 正在做一个简单扫描一样，依次检查每个 <code>pattern</code> 是否匹配。一个模式包含一些表示符，就像 <code>count</code> 和 <code>units</code>，匹配之后，枚举值内容都会被移动会复制到这些局部变量中，这些局部变量只能在当前模式中使用。</p>
<p><code>Rust</code> 的模式匹配除了匹配枚举值，还能匹配很多类型的数据，如下表所示：</p>
<img data-src="/2022/06/21/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/pattern-table.png" class="">

<h4 id="字面量、变量、通配符"><a href="#字面量、变量、通配符" class="headerlink" title="字面量、变量、通配符"></a>字面量、变量、通配符</h4><p>数值，字符，bool，字符串都可以用于模式匹配，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> meadow.<span class="title function_ invoke__">count_rabbits</span>() &#123;</span><br><span class="line">    <span class="number">0</span> =&gt; &#123;&#125; <span class="comment">// nothing to say</span></span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;A rabbit is nosing around in the clover.&quot;</span>),</span><br><span class="line">    n =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There are &#123;&#125; rabbits hopping about in the meadow&quot;</span>, n),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">calendar</span> = <span class="keyword">match</span> settings.<span class="title function_ invoke__">get_string</span>(<span class="string">&quot;calendar&quot;</span>) &#123;</span><br><span class="line">    <span class="string">&quot;gregorian&quot;</span> =&gt; Calendar::Gregorian,</span><br><span class="line">    <span class="string">&quot;chinese&quot;</span> =&gt; Calendar::Chinese,</span><br><span class="line">    <span class="string">&quot;ethiopian&quot;</span> =&gt; Calendar::Ethiopian,</span><br><span class="line">    other =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">parse_error</span>(<span class="string">&quot;calendar&quot;</span>, other),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>n</code> 和 <code>other</code> 都用于匹配其他的情况，可以使用 <code>_</code> 捕获剩余所有情况：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">caption</span> = <span class="keyword">match</span> photo.<span class="title function_ invoke__">tagged_pet</span>() &#123;</span><br><span class="line">    Pet::Tyrannosaur =&gt; <span class="string">&quot;RRRAAAAAHHHHHH&quot;</span>,</span><br><span class="line">    Pet::Samoyed =&gt; <span class="string">&quot;*dog thoughts*&quot;</span>,</span><br><span class="line">    _ =&gt; <span class="string">&quot;I&#x27;m cute, love me&quot;</span>, <span class="comment">// generic caption, works for any pet</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>要注意的是，<code>Rust</code> 中，必须为 <code>match</code> 列出所有可能情况，<code>_</code> 通常用来处理剩余的情况。</strong></p>
<h4 id="tuple、结构体匹配"><a href="#tuple、结构体匹配" class="headerlink" title="tuple、结构体匹配"></a><code>tuple</code>、结构体匹配</h4><p><code>tuple</code>模式匹配元组，当你想要在单个匹配中获取多条数据时，它们很有用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_point</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">use</span> std::cmp::Ordering::*;</span><br><span class="line">    <span class="title function_ invoke__">match</span> (x.<span class="title function_ invoke__">cmp</span>(&amp;<span class="number">0</span>), y.<span class="title function_ invoke__">cmp</span>(&amp;<span class="number">0</span>)) &#123;</span><br><span class="line">        (Equal, Equal) =&gt; <span class="string">&quot;at the origin&quot;</span>,</span><br><span class="line">        (_, Equal) =&gt; <span class="string">&quot;on the x axis&quot;</span>,</span><br><span class="line">        (Equal, _) =&gt; <span class="string">&quot;on the y axis&quot;</span>,</span><br><span class="line">        (Greater, Greater) =&gt; <span class="string">&quot;in the first quadrant&quot;</span>,</span><br><span class="line">        (Less, Greater) =&gt; <span class="string">&quot;in the second quadrant&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;somewhere else&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体模式使用花括号，就像结构体表达式一样。 它们包含每个字段的子模式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> balloon.location &#123;</span><br><span class="line">    Point &#123; x: <span class="number">0</span>, y: height &#125; =&gt;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;straight up &#123;&#125; meters&quot;</span>, height),</span><br><span class="line">    Point &#123; x: x, y: y &#125; =&gt;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;at (&#123;&#125;m, &#123;&#125;m)&quot;</span>, x, y),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果第一个模式匹配上，那么 <code>balloon.location.y</code> 将存储在 <code>height</code> 中。像 <code>Point &#123; x: x, y: y &#125;</code> 这样的模式在匹配结构体时很常见，冗余的名称在视觉上很混乱，所以 <code>Rust</code> 有一个简写：<code>Point &#123;x, y&#125;</code>， 意思是一样的。这种模式仍然将 <code>Point</code> 的 <code>x</code> 字段存储在新的本地 <code>x</code> 中，并将其 <code>y</code> 字段存储在新的本地 <code>y</code> 中。</p>
<p>即使使用简写，当我们只关心几个字段时，匹配一个大型结构也很麻烦：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">get_account</span>(id) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(Account &#123;</span><br><span class="line">        name, language, <span class="comment">// &lt;--- the 2 things we care about</span></span><br><span class="line">        id: _, status: _, address: _, birthday: _, eye_color: _,</span><br><span class="line">        pet: _, security_question: _, hashed_innermost_secret: _,</span><br><span class="line">        is_adamantium_preferred_customer: _, &#125;) =&gt;</span><br><span class="line">        language.<span class="title function_ invoke__">show_custom_greeting</span>(name),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>为了避免这个，可以使用 <code>..</code> 去告诉 <code>Rust</code> 不要关心剩余的字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">Some</span>(Account &#123; name, language, .. &#125;) =&gt;</span><br><span class="line">    language.<span class="title function_ invoke__">show_custom_greeting</span>(name),</span><br></pre></td></tr></table></figure>

<h4 id="数组、切片匹配"><a href="#数组、切片匹配" class="headerlink" title="数组、切片匹配"></a>数组、切片匹配</h4><p>模式可以匹配数组，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hsl_to_rgb</span>(hsl: [<span class="type">u8</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> [<span class="type">u8</span>; <span class="number">3</span>] &#123;</span><br><span class="line">    <span class="keyword">match</span> hsl &#123;</span><br><span class="line">        [_, _, <span class="number">0</span>] =&gt; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [_, _, <span class="number">255</span>] =&gt; [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>],</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片模式类似数组，不同的是切片具有可变长度，因此切片模式不仅匹配值，还要匹配长度，<code>..</code> 用于匹配任意数量的元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">greet_people</span>(names: &amp;[&amp;<span class="type">str</span>]) &#123;</span><br><span class="line">    <span class="keyword">match</span> names &#123;</span><br><span class="line">        [] =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;Hello, nobody.&quot;</span>) &#125;,</span><br><span class="line">        [a] =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;.&quot;</span>, a) &#125;,</span><br><span class="line">        [a, b] =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125; and &#123;&#125;.&quot;</span>, a, b) &#125;,</span><br><span class="line">        [a, .., b] =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;Hello, everyone from &#123;&#125; to &#123;&#125;.&quot;</span>, a, b) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ref-和"><a href="#ref-和" class="headerlink" title="ref 和 &amp;"></a><code>ref</code> 和 <code>&amp;</code></h4><p>匹配不可复制的值会转移所有权，例如下面这段代码编译失败：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> account &#123;</span><br><span class="line">    Account &#123; name, language, .. &#125; =&gt; &#123;</span><br><span class="line">        ui.<span class="title function_ invoke__">greet</span>(&amp;name, &amp;language);</span><br><span class="line">        ui.<span class="title function_ invoke__">show_settings</span>(&amp;account); <span class="comment">// error: borrow of moved value: `account`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>在这里，字段 <code>account.name</code> 和<code> account.language</code> 被移动到局部变量 <code>name</code> 和 <code>language</code> 中，的其余部分被删除，这就是为什么我们不能在之后借用它。如果 <code>name</code> 和 <code>language</code> 都是可复制的值，<code>Rust</code> 会复制字段而不是移动它们，这段代码就可以了。但是如果这些是字符串，就需要一种借用匹配值而不是移动它们的模式，<code>ref</code> 关键字就是这样做的：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> account &#123;</span><br><span class="line">    Account &#123; <span class="keyword">ref</span> name, <span class="keyword">ref</span> language, .. &#125; =&gt; &#123;</span><br><span class="line">        ui.<span class="title function_ invoke__">greet</span>(name, language);</span><br><span class="line">        ui.<span class="title function_ invoke__">show_settings</span>(&amp;account); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>现在局部变量 <code>name</code> 和 <code>language</code> 是对 <code>account</code> 中相应字段的引用，由于 <code>account</code> 只是被借用而不是被消耗，因此可以继续对其调用方法。可以使用 <code>ref mut</code> 借用 <code>mut</code> 引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> line_result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">log_error</span>(err), <span class="comment">// `err` is &amp;Error (shared ref)</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> line) =&gt; &#123; <span class="comment">// `line` is &amp;mut String (mut ref)</span></span><br><span class="line">        <span class="title function_ invoke__">trim_comments</span>(line); <span class="comment">// modify the String in place</span></span><br><span class="line">        <span class="title function_ invoke__">handle</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式 <code>Ok(ref mut line)</code> 匹配任何成功结果，并借用 <code>mut</code> 引用存储在其中的成功值。</p>
<p>之前我们都是匹配的值，现在假如我们要匹配一个引用，假设 <code>sphere.center()</code> 返回 <code>Point3d</code> 的地址，例如 <code>&amp;Point3d &#123; x: 0.0, y: 0.0, z: 0.0 &#125;</code>，我们就得这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> sphere.<span class="title function_ invoke__">center</span>() &#123;</span><br><span class="line">    &amp;Point3d &#123; x, y, z &#125; =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要记住的是，模式和表达式是自然对立的。表达式 <code>(x, y)</code> 将两个值组合成一个新的元组，但模式 <code>(x, y)</code> 则相反，它匹配一个元组并分解这两个值，<code>&amp;</code> 也一样，在表达式中，<code>&amp;</code> 创建一个引用，在一个模式中， <code>&amp;</code> 匹配一个引用。</p>
<p>匹配引用遵循我们所期望的所有规则，无法通过共享引用获得 <code>mut</code> 访问权限。当我们匹配 <code>&amp;Point3d &#123; x, y, z &#125;</code> 时，变量 <code>x</code>、<code>y</code> 和 <code>z</code> 接收坐标的副本，而原始 <code>Point3d</code> 值保持不变。它之所以有效，是因为这些字段是可复制的。如果我们在具有不可复制字段的结构上尝试同样的事情，我们会得到一个错误：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> friend.<span class="title function_ invoke__">borrow_car</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;Car &#123; engine, .. &#125;) =&gt; <span class="comment">// error: can&#x27;t move out of borrow</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="literal">None</span> =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>但是我们可以使用 <code>ref</code> 获得对他的引用：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">Some</span>(&amp;Car &#123; <span class="keyword">ref</span> engine, .. &#125;) =&gt; <span class="comment">// ok, engine is a reference</span></span><br></pre></td></tr></table></figure></div>

<p>让我们再看一个 <code>&amp;</code> 模式的例子。假设我们对字符串中的字符有一个迭代器 <code>chars</code>，并且它有一个方法 <code>chars.peek()</code>，它返回一个 <code>Option&lt;&amp;char&gt;</code>：对下一个字符的引用。程序可以使用 <code>&amp;</code> 模式来获取指向的字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> chars.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;c) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;coming up: &#123;:?&#125;&quot;</span>, c),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;end of chars&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件模式"><a href="#条件模式" class="headerlink" title="条件模式"></a>条件模式</h4><p>可以在 <code>pattern</code> 和 <code>=&gt;</code> 之间使用 <code>if CONDITION</code> 来决定是否匹配，例如：：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">point_to_hex</span>(click) &#123;</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(<span class="string">&quot;That&#x27;s not a game space.&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(hex) <span class="keyword">if</span> hex == current_hex =&gt;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;You are already there! You must click somewhere else&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(hex) =&gt; <span class="title function_ invoke__">Ok</span>(hex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果匹配成功，但是条件未达到，就会继续匹配下一个。</p>
<h4 id="匹配多种可能"><a href="#匹配多种可能" class="headerlink" title="匹配多种可能"></a>匹配多种可能</h4><p>竖线 <code>|</code> 可用于在单个匹配中组合多个模式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">at_end</span> = <span class="keyword">match</span> chars.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&#x27;\r&#x27;</span>) | <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&#x27;\n&#x27;</span>) | <span class="literal">None</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">    _ =&gt; <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在表达式中，<code>|</code> 是按位或运算符，但在这里它更像正则表达式中的 <code>|</code>，<code>chars.peek()</code> 匹配任何三种模式之一都会返回 <code>true</code>。另外可以使用 <code>..=</code> 匹配整个范围的值，范围模式包括开始和结束值，所以 <code>&#39;0&#39; ..= &#39;9&#39;</code> 匹配所有 <code>ASCII</code> 数字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> next_char &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">read_number</span>(),</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">read_word</span>(),</span><br><span class="line">    <span class="string">&#x27; &#x27;</span> | <span class="string">&#x27;\t&#x27;</span> | <span class="string">&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">skip_whitespace</span>(),</span><br><span class="line">    _ =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">handle_punctuation</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Rust</code> 目前不允许在模式中使用 <code>0..100</code> 这样的不包含结束符的范围。</strong></p>
<h4 id="绑定"><a href="#绑定" class="headerlink" title="@ 绑定"></a><code>@</code> 绑定</h4><p>使用 <code>x @ pattern</code> 在匹配成功时会创建一个变量，将匹配到的整个值 <code>copy</code> 进去或者移动所有权，看这样一个示例代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">get_selection</span>() &#123;</span><br><span class="line">    Shape::<span class="title function_ invoke__">Rect</span>(top_left, bottom_right) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">optimized_paint</span>(&amp;Shape::<span class="title function_ invoke__">Rect</span>(top_left, bottom_right))</span><br><span class="line">    &#125;</span><br><span class="line">    other_shape =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">paint_outline</span>(other_shape.<span class="title function_ invoke__">get_outline</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个例子，解构 <code>Shape::Rect</code> 然后又构建了一个，我们可以使用 <code>@</code> 来完成这个目的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">rect @ Shape::<span class="title function_ invoke__">Rect</span>(..) =&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">optimized_paint</span>(&amp;rect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@</code> 也用于范围绑定：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> chars.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(digit @ <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span>) =&gt; <span class="title function_ invoke__">read_number</span>(digit, chars),</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="模式的其他用途"><a href="#模式的其他用途" class="headerlink" title="模式的其他用途"></a>模式的其他用途</h4><p>模式匹配除了应用于 <code>match</code>，也可以应用与 <code>tuple</code>，<code>struct</code> 以及 <code>HashMap</code> 解构：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将结构体解构到三个变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Track</span> &#123; album, track_number, title, .. &#125; = song;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构 tuple</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">distance_to</span>((x, y): (<span class="type">f64</span>, <span class="type">f64</span>)) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代 HashMap 的键和值</span></span><br><span class="line"><span class="title function_ invoke__">for</span> (id, document) <span class="keyword">in</span> &amp;cache_map &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;Document #&#123;&#125;: &#123;&#125;&quot;</span>, id, document.title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...automatically dereference an argument to a closure</span></span><br><span class="line"><span class="comment">// (handy because sometimes other code passes you a reference</span></span><br><span class="line"><span class="comment">// when you&#x27;d rather have a copy)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = numbers.<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |a, &amp;num| a + num);</span><br></pre></td></tr></table></figure>

<p>还可以应用于我们之前学习到的 <code>if let</code> 和 <code>while let</code> 模式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...handle just one enum variant specially</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">RoughTime</span>::<span class="title function_ invoke__">InTheFuture</span>(_, _) = user.<span class="title function_ invoke__">date_of_birth</span>() &#123;</span><br><span class="line"> user.<span class="title function_ invoke__">set_time_traveler</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...run some code only if a table lookup succeeds</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(document) = cache_map.<span class="title function_ invoke__">get</span>(&amp;id) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_ invoke__">send_cached_response</span>(document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...repeatedly try something until it succeeds</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = <span class="title function_ invoke__">present_cheesy_anti_robot_task</span>() &#123;</span><br><span class="line"> <span class="title function_ invoke__">log_robot_attempt</span>(err);</span><br><span class="line"> <span class="comment">// let the user try again (it might still be a human)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...manually loop over an iterator</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(_) = lines.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line"> <span class="title function_ invoke__">read_paragraph</span>(&amp;<span class="keyword">mut</span> lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>枚举</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】运算符重载</title>
    <url>/2022/05/30/%E3%80%90Rust%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>我们可以为自定义的类型实现加减乘除操作，只要实现标准库的一些 <code>Trait</code>，这称之为<strong>运算符重载</strong>。下图是可以重载的运算符和需要对应实现的 <code>Trait</code> 列表：</p>
<img data-src="/2022/05/30/%E3%80%90Rust%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/operattor-overloading.png" class="">

<span id="more"></span>

<h3 id="算数和位运算符"><a href="#算数和位运算符" class="headerlink" title="算数和位运算符"></a>算数和位运算符</h3><p>在 <code>Rust</code> 中，表达式 <code>a + b</code> 实际上是 <code>a.add(b)</code> 的简写，调用 <code>std::ops::Add</code> 的方法，<code>Rust</code> 标准库数值类型都实现了这个 <code>Trait</code>。所有如果我们要实现类型之间的算数运算，只需要为这个类型实现相应的 <code>Trait</code> 即可。</p>
<p>假设我们需要为 <a href="https://docs.rs/num/latest/num/"><code>num</code></a> 中的 <a href="https://docs.rs/num/latest/num/struct.Complex.html"><code>Complex&lt;T&gt;</code></a> 实现 <code>+</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// Real portion of the complex number</span></span><br><span class="line">    <span class="keyword">pub</span> re: T,</span><br><span class="line">    <span class="comment">/// Imaginary portion of the complex number</span></span><br><span class="line">    <span class="keyword">pub</span> im: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之前说过可以为一类类型添加方法，这样的话不至于为 <code>Complex&lt;i32&gt;</code> 和 <code>Complex&lt;u64&gt;</code> 都添加 <code>+</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq, Eq, Clone, Copy, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// Real portion of the complex number</span></span><br><span class="line">    <span class="keyword">pub</span> re: T,</span><br><span class="line">    <span class="comment">/// Imaginary portion of the complex number</span></span><br><span class="line">    <span class="keyword">pub</span> im: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Add <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Add&lt;Output = T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Complex &#123;</span><br><span class="line">            re: <span class="keyword">self</span>.re + rhs.re,</span><br><span class="line">            im: <span class="keyword">self</span>.im + rhs.im,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 <code>Rust</code> 不赞成支持混合类型的操作，但我们可以实现，这里要求 <code>L</code> 必须能和 <code>R</code> 实现加法操作：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;L, R&gt; Add&lt;Complex&lt;R&gt;&gt; <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;L&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    L: Add&lt;R&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Complex&lt;L::Output&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Complex&lt;R&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        Complex &#123;</span><br><span class="line">            re: <span class="keyword">self</span>.re + rhs.re,</span><br><span class="line">            im: <span class="keyword">self</span>.im + rhs.im,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p><code>Rust</code> 有两个一元操作符 <code>-</code> 和 <code>!</code>，<code>Rust</code> 的所有带符号数字类型都实现了 <code>std::ops::Neg</code>，用于一元负数运算符 <code>-</code>。整数类型和 <code>bool</code> 实现 <code>std::ops::Not</code>，用于一元补码运算符 <code>!</code>。 <code>!</code> 可以用于 <code>bool</code> 值也可以用于整数的按位取反。</p>
<p><a href="https://doc.rust-lang.org/stable/std/ops/trait.Neg.html"><code>std::ops::Neg</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Not.html"><code>std::ops::Not</code></a> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Neg</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">neg</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Not</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">not</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来实现对复数 <code>Complex&lt;T&gt;</code> 的 <code>-</code> 运算：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Neg;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Neg <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Neg&lt;Output = T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Complex&lt;T&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">neg</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Complex&lt;T&gt; &#123;</span><br><span class="line">        Complex &#123;</span><br><span class="line">            re: -<span class="keyword">self</span>.re,</span><br><span class="line">            im: -<span class="keyword">self</span>.im,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>所有 <code>Rust</code> 的数值类型都实现了算数运算符，整数和 <code>bool</code> 类型实现了位运算符。所有这些 <code>Trait</code> 都有相同的形式，<code>^</code> 运算符对应的 <a href="https://doc.rust-lang.org/stable/std/ops/trait.BitXor.html"><code>std::ops::BitXor</code></a> 如下图所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">BitXor</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">bitxor</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p>复合赋值表达式类似于 <code>x += y</code> 或 <code>x &amp;= y</code>：它接受两个操作数，对它们执行一些操作，如加法或按位与，并将结果存储回左操作数。在 <code>Rust</code> 中，复合赋值表达式的值始终是 <code>()</code>，而不是存储的值。</p>
<p>许多语言都有这样的运算符，通常将它们定义为 <code>x = x + y</code> 或 <code>x = x &amp; y</code> 等表达式的简写，但是 <code>Rust</code> 没有采用这种方法。相反，<code>x += y</code> 是方法调用 <code>x.add_assign(y)</code> 的简写，其中 <code>add_assign</code> 是 <a href="https://doc.rust-lang.org/stable/std/ops/trait.AddAssign.html"><code>std::ops::AddAssign</code></a> 的唯一方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">AddAssign</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_assign</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, rhs: Rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 的所有数字类型都实现了算术复合赋值运算符，<code>Rust</code> 的整数类型和 <code>bool</code> 实现了按位复合赋值运算符。我们来看一个对 <code>Complex&lt;T&gt;</code> 的假发复合赋值运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::AddAssign;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; AddAssign <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: AddAssign&lt;T&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_assign</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, rhs: Complex&lt;T&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.re += rhs.re;</span><br><span class="line">        <span class="keyword">self</span>.im += rhs.im;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复合赋值运算符的内置<code>Trait</code>完全不同于相应二元运算符的内置<code>Trait</code>。实现 <code>std::ops::Add</code> 不会自动实现 <code>std::ops::AddAssign</code>。如果你想让 <code>Rust</code> 允许你的类型作为 <code>+=</code> 运算符的左操作数，你必须自己实现 <code>AddAssign</code>。</p>
<h3 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h3><p><code>Rust</code> 的相等运算符 <code>==</code> 和 <code>!=</code> 是调用 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code>std::cmp::PartialEq</code></a> 的 <code>eq</code> 和 <code>ne</code> 方法，这个 <code>trait</code> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">PartialEq</span>&lt;Rhs = <span class="keyword">Self</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    Rhs: ?<span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eq</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">ne</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        !<span class="keyword">self</span>.<span class="title function_ invoke__">eq</span>(other)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>ne</code> 有个默认实现，我们只需要实现 <code>eq</code> 方法，这里有个为 <code>Complex&lt;T&gt;</code> 的实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">PartialEq</span>&gt; <span class="built_in">PartialEq</span> <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eq</span>(&amp;<span class="keyword">self</span>, other: &amp;Complex&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.re == other.re &amp;&amp; <span class="keyword">self</span>.im == other.im</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PartialEq</code> 的实现几乎总是如出一辙，每次都显示写出来显得很无聊，所以 <code>Rust</code> 经常会为我们自动派生这个 <code>Trait</code> 的实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 自动生成的实现本质上与我们的手写代码相同，依次比较类型的每个字段或元素，<code>Rust</code> 也可以为枚举类型派生 <code>PartialEq</code> 实现。自然地，该类型持有的每个值（或者在枚举的情况下可能持有）必须自己实现 <code>PartialEq</code>。</p>
<p>这里我们需要着重注意的是，这与算数运算符不同，<code>eq</code> 获取的是值的引用，这意味着比较 <code>String</code>，<code>Vec</code> 或者 <code>HashMap</code> 不会转移所有权：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;d\x6fv\x65t\x61i\x6c&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="string">&quot;\x64o\x76e\x74a\x69l&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="built_in">assert!</span>(s == t); <span class="comment">// s and t are only borrowed...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... so they still have their values here.</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s, t), <span class="string">&quot;dovetail dovetail&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们再来看看 <code>Rhs: ?Sized</code> 的约定，之前从未见过。这放宽了 <code>Rust</code> 通常要求类型参数必须是 <code>Sized</code> 类型的要求，让我们可以编写像 <code>PartialEq&lt;str&gt;</code> 或 <code>PartialEq&lt;[T]&gt;</code> 这样的 <code>Trait</code>。<code>eq</code> 和 <code>ne</code> 方法采用 <code>&amp;Rhs</code> 类型的参数，将某些东西与 <code>&amp;str</code> 或 <code>&amp;[T]</code> 进行比较是完全合理的。由于 <code>str</code> 实现了 <code>PartialEq&lt;str&gt;</code>，以下断言是等价的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(<span class="string">&quot;ungula&quot;</span> != <span class="string">&quot;ungulate&quot;</span>);</span><br><span class="line"><span class="built_in">assert!</span>(<span class="string">&quot;ungula&quot;</span>.<span class="title function_ invoke__">ne</span>(<span class="string">&quot;ungulate&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在这里，<code>Self</code> 和 <code>Rhs</code> 都将是 <code>unsized</code> 类型 <code>str</code>，使得 <code>ne</code> 的 <code>Self</code> 和 <code>rhs</code> 参数都是 <code>&amp;str</code> 值。为什么 <code>PartialEq?</code> 叫做部分相等，因为从数学定义上来说，等价关系应该满足三个要求，对于任何值 <code>x</code> 和 <code>y</code>：</p>
<ul>
<li><p>如果 <code>x == y</code> 那么 <code>y == x</code>；</p>
</li>
<li><p>如果 <code>x == y</code>，<code>y == x</code> 那么 <code>x == z</code>；</p>
</li>
<li><p><code>x == x</code> 永远成立；</p>
</li>
</ul>
<p>虽然最后一个足够简单，但最后一个正是出问题的地方。<code>Rust</code> 的 <code>f32</code> 和 <code>f64</code> 是 <code>IEEE</code> 标准浮点值，像 <code>0.0 / 0.0</code> 以及其他没有适当值的表达式必须产生 <code>NaN</code>，而且 <code>NaN</code> 不等于任何值包括自身：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(<span class="type">f64</span>::<span class="title function_ invoke__">is_nan</span>(<span class="number">0.0</span> / <span class="number">0.0</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0.0</span> / <span class="number">0.0</span> == <span class="number">0.0</span> / <span class="number">0.0</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0.0</span> / <span class="number">0.0</span> != <span class="number">0.0</span> / <span class="number">0.0</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0.0</span> / <span class="number">0.0</span> &lt; <span class="number">0.0</span> / <span class="number">0.0</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0.0</span> / <span class="number">0.0</span> &gt; <span class="number">0.0</span> / <span class="number">0.0</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0.0</span> / <span class="number">0.0</span> &lt;= <span class="number">0.0</span> / <span class="number">0.0</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0.0</span> / <span class="number">0.0</span> &gt;= <span class="number">0.0</span> / <span class="number">0.0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>因此，虽然 <code>Rust</code> 的 <code>==</code> 运算符满足等价关系的前两个要求，但在 <code>IEEE</code> 浮点值上使用时显然不满足第三个要求，这称为部分等价关系。</p>
<p>如果你希望通用代码需要<strong>完全等价关系</strong>，则可以改为使用 <code>std::cmp::Eq</code> 作为边界，它表示<strong>完全等价关系</strong>：如果类型实现 <code>Eq</code>，则 <code>x == x</code> 对于该类型的每个值 <code>x</code> 都必须为真。在实践中，几乎所有实现 <code>PartialEq</code> 的类型也应该实现 <code>Eq</code>； <code>f32</code> 和 <code>f64</code> 是标准库中唯一属于 <code>PartialEq</code> 但不是 <code>Eq</code> 的类型。</p>
<p>标准库定义 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code>Eq</code></a> 是 <code>PartialEq</code> 的扩展，但是没有添加方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Eq</span>: <span class="built_in">PartialEq</span>&lt;<span class="keyword">Self</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的类型实现了 <code>PartialEq</code> 也希望是 <code>Eq</code>，那么必须显示实现 <code>Eq</code>，即使不用实现任何新的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Eq</span>&gt; <span class="built_in">Eq</span> <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>更简单的是我们可以使用派生 <code>Eq</code> 来实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类型的派生实现可能取决于类型参数，使用派生属性，<code>Complex&lt;i32&gt;</code> 将实现 <code>Eq</code>，因为 <code>i32</code> 可以，但是<code>Complex&lt;f32&gt;</code> 只会实现 <code>PartialEq</code>，因为 <code>f32</code> 没有实现 <code>Eq</code>。当自己实现 <code>std::cmp::PartialEq</code> 时，<code>Rust</code> 无法检查你的 <code>eq</code> 和 <code>ne</code> 是完全相等还是部分相等。</p>
<h3 id="有序比较"><a href="#有序比较" class="headerlink" title="有序比较"></a>有序比较</h3><p><code>Rust</code> 在 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> 中定义了 <code>&lt; &gt; &lt;= &gt;=</code> 的逻辑：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">PartialOrd</span>&lt;Rhs = <span class="keyword">Self</span>&gt;: <span class="built_in">PartialEq</span>&lt;Rhs&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    Rhs: ?<span class="built_in">Sized</span>, </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">partial_cmp</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Ordering&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">lt</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">le</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">gt</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">ge</span>(&amp;<span class="keyword">self</span>, other: &amp;Rhs) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>Trait</code> 中唯一需要实现的是 <code>partial_cmp</code> 方法，根据它的返回结果，就确定了比较结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Ordering</span> &#123;</span><br><span class="line">    Less, <span class="comment">// self &lt; other</span></span><br><span class="line">    Equal, <span class="comment">// self == other</span></span><br><span class="line">    Greater, <span class="comment">// self &gt; other</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果 <code>partial_cmp</code> 返回 <code>None</code>，这意味着 <code>self</code> 和 <code>other</code> 相对于彼此是无序的：既不大于另一个，也不相等，在 <code>Rust</code> 中，只有 <code>NaN</code> 之间的比较才会有这样的结果。</p>
<p>像其他二元运算符一样，比较左右两种类型的值，左值必须实现 <code>PartialOrd&lt;Right&gt;</code>。 像 <code>x &lt; y</code> 或 <code>x &gt;= y</code> 这样的表达式是下面一些方法的简写：</p>
<img data-src="/2022/05/30/%E3%80%90Rust%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/ordered-comparisons.png" class="">

<p>如果想始终确定两个值得大小关系，那么就需要使用更严格的 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Ord</span>: <span class="built_in">Eq</span> + <span class="built_in">PartialOrd</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp</span>(&amp;<span class="keyword">self</span>, other: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> Ordering;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">max</span>(<span class="keyword">self</span>, other: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">min</span>(<span class="keyword">self</span>, other: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clamp</span>(<span class="keyword">self</span>, min: <span class="keyword">Self</span>, max: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>cmp</code> 方法总是返回 <code>Odering</code>，说明两个值总是有顺序的，几乎所有实现 <code>PartialOrd</code> 的类型也实现了 <code>Ord</code>，除了 <code>f32</code> 和 <code>f64</code>。</p>
<h3 id="Index-和-IndexMut"><a href="#Index-和-IndexMut" class="headerlink" title="Index 和 IndexMut"></a><code>Index</code> 和 <code>IndexMut</code></h3><p>索引运算符 <code>[]</code> 也是可以重载的，例如，<code>a[i]</code> 实际上是 <code>*a.index(i)</code>，如果这个表达式赋值给可变引用那家么实际上调用的是 <code>*a.index_mut(i)</code>，这俩方法分别代表的是<a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code>std::ops::Index</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/ops/trait.IndexMut.html"><code>std::ops::IndexMut</code></a>，它们的实际定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Index</span>&lt;Idx&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    Idx: ?<span class="built_in">Sized</span>, </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>: ?<span class="built_in">Sized</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IndexMut</span>&lt;Idx&gt;: Index&lt;Idx&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    Idx: ?<span class="built_in">Sized</span>, </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用单个 <code>usize</code> 来索引切片，引用单个元素，因为切片实现 <code>Index&lt;usize&gt;</code>。但也可以可以使用像 <code>a[i..j]</code> 这样的表达式来引用子切片，因为它们也实现了 <code>Index&lt;Range&lt;usize&gt;&gt;</code>，这个表达式是简写为了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">*a.<span class="title function_ invoke__">index</span>(std::ops::Range &#123; start: i, end: j &#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>std::collections::HashMap</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code>std::collections::BTreeMap</code></a> 都实现了 <code>Index&lt;&amp;str&gt;</code>。</p>
<p>所以我们可以这样使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;十&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;百&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;千&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;万&quot;</span>, <span class="number">1_0000</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;億&quot;</span>, <span class="number">1_0000_0000</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(m[<span class="string">&quot;十&quot;</span>], <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(m[<span class="string">&quot;千&quot;</span>], <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*m.<span class="title function_ invoke__">index</span>(<span class="string">&quot;十&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*m.<span class="title function_ invoke__">index</span>(<span class="string">&quot;千&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从定义可以看出 <code>IndexMut</code> 扩展了 <code>Index</code> 并且增加了 <code>index_mut</code> 方法。当索引表达式出现在必要的上下文中时，<code>Rust</code> 会自动选择 <code>index_mut</code>。例如，假设我们编写以下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">desserts</span> =</span><br><span class="line"><span class="built_in">vec!</span>[<span class="string">&quot;Howalon&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;Soan papdi&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line">desserts[<span class="number">0</span>].<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; (fictional)&quot;</span>);</span><br><span class="line">desserts[<span class="number">1</span>].<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; (real)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::IndexMut;</span><br><span class="line">(*desserts.<span class="title function_ invoke__">index_mut</span>(<span class="number">0</span>)).<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; (fictional)&quot;</span>);</span><br><span class="line">(*desserts.<span class="title function_ invoke__">index_mut</span>(<span class="number">1</span>)).<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; (real)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>IndexMut</code> 的一个限制是，根据设计，它必须返回对某个值的可变引用。这就是为什么你不能使用像 <code>m[&quot;十&quot;] = 10;</code> 这样的表达式的原因。因为向 <code>HashMap</code> 中插入一个值：该表需要首先为<code>“十”</code>创建一个 <code>entry</code>，并使用一些默认值，然后返回一个可变引用，但并非所有类型都具有简单的默认值，而且这里创建一个默认值并且立马丢掉，然后使用新值覆盖。</p>
<p>实现一个二维数组示例，存储图片的像素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Image</span>&lt;P&gt; &#123;</span><br><span class="line">    width: <span class="type">usize</span>,</span><br><span class="line">    pixels: <span class="type">Vec</span>&lt;P&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;P: <span class="built_in">Default</span> + <span class="built_in">Copy</span>&gt; Image&lt;P&gt; &#123;</span><br><span class="line">    <span class="comment">/// Create a new image of the given size.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">usize</span>, height: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Image&lt;P&gt; &#123;</span><br><span class="line">        Image &#123;</span><br><span class="line">            width,</span><br><span class="line">            pixels: <span class="built_in">vec!</span>[P::<span class="title function_ invoke__">default</span>(); width * height],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; std::ops::Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">Image</span>&lt;P&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = [P];</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, row: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;[P] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">start</span> = row * <span class="keyword">self</span>.width;</span><br><span class="line">        &amp;<span class="keyword">self</span>.pixels[start..start + <span class="keyword">self</span>.width]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; std::ops::IndexMut&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">Image</span>&lt;P&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, row: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> [P] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">start</span> = row * <span class="keyword">self</span>.width;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.pixels[start..start + <span class="keyword">self</span>.width]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">image</span> = Image::&lt;<span class="type">u8</span>&gt;::<span class="title function_ invoke__">new</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;image[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>并非所有的运算符都可以重载，例如，用于错误检测的 <code>?</code>，逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code>，范围运算符 <code>..</code> 和 <code>..=</code>，借用运算符 <code>&amp;</code> 和赋值运算符 <code>=</code> 不能被重载。</p>
<p>解引用运算符 <code>*</code> 和字段(方法)运算符 <code>.</code> 是可以通过 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>std::ops::Deref</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>std::ops::DerefMut</code></a> 重载的。</p>
<p><code>Rust</code> 不支持重载函数调用运算符 <code>f(x)</code>，而是当你需要一个可调用的值时，用闭包来实现。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】输入输出</title>
    <url>/2022/04/22/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p><code>Rust</code> 用于输入和输出的标准库功能围绕三个<code>Trait</code>组织：<a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>、<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a>：</p>
<ul>
<li><p>实现 <code>Read</code> 的值具有面向字节的输入的方法，他们被称为 <code>Reader</code>；</p>
</li>
<li><p>实现 <code>BufRead</code> 的值是缓冲读取器，它们支持 <code>Read</code> 的所有方法，以及读取文本行等的方法；</p>
</li>
<li><p>实现 <code>Write</code> 的值支持面向字节和<code>UTF-8</code> 文本输出，它们被称为 <code>Writer</code>；</p>
</li>
</ul>
<p>在本节中，将解释如何使用这些<code>Trait</code>及其方法，涵盖图中所示的读取器和写入器类型，并展示与文件、终端和网络交互的其他方式。</p>
<img data-src="/2022/04/22/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/read-write.png" class="">

<h3 id="Readers、Writers"><a href="#Readers、Writers" class="headerlink" title="Readers、Writers"></a><code>Readers</code>、<code>Writers</code></h3><p><code>Readers</code> 是内容输入源，可以从哪里读取字节。例如：</p>
<ul>
<li><p>使用 <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> 打开的文件；</p>
</li>
<li><p>可以从 <a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html"><code>std::net::TcpStream</code></a> 代表的网络连接中读取数据；</p>
</li>
<li><p>可以从 <a href="https://doc.rust-lang.org/std/io/fn.stdin.html"><code>std::io::stdin()</code></a> 标准输入读取数据；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html"><code>std::io::Cursor&lt;&amp;[u8]&gt;</code></a> 和 <a href="https://doc.rust-lang.org/std/io/struct.Cursor.html"><code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code></a> 值，它们是从已经在内存中的字节数组或<code>vector</code>中“读取”的读取器；</p>
</li>
</ul>
<p><code>Writers</code> 是那些你可以把值写入的地方，例如：</p>
<ul>
<li><p>使用 <code>std::fs::File::create</code> 创建的文件；</p>
</li>
<li><p>基于网络连接 <code>std::net::TcpStream</code> 传输数据；</p>
</li>
<li><p><code>std::io::stdout()</code> 和 <code>std::io:stderr()</code> 可以用于向标准输出和标准错误写入内容；</p>
</li>
<li><p><code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code> 类似，但允许读取和写入数据，并在<code>vector</code>中寻找不同的位置；</p>
</li>
<li><p><code>std::io::Cursor&lt;&amp;mut [u8]&gt;</code> 和上面的类似，但是不能增长内部的 <code>buffer</code>，因为它仅仅是已存在的字节数组的引用；</p>
</li>
</ul>
<p>由于<code>Reader</code>和<code>Writer</code>有标准的 <code>Trait</code>（<code>std::io::Read</code> 和 <code>std::io::Write</code>），编写适用于各种输入或输出通道的通用代码是很常见的。 例如，这是一个将所有字节从任何读取器复制到任何写入器的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, ErrorKind, Read, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_BUF_SIZE: <span class="type">usize</span> = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">copy</span>&lt;R: ?<span class="built_in">Sized</span>, W: ?<span class="built_in">Sized</span>&gt;(reader: &amp;<span class="keyword">mut</span> R, writer: &amp;<span class="keyword">mut</span> W) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">u64</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: Read,</span><br><span class="line">    W: Write,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; DEFAULT_BUF_SIZE];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">written</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = <span class="keyword">match</span> reader.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="number">0</span>) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(written),</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(len) =&gt; len,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="keyword">ref</span> e) <span class="keyword">if</span> e.<span class="title function_ invoke__">kind</span>() == ErrorKind::Interrupted =&gt; <span class="keyword">continue</span>,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        &#125;;</span><br><span class="line">        writer.<span class="title function_ invoke__">write_all</span>(&amp;buf[..len])?;</span><br><span class="line">        written += len <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>Rust</code> 标准库 <a href="https://doc.rust-lang.org/std/io/fn.copy.html"><code>std::io::copy()</code></a> 的实现，因为它是泛型的，所以可以把数据从 <code>File</code> 复制到 <code>TcpStream</code>，或者从 <code>Stdin</code> 到内存中的 <code>Vec&lt;u8&gt;</code>。</p>
<span id="more"></span>

<h4 id="Readers"><a href="#Readers" class="headerlink" title="Readers"></a><code>Readers</code></h4><p><code>std::io::Read</code> 有几个读取数据逇方法，它们所有都以 <code>&amp;mut self</code> 作为参数。</p>
<ul>
<li><p><code>reader.read(&amp;mut buffer)</code>：从数据源读取一些字节并将它们存储在给定的缓冲区中，缓冲区参数的类型是 <code>&amp;mut [u8]</code>，这最多读取 <code>buffer.len()</code> 个字节。返回类型是 <code>io::Result&lt;u64&gt;</code>，它是 <code>Result&lt;u64,io::Error&gt;</code> 的类型别名。成功时，<code>u64</code> 值是读取的字节数，它可能等于或小于 <code>buffer.len()</code>，<code>Ok(0)</code> 表示没有数据要读取。</p>
<p>出错时，<code>.read()</code> 返回 <code>Err(err)</code>，其中 <code>err</code> 是 <code>io::Error</code> 值。<code>io::Error</code> 是可打印的。对于程序，它有一个 <code>.kind()</code> 方法，该方法返回 <code>io::ErrorKind</code> 类型的错误代码。这个枚举的成员具有 <code>PermissionDenied</code> 和 <code>ConnectionReset</code> 之类的名称，大多数不可忽视的明显错误，但应特别处理一种错误，<code>io::ErrorKind::Interrupted</code> 对应 <code>Unix</code> 错误代码 <code>EINTR</code>，表示读取恰好被信号中断，除非程序被设计成巧妙地处理信号，否则它应该只是重新读去。</p>
<p><code>.read()</code> 方法非常低级，甚至继承了底层操作系统的怪癖。如果你正在为一种新型数据源实现 <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>，这会给你很大的余地，如果你试图读取一些数据，那会很痛苦。因此，<code>Rust</code> 提供了几种更高级的便利方法。它们都具有 <code>.read()</code> 方面的默认实现，它们都处理 <code>ErrorKind::Interrupted</code>，所以你不必这样做。</p>
</li>
<li><p><code>reader.read_to_end(&amp;mut byte_vec)</code>：从 <code>Reader</code> 中读取剩余的输入追加到 <code>byte_vec</code>，它是 <code>Vec&lt;u8&gt;</code> 类型，返回 <code>io::Result&lt;usize&gt;</code> 表示读取的数量；</p>
</li>
<li><p><code>reader.read_to_string(&amp;mut string)</code>：同上，但是追加数据到 <code>String</code> 中，如果遇到无效的 <code>UTF-8</code>，将返回 <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.InvalidData"><code>ErrorKind::InvalidData</code></a>。在某些编程语言中，字节输入和字符输入由不同的类型处理。如今，<code>UTF-8</code> 如此占主导地位，以至于 <code>Rust</code> 承认这一事实标准并在任何地方都支持 <code>UTF-8</code>；</p>
</li>
<li><p><code>reader.read_exact(&amp;mut buf)</code>：读取足够的数据以填充给定的缓冲区，参数类型是 <code>&amp;[u8]</code>。如果读取器在读取 <code>buf.len()</code> 字节之前用完数据，则返回 <code>ErrorKind::UnexpectedEof</code> 错误；</p>
</li>
<li><p><code>reader.bytes()</code>：返回输入流的按字节迭代器，类型是 <a href="https://doc.rust-lang.org/std/io/struct.Bytes.html"><code>std::io::Bytes</code></a>。</p>
</li>
<li><p><code>reader.chain(reader2)</code>：将多个 <code>Reader</code> 连接起来，先从当前 <code>reader</code> 读取数据，如果遇到 <code>EOF</code>，则从 <code>reader2</code> 读取；</p>
</li>
<li><p><code>reader.take(n)</code>：创建一个适配器，该适配器最多可以从中读取限制字节。此函数返回一个新的 <code>Read</code> 实例，它最多读取<code>n</code>个字节，之后它将始终返回 <code>EOF (Ok(0))</code>。任何读取错误都不会计入读取的字节数，未来对 <code>read()</code> 的调用可能会成功。</p>
</li>
</ul>
<h4 id="Buffered-Readers"><a href="#Buffered-Readers" class="headerlink" title="Buffered Readers"></a><code>Buffered Readers</code></h4><p>为了提高效率，可以缓冲读取器和写入器，这仅仅意味着它们有一块内存（缓冲区），用于在内存中保存一些输入或输出数据。这减少了系统调用，如下图所示，应用程序应该从 <code>BufReader</code> 读取数据，在此示例中通过调用其 <code>.read_line()</code> 方法。<code>BufReader</code> 反过来从操作系统获取更大块的输入。</p>
<img data-src="/2022/04/22/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/buffer-reader.png" class="">

<p>缓冲 <code>Reader</code> 实现了 <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>std::io::Read</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>std::io::BufRead</code></a> ，后者增加了下面的方法：</p>
<ul>
<li><p><code>reader.read_line(&amp;mut line)</code>：读取一行文本追加到 <code>line</code> 中，它是 <code>String</code> 类型，换行符 <code>\n</code> 或者 <code>\r\n</code> 都会追加到 <code>line</code> 中，返回值是 <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>std::io::Result&lt;usize&gt;</code></a> ，表示读取的字节数量，如果 <code>reader</code> 已经读完，则应该保持不变直接返回 <code>Ok(0)</code>；</p>
</li>
<li><p><code>reader.lines()</code>：在输入的行上返回一个迭代器，项目类型是 <code>io::Result&lt;String&gt;</code>，换行符不包含在字符串中。如果输入具有 <code>Windows</code> 样式的行尾<code>&quot;\r\n&quot;</code>，则两个字符都将被删除。这种方法几乎总是想要的文本输入，接下来的两节展示了它的一些使用示例；</p>
</li>
<li><p><code>reader.read_until(stop_byte, &amp;mut byte_vec)</code>、<code>reader.split(stop_byte)</code>：它们就像 <code>.read_line()</code> 和 <code>.lines()</code>，但面向字节，生成 <code>Vec&lt;u8&gt;</code> 而不是字符串，由调用者选择分隔符 <code>stop_byte</code>；</p>
</li>
</ul>
<p><code>BufRead</code> 还提供了一对低级方法，<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#tymethod.fill_buf"><code>.fill_buf()</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#tymethod.consume"><code>.consume(n)</code></a>，用于直接访问读取器的内部缓冲区。</p>
<h4 id="Reading-Lines"><a href="#Reading-Lines" class="headerlink" title="Reading Lines"></a><code>Reading Lines</code></h4><p>这里有一个实现类似 <code>grep</code> 的函数，它搜索许多文本行，然后将它传入下一个命令：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">grep</span>(target: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdin</span> = io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line_result</span> <span class="keyword">in</span> stdin.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line_result?;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(target) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于要调用 <code>.lines()</code>，需要一个实现 <code>BufRead</code> 的输入源。在这种情况下，我们调用 <code>io::stdin()</code> 来获取通过管道传输给我们的数据。但是，<code>Rust</code> 标准库使用互斥锁保护标准输入。我们调用 <code>.lock()</code> 来锁定 <code>stdin</code> 以供当前线程独占使用，它返回一个实现 <code>BufRead</code> 的 <code>StdinLock</code> 值，在循环结束时，<code>StdinLock</code> 被丢弃，释放互斥锁。</p>
<p>该函数的其余部分很简单，它调用 <code>.lines()</code> 并遍历生成的迭代器。因为这个迭代器产生 <code>Result</code> 值，所以我们使用 <code>?</code> 操作员检查错误。假设我们想让我们的 <code>grep</code> 程序更进一步，并添加对在磁盘上搜索文件的支持。我们可以使这个函数通用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">grep</span>&lt;R&gt;(target: &amp;<span class="type">str</span>, reader: R) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: BufRead,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line_result</span> <span class="keyword">in</span> reader.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line_result?;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(target) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以向它传递一个 <code>StdinLock</code> 或一个缓冲文件：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">stdin</span> = io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line"><span class="title function_ invoke__">grep</span>(&amp;target, stdin.<span class="title function_ invoke__">lock</span>())?; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file)?;</span><br><span class="line"><span class="title function_ invoke__">grep</span>(&amp;target, BufReader::<span class="title function_ invoke__">new</span>(f))?; <span class="comment">// also ok</span></span><br></pre></td></tr></table></figure>

<p>请注意，文件不会自动缓冲，<code>File</code> 实现 <code>Read</code> 但没有实现 <code>BufRead</code>。但是，为文件或任何其他非缓冲读取器创建缓冲读取器很容易，就像 <code>BufReader::new(reader)</code>。（要设置缓冲区的大小，请使用 <code>BufReader::with_capacity(size, reader)</code>）</p>
<p>在大多数语言中，默认情况下文件带有缓冲功能，如果你想要无缓冲的输入或输出，你必须弄清楚如何关闭缓冲。在 <code>Rust</code> 中，<code>File</code> 和 <code>BufReader</code> 是两个独立的库功能，因为有时希望文件没有缓冲，有时希望缓冲来自网络的输入。</p>
<p>完整的程序如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code, unused_imports)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, BufReader&#125;;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">grep</span>&lt;R&gt;(target: &amp;<span class="type">str</span>, reader: R) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: BufRead,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line_result</span> <span class="keyword">in</span> reader.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line_result?;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(target) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">grep_main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Get the command-line arguments. The first argument is the</span></span><br><span class="line">    <span class="comment">// string to search for; the rest are filenames.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">args</span> = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">target</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) =&gt; s,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(<span class="string">&quot;usage: grep PATTERN FILE...&quot;</span>)?,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">files</span>: <span class="type">Vec</span>&lt;PathBuf&gt; = args.<span class="title function_ invoke__">map</span>(PathBuf::from).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> files.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stdin</span> = io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">        <span class="title function_ invoke__">grep</span>(&amp;target, stdin.<span class="title function_ invoke__">lock</span>())?;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">file</span> <span class="keyword">in</span> files &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file)?;</span><br><span class="line">            <span class="title function_ invoke__">grep</span>(&amp;target, BufReader::<span class="title function_ invoke__">new</span>(f))?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">grep_main</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = result &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, err);</span><br><span class="line">        std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Writers"><a href="#Writers" class="headerlink" title="Writers"></a><code>Writers</code></h4><p>正如我们所见，输入主要是使用方法完成的，输出有点不同，输出主要用作参数。</p>
<ul>
<li><p><code>println!()</code> 和 <code>print!()</code>：都是将信息输出到标准输出，不同的是前者会增加一个换行符，遇到错误都 <code>panic</code>；</p>
</li>
<li><p><code>eprintln!()</code> 和 <code>eprint!()</code>：将信息输出到标准错误，不同的是前者会增加一个换行符，遇到错误都 <code>panic</code>；</p>
</li>
<li><p><code>writeln!()</code> 和 <code> write!()</code>：将信息输出到第一个参数指定的目的地，不同的是前者会增加一个换行符，返回一个 <code>Result</code>；</p>
</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>std::io::Write</code></a> 有以下方法：</p>
<ul>
<li><p><code>writer.write(&amp;buf)</code>：将切片 <code>buf</code> 中的一些字节写入底层流。它返回一个 <code>io::Result&lt;usize&gt;</code>。成功时，返回写入的字节数，可能小于 <code>buf.len()</code>，与 <code>Reader::read()</code> 一样，这是一种低级方法，应避免直接使用；</p>
</li>
<li><p><code>writer.write_all(&amp;buf)</code>：写入 <code>buf</code> 所有字节，返回 <code>io::Result&lt;()&gt;</code>；</p>
</li>
<li><p><code>writer.flush()</code>：将缓存的所有数据都写入底层的流中，返回 <code>Result&lt;()&gt;</code>；</p>
</li>
</ul>
<p><code>writer</code> 会被自动关闭，当它们被丢弃的时候，可以使用 <a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.new"><code>BufWriter::new(writer)</code></a> 基于任何 <code>writer</code> 生成一个带缓冲的 <code>Writer</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;tmp.txt&quot;</span>)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">writer</span> = BufWriter::<span class="title function_ invoke__">new</span>(file);</span><br></pre></td></tr></table></figure>

<p>如果要设置 <code>buffer</code> 大小，可以使用 <code> BufWriter::with_capacity(size, writer)</code>。当 <code>BufWriter</code> 被丢弃的时候，所有缓存的数据被写入底层的 <code>Writer</code>，如果这期间发生错误，将被忽略。为了让程序处理所有可能的错误，在丢弃 <code>BufWriter</code> 之前，使用 <code>.flush()</code> 将缓存的数据写到底层的流中。</p>
<h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a><code>Files</code></h4><p>下面列出常用的文件打开方法：</p>
<ul>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open(filename)</code></a>：打开已经存在的文件用于读取，返回 <code>std::io::Result</code>，如果文件返回错误；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.create"><code>std::fs::File::create(filename)</code></a>：创建一个文件用于写，如果文件已经存在，将会被清空；</p>
</li>
</ul>
<p>如果这些不满足，还可以使用 <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>std::fs::OpenOptions</code></a> 在打开文件时，设置更多的参数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::OpenOptions;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">log</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    .<span class="title function_ invoke__">append</span>(<span class="literal">true</span>) <span class="comment">// if file exists, add to the end</span></span><br><span class="line">    .<span class="title function_ invoke__">open</span>(<span class="string">&quot;server.log&quot;</span>)?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    .<span class="title function_ invoke__">write</span>(<span class="literal">true</span>)</span><br><span class="line">    .<span class="title function_ invoke__">create_new</span>(<span class="literal">true</span>) <span class="comment">// fail if file exists</span></span><br><span class="line">    .<span class="title function_ invoke__">open</span>(<span class="string">&quot;new_file.txt&quot;</span>)?;</span><br></pre></td></tr></table></figure>

<p><code>OpenOptions</code> 有几个方法用于打开文件时设置属性：</p>
<ul>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.append"><code>.append()</code></a>：设置追加模式；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.create"><code>.create()</code></a>：如果文件存在则打开，不存在则创建；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.create_new"><code>.create_new()</code></a>：创建新文件，如果文件已经存在则会失败，这个 <code>option</code> 是原子的，另外如果该选项设置，<code>.create()</code> 和 <code>.truncate()</code> 就被忽略；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.read"><code>.read()</code></a>：设置读权限；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.truncate"><code>.truncate()</code></a>：如果文件已经存在，清空文件；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#method.write"><code>.write()</code></a>：设置写权限；</p>
</li>
</ul>
<h4 id="Seeking"><a href="#Seeking" class="headerlink" title="Seeking"></a><code>Seeking</code></h4><p><code>File</code> 也实现了 <a href="https://doc.rust-lang.org/std/io/trait.Seek.html"><code>std::io::Seek</code></a>，这意味着可以在 <code>File</code> 内跳转，而不是从头到尾一次读取或写入，<code>Seek</code> 是这样定义的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Seek</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">seek</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pos: SeekFrom) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">u64</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SeekFrom</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Start</span>(<span class="type">u64</span>),</span><br><span class="line">    <span class="title function_ invoke__">End</span>(<span class="type">i64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Current</span>(<span class="type">i64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在文件内跳来跳去效率很低，无论是机械硬盘还是固态硬盘，一次寻址所需的时间都与读取几兆字节的数据一样长。</p>
<h4 id="其他读写类型"><a href="#其他读写类型" class="headerlink" title="其他读写类型"></a>其他读写类型</h4><p>这里有其他的读写类型：</p>
<ul>
<li><p><a href="std::io::stdin"><code>io::stdin()</code></a>：返回标准输入用于数据读取，返回值的类型是 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>，因为这个被所有线程共享，所以每次使用都需要使用互斥锁。</p>
<p>  <code>Stdin</code> 的 <code>.lock</code> 方法返回 <a href="https://doc.rust-lang.org/std/io/struct.StdinLock.html"><code>io::StdinLock</code></a>，它是一个带缓冲的 <code>Reader</code> 持有互斥锁直到丢弃。</p>
<p>  出于技术原因，<code>io::stdin().lock()</code> 是无效的，锁持有 <code>Stdin</code> 的引用，这意味着 <code>Stdin</code> 必须被存在一个变量中以至于它的生命周期足够长：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">stdin</span> = io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">lines</span> = stdin.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">lines</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://doc.rust-lang.org/std/io/fn.stdout.html"><code>io::stdout()</code></a>、<a href="https://doc.rust-lang.org/std/io/fn.stderr.html"><code>io::stderr()</code></a>：返回标准输出和标准错误用于数据写入，它们也有 <code>.lock</code> 方法；</p>
</li>
<li><p><code>Vec&lt;u8&gt;</code>：实现了 <code>std::io::Write</code>，写入数据到 <code>u8</code> 序列；</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html"><code>std::io::Cursor::new(buf)</code></a>：创建一个 <code>Cursor</code>，一个从 <code>buf</code> 读取的缓冲读取器，这就是创建读取字符串的阅读器的方式。参数 <code>buf</code> 可以是任何实现 <code>AsRef&lt;[u8]&gt;</code> 的类型，因此也可以传递 <code>&amp;[u8]</code>、<code>&amp;str</code> 或 <code>Vec&lt;u8&gt;</code>。</p>
<p>  <code>Cursor</code> 在内部是很简单的，它们只有两个字段：<code>buf</code> 本身和一个整数，即 <code>buf</code> 中下一次读取将开始的偏移量，该位置最初为 <code>0</code>。</p>
<p>  <code>Cursor</code> 实现 <code>Read</code>、<code>BufRead</code> 和 <code>Seek</code>，如果 <code>buf</code> 的类型是 <code>&amp;mut [u8]</code> 或 <code>Vec&lt;u8&gt;</code>，那么 <code>Cursor</code> 也会实现 <code>Write</code>。写入 <code>Curosr</code> 会覆盖 <code>buf</code> 中从当前位置开始的字节。如果试图写超出 <code>&amp;mut [u8]</code> 的末尾，会得到一个部分写或一个 <code>io::Error</code>。不过，使用 <code>Curosr</code> 写入 <code>Vec&lt;u8&gt;</code> 的末尾是可以的，它会增大 <code>vector</code>。因此，<code>Cursor&lt;&amp;mut [u8]&gt;</code> 和 <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code> 实现了所有 <code>4</code> 个 <code>std::io::prelude</code> 中的 <code>Trait</code>。</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html"><code>std::net::TcpStream</code></a>：代表底层的 TCP 连接，可读可写；<code>TcpStream::connect((&quot;hostname&quot;, PORT))</code> 尝试去连接到一个 <code>server</code> 并且返回 <code>io::Result&lt;TcpStream&gt;</code>。</p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a>：支持生成子进程并将数据传输到其标准输入，如下所示：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="keyword">use</span> std::process::&#123;Command, Stdio&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">child</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;grep&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">arg</span>(<span class="string">&quot;-e&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">arg</span>(<span class="string">&quot;a.*e.*i.*o.*u&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">stdin</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">        .<span class="title function_ invoke__">spawn</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_words</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">to_child</span> = child.stdin.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> my_words &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(to_child, <span class="string">&quot;&#123;&#125;&quot;</span>, word)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(to_child); <span class="comment">// close grep&#x27;s stdin, so it will exit</span></span><br><span class="line">    child.<span class="title function_ invoke__">wait</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>child.stdin</code> 的类型是 <code>Option&lt;std::process::ChildStdin&gt;</code>，在这里在设置子进程时使用 <code>.stdin(Stdio::piped())</code>，所以 当 <code>.spawn()</code> 成功时，<code>child.stdin</code> 肯定会被填充。如果没有，<code>child.stdin</code> 将是 <code>None</code>。<code>Command</code> 也有类似的方法 <code>.stdout()</code> 和 <code>.stderr()</code>，可以用来请求 <code>child.stdout</code> 和 <code>child.stderr</code> 中的读取器。</p>
</li>
</ul>
<p><code>std::io</code> 模块还提供了一些返回实验性的的读取器和写入器的函数：</p>
<ul>
<li><p><code>io::sink()</code>：没有实际操作，所有写操作返回 <code>Ok</code>，但是数据被丢弃了；</p>
</li>
<li><p><code>io::empty()</code>：总是读取成功，但返回属于结束；</p>
</li>
<li><p><code>io::repeat(byte)</code>：返回 <code>Reader</code> 无止境地重复给定字节；</p>
</li>
</ul>
<h4 id="二进制数据、压缩、序列化"><a href="#二进制数据、压缩、序列化" class="headerlink" title="二进制数据、压缩、序列化"></a>二进制数据、压缩、序列化</h4><p>许多开源库构建于 <code>std::io</code> 之上提供了很多额外的功能。<a href="https://crates.io/crates/byteorder"><code>byteorder</code></a> 提供了 <code>ReadBytesExt</code> 和 <code>WriteBytesExt</code> 用于二进制数据的读写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> byteorder::&#123;ReadBytesExt, WriteBytesExt, LittleEndian&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = reader.read_u32::&lt;LittleEndian&gt;()?;</span><br><span class="line">writer.write_i64::&lt;LittleEndian&gt;(n <span class="keyword">as</span> <span class="type">i64</span>)?;</span><br></pre></td></tr></table></figure>

<p><a href="https://crates.io/crates/flate2"><code>flate2</code></a> 提供读取压缩数据的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> flate2::read::GzDecoder;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;access.log.gz&quot;</span>)?;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gzip_reader</span> = GzDecoder::<span class="title function_ invoke__">new</span>(file);</span><br></pre></td></tr></table></figure>

<p><a href="https://crates.io/crates/serde"><code>serde</code></a> 关联的 <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a> 实现了数据的序列化和反序列化。</p>
<p><code>serde</code> 也提供了两个关键的 <code>Trait</code> 这用于自动派生序列化和反序列化功能：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    location: <span class="type">String</span>,</span><br><span class="line">    items: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    health: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">player</span> = Player &#123;</span><br><span class="line">        location: <span class="string">&quot;ShangHai&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        items: <span class="built_in">vec!</span>[<span class="string">&quot;apple&quot;</span>.<span class="title function_ invoke__">to_string</span>()],</span><br><span class="line">        health: <span class="number">32</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    serde_json::<span class="title function_ invoke__">to_writer</span>(&amp;<span class="keyword">mut</span> std::io::<span class="title function_ invoke__">stdout</span>(), &amp;player)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>&#123;&quot;location&quot;:&quot;ShangHai&quot;,&quot;items&quot;:[&quot;apple&quot;],&quot;health&quot;:32&#125;
</code></pre>
<p>由于派生代码会使编译时间变长，所以使用这个功能需要显示声明：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>现在我们已经展示了如何使用读取器和写入器，接下来的几节将介绍 Rust 处理文件和目录的特性，它们位于 <code>std::path</code> 和 <code>std::fs</code> 模块中，所有这些功能都涉及使用文件名，因此我们将从文件名类型开始。</p>
<h4 id="OsStr、Path"><a href="#OsStr、Path" class="headerlink" title="OsStr、Path"></a><code>OsStr</code>、<code>Path</code></h4><p>操作系统不会强制文件名是有效的 <code>Unicode</code>，下面是两个创建文本文件的 <code>shell</code> 命令，只有第一个使用有效的 <code>UTF-8</code> 文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hello world&quot; &gt; ô.txt</span><br><span class="line">$ echo &quot;O brave new world, that has such filenames in&#x27;t&quot; &gt; $&#x27;\xf4&#x27;.txt</span><br></pre></td></tr></table></figure>

<p>对于内核，任何字节串（不包括空字节和斜杠）都是可接受的文件名。在 <code>Windows</code> 上也有类似的情况，几乎任何 <code>16</code>位“宽字符”字符串都是可接受的文件名，即使是无效的 <code>UTF-16</code> 字符串也是如此。操作系统处理的其他字符串也是如此，例如命令行参数和环境变量。</p>
<p><code>Rust</code> 字符串始终是有效的 <code>Unicode</code>，文件名在实践中几乎总是 <code>Unicode</code>，但 <code>Rust</code> 必须以某种方式应对它们不是的情况，这就是 <code>Rust</code> 有 <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>std::ffi::OsStr</code></a> 和 <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a> 的原因。</p>
<p><code>OsStr</code> 是一个字符串类型，它是 <code>UTF-8</code> 的超集。它的工作是能够表示当前系统上的所有文件名、命令行参数和环境变量，无论它们是否是有效的 <code>Unicode</code>。在 <code>Unix</code> 上，一个 <code>OsStr</code> 可以保存任何字节序列。在 <code>Windows</code> 上，<code>OsStr</code> 使用 <code>UTF-8</code> 的扩展存储，该扩展可以编码任何 <code>16</code> 位值序列，包括不匹配的。</p>
<p>所以我们有两种字符串类型：<code>str</code> 用于实际的 <code>Unicode</code> 字符串；<code>OsStr</code> 用于操作系统可以发出的任何东西。我们将再介绍一个：<code>std::path::Path</code>，用于文件名。<code>Path</code> 与 <code>OsStr</code> 完全相同，但它添加了许多方便的文件名相关方法。</p>
<p>最后，对于每个字符串类型，都有一个对应的 <code>owning</code> 类型：一个 <code>String</code> 拥有一个堆分配的 <code>str</code>，一个 <code>std::ffi::OsString</code> 拥有一个堆分配的 <code>OsStr</code>，一个 <code>std::path::PathBuf</code> 拥有一个堆分配的 <code>Path</code>。</p>
<img data-src="/2022/04/22/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/fileaname-types.png" class="">

<p>所有这三种类型都实现了一个共同的特征，<code>AsRef&lt;Path&gt;</code>，因此我们可以轻松地声明一个接受“任何文件名类型”作为参数的泛型函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">swizzle_file</span>&lt;P&gt;(path_arg: P) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: <span class="built_in">AsRef</span>&lt;Path&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = path_arg.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Path、PathBuf"><a href="#Path、PathBuf" class="headerlink" title="Path、PathBuf"></a><code>Path</code>、<code>PathBuf</code></h4><p><code>Path</code> 提供以下方法：</p>
<ul>
<li><p><code>Path::new(str)</code>：转换 <code>&amp;str</code> 或者 <code>&amp;OsStr</code> 为 <code>&amp;Path</code>，转换过程中不发生复制，<code>&amp;Path</code> 指向原始 <code>&amp;str</code> 或者 <code>&amp;OsStr</code> 的相同字节；</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">home_dir</span> = Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/fwolfe&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>path.parent()</code>：返回路径父目录，以 <code>Option&lt;&amp;Path&gt;</code> 表示，父目录的路径仅仅是当前路径的子串：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/fwolfe/program.txt&quot;</span>).<span class="title function_ invoke__">parent</span>(),</span><br><span class="line"><span class="title function_ invoke__">Some</span>(Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/fwolfe&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>path.file_name()</code>：返回路径中的最后一个部分，返回类型是 <code>Option&lt;&amp;OsStr&gt;</code>。例如：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"><span class="built_in">assert_eq!</span>(Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/fwolfe/program.txt&quot;</span>).<span class="title function_ invoke__">file_name</span>(),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;program.txt&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>path.is_absolute(), path.is_relative()</code>：相对路径还是绝对路径；</p>
</li>
<li><p><code>path1.join(path2)</code>：连接两个新路径，返回新的 <code>PathBuf</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">path1</span> = Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/usr/share/dict&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(path1.<span class="title function_ invoke__">join</span>(<span class="string">&quot;words&quot;</span>), Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/usr/share/dict/words&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>  如果 <code>path2</code> 是绝对路径，仅仅返回 <code>path2</code> 的副本，所以这个方法能被用于转换任何路径为绝对路径：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">abs_path</span> = std::env::<span class="title function_ invoke__">current_dir</span>()?.<span class="title function_ invoke__">join</span>(any_path);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>path.components()</code>：返回一个迭代器，包含给定路径从左至右的所有部分，内容类型是 <a href="https://doc.rust-lang.org/std/path/enum.Component.html"><code>std::path::Component</code></a>，它是一个枚举，能代表一个文件路径中所有不同的片段：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Component</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Prefix</span>(PrefixComponent&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    RootDir,</span><br><span class="line">    CurDir,</span><br><span class="line">    ParentDir,</span><br><span class="line">    <span class="title function_ invoke__">Normal</span>(&amp;<span class="symbol">&#x27;a</span> OsStr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>path.ancestors()</code>：返回一个迭代器，返回当前文件或者目录的祖先直到根目录。每个 <code>item</code> 类型是 <code>Path</code>，第一个是它自己：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/jimb/calendars/calendar-18x18.pdf&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(</span><br><span class="line">    file.<span class="title function_ invoke__">ancestors</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">    <span class="built_in">vec!</span>[</span><br><span class="line">        Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/jimb/calendars/calendar-18x18.pdf&quot;</span>),</span><br><span class="line">        Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/jimb/calendars&quot;</span>),</span><br><span class="line">        Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/jimb&quot;</span>),</span><br><span class="line">        Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home&quot;</span>),</span><br><span class="line">        Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些方法适用于内存中的字符串，<code>Path</code> 也有一些查询文件系统的方法：<code>.exists()</code>、<code>.is_file()</code>、<code>.is_dir()</code>、<code>.read_dir()</code>、.<code>canonicalize()</code> 等等。 将 <code>Path </code>转换为字符串有三种方法，每一个都允许 <code>Path</code> 中出现无效 <code>UTF-8</code> 的可能性：</p>
<ul>
<li><p><code>path.to_str()</code>：返回 <code>Option&lt;&amp;str&gt;</code>，如果包含无效的 <code>UTF-8</code>，返回 <code>None</code>；</p>
</li>
<li><p><code>path.to_string_lossy()</code>：这基本上是同一件事，但它设法在所有情况下返回某种字符串。如果路径不是有效的 <code>UTF-8</code>，这些方法会创建一个副本，用 <code>Unicode</code> 替换字符 <code>U+FFFD (&#39;�&#39;)</code> 替换每个无效的字节序列；</p>
</li>
<li><p><code>path.display()</code>：用于路径打印，它返回的值不是字符串，但它实现了 <code>std::fmt::Display</code>，因此它可以与 <code>format!()</code>、<code>println!()</code> 等一起使用。 如果路径不是有效的 <code>UTF-8</code>，则输出可能包含 <code>�</code> 字符。</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Download found. You put it in: &#123;&#125;&quot;</span>, dir_path.<span class="title function_ invoke__">display</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="文件系统访问"><a href="#文件系统访问" class="headerlink" title="文件系统访问"></a>文件系统访问</h4><p>下表列出了 <a href="https://doc.rust-lang.org/std/fs/index.html#functions"><code>std::fs</code></a> 提供的用于文件系统访问的函数：</p>
<img data-src="/2022/04/22/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/filesystem-access.png" class="">

<p><code>Rust</code> 提供了可在 <code>Windows</code> 以及 <code>macOS</code>、<code>Linux</code> 和其他 <code>Unix</code> 系统上行为一致的可移植函数。</p>
<p>所有这些功能都是通过调用操作系统来实现的，例如，<code>std::fs::canonicalize(path)</code> 不仅仅使用字符串处理来消除 <code>.</code> 和<code>..</code>从给定的路径。它使用当前工作目录解析相对路径，并追踪符号链接，如果路径不存在，则为错误。</p>
<p>由 <a href="https://doc.rust-lang.org/std/fs/fn.metadata.html"><code>std::fs::metadata(path)</code></a> 和 <code>std::fs::symlink_metadata(path)</code> 包含文件类型和大小、权限和时间戳等信息。为方便起见，<code>Path</code> 类型有一些内置方法：例如，<code>path.metadata()</code> 与 <code>std::fs::metadata(path)</code> 相同。</p>
<h4 id="目录读取"><a href="#目录读取" class="headerlink" title="目录读取"></a>目录读取</h4><p>可以使用 <a href="https://doc.rust-lang.org/std/fs/fn.read_dir.html"><code>std::fs::read_dir</code></a> 列出目录中的内容，或者使用 <a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.read_dir"><code>path::read_dir()</code></a> :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">entry_result</span> <span class="keyword">in</span> path.<span class="title function_ invoke__">read_dir</span>()? &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">entry</span> = entry_result?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, entry.<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">to_string_lossy</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>?</code> 的两种用法，在这段代码中，第一行检查打开目录的错误，第二行检查读取下一个条目的错误。<a href="https://doc.rust-lang.org/std/fs/struct.DirEntry.html"><code>std::fs::DirEntry</code></a> 一些方法：</p>
<ul>
<li><p><code>entry.file_name()</code>：目录或者文件的名称，类型是 <code>OsString</code>；</p>
</li>
<li><p><code>entry.path()</code>：文件或者目录路径，如果我们正在浏览的目录是 <code>/home/jimb</code>，<code>entry.file_name()</code> 是 <code>&quot;.emacs&quot;</code>，那么 <code>entry.path()</code> 将返回 <code>PathBuf::from(&quot;/home/jimb/.emacs&quot;)</code>；</p>
</li>
<li><p><code>entry.file_type()</code>：返回 <code>io::Result&lt;FileType&gt;</code>，<code>FileType</code> 有 <code>.is_file(), .is_dir(), .is_symlink()</code> 方法；</p>
</li>
</ul>
<p>当读取目录的时候，<code>.</code> 和 <code>..</code> 不会包括在内。下面是一个递归复制目录的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Copy the existing directory `src` to the target path `dst`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">copy_dir_to</span>(src: &amp;Path, dst: &amp;Path) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> !dst.<span class="title function_ invoke__">is_dir</span>() &#123;</span><br><span class="line">        fs::<span class="title function_ invoke__">create_dir</span>(dst)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry_result</span> <span class="keyword">in</span> src.<span class="title function_ invoke__">read_dir</span>()? &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">entry</span> = entry_result?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_type</span> = entry.<span class="title function_ invoke__">file_type</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">copy_to</span>(&amp;entry.<span class="title function_ invoke__">path</span>(), &amp;file_type, &amp;dst.<span class="title function_ invoke__">join</span>(entry.<span class="title function_ invoke__">file_name</span>()))?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Copy wha tever is at `src` to the target path `dst`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">copy_to</span>(src: &amp;Path, src_type: &amp;fs::FileType, dst: &amp;Path) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> src_type.<span class="title function_ invoke__">is_file</span>() &#123;</span><br><span class="line">        fs::<span class="title function_ invoke__">copy</span>(src, dst)?;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> src_type.<span class="title function_ invoke__">is_dir</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">copy_dir_to</span>(src, dst)?;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(io::Error::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            io::ErrorKind::Other,</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;don&#x27;t know how to copy: &#123;&#125;&quot;</span>, src.<span class="title function_ invoke__">display</span>()),</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平台特定功能"><a href="#平台特定功能" class="headerlink" title="平台特定功能"></a>平台特定功能</h4><p>上面的例子中，如果我们是在 <code>Unix</code> 系统中，将会遇到符号链接，但是符号链接 <code>Windows</code> 系统又没有，<code>Rust</code> 使用条件编译解决此类问题。对于这个场景，可以使用 <code>use std::os::unix::fs::symlink</code>，下面是完整程序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(unix)]</span></span><br><span class="line"><span class="keyword">use</span> std::os::unix::fs::symlink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Copy the existing directory `src` to the target path `dst`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">copy_dir_to</span>(src: &amp;Path, dst: &amp;Path) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> !dst.<span class="title function_ invoke__">is_dir</span>() &#123;</span><br><span class="line">        fs::<span class="title function_ invoke__">create_dir</span>(dst)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry_result</span> <span class="keyword">in</span> src.<span class="title function_ invoke__">read_dir</span>()? &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">entry</span> = entry_result?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_type</span> = entry.<span class="title function_ invoke__">file_type</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">copy_to</span>(&amp;entry.<span class="title function_ invoke__">path</span>(), &amp;file_type, &amp;dst.<span class="title function_ invoke__">join</span>(entry.<span class="title function_ invoke__">file_name</span>()))?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Copy wha tever is at `src` to the target path `dst`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">copy_to</span>(src: &amp;Path, src_type: &amp;fs::FileType, dst: &amp;Path) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> src_type.<span class="title function_ invoke__">is_file</span>() &#123;</span><br><span class="line">        fs::<span class="title function_ invoke__">copy</span>(src, dst)?;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> src_type.<span class="title function_ invoke__">is_dir</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">copy_dir_to</span>(src, dst)?;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> src_type.<span class="title function_ invoke__">is_symlink</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target</span> = src.<span class="title function_ invoke__">read_link</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">symlink</span>(target, dst)?;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(io::Error::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            io::ErrorKind::Other,</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;don&#x27;t know how to copy: &#123;&#125;&quot;</span>, src.<span class="title function_ invoke__">display</span>()),</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Stub implementation of `symlink` for platforms that don&#x27;t provide it.</span></span><br><span class="line"><span class="meta">#[cfg(not(unix))]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">symlink</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;, Q: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(src: P, _dst: Q) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(io::Error::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        io::ErrorKind::Other,</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;can&#x27;t copy symbolic link: &#123;&#125;&quot;</span>, src.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">display</span>()),</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>#[cfg(unix)]</code> 和 <code>#[cfg(not(unix))]</code> 我们区分了 <code>Unix</code> 和 非 <code>Unix</code> 平台。大多数 <code>Unix</code> 特定的特性不是独立的函数，而是向标准库类型添加新方法的扩展特性，有一个 <a href="https://doc.rust-lang.org/std/os/unix/prelude/index.html"><code>preclude</code></a> 模块可用于一次启用所有这些扩展：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::os::unix::prelude::*;</span><br></pre></td></tr></table></figure>

<p>例如，在 <code>Unix</code> 上，这会为 <code>std::fs::Permissions</code> 添加一个 <code>.mode()</code> 方法，提供对表示 <code>Unix</code> 权限的底层 <code>u32</code> 值的访问。还有 <code>std::fs::Metadata</code> 在 <code>unix</code> 系统上扩展了 <code>std::os::unix::fs::MetadataExt</code>，能够获取<code>UID</code>，<code>UID</code> 等信息。</p>
<h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a><code>Networking</code></h3><p>对于底层网络代码，从 <code>std::net</code> 模块开始，它为 <code>TCP</code> 和 <code>UDP</code> 网络提供跨平台支持，使用 <code>native_tls crate</code> 来支持 <code>SSL/TLS</code>。</p>
<p>这些模块为网络上直接的、阻塞的输入和输出提供了构建块，可以用几行代码编写一个简单的服务器，使用 <code>std::net</code> 并为每个连接生成一个线程。 例如，这是一个<code>&quot;echo&quot;</code>服务器：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpListener;</span><br><span class="line"><span class="keyword">use</span> std::thread::spawn;</span><br><span class="line"><span class="comment">/// Accept connections forever, spawning a thread for each one.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">echo_main</span>(addr: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(addr)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;listening on &#123;&#125;&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// Wait for a client to connect.</span></span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> stream, addr) = listener.<span class="title function_ invoke__">accept</span>()?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;connection received from &#123;&#125;&quot;</span>, addr);</span><br><span class="line">        <span class="comment">// Spawn a thread to handle this client.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">write_stream</span> = stream.<span class="title function_ invoke__">try_clone</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// Echo everything we receive from `stream` back to it.</span></span><br><span class="line">            io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> stream, &amp;<span class="keyword">mut</span> write_stream).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error in client thread: &quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;connection closed&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">echo_main</span>(<span class="string">&quot;127.0.0.1:17007&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error: &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回显服务器只是简单地重复您发送给它的所有内容，这种代码与用 <code>Java</code> 或 <code>Python</code> 编写的代码没有太大区别。但是，对于高性能服务器，需要使用异步输入和输出，后面将介绍 <code>Rust</code> 对异步编程的支持，并展示了网络客户端和服务器的完整代码。</p>
<p>第三方 <code>crate</code> 支持更高级别的协议。例如，<a href="https://crates.io/crates/reqwest"><code>reqwest</code></a> 为 <code>HTTP</code> 客户端提供了一个漂亮的 <code>API</code>。<code>actix-web</code> 提供了高级功能，例如服务和转换特征，它们可以帮助从可插入的部分组成应用程序。<code>websocket</code> 实现了 <code>WebSocket</code> 协议。 </p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】错误处理</title>
    <url>/2022/06/24/%E3%80%90Rust%E3%80%91%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><code>Rust</code> 的错误处理方法非常不同寻常，本节介绍了 Rust 中两种不同类型的错误处理：<code>panic</code> 和 <code>Result</code>。</p>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a><code>Panic</code></h3><p>当程序遇到,数组越界，除<code>0</code>，这样很严重的<code>bug</code>时就会<code>panic</code>，在 <code>Result</code> 上调用 <code>.expect()</code> 遇到错误以及断言失败都会发生<code>panic</code>。还有宏 <code>panic!()</code>，用于在代码发现它出错是，想要直接退出。<code>panic!()</code> 接受可选的 <code>println!()</code> 样式参数，用于构建错误消息。</p>
<p>这些都是程序员的错，但我们都会犯错，当这些不该发生的错误发生时，<code>Rust</code> 可以终止进程。来看一个除<code>0</code>的示例：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">pirate_share</span>(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">pirate_share</span>(total: <span class="type">u64</span>, crew_size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">half</span> = total / <span class="number">2</span>;</span><br><span class="line">    half / crew_size <span class="keyword">as</span> <span class="type">u64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这段代码，程序会奔溃的并且打印出调用栈，还提示我们可以设置 <code>RUST_BACKTRACE=full</code> 获得更多的信息：</p>
<pre><code>/Users/fudenglong/.cargo/bin/cargo run --color=always --package mandelbrot --bin mandelbrot
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/mandelbrot`
thread &#39;main&#39; panicked at &#39;attempt to divide by zero&#39;, src/main.rs:7:5
stack backtrace:
0: rust_begin_unwind
            at /rustc/4ca19e09d302a4cbde14f9cb1bc109179dc824cd/library/std/src/panicking.rs:584:5
1: core::panicking::panic_fmt
            at /rustc/4ca19e09d302a4cbde14f9cb1bc109179dc824cd/library/core/src/panicking.rs:142:14
2: core::panicking::panic
            at /rustc/4ca19e09d302a4cbde14f9cb1bc109179dc824cd/library/core/src/panicking.rs:48:5
3: mandelbrot::pirate_share
            at ./src/main.rs:7:5
4: mandelbrot::main
            at ./src/main.rs:2:5
5: core::ops::function::FnOnce::call_once
            at /rustc/4ca19e09d302a4cbde14f9cb1bc109179dc824cd/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.

Process finished with exit code 101
</code></pre>
</div>

<p>线程之间的 <code>panic</code> 是相互独立的，也可以调用 <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind()</code></a> 捕获异常，并且让程序执行。默认发生 <code>panic</code> 时会展开调用栈，此外有两种情况 <code>Rust</code> 不会尝试展开调用栈： </p>
<ul>
<li><p>如果 <code>.drop()</code> 方法触发了第二次恐慌，而 <code>Rust</code> 在第一次之后仍在尝试清理，这被认为是致命的，<code>Rust</code> 停止展开并中止整个进程； </p>
</li>
<li><p><code>Rust</code> 的恐慌行为是可定制的。如果使用 <code>-C panic=abort</code> 编译，程序中的第一个 <code>panic</code> 会立即中止进程。（使用这个选项，<code>Rust</code> 不需要知道如何展开调用栈，因此这可以减少编译代码的大小。）</p>
</li>
</ul>
<span id="more"></span>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a><code>Result</code></h3><p><code>Rust</code> 中没有异常，而是在会出现错误的函数中会返回一个 <code>Result</code> 类型，它预示着函数会预期执行成功，也可能因异常执失败。当我们调用函数 <code>get_weather</code> 的时候，要么成功返回 <code>Ok(weather)</code>，<code>weather</code> 是 <code>WeatherReport</code> 的一个实例。或者出现错误时返回 <code>Err(error_value)</code>，其中 <code>error_value</code> 是 <code>io:Error</code> 类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_weather</span>(location: LatLng) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;WeatherReport, io::Error&gt;</span><br></pre></td></tr></table></figure>

<p>每当我们调用这个函数时，<code>Rust</code> 要求我们编写错误处理程序。如果不对 <code>Result</code> 做一些处理，我们就无法获取 <code>WeatherReport</code>，如果未使用 <code>Result</code> 值，编译器就会警告。</p>
<h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><p>处理 <code>Result</code> 类型最直接的方式是使用 <code>match</code> 表达式，这类似于其他语言中 <code>try/catch</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">get_weather</span>(hometown) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(report) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">display_weather</span>(hometown, &amp;report);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;error querying the weather: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        <span class="title function_ invoke__">schedule_weather_retry</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code> 可以处理，但看起来似乎有点冗长。因此 <code>Result&lt;T, E&gt;</code> 提供了很多方法使用，全部方法可以阅读 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>https://doc.rust-lang.org/std/result/enum.Result.html</code></a>，下面是一些常用的方法列表：</p>
<ul>
<li><p><code>result.is_ok(), result.is_err()</code>：返回一个 <code>bool</code> 表示执行成功还是遇到错误；</p>
</li>
<li><p><code>result.ok()</code>：以 <code>Option(T)</code> 的形式返回成功值，如果结果是成功的则返回 <code>Some(success_value)</code>，否则返回 <code>None</code>；</p>
</li>
<li><p><code>result.err()</code>：以 <code>Option(T)</code> 的返回错误值；</p>
</li>
<li><p><code>result.unwrap_or(fallback)</code>：如果有的话返回成功值，否则返回备选值，丢掉错误；</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">// A fairly safe prediction for Southern California.</span></span><br><span class="line"><span class="keyword">const</span> THE_USUAL: WeatherReport = WeatherReport::<span class="title function_ invoke__">Sunny</span>(<span class="number">72</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a real weather report, if possible.</span></span><br><span class="line"><span class="comment">// If not, fall back on the usual.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">report</span> = <span class="title function_ invoke__">get_weather</span>(los_angeles).<span class="title function_ invoke__">unwrap_or</span>(THE_USUAL);</span><br><span class="line"><span class="title function_ invoke__">display_weather</span>(los_angeles, &amp;report);</span><br></pre></td></tr></table></figure>

<p>  相比 <code>.ok()</code> 来说它是比较好的，因为返回的是 <code>T</code> 而不是 <code>Option&lt;T&gt;</code>，但是只有在存在备选值得时候才有效。</p>
</li>
<li><p><code>result.unwrap_or_else(fallback_fn)</code>：和前面的方法是一样的，不同的是，它需要传递一个函数或闭包。这适用于在错误时有自定义逻辑处理的情况：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">report</span> =</span><br><span class="line">    <span class="title function_ invoke__">get_weather</span>(hometown)</span><br><span class="line">    .<span class="title function_ invoke__">unwrap_or_else</span>(|_err| <span class="title function_ invoke__">vague_prediction</span>(hometown));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>result.unwrap()</code>：如果 <code>result</code> 是成功的，则返回成功值，否则将会 <code>panic</code>；</p>
</li>
<li><p><code>result.expect(message)</code>：类似于 <code>unwrap()</code>，但是允许提供一个信息在 <code>panic</code> 时打印；</p>
</li>
<li><p><code>result.as_ref()</code>：将 <code>Result&lt;T, E&gt;</code> 转换为 <code>Result&lt;&amp;T, &amp;E&gt;</code>；</p>
</li>
<li><p><code>result.as_mut()</code>：将 <code>Result&lt;T, E&gt;</code> 转换为 <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code>；</p>
</li>
</ul>
<p>最后这两个方法和除 <code>.is_ok()</code> 和 <code>.is_err()</code> 之外的方法不同，其他的都会消耗 <code>result</code> 的值，也就是它们会获取 <code>result</code> 的所有权，它们都是接受 <code>self</code> 作为参数。但是有时候我们想在不破坏数据的情况下访问数据，例如，我们想调用 <code>result.ok()</code>，又想保持 <code>result</code> 在我们调用之后任然可用，所以我们可以编写 <code>result.as_ref().ok()</code>，他只是借用 <code>result</code> 而不获取它的所有权，当然返回的也就是 <code>Option&lt;&amp;T&gt;</code> 不再是 <code>Option&lt;T&gt;</code>。</p>
<h3 id="Result-别名"><a href="#Result-别名" class="headerlink" title="Result 别名"></a><code>Result</code> 别名</h3><p>我们可以给 <code>Result&lt;T, E&gt;</code> 起个别名，让写起来更加简单，就像 <a href="https://doc.rust-lang.org/std/fs/fn.remove_file.html"><code>std::fs::remove_file</code></a> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove_file</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;</span><br></pre></td></tr></table></figure>

<p>模块通常定义一个 <code>Result</code> 类型别名，以避免必须重复模块中几乎每个函数都一致使用的错误类型。例如，标准库的 <code>std::io</code> 模块包括这行代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = result::<span class="type">Result</span>&lt;T, Error&gt;;</span><br></pre></td></tr></table></figure>

<p>这定义了一个公共类型 <code>std::io::Result&lt;T&gt;</code>，它是 <code>Result&lt;T, E&gt;</code> 的别名，但将 <code>std::io::Error</code> 硬编码为错误类型。实际上，这意味着<code>Rust</code> 会将 <code>std::io::Result&lt;String&gt;</code> 理解为 <code>std::io::Result&lt;String, std::io::Error&gt;</code> 的简写。</p>
<h3 id="错误打印"><a href="#错误打印" class="headerlink" title="错误打印"></a>错误打印</h3><p>我们经常处理错误的方式就是将错误信息打印出来，然后程序继续执行。我们之前都是用 <code>println!()</code> 这个宏来完成的，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;error querying the weather: &#123;&#125;&quot;</span>, err);</span><br></pre></td></tr></table></figure>

<p>标注库里面提供了很多错误类型，例如 <code>std::io::Error</code>，<code>std::fmt::Error</code> 和 <code>std::str::Utf8Error</code> 等等，但是它们都实现了 <code>std::error::Error</code>，这意味着所有的错误都有下面的接口：</p>
<ul>
<li><p><code>println!()</code>：所有错误类型都可以使用它打印。 使用 <code>&#123;&#125;</code> 格式说明符打印错误通常只显示简短的错误消息。 或者可以使用 <code>&#123;:?&#125;</code> ，以获取错误的调试视图， 这对用户不太友好，但包含额外的技术信息；</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// result of `println!(&quot;error: &#123;&#125;&quot;, err);`</span><br><span class="line">error: failed to lookup address information: No address associated with</span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line">// result of `println!(&quot;error: &#123;:?&#125;&quot;, err);`</span><br><span class="line">error: Error &#123; repr: Custom(Custom &#123; kind: Other, error: StringError(</span><br><span class="line">&quot;failed to lookup address information: No address associated with</span><br><span class="line">hostname&quot;) &#125;) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>err.to_string()</code>：返回一个错误信息作为 <code>String</code>；</p>
</li>
<li><p><code>err.source()</code>：返回底层的 <code>err</code>。例如，网络原因导致银行交易失败，然后又导致你的转账被取消，那么 <code>err.souce()</code> 可以返回下层的错误。</p>
</li>
</ul>
<p>打印错误值不会同时打印出其来源。如果想确保打印所有可用信息，使用下面的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Write, stderr&#125;;</span><br><span class="line"><span class="comment">/// Dump an error message to `stderr`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If another error happens while building the error message or</span></span><br><span class="line"><span class="comment">/// writing to `stderr`, it is ignored.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_error</span>(<span class="keyword">mut</span> err: &amp;<span class="keyword">dyn</span> Error) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = <span class="built_in">writeln!</span>(<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;error: &#123;&#125;&quot;</span>, err);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(source) = err.<span class="title function_ invoke__">source</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_</span> = <span class="built_in">writeln!</span>(<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;caused by: &#123;&#125;&quot;</span>, source);</span><br><span class="line">        err = source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writeln!</code> 宏的工作方式与 <code>println!</code> 类似，不同之处在于它将数据写入你选择的流。在这里，我们将错误消息写入标准错误流 <code>std::io::stderr</code>。我们可以使用 <code>eprintln!</code> 宏做同样的事情，但 <code>eprintln!</code> 如果发生错误会 <code>panic</code>。</p>
<h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p><code>Rust</code> 中有个 <code>?</code> 操作符，用于向上传播错误。主要的应用场景是，当我们调用函数遇到错误，但又不想立即处理，只是想把这个错误继续往外传播，让最外层的调用者处理，我们就可以使用它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">weather</span> = <span class="title function_ invoke__">get_weather</span>(hometown)?;</span><br></pre></td></tr></table></figure>

<p><code>?</code> 这个操作符的行为取决于 <code>get_weather</code> 函数返回成功结果还是错误结果：</p>
<ul>
<li><p>成功时，它会获取里面成功的值，也就是获取 <code>WeatherReport</code>，而不是 <code>Result&lt;WeatherReport, io::Error&gt;</code>；</p>
</li>
<li><p>出错时，它会立即返回，为了确保有效，<code>?</code> 只能用于具有 <code>Result</code> 返回类型的函数；</p>
</li>
</ul>
<p><code>?</code> 可以看做是 <code>match</code> 的一种简化方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">weather</span> = <span class="keyword">match</span> <span class="title function_ invoke__">get_weather</span>(hometown) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(success_value) =&gt; success_value,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>Rust</code> 较老的代码中，这个干工作是用 <code>try!</code> 宏处理的，直到 <code>1.13</code> 引入 <code>?</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">weather</span> = <span class="built_in">try!</span>(<span class="title function_ invoke__">get_weather</span>(hometown))</span><br></pre></td></tr></table></figure>

<p>错误在程序中是非常普遍，尤其是在与操作系统接口的代码中， 因此 <code>?</code> 运算符可能会出现在函数的每一行：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">move_all</span>(src: &amp;Path, dst: &amp;Path) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry_result</span> <span class="keyword">in</span> src.<span class="title function_ invoke__">read_dir</span>()? &#123; <span class="comment">// opening dir could fail</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">entry</span> = entry_result?; <span class="comment">// reading dir could fail</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dst_file</span> = dst.<span class="title function_ invoke__">join</span>(entry.<span class="title function_ invoke__">file_name</span>());</span><br><span class="line">        fs::<span class="title function_ invoke__">rename</span>(entry.<span class="title function_ invoke__">path</span>(), dst_file)?; <span class="comment">// renaming could fail</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(()) <span class="comment">// phew!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>?</code> 也可以用于 <code>Option</code> 类型，道理和 <code>Result</code> 是相同的。</p>
<h3 id="处理不同类型错误"><a href="#处理不同类型错误" class="headerlink" title="处理不同类型错误"></a>处理不同类型错误</h3><p>有时候，在一个函数中会遇到多种类型的错误，而函数的返回类型是固定的，如果我们使用 <code>?</code> 向上传播错误就会遇到问题，错误类型不匹配，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, BufRead&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Read integers from a text file.</span></span><br><span class="line"><span class="comment">/// The file should have one number on each line.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_numbers</span>(file: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> BufRead) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i64</span>&gt;, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line_result</span> <span class="keyword">in</span> file.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line_result?; <span class="comment">// reading lines can fail</span></span><br><span class="line">        numbers.<span class="title function_ invoke__">push</span>(line.<span class="title function_ invoke__">parse</span>()?); <span class="comment">// parsing integers can fail</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(numbers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这段代码，会看到如下的错误，总结来说就是 <code>line.parse()</code> 返回的错误没法转换成 <code>io::Error</code>，因为 <code>line.parse()</code> 返回的是 <code>Result&lt;i64 std::num::ParseIntError&gt;</code>，<code>ParseIntError</code> 没法转换成 <code>io::Error</code>：</p>
<pre><code>error[E0277]: `?` couldn&#39;t convert the error to `std::io::Error`
--&gt; src/main.rs:9:34
|
5 | fn read_numbers(file: &amp;mut dyn BufRead) -&gt; Result&lt;Vec&lt;i64&gt;, io::Error&gt; {
|                                            --------------------------- expected `std::io::Error` because of this
...
9 |         numbers.push(line.parse()?); // parsing integers can fail
|                                  ^ the trait `From&lt;ParseIntError&gt;` is not implemented for `std::io::Error`
|
= note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
= help: the following other types implement trait `From&lt;T&gt;`:
            &lt;std::io::Error as From&lt;ErrorKind&gt;&gt;
            &lt;std::io::Error as From&lt;IntoInnerError&lt;W&gt;&gt;&gt;
            &lt;std::io::Error as From&lt;alloc::ffi::c_str::NulError&gt;&gt;
= note: required because of the requirements on the impl of `FromResidual&lt;Result&lt;Infallible, ParseIntError&gt;&gt;` for `Result&lt;Vec&lt;i64&gt;, std::io::Error&gt;`
</code></pre>
</div>

<p>这里介绍一种错误的处理方法，<code>Rust</code> 标准库中的所有错误都可以转换为 <code>Box&lt;dyn std::error::Error + Send + Sync + &#39;static&gt;</code> 类型，其中：</p>
<ul>
<li><p><code>dyn std::error::Error</code>：表示任意错误；</p>
</li>
<li><p><code>Send + Sync + &#39;static</code>：能够在多线程之间安全传递；</p>
</li>
</ul>
<p>出于方便，我们可以下面的类型，并且对 <code>read_numbers()</code> 函数进行整改， </p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, BufRead&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GenericError</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GenericResult</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, GenericError&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Read integers from a text file.</span></span><br><span class="line"><span class="comment">/// The file should have one number on each line.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_numbers</span>(file: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> BufRead) <span class="punctuation">-&gt;</span> GenericResult&lt;<span class="type">Vec</span>&lt;<span class="type">i64</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line_result</span> <span class="keyword">in</span> file.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">line</span> = line_result?; <span class="comment">// reading lines can fail</span></span><br><span class="line">        numbers.<span class="title function_ invoke__">push</span>(line.<span class="title function_ invoke__">parse</span>()?); <span class="comment">// parsing integers can fail</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(numbers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想从一个返回 <code>GenericResult</code> 的函数，找到一种特定类型的错误处理，但让其他错误传播出去，可以使用泛型方法 <code>error.downcast_ref::&lt;ErrorType&gt;()</code>。 如果它恰好是要查找的特定类型的错误，它会借用对错误的引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">compile_project</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(()) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(mse) = err.downcast_ref::&lt;MissingSemicolonError&gt;() &#123;</span><br><span class="line">                <span class="title function_ invoke__">insert_semicolon_in_source_code</span>(mse.<span class="title function_ invoke__">file</span>(), mse.<span class="title function_ invoke__">line</span>())?;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// try again!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还有一种处理方式是使用 <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a> 帮我自动实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>。</p>
<h3 id="忽略错误"><a href="#忽略错误" class="headerlink" title="忽略错误"></a>忽略错误</h3><p>有时候，我们可能就是想忽略一个错误，因为某个函数执行成功与否关系不大，例如写日志到 <code>stderr</code>，但是我们如果不处理，编译器会报告警：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">writeln!</span>(<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;error: &#123;&#125;&quot;</span>, err); <span class="comment">// warning: unused result</span></span><br></pre></td></tr></table></figure>

<p>不过可以使用 <code>let _ = ...</code> 消除这个告警：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = <span class="built_in">writeln!</span>(<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;error: &#123;&#125;&quot;</span>, err); <span class="comment">// ok, ignore result</span></span><br></pre></td></tr></table></figure>

<h3 id="处理-main-函数中的错误"><a href="#处理-main-函数中的错误" class="headerlink" title="处理 main 函数中的错误"></a>处理 <code>main</code> 函数中的错误</h3><p>使用 <code>?</code> 向上传递错误大多时候是比较正确的行为，可是当错误传播到 <code>main</code> 函数的时候我们就需要处理。大多时候，我们看到的 <code>main</code> 函数签名都是下面这个样子，它的返回值类型是 <code>()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们不能使用 <code>?</code> 传播错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">calculate_tides</span>()?; <span class="comment">// error: can&#x27;t pass the buck any further</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的方式是使用 <code>.expect()</code>，检查是否调用成功，如果失败就打印错误信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">calculate_tides</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error&quot;</span>); <span class="comment">// the buck stops here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，我们也可以更改这个 <code>main</code> 函数的签名，让它返回 <code>Result</code> 类型，使用 <code>?</code> 传递错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TideCalcError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tides</span> = <span class="title function_ invoke__">calculate_tides</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">print_tides</span>(tides);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式打印的错误信息不是很详细，如果想自定义错误输出，还需要自己处理错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = <span class="title function_ invoke__">calculate_tides</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">print_error</span>(&amp;err);</span><br><span class="line">        std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误定义"><a href="#错误定义" class="headerlink" title="错误定义"></a>错误定义</h3><p>标注库里面的错误不可能满足所有情况，大多时候我们需要自定义错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">JsonError</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> message: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> line: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> column: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们希望和标准的错误类型表现一样，我们还需要做点适配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="comment">// Errors should be printable.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">JsonError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), fmt::Error&gt; &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125; (&#123;&#125;:&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.message, <span class="keyword">self</span>.line, <span class="keyword">self</span>.column)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Errors should implement the std::error::Error trait,</span></span><br><span class="line"><span class="comment">// but the default definitions for the Error methods are fine.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::error::Error <span class="keyword">for</span> <span class="title class_">JsonError</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>不过，每次都实现这些 <code>trait</code> 是很头疼的，所以我们可使用 <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>，帮我自动实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> thiserror::Error;</span><br><span class="line"><span class="meta">#[derive(Error, Debug)]</span></span><br><span class="line"><span class="meta">#[error(<span class="string">&quot;&#123;message:&#125; (&#123;line:&#125;, &#123;column&#125;)&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">JsonError</span> &#123;</span><br><span class="line">    message: <span class="type">String</span>,</span><br><span class="line">    line: <span class="type">usize</span>,</span><br><span class="line">    column: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】迭代器</title>
    <url>/2022/05/28/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>迭代器是产生一系列值的值，通常用于循环操作。<code>Rust</code> 的标准库提供了遍历<code>vector</code>、字符串、哈希表和其他集合的迭代器，还提供了从输入流生成文本行、网络连接、用于多线程之间值传递的迭代器，<code>Rust</code> 的迭代器灵活、富有表现力且高效。</p>
<p>在 <code>Rust</code> 中，<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>std::iter::IntoIterator</code></a> 是实现迭代器的基础。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器可以是任何实现了 <code>Iterator</code> 的值，<code>Item</code> 是每次迭代产生的值，<code>next</code> 要么返回 <code>Some(v)</code>，<code>v</code> 是下一个值，要么返回 <code>None</code> 表示迭代结束。</p>
<p>想要被迭代的类型也可以实现 <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>std::iter::IntoIterator</code></a>，它的 <code>into_iter</code> 返回一个迭代器：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IntoIterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span>: <span class="built_in">Iterator</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::IntoIter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们常用的 <code>for</code> 循环仅仅是先调用 <code>into_iter</code> 生成一个迭代器，然后重复调用迭代器的 <code>next</code> 方法，直到 <code>next</code> 返回 <code>None</code>，预示着迭代结束。</p>
<span id="more"></span>

<h3 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h3><p><code>Rust</code> 标准库文档详细解释了每种类型提供的迭代器类型，但该库遵循一些通用约定来帮助定位并找到需要的东西。</p>
<h4 id="iter-和-iter-mut"><a href="#iter-和-iter-mut" class="headerlink" title="iter 和 iter_mut"></a><code>iter</code> 和 <code>iter_mut</code></h4><p>大多数集合类型都提供了 <code>iter</code> 和 <code>iter_mut</code> 方法，它们返回类型的迭代器，生成对每个<code>item</code>的共享或可变引用。像 <code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 这样的数组切片也有 <code>iter</code> 和 <code>iter_mut</code> 方法。这些方法是获取迭代器的最常用方法，如果不打算让 <code>for</code> 循环为您处理它，可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">20</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">12</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">8</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">6</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>这个迭代器的 <code>item</code> 类型是 <code>&amp;i32</code>：每次调用 <code>next</code> 都会产生对下一个元素的引用，直到我们到达<code>vector</code>的末尾。每种类型都可以自由地以最适合其目的的方式实现 <code>iter</code> 和 <code>iter_mut</code>。<code>std::path::Path</code> 上的 <code>iter</code> 方法返回一个迭代器，该迭代器一次生成一个路径信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">path</span> = Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;C:/Users/JimB/Downloads/Fedora.iso&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = path.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;C:&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Users&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;JimB&quot;</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="into-iter-实现"><a href="#into-iter-实现" class="headerlink" title="into_iter 实现"></a><code>into_iter</code> 实现</h4><p>当一个类型实现 <code>IntoIterator</code> 时，你可以自己调用它的 <code>into_iter</code> 方法，就像 <code>for</code> 循环一样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeSet;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">favorites</span> = BTreeSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">favorites.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Lucy in the Sky With Diamonds&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">favorites.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Liebesträume No. 3&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">it</span> = favorites.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(it.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Liebesträume No. 3&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(it.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Lucy in the Sky With Diamonds&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(it.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>大多数集合提供了几种 <code>IntoIterator</code> 的实现，例如，<code>&amp;T</code>，<code>&amp;mut T</code> 和 <code>T</code>：</p>
<ul>
<li><p><code>&amp;T</code> 类型的迭代器产生的每个值都是对值的共享引用；</p>
</li>
<li><p><code>&amp;mut T</code> 类型的迭代器产生的每个值都对值的可变引用。例如 <code>Vec&lt;String&gt;</code>，调用 <code>(&amp;mut vector).into_iter()</code> 返回了一个迭代器，它的 <code>Item</code> 类型是 <code>&amp;mut String</code>；</p>
</li>
<li><p>调用 <code>T</code> 类型的 <code>into_iter()</code> 方法首先会获取集合值的是所有权，在迭代过程中，每个 <code>item</code> 的所有权从集合移动至消费的人；</p>
</li>
</ul>
<p><code>for</code> 循环将 <code>IntoIterator::into_iter</code> 应用于其操作数，因此这三个实现创建了以下习惯用法，用于迭代对集合的共享或可变引用，或使用集合并获取其元素的所有权：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> &amp;collection &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> collection &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> collection &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>并非每种类型都提供所有三种实现。例如，<code>HashSet</code>、<code>BTreeSet</code> 和 <code>BinaryHeap</code> 不会在可变引用上实现 <code>IntoIterator</code>，因为修改它们的元素可能会违反类型的不变性。</p>
<p>切片实现了三个 <code>IntoIterator</code> 变体中的两个，因为它们不拥有自己的元素，所以不存在<code>[T]</code>这种情况。相反，<code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 的 <code>into_iter</code> 返回一个迭代器，该迭代器生成对元素的共享和可变引用。</p>
<h4 id="from-fn-和-successors"><a href="#from-fn-和-successors" class="headerlink" title="from_fn 和 successors"></a><code>from_fn</code> 和 <code>successors</code></h4><p>一个更简单通用的方式是提供一个返回它们的闭包。<a href="https://doc.rust-lang.org/stable/std/iter/fn.from_fn.html"><code>std::iter::from_fn</code></a> 调用一个返回 <code>Option&lt;T&gt;</code> 的函数生成一个迭代器：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> rand::random; <span class="comment">// In Cargo.toml dependencies: rand = &quot;0.7&quot;</span></span><br><span class="line">    <span class="keyword">use</span> std::iter::from_fn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lengths</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="title function_ invoke__">from_fn</span>(|| <span class="title function_ invoke__">Some</span>((random::&lt;<span class="type">f64</span>&gt;() - random::&lt;<span class="type">f64</span>&gt;()).<span class="title function_ invoke__">abs</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(<span class="number">1000</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个迭代器永远返回 <code>Some(f64)</code>，所以它永远不会结束，但是我们通过 <code>take(1000)</code> 只取了前 <code>1000</code> 个值。</p>
<p>如果产生的每个值都和前一个相关，那么可以使用 <a href="https://doc.rust-lang.org/stable/std/iter/fn.successors.html"><code>std::iter::successors</code></a> 函数完成，它接受一个初始值和一个函数并且返回下一个 <code>item</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::Complex;</span><br><span class="line"><span class="keyword">use</span> std::iter::successors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">escape_time</span>(c: Complex&lt;<span class="type">f64</span>&gt;, limit: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">zero</span> = Complex &#123; re: <span class="number">0.0</span>, im: <span class="number">0.0</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">successors</span>(<span class="title function_ invoke__">Some</span>(zero), |&amp;z| <span class="title function_ invoke__">Some</span>(z * z + c))</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(limit)</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_i, z)| z.<span class="title function_ invoke__">norm_sqr</span>() &gt; <span class="number">4.0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(i, _z)| i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从零开始，<code>successors</code> 通过重复对最后一个点求平方并与参数 <code>c</code>求和。</p>
<p><code>from_fn</code> 和 <code>successors</code> 都接受 <code>FnMut</code> 闭包，因此闭包可以捕获和修改来自周围范围的变量。例如，这个斐波那契函数使用<code>move</code>闭包来捕获变量并将其用作其运行状态：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fibonacci</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    std::iter::<span class="title function_ invoke__">from_fn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        state = (state.<span class="number">1</span>, state.<span class="number">0</span> + state.<span class="number">1</span>);</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(state.<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">fibonacci</span>().<span class="title function_ invoke__">take</span>(<span class="number">10</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="drain"><a href="#drain" class="headerlink" title="drain"></a><code>drain</code></h4><p>许多集合类型提供了一个 <code>drain</code> 方法，该方法需要获取集合的可变引用，将对应区间的值从原来的集合中删掉，并且将删除的值以一个新的迭代器返回：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">outer</span> = <span class="string">&quot;Earth&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inner</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_iter</span>(outer.<span class="title function_ invoke__">drain</span>(<span class="number">1</span>..<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(outer, <span class="string">&quot;Eh&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(inner, <span class="string">&quot;art&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他迭代器"><a href="#其他迭代器" class="headerlink" title="其他迭代器"></a>其他迭代器</h4><img data-src="/2022/05/28/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/other-iterators.png" class="">

<h3 id="迭代适配器"><a href="#迭代适配器" class="headerlink" title="迭代适配器"></a>迭代适配器</h3><p>一旦有了一个迭代器，<code>Iterator</code> 提供了广泛的适配器方法选择，它们使用一个迭代器并构建一个新迭代器。要了解适配器的工作原理，我们将从两个最流行的 <code>map</code> 和 <code>filter</code> 开始。</p>
<h4 id="map、filter"><a href="#map、filter" class="headerlink" title="map、filter"></a><code>map</code>、<code>filter</code></h4><p><code>Iterator</code> 和 <code>map</code> 方法接受一个闭包或者函数作为参数应用于它的所有元素，然后产生新的迭代器。而 <code>filter</code> 接受一个闭包或函数作为参数，应用于所有元素过滤出符合要求的元素组成新的迭代器。</p>
<p>例如，我们可以使用 <code>map</code> 去将一段文本每行开始和结尾的空格去掉：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot; ponies \n giraffes\niguanas \nsquid&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">map</span>(<span class="type">str</span>::trim).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="string">&quot;ponies&quot;</span>, <span class="string">&quot;giraffes&quot;</span>, <span class="string">&quot;iguanas&quot;</span>, <span class="string">&quot;squid&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的案例，我们如果想在处理掉首尾的空格之后，还要排除 <code>&quot;iguanas&quot;</code>，我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot; ponies \n giraffes\niguanas \nsquid&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = text</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(<span class="type">str</span>::trim)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|s| *s != <span class="string">&quot;iguanas&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="string">&quot;ponies&quot;</span>, <span class="string">&quot;giraffes&quot;</span>, <span class="string">&quot;squid&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器适配器就像 <code>shell</code> 中的 <code>pipeline</code>，每个适配器有一个单独的目的。这些适配器函数签名如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map</span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=B&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">filter</span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>

<p>在标准库中，<code>map</code> 和 <code>filter</code> 实际上返回名为 <code>std::iter::Map</code> 和 <code>std::iter::Filter</code> 的特定不透明结构类型。然而，仅仅看到它们的名字并不能提供太多信息，所以这里，我们只打算写 <code>-&gt; impl Iterator&lt;Item=...&gt;</code> ，因为它告诉我们真正想知道的：方法返回一个生成给定 <code>item</code> 类型的迭代器。</p>
<p>由于大多数适配器需要获取所有权，因此它们需要 <code>Self </code> 是 <code>Sized</code>。</p>
<p><code>map</code> 通过值将每个 <code>item</code> 传递给它的闭包，然后将闭包结果的所有权传递给它的消费者。<code>filter</code> 通过共享引用将每个项目传递给它的闭包，在<code>item</code>被选择传递给其消费者的情况下保留所有权。这就是示例必须解引用 <code>s</code> 来和 <code>&quot;iguanas&quot;</code> 比较的原因：<code>filter</code> 闭包的参数 <code>s</code> 的类型是 <code>&amp;&amp;str</code>。</p>
<p>关于迭代器适配器，有两点需要注意。</p>
<ul>
<li><p>迭代器是惰性的，不调用 <code>next</code> 方法就不会实际运行，也就是不会消费任何 <code>item</code>。前面的例子中，在 <code>collect</code> 调用 <code>filter</code> 返回的迭代器的 <code>next</code> 方法之前，<code>text.lines()</code> 和 <code>map()</code> 不会做任何工作，这点很像 <code>python</code> 中的生成器；</p>
</li>
<li><p>迭代适配器是零成本抽象，这意味着 <code>Rust</code> 有足够的信息将每个迭代器的 <code>next</code> 方法内联到其消费者中，然后将整个流程转换为机器代码作为一个单元，也就是我们不用关心适配器的性能开销，<code>Rust</code> 帮我们解决，对于上面的例子，和我们手写下面的代码有同样的性能：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span> = line.<span class="title function_ invoke__">trim</span>();</span><br><span class="line">    <span class="keyword">if</span> line != <span class="string">&quot;iguanas&quot;</span> &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="filter-map、flat-map"><a href="#filter-map、flat-map" class="headerlink" title="filter_map、flat_map"></a><code>filter_map</code>、<code>flat_map</code></h4><p><code>filter_map</code> 类似于 <code>map</code>，但是它的闭包函数返回一个 <code>Option&lt;T&gt;</code> 决定这个值是留还是删掉，有点像 <code>filter</code> 和 <code>map</code> 的结合，该函数的声明如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">filter_map</span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=B&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;B&gt;;</span><br></pre></td></tr></table></figure>

<p>举个例子，如果你想从一段以空格分割的字符串中解析出数字，可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;1\nfrond .25 289\n3.1415 estuary\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> text</span><br><span class="line">        .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|w| <span class="type">f64</span>::<span class="title function_ invoke__">from_str</span>(w).<span class="title function_ invoke__">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:4.2&#125;&quot;</span>, number.<span class="title function_ invoke__">sqrt</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码输出：</p>
<pre><code>1.00
0.50
17.00
1.77
</code></pre>
<p>这个目的可以使用 <code>map</code> 和 <code>filter</code> 配合完成，但是有了 <code>filter_map</code> 就显得有点笨拙了：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;1\nfrond .25 289\n3.1415 estuary\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> text</span><br><span class="line">        .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|w| <span class="type">f64</span>::<span class="title function_ invoke__">from_str</span>(w))</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|r| r.<span class="title function_ invoke__">is_ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|r| r.<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:4.2&#125;&quot;</span>, number.<span class="title function_ invoke__">sqrt</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>flat_map</code> 和 <code>map</code> 一样，只是它的闭包可以返回多个 <code>item</code>，而不是一个，它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">flat_map</span>&lt;U, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=U::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> U, U: <span class="built_in">IntoIterator</span>;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">major_cities</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Japan&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Tokyo&quot;</span>, <span class="string">&quot;Kyoto&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;The United States&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Portland&quot;</span>, <span class="string">&quot;Nashville&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Brazil&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;São Paulo&quot;</span>, <span class="string">&quot;Brasília&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Kenya&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Nairobi&quot;</span>, <span class="string">&quot;Mombasa&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;The Netherlands&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Amsterdam&quot;</span>, <span class="string">&quot;Utrecht&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">countries</span> = [<span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;Brazil&quot;</span>, <span class="string">&quot;Kenya&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;city <span class="keyword">in</span> countries.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">flat_map</span>(|country| &amp;major_cities[country]) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码输出：</p>
<pre><code>Tokyo
Kyoto
São Paulo
Brasília
Nairobi
Mombasa
</code></pre>
<h4 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a><code>flatten</code></h4><p>如果我们要将一个二维数组转换成一维数组，就可以使用 <code>flatten</code>，在这里二维数组的每个元素都是可迭代的，它的定义如下，要求迭代器中的每个元素也都是可迭代的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">flatten</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>::Item: <span class="built_in">IntoIterator</span>;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line">    <span class="comment">// A table mapping cities to their parks: each value is a vector.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parks</span> = BTreeMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    parks.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Portland&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Mt. Tabor Park&quot;</span>, <span class="string">&quot;Forest Park&quot;</span>]);</span><br><span class="line">    parks.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Kyoto&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Tadasu-no-Mori Forest&quot;</span>, <span class="string">&quot;Maruyama Koen&quot;</span>]);</span><br><span class="line">    parks.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Nashville&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Percy Warner Park&quot;</span>, <span class="string">&quot;Dragon Park&quot;</span>]);</span><br><span class="line">    <span class="comment">// Build a vector of all parks. `values` gives us an iterator producing</span></span><br><span class="line">    <span class="comment">// vectors, and then `flatten` produces each vector&#x27;s elements in turn.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">all_parks</span>: <span class="type">Vec</span>&lt;_&gt; = parks.<span class="title function_ invoke__">values</span>().<span class="title function_ invoke__">flatten</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        all_parks,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;Tadasu-no-Mori Forest&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Maruyama Koen&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Percy Warner Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Dragon Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Mt. Tabor Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Forest Park&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以用 <code>flatten</code> 挑出 <code>Vec&lt;Option&lt;&amp;str&gt;&gt;</code> 中所有 <code>Some&lt;&amp;str&gt;</code>，因为 <code>Option</code> 也是可迭代的，例如，：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(<span class="string">&quot;day&quot;</span>), <span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(<span class="string">&quot;one&quot;</span>)]</span><br><span class="line">            .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">            .<span class="title function_ invoke__">flatten</span>()</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="string">&quot;day&quot;</span>, <span class="string">&quot;one&quot;</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="take、take-while"><a href="#take、take-while" class="headerlink" title="take、take_while"></a><code>take</code>、<code>take_while</code></h4><p><code>take</code> 和 <code>take_while</code> 用于决定迭代什么时候结束，前者通过迭代次数，后者通过一个闭包。它们都会获取原迭代器的所有权，它们的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">take</span>(<span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">take_while</span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>

<p>举个例子，给定一封电子邮件，其中一个空行将标头与邮件正文分开，可以使用 <code>take_while</code> 仅迭代标头：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;To: jimb\r\n\</span></span><br><span class="line"><span class="string"> From: superego &lt;editor@oreilly.com&gt;\r\n\</span></span><br><span class="line"><span class="string"> \r\n\</span></span><br><span class="line"><span class="string"> Did you get any writing done today?\r\n\</span></span><br><span class="line"><span class="string"> When will you stop wasting time plotting fractals?\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">header</span> <span class="keyword">in</span> message.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">take_while</span>(|l| !l.<span class="title function_ invoke__">is_empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="skip、skip-while"><a href="#skip、skip-while" class="headerlink" title="skip、skip_while"></a><code>skip</code>、<code>skip_while</code></h4><p><code>skip</code> 和 <code>skip_while</code> 方法是 <code>take</code> 和 <code>take_while</code> 的补充：它们从迭代的开始丢弃一定数量的<code>item</code>，或者丢弃<code>item</code>直到闭包找到一个可接受的项目，剩余的保持不变。它们的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">skip</span>(<span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">skip_while</span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>

<p>例如，我们处理命令行参数时，通常丢掉第一个表示程序路径的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">arg</span> <span class="keyword">in</span> std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想处理上面的邮件中的主体消息而不是标题，我们可以跳过开头的非空行：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;To: jimb\r\n\</span></span><br><span class="line"><span class="string"> From: superego &lt;editor@oreilly.com&gt;\r\n\</span></span><br><span class="line"><span class="string"> \r\n\</span></span><br><span class="line"><span class="string"> Did you get any writing done today?\r\n\</span></span><br><span class="line"><span class="string"> When will you stop wasting time plotting fractals?\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">body</span> <span class="keyword">in</span> message.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">skip_while</span>(|l| !l.<span class="title function_ invoke__">is_empty</span>()).<span class="title function_ invoke__">skip</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peekable"><a href="#peekable" class="headerlink" title="peekable"></a><code>peekable</code></h4><p><code>peekable</code> 迭代器就是可以让你浏览下一个 <code>item</code> 但是又没实际使用它，就像调用了 <code>next</code> 然后又退回来了（假设），可以将任何迭代器通过转换成 <code>peekable</code> 的 <code>Iterator</code>。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">peekable</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> std::iter::Peekable&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html"><code>std::iter::Peekable</code></a> 是实现了 <code>Iterator&lt;Item=Self::Item&gt;</code> 的迭代器，这里的 <code>Self</code> 指的是底层的迭代器。</p>
<p>例如，如果要从字符流中解析数字，则在看到其后的第一个非数字字符之前，无法确定数字的结束位置：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::Peekable;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_number</span>&lt;I&gt;(tokens: &amp;<span class="keyword">mut</span> Peekable&lt;I&gt;) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    I: <span class="built_in">Iterator</span>&lt;Item = <span class="type">char</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> tokens.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(r) <span class="keyword">if</span> r.<span class="title function_ invoke__">is_digit</span>(<span class="number">10</span>) =&gt; &#123;</span><br><span class="line">                n = n * <span class="number">10</span> + r.<span class="title function_ invoke__">to_digit</span>(<span class="number">10</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="keyword">return</span> n,</span><br><span class="line">        &#125;</span><br><span class="line">        tokens.<span class="title function_ invoke__">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chars</span> = <span class="string">&quot;226153980,1766319049&quot;</span>.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">peekable</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parse_number</span>(&amp;<span class="keyword">mut</span> chars), <span class="number">226153980</span>);</span><br><span class="line">    <span class="comment">// Look, `parse_number` didn&#x27;t consume the comma! So we will.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(chars.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parse_number</span>(&amp;<span class="keyword">mut</span> chars), <span class="number">1766319049</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(chars.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fuse"><a href="#fuse" class="headerlink" title="fuse"></a><code>fuse</code></h4><p><code>fuse</code> 在迭代器第一次结束，即调用它的 <code>next</code> 方法返回 <code>None</code> 之后永远都返回 <code>None</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Flaky</span>(<span class="type">bool</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Flaky</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="number">0</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="number">0</span> = <span class="literal">true</span>; <span class="comment">// D&#x27;oh!</span></span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flaky</span> = <span class="title function_ invoke__">Flaky</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(flaky.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(flaky.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(flaky.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">not_flaky</span> = <span class="title function_ invoke__">Flaky</span>(<span class="literal">true</span>).<span class="title function_ invoke__">fuse</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(not_flaky.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(not_flaky.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(not_flaky.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="next-back、rev"><a href="#next-back、rev" class="headerlink" title="next_back、rev"></a><code>next_back</code>、<code>rev</code></h4><p>如果迭代器实现了 <a href="https://doc.rust-lang.org/stable/std/iter/trait.DoubleEndedIterator.html"><code>std::iter::DoubleEndedIterator</code></a>，就可以从两端开始迭代，直到它们相遇迭代结束。该 <code>trait</code> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">DoubleEndedIterator</span>: <span class="built_in">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_back</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bee_parts</span> = [<span class="string">&quot;head&quot;</span>, <span class="string">&quot;thorax&quot;</span>, <span class="string">&quot;abdomen&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = bee_parts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;head&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next_back</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;abdomen&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;thorax&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next_back</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个迭代器是双端迭代器，我们就可以使用 <code>rev</code> 对迭代器进行反转，<code>rev</code> 方法的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">rev</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span> + <span class="built_in">DoubleEndedIterator</span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">meals</span> = [<span class="string">&quot;breakfast&quot;</span>, <span class="string">&quot;lunch&quot;</span>, <span class="string">&quot;dinner&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = meals.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rev</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;dinner&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;lunch&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;breakfast&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a><code>inspect</code></h4><p><code>inspect</code> 对于调试很方便，但在生产代码中使用不多。它只是将闭包应用于每个<code>item</code>的共享引用，然后传递该<code>item</code>。闭包不会影响<code>item</code>，但它可以做一些事情，比如打印它们或对它们进行断言。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">upper_case</span>: <span class="type">String</span> = <span class="string">&quot;große&quot;</span></span><br><span class="line">        .<span class="title function_ invoke__">chars</span>()</span><br><span class="line">        .<span class="title function_ invoke__">inspect</span>(|c| <span class="built_in">println!</span>(<span class="string">&quot;before: &#123;:?&#125;&quot;</span>, c))</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|c| c.<span class="title function_ invoke__">to_uppercase</span>())</span><br><span class="line">        .<span class="title function_ invoke__">inspect</span>(|c| <span class="built_in">println!</span>(<span class="string">&quot; after: &#123;:?&#125;&quot;</span>, c))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(upper_case, <span class="string">&quot;GROSSE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小写德语字母<code>“ß”</code>的大写等效项是<code>“SS”</code>，这就是为什么 <code>char::to_uppercase</code> 返回字符的迭代器，而不是单个替换字符。 前面的代码使用 <code>flat_map</code> 将 <code>to_uppercase</code> 返回的所有序列连接成一个字符串，并打印以下内容：</p>
<pre><code>before: &#39;g&#39;
after: &#39;G&#39;
before: &#39;r&#39;
after: &#39;R&#39;
before: &#39;o&#39;
after: &#39;O&#39;
before: &#39;ß&#39;
after: &#39;S&#39;
after: &#39;S&#39;
before: &#39;e&#39;
after: &#39;E&#39;
</code></pre>
<h4 id="chain"><a href="#chain" class="headerlink" title="chain"></a><code>chain</code></h4><p><code>chain</code> 可以将多个迭代器连接起来，它的方法声明如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">chain</span>&lt;U&gt;(<span class="keyword">self</span>, other: U) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, U: <span class="built_in">IntoIterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">chain</span>(<span class="built_in">vec!</span>[<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>chain</code> 迭代器是可以反转的，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">chain</span>(<span class="built_in">vec!</span>[<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]).<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a><code>enumerate</code></h4><p><code>enumerate</code> 可以用于在迭代的时候自动加上索引，例如，原本返回 <code>A, B, C</code> 序列，现在返回 <code>(0, A), (1, B), (2, C)</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (index, num) <span class="title function_ invoke__">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">chain</span>(<span class="built_in">vec!</span>[<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]).<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, index, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码输出：<br>    0, 40<br>    1, 30<br>    2, 20<br>    3, 3<br>    4, 2<br>    5, 1</p>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a><code>zip</code></h4><p><code>zip</code> 用于将两个迭代器合成一个迭代器，每次各从一个中取出一个值，组成一对，直到有一个迭代结束。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;_&gt; = (<span class="number">0</span>..).<span class="title function_ invoke__">zip</span>(<span class="string">&quot;ABCD&quot;</span>.<span class="title function_ invoke__">chars</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="built_in">vec!</span>[(<span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;D&#x27;</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zip</code> 的参数可以是任何可迭代对象：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::repeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">endings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;once&quot;</span>, <span class="string">&quot;twice&quot;</span>, <span class="string">&quot;chicken soup with rice&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rhyme</span>: <span class="type">Vec</span>&lt;(&amp;<span class="type">str</span>, &amp;<span class="type">str</span>)&gt; = <span class="title function_ invoke__">repeat</span>(<span class="string">&quot;going&quot;</span>).<span class="title function_ invoke__">zip</span>(endings).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        rhyme,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            (<span class="string">&quot;going&quot;</span>, <span class="string">&quot;once&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;going&quot;</span>, <span class="string">&quot;twice&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;going&quot;</span>, <span class="string">&quot;chicken soup with rice&quot;</span>)</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="by-ref"><a href="#by-ref" class="headerlink" title="by_ref"></a><code>by_ref</code></h4><p>前面看到的大多数的适配器都会获取底层迭代器的所有权，没法再次使用，例如，对于上面的邮件示例，我们想解析邮件标题和邮件内容，可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;To: jimb\r\n\</span></span><br><span class="line"><span class="string"> From: superego &lt;editor@oreilly.com&gt;\r\n\</span></span><br><span class="line"><span class="string"> \r\n\</span></span><br><span class="line"><span class="string"> Did you get any writing done today?\r\n\</span></span><br><span class="line"><span class="string"> When will you stop wasting time plotting fractals?\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lines</span> = message.<span class="title function_ invoke__">lines</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Headers:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">header</span> <span class="keyword">in</span> lines.<span class="title function_ invoke__">by_ref</span>().<span class="title function_ invoke__">take_while</span>(|l| !l.<span class="title function_ invoke__">is_empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\nBody:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">body</span> <span class="keyword">in</span> lines &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>lines.by_ref()</code> 借用了一个对迭代器的可变引用，而 <code>take_while</code> 迭代器正是这个引用的所有者。该迭代器在第一个 <code>for</code> 循环结束时退出时被丢掉，因此可以在第二个 <code>for</code> 循环中再次使用行。该代码输出：</p>
<pre><code>Headers:
To: jimb
From: superego &lt;editor@oreilly.com&gt;

Body:
Did you get any writing done today?
When will you stop wasting time plotting fractals?
</code></pre>
<h4 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a><code>cycle</code></h4><p><code>cycle</code> 可以通过底层的迭代器无休止地生成值序列，只要底层的迭代器实现了 <code>std::clone::Clone</code>，因为他需要保存它的初始状态并且在每次循环开始时重用它，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dirs</span> = [<span class="string">&quot;North&quot;</span>, <span class="string">&quot;East&quot;</span>, <span class="string">&quot;South&quot;</span>, <span class="string">&quot;West&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spin</span> = dirs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cycle</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;North&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;East&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;South&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;West&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;North&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;East&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费迭代器"><a href="#消费迭代器" class="headerlink" title="消费迭代器"></a>消费迭代器</h3><p>前面已经讲解了如何创建和转换迭代器，这节来说明如何消费迭代器，除了使用 <code>for</code> 和直接调用 <code>next</code> 之外的其他方法。</p>
<h4 id="count、sum、product"><a href="#count、sum、product" class="headerlink" title="count、sum、product"></a><code>count</code>、<code>sum</code>、<code>product</code></h4><p><code>count</code> 用于统计迭代器中有多少个 <code>item</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sum</code> 和 <code>product</code> 用于计算迭代器整数或者浮点数的和或者乘积：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">triangle</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    (<span class="number">1</span>..=n).<span class="title function_ invoke__">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">factorial</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    (<span class="number">1</span>..=n).<span class="title function_ invoke__">product</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">triangle</span>(<span class="number">20</span>), <span class="number">210</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">factorial</span>(<span class="number">20</span>), <span class="number">2432902008176640000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="max、min"><a href="#max、min" class="headerlink" title="max、min"></a><code>max</code>、<code>min</code></h4><p><code>min</code> 和 <code>max</code> 分别返回迭代器内<code>item</code>的最大或者最小值，其中这里的<code>item</code>必须实现 <code>std::cmp::Ord</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">5</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">5</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>(), <span class="title function_ invoke__">Some</span>(&amp;-<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法返回 <code>Option&lt;Self::Item&gt;</code>，所以它们可以返回 <code>None</code> 如果迭代器内没有 <code>item</code>。</p>
<h4 id="max-by、min-by"><a href="#max-by、min-by" class="headerlink" title="max_by、min_by"></a><code>max_by</code>、<code>min_by</code></h4><p>同 <code>max</code> 和 <code>min</code> 一样，只是它们使用自定义的比较函数，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line">    <span class="comment">// Compare two f64 values. Panic if given a NaN.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp</span>(lhs: &amp;<span class="type">f64</span>, rhs: &amp;<span class="type">f64</span>) <span class="punctuation">-&gt;</span> Ordering &#123;</span><br><span class="line">        lhs.<span class="title function_ invoke__">partial_cmp</span>(rhs).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">max_by</span>(cmp), <span class="title function_ invoke__">Some</span>(<span class="number">4.0</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">min_by</span>(cmp), <span class="title function_ invoke__">Some</span>(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1.0</span>, <span class="number">4.0</span>, std::<span class="type">f64</span>::NAN, <span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">max_by</span>(cmp), <span class="title function_ invoke__">Some</span>(<span class="number">4.0</span>)); <span class="comment">// panics</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="max-by-key、min-by-key"><a href="#max-by-key、min-by-key" class="headerlink" title="max_by_key、min_by_key"></a><code>max_by_key</code>、<code>min_by_key</code></h4><p><code>max_by_key</code> 和<code>min_by_key</code> 通过传入的闭包选择根据 <code>item</code> 的某些内容来确定最大最小值，它们的定义如下，传入的闭包返回 <code>None</code> 表示这个 <code>item</code> 不参与比较：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min_by_key</span>&lt;B: <span class="built_in">Ord</span>, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">max_by_key</span>&lt;B: <span class="built_in">Ord</span>, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> B;</span><br></pre></td></tr></table></figure>

<p>举个例子，根据 <code>HashMap</code> 的值进行比较：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">populations</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Portland&quot;</span>, <span class="number">583_776</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Fossil&quot;</span>, <span class="number">449</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Greenhorn&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Boring&quot;</span>, <span class="number">7_762</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;The Dalles&quot;</span>, <span class="number">15_340</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        populations.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max_by_key</span>(|&amp;(_name, pop)| pop),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>((&amp;<span class="string">&quot;Portland&quot;</span>, &amp;<span class="number">583_776</span>))</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        populations.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min_by_key</span>(|&amp;(_name, pop)| pop),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>((&amp;<span class="string">&quot;Greenhorn&quot;</span>, &amp;<span class="number">2</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="item-序列比较"><a href="#item-序列比较" class="headerlink" title="item 序列比较"></a><code>item</code> 序列比较</h4><p>可以使用 <code>&lt;</code>，<code>==</code> 等比较运算符比较 <code>str</code>，<code>vector</code> 或者 <code>slice</code>，只要它们的 <code>item</code> 支持比较，除此之外还可以使用 <code>eq</code>，<code>lt</code> 等方法进行比较：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">packed</span> = <span class="string">&quot;Helen of Troy&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaced</span> = <span class="string">&quot;Helen   of    Troy&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">obscure</span> = <span class="string">&quot;Helen of Sandusky&quot;</span>; <span class="comment">// nice person, just not famous</span></span><br><span class="line">    <span class="built_in">assert!</span>(packed != spaced);</span><br><span class="line">    <span class="built_in">assert!</span>(packed.<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">eq</span>(spaced.<span class="title function_ invoke__">split_whitespace</span>()));</span><br><span class="line">    <span class="comment">// This is true because &#x27; &#x27; &lt; &#x27;o&#x27;.</span></span><br><span class="line">    <span class="built_in">assert!</span>(spaced &lt; obscure);</span><br><span class="line">    <span class="comment">// This is true because &#x27;Troy&#x27; &gt; &#x27;Sandusky&#x27;.</span></span><br><span class="line">    <span class="built_in">assert!</span>(spaced.<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">gt</span>(obscure.<span class="title function_ invoke__">split_whitespace</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>split_whitespace</code> 使用空格分割字符串生成字符串序列，然后比较字符串而不是按字符比较。</p>
<h4 id="any、all"><a href="#any、all" class="headerlink" title="any、all"></a><code>any</code>、<code>all</code></h4><p><code>any</code> 和 <code>all</code> 引用传入的返回 <code>bool</code> 的函数，判断迭代器的 <code>item</code> 是否存在满足条件还是都满足条件：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = <span class="string">&quot;Iterator&quot;</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(id.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">any</span>(<span class="type">char</span>::is_uppercase));</span><br><span class="line">    <span class="built_in">assert!</span>(!id.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">all</span>(<span class="type">char</span>::is_uppercase));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="position、rposition、ExactSizeIterator"><a href="#position、rposition、ExactSizeIterator" class="headerlink" title="position、rposition、ExactSizeIterator"></a><code>position</code>、<code>rposition</code>、<code>ExactSizeIterator</code></h4><p><code>position</code> 和 <code>rposition</code> 都是用于从迭代器序列中查找满足条件元素的索引，只是一个从左往右，一个从右往左。如果查找到满足条件的返回 <code>Some(v)</code>，否则返回 <code>None</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;Xerxes&quot;</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(text.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">position</span>(|c| c == <span class="string">&#x27;e&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(text.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">position</span>(|c| c == <span class="string">&#x27;z&#x27;</span>), <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = <span class="string">b&quot;Xerxes&quot;</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rposition</span>(|&amp;c| c == <span class="string">b&#x27;e&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rposition</span>(|&amp;c| c == <span class="string">b&#x27;X&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><code>rposition</code> 需要满足的条件更多，他要求迭代器必须是可反转的，并且是取得其精确长度，需要实现 <code>std::iter::ExactSizeIterator</code> :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">ExactSizeIterator</span>: <span class="built_in">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_empty</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>len</code> 方法返回剩余的项目数，如果迭代完成，<code>is_empty</code> 方法返回 <code>true</code>。</p>
<h4 id="fold、rfold"><a href="#fold、rfold" class="headerlink" title="fold、rfold"></a><code>fold</code>、<code>rfold</code></h4><p><code>fold</code> 方法是一个非常通用的工具，用于在迭代器产生的整个项目序列上累积某种结果。给定一个我们称为累计值的初始值和一个闭包，<code>fold</code>重复地将闭包应用于当前累计值和迭代器的下一<code>item</code>。闭包返回的值作为新的累计值，与下一<code>item</code>一起传递给闭包。</p>
<p><code>sum</code>，<code>count</code>，<code>product</code> 以及 <code>max</code> 都可以用 <code>fold</code> 来实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |n, _| n + <span class="number">1</span>), <span class="number">6</span>); <span class="comment">// count</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |n, i| n + i), <span class="number">45</span>); <span class="comment">// sum</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">1</span>, |n, i| n * i), <span class="number">151200</span>); <span class="comment">// product</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">fold</span>(<span class="type">i32</span>::<span class="title function_ invoke__">min_value</span>(), std::cmp::max), <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fold</code> 的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fold</span>&lt;A, F&gt;(<span class="keyword">self</span>, init: A, f: F) <span class="punctuation">-&gt;</span> A</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(A, <span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> A;</span><br></pre></td></tr></table></figure>

<p>这里，<code>A</code> 是累计值类型。<code>init</code> 参数是一个 <code>A</code>，闭包的第一个参数和返回值以及 <code>fold</code> 本身的返回值也是如此。请注意，累计值被移入和移出闭包，因此可以将 <code>fold</code> 与非 <code>Copy</code> 累计值类型一起使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [</span><br><span class="line">        <span class="string">&quot;Pack&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="string">&quot;box&quot;</span>, <span class="string">&quot;with&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;dozen&quot;</span>, <span class="string">&quot;liquor&quot;</span>, <span class="string">&quot;jugs&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">// See also: the `join` method on slices, which won&#x27;t</span></span><br><span class="line">    <span class="comment">// give you that extra space at the end.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pangram</span> = a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>(), |s, w| s + w + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(pangram, <span class="string">&quot;Pack my box with five dozen liquor jugs &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rfold</code> 作用类似，它要求迭代器是可以从右往左进行迭代：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">weird_pangram</span> = a.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">rfold</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>(), |s, w| s + w + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(weird_pangram, <span class="string">&quot;jugs liquor dozen five with box my Pack &quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="try-fold、try-rfold"><a href="#try-fold、try-rfold" class="headerlink" title="try_fold、try_rfold"></a><code>try_fold</code>、<code>try_rfold</code></h4><p><code>try_fold</code> 方法与 <code>fold</code> 相同，只是迭代过程可以提前退出，而不会消耗迭代器中的所有值。传递给 <code>try_fold</code> 的闭包必须返回一个 <code>Result</code>：如果它返回 <code>Err(e)</code>，<code>try_fold</code> 会立即返回 <code>Err(e)</code> 作为它的值，否则它继续继续处理。 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::error::Error;</span><br><span class="line">    <span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stdin</span> = std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sum</span> = stdin</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">            .<span class="title function_ invoke__">try_fold</span>(<span class="number">0</span>, |sum, line| <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u64</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(sum + <span class="type">u64</span>::<span class="title function_ invoke__">from_str</span>(&amp;line?.<span class="title function_ invoke__">trim</span>())?)</span><br><span class="line">            &#125;)?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, sum);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>try_fold</code> 非常灵活，它被用来实现 <code>Iterator</code> 的许多其他消费者方法。 例如这是 <a href="https://doc.rust-lang.org/stable/src/core/iter/traits/iterator.rs.html#2452-2455"><code>all</code></a>的实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">all</span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#[inline]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">check</span>&lt;T&gt;(<span class="keyword">mut</span> f: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>((), T) <span class="punctuation">-&gt;</span> ControlFlow&lt;()&gt; &#123;</span><br><span class="line">            <span class="keyword">move</span> |(), x| &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="title function_ invoke__">f</span>(x) &#123; ControlFlow::CONTINUE &#125; <span class="keyword">else</span> &#123; ControlFlow::BREAK &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">try_fold</span>((), <span class="title function_ invoke__">check</span>(f)) == ControlFlow::CONTINUE</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="nth、nth-back"><a href="#nth、nth-back" class="headerlink" title="nth、nth_back"></a><code>nth</code>、<code>nth_back</code></h4><p><code>nth(n)</code> 从迭代器中跳过 <code>n</code> 个 <code>item</code> 返回下一个，<code>nth(0)</code> 等价于 <code>.next()</code>，而且它没有获取迭代器的所有权，所以可以多次调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">squares</span> = (<span class="number">0</span>..<span class="number">10</span>).<span class="title function_ invoke__">map</span>(|i| i*i);</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">nth</span>(<span class="number">4</span>), <span class="title function_ invoke__">Some</span>(<span class="number">16</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">nth</span>(<span class="number">0</span>), <span class="title function_ invoke__">Some</span>(<span class="number">25</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">nth</span>(<span class="number">6</span>), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">nth</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br></pre></td></tr></table></figure>

<p><code>nth_back(n)</code> 需要一个可以双端迭代的迭代器，从后往前找，<code>.nth_back(0)</code> 等价于 <code>.nth_back(0)</code>。</p>
<h4 id="last"><a href="#last" class="headerlink" title="last"></a><code>last</code></h4><p><code>last</code> 返回最后迭代器的最后一个元素，如果迭代器为空，返回 <code>None</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">squares</span> = (<span class="number">0</span>..<span class="number">10</span>).<span class="title function_ invoke__">map</span>(|i| i*i);</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">last</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">81</span>));</span><br><span class="line">This consumes all the iterator’s items starti</span><br></pre></td></tr></table></figure>

<p>它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br></pre></td></tr></table></figure>

<p>这个从前往后消费迭代器的所有<code>item</code>，即使它是可以 <code>reversible</code>，因此，如果你有一个 <code>reversible</code> 迭代器，而且不想消费所有 <code>item</code>，可以使用 <code>.next_back()</code>。</p>
<h4 id="find、rfind、find-map"><a href="#find、rfind、find-map" class="headerlink" title="find、rfind、find_map"></a><code>find</code>、<code>rfind</code>、<code>find_map</code></h4><p><code>find</code> 依次将迭代器的 <code>item</code> 传入给定的闭包，返回第一个满足条件的，如果直到结束都没有找到，返回 <code>None</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find</span>&lt;P&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>

<p><code>rfind</code> 要求迭代器必须是可以从后往前迭代，除此之外和 <code>find</code> 相同。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">289</span>, <span class="number">1234</span>, <span class="number">546</span>, <span class="number">19989</span>, <span class="number">878</span>, <span class="number">345</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|&amp;item| *item &gt; <span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rfind</span>(|&amp;item| *item &gt; <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>find_map</code> 可以对返回的值进行自定义，而不是迭代器中的类型，它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_map</span>&lt;B, F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;B&gt; <span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;B&gt;;</span><br></pre></td></tr></table></figure>

<p>例如，对于上面的例子，我们可以在满足要求时，将返回值包装成 <code>Some(Number)</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    num: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">289</span>, <span class="number">1234</span>, <span class="number">546</span>, <span class="number">19989</span>, <span class="number">878</span>, <span class="number">345</span>];</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;:?&#125;&quot;</span>,</span><br><span class="line">        numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find_map</span>(|&amp;item| &#123;</span><br><span class="line">            <span class="keyword">if</span> item &gt; <span class="number">1000</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(Number &#123; num: item &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="collect、FromIterator"><a href="#collect、FromIterator" class="headerlink" title="collect、FromIterator"></a><code>collect</code>、<code>FromIterator</code></h4><p><code>collect</code> 可以从 <code>Rust</code> 的标准库构建任何类型的集合，只要迭代器产生合适的项目类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashSet, BTreeSet, LinkedList, HashMap, BTreeMap&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: HashSet&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: BTreeSet&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: LinkedList&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collecting a map requires (key, value) pairs, so for this example,</span></span><br><span class="line"><span class="comment">// zip the sequence of strings with a sequence of integers.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: HashMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">zip</span>(<span class="number">0</span>..).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: BTreeMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">zip</span>(<span class="number">0</span>..).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p><code>collect</code> 本身并不知道如何构造所有这些类型。相反当一些像 <code>Vec</code> 或 <code>HashMap</code> 这样的集合类型知道如何从一个迭代器构造自己时，它实现了 <a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html#"><code>std::iter::FromIterator</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FromIterator</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_iter</span>&lt;T&gt;(iter: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: <span class="built_in">IntoIterator</span>&lt;Item = A&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a><code>extend</code></h4><p>如果一个类型实现了 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Extend.html"><code>std::iter::Extend</code></a>，<code>extend</code> 方法可以从另外一个可迭代的集合添加 <code>item</code> 到自身，它的声明如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Extend</span>&lt;A&gt; &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">extend</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, iter: T)</span><br><span class="line"> <span class="keyword">where</span> T: <span class="built_in">IntoIterator</span>&lt;Item=A&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有标准库的集合类型都实现了 <code>Extend</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">0</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(|i| <span class="number">1</span> &lt;&lt; i).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">v.<span class="title function_ invoke__">extend</span>(&amp;[<span class="number">31</span>, <span class="number">57</span>, <span class="number">99</span>, <span class="number">163</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">31</span>, <span class="number">57</span>, <span class="number">99</span>, <span class="number">163</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a><code>partition</code></h4><p><code>partition</code> 通过传入的闭包将集合分成两拨，例如我们可以将切片数字分成奇数偶数序列：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">289</span>, <span class="number">1234</span>, <span class="number">546</span>, <span class="number">19989</span>, <span class="number">878</span>, <span class="number">345</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (base, even): (<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">partition</span>(|n| *n &amp; <span class="number">1</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;&quot;</span>, base, even);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码输出：<br>    [10, 34, 1234, 546, 878], [9, 289, 19989, 345]</p>
<p>和 <code>collect</code> 一样，<code>partition</code> 可以创建任何你喜欢的集合，但是两者必须是相同的类型，使用上和 <code>collect</code> 一样，需要指定返回类型。<code>partition</code> 的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">partition</span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> (B, B)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        B: <span class="built_in">Default</span> + <span class="built_in">Extend</span>&lt;<span class="keyword">Self</span>::Item&gt;,</span><br><span class="line">        F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br></pre></td></tr></table></figure>

<h4 id="for-each、try-for-each"><a href="#for-each、try-for-each" class="headerlink" title="for_each、try_for_each"></a><code>for_each</code>、<code>try_for_each</code></h4><p><code>for_each</code> 的用途和 <code>for</code> 相似，在其中也可使用 <code>break</code> 和 <code>continue</code> 这样的控制结构：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    [<span class="string">&quot;doves&quot;</span>, <span class="string">&quot;hens&quot;</span>, <span class="string">&quot;birds&quot;</span>]</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>([<span class="string">&quot;turtle&quot;</span>, <span class="string">&quot;french&quot;</span>, <span class="string">&quot;calling&quot;</span>].<span class="title function_ invoke__">iter</span>())</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(<span class="number">2</span>..<span class="number">5</span>)</span><br><span class="line">        .<span class="title function_ invoke__">rev</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|((item, kind), quantity)| <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, quantity, kind, item))</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|gift| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;You have received: &#123;&#125;&quot;</span>, gift);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改代码输出：</p>
<pre><code>You have received: 4 calling birds
You have received: 3 french hens
You have received: 2 turtle doves
</code></pre>
<p>如果闭包可以失败，或者需要提前退出，可以使用 <code>try_for_each</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> .<span class="title function_ invoke__">try_for_each</span>(|gift| &#123;</span><br><span class="line">    <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> output_file, <span class="string">&quot;You have received: &#123;&#125;&quot;</span>, gift)</span><br><span class="line">&#125;)?;</span><br></pre></td></tr></table></figure>

<h3 id="实现迭代器"><a href="#实现迭代器" class="headerlink" title="实现迭代器"></a>实现迭代器</h3><p>可以为自己的类型实现 <code>IntoIterator</code> 和 <code>Iterator</code>，这样前面讲的所有方法都可以使用了，<code>for</code> 循环使用 <code>IntoIterator::into_iter</code> 将其操作数转换为迭代器。但是标准库为实现 <code>Iterator</code> 的每种类型提供了 <code>IntoIterator</code> 的全面实现，<a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html#impl-IntoIterator-25">例如</a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;I: <span class="built_in">Iterator</span>&gt; <span class="built_in">IntoIterator</span> <span class="keyword">for</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = I::Item;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span> = I;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> I &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个 <a href="https://github.com/ProgrammingRust/examples/blob/master/binary-tree/src/lib.rs">BinaryTree</a> 的实现，</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】表达式</title>
    <url>/2022/06/25/%E3%80%90Rust%E3%80%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><code>Rust</code> 被称作表达式语言，在<code>C</code>中，<code>if</code> 和<code>switch</code> 是语句，它们不会产生值，也不能在表达式中间使用。在<code>Rust</code>中，<code>if</code> 和 <code>match</code>可以产生值。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = <span class="keyword">if</span> cpu.temperature &lt;= MAX_TEMP &#123;</span><br><span class="line">    HttpStatus::<span class="literal">Ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HttpStatus::ServerError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;Inside the vat, you see &#123;&#125;.&quot;</span>,</span><br><span class="line">    <span class="keyword">match</span> vat.contents &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(brain) =&gt; brain.<span class="title function_ invoke__">desc</span>(),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="string">&quot;nothing of interest&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这解释了为什么<code>Rust</code>没有<code>C</code>的三元运算符<code>(expr1: Expr2: expr3)</code>，在 <code>C</code> 中，它类似 <code>if</code> 语句，而在 <code>Rust</code> 中，<code>if</code> 完全可以代替。另外大多数控制流在 <code>C</code> 中是语句，而在 <code>Rust</code> 中是表达式（语句都会以 <code>;</code> 结束，而表达式没有）。</p>
<span id="more"></span>

<p>下面是 <code>Rust</code> 中所有支持的表达式列表：</p>
<img data-src="/2022/06/25/%E3%80%90Rust%E3%80%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/express_list-1.png" class="">
<img data-src="/2022/06/25/%E3%80%90Rust%E3%80%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/express_list-2.png" class="">

<p>下面的运算符都是左联运算符。例如：<code>a - b - c</code> 被分组成 <code>(a-b)-c</code>，而不是 <code>a - (b - c)</code>：</p>
<blockquote>
<p><code>* / % + - &lt;&lt; &gt;&gt; &amp; ^ | &amp;&amp; || as</code></p>
</blockquote>
<p>比较运算符，赋值运算符以及范围运算符 <code>..</code> 不能被链在一起使用。</p>
<h3 id="代码块和分号"><a href="#代码块和分号" class="headerlink" title="代码块和分号"></a>代码块和分号</h3><p>块，也就是一个大括号，是最通用的表达方式，它能产生一个值，可以在任何需要值的地方使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">display_name</span> = <span class="keyword">match</span> post.<span class="title function_ invoke__">author</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(author) =&gt; author.<span class="title function_ invoke__">name</span>(),</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">network_info</span> = post.<span class="title function_ invoke__">get_network_metadata</span>()?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ip</span> = network_info.<span class="title function_ invoke__">client_address</span>();</span><br><span class="line">            ip.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Some(author) =&gt;</code> 后面是简单的表达式 <code>author.name()</code>，而 <code>None</code> 后面是一个块表达式，它的值是其中的最后一个表达式 <code>ip.to_string()</code> 的值，并且要注意它的后面没有分号。</p>
<p>确实大多数 <code>Rust</code> 代码行都是以 <code>;</code> 分号结束的，如果一个代码块以 <code>;</code> 结束，那么它的值是 <code>()</code>。在 <code>javascript</code> 中，允许省略 <code>;</code>，但是语言会自动填充。在 <code>Rust</code> 中有没有分号是有不同的意义的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = &#123;</span><br><span class="line">        <span class="comment">// let 语句，分号是必要的</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dandelion_control</span> = puffball.<span class="title function_ invoke__">open</span>();</span><br><span class="line">        <span class="comment">// 表达式 + 分号：方法被调用，但是返回值被丢弃</span></span><br><span class="line">        dandelion_control.<span class="title function_ invoke__">release_all_seeds</span>(launch_codes);</span><br><span class="line">        <span class="comment">// 表达式没有分号：方法被调用，值被存储在msg中</span></span><br><span class="line">        dandelion_control.<span class="title function_ invoke__">get_status</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块内可以做一些声明，并且在最后返回一个值，能够使代码看起来比较整洁，用多了会觉得很爽。缺点是当忘记加分号时，可能会引发错误。但一般情况下是编译器都会提示我们。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>let</code> 语句的形式如下，其中的 <code>type</code> 和 <code>expr</code> 是可以省略的：</p>
<blockquote>
<p>let name: type &#x3D; expr;</p>
</blockquote>
<p><code>let</code> 语句可以只声明一个变量而不用初始化，可以在后面的代码中用赋值语句初始化它。这有时候很有用，我们可以先声明一个变量，然后在下面的控制流代中初始化它：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">name</span>;</span><br><span class="line"><span class="keyword">if</span> user.<span class="title function_ invoke__">has_nickname</span>() &#123;</span><br><span class="line">    name = user.<span class="title function_ invoke__">nickname</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = <span class="title function_ invoke__">generate_unique_name</span>();</span><br><span class="line">    user.<span class="title function_ invoke__">register</span>(&amp;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里局部变量有两种不同的方式初始化，但无论哪种方式，<code>name</code> 仅被初始化一次，所以无需声明为 <code>mut</code> 类型，在没有初始化之前使用变量是不允许的。</p>
<p><code>Rust</code> 代码中允许重新二次定义同名变量，它会在这个二次定义的变量存在期间，将之前的变量屏蔽。在这里，<code>line</code> 开始的类型是 <code>Result&lt;String, io::Error&gt;</code>，后面又是 <code>String</code>，这在代码中是非常常见的，具有同一个语义的变量具有不同的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> file.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span>  = line?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们甚至可以在代码块中声明一个 <code>fn</code> 或者结构体，但是它们的作用域仅限于这个代码块。当我们在代码块中定义函数时，它是不能访问代码块中的局部变量的。例如，下面的 <code>cmp_by_timestamp_then_name</code> 不能访问变量 <code>v</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_files</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_by_timestamp_then_name</span>(a: &amp;FileInfo, b: &amp;FileInfo) <span class="punctuation">-&gt;</span> Ordering &#123;</span><br><span class="line">        a.timestamp.<span class="title function_ invoke__">cmp</span>(&amp;b.timestamp) <span class="comment">// first, compare timestamps</span></span><br><span class="line">        .<span class="title function_ invoke__">reverse</span>() <span class="comment">// newest file first</span></span><br><span class="line">        .<span class="title function_ invoke__">then</span>(a.path.<span class="title function_ invoke__">cmp</span>(&amp;b.path)) <span class="comment">// compare paths to break ties</span></span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="title function_ invoke__">sort_by</span>(cmp_by_timestamp_then_name);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="if-和-match"><a href="#if-和-match" class="headerlink" title="if 和 match"></a><code>if</code> 和 <code>match</code></h3><p><code>if</code> 表达式比较简单，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if condition1 &#123; </span><br><span class="line">    block1</span><br><span class="line">&#125; else if condition2 &#123; </span><br><span class="line">    block2</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    block_n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 <code>condition</code> 必须是一个 <code>bool</code> 类型的表达式，<code>Rust</code> 不会对数字或者指针进行隐式转换。<code>condition</code> 两边的括号不是必须的，如果添加了，<code>rustc</code> 会给一个告警。</p>
<p><code>match</code> 语句很像 <code>C</code>  语言中的 <code>switch</code>，但是更加灵活，下面是一个简单的例子。这很像 <code>switch</code> 语句根据 <code>code</code> 的值具体执行某个分支的表达式，通配符 <code>_</code> 就像 <code>switch</code> 中的 <code>default</code>，能匹配任何东西，只是它必须放在最后面。将 <code>_</code> 放在之前，意味着它的优先级更高，在它的之后匹配都不可达。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">match</span> code &#123;</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Wires Tangled&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;User Asleep&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Unrecognized Error &#123;&#125;&quot;</span>, code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code> 表达式经常用于去区分 <code>Option</code> 的两种类型：<code>Some(v)</code> 和 <code>None</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> params.<span class="title function_ invoke__">get</span>(<span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(name) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Greetings, stranger.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code> 的通用形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match value &#123; </span><br><span class="line">    pattern =&gt; expr,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>expr</code> 是一个代码块，那么逗号 <code>,</code> 是可以省略的的。<code>Rust</code> 从头开始检查 <code>value</code> 和哪个 <code>pattern</code> 匹配，一旦匹配，表达式 <code>expr</code> 就会被执行，后面的 <code>pattern</code> 就不会被检查了，所以如果我们将通配符 <code>_</code> 放在最前面，那么在它后面的 <code>pattern</code> 都不会被检查了。<code>rust</code> 中，<code>match</code> 表达式必须包含所有可能的情况，例如下面的代码会编译失败:</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">code</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">match</span> code &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Wires Tangled&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;User Asleep&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器提示我们有未覆盖的情况，建议我们使用通配符：</p>
<pre><code>error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered
--&gt; src/main.rs:4:11
|
4 |     match code {
|           ^^^^ patterns `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered
|
= note: the matched value is of type `i32`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms
|
7 ~         2 =&gt; println!(&quot;User Asleep&quot;),
8 ~         i32::MIN..=-1_i32 | 3_i32..=i32::MAX =&gt; todo!(),
</code></pre>
</div>


<p>所有的 <code>if</code> 分支返回的值类型必须是相同的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">suggested_pet</span> =</span><br><span class="line">    <span class="keyword">if</span> with_wings &#123; Pet::Buzzard &#125; <span class="keyword">else</span> &#123; Pet::Hyena &#125;; <span class="comment">// ok </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">favorite_number</span> =</span><br><span class="line">    <span class="keyword">if</span> user.<span class="title function_ invoke__">is_hobbit</span>() &#123; <span class="string">&quot;eleventy-one&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="number">9</span> &#125;; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">best_sports_team</span> =</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_ invoke__">is_hockey_season</span>() &#123; <span class="string">&quot;Predators&quot;</span> &#125;; <span class="comment">// 错误，因为会返回数字或者 ()</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>match</code> 表达式也是，所有的分支必须返回相同类型的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">suggested_pet</span> =</span><br><span class="line">    <span class="keyword">match</span> favorites.element &#123;</span><br><span class="line">        Fire =&gt; Pet::RedPanda,</span><br><span class="line">        Air =&gt; Pet::Buffalo,</span><br><span class="line">        Water =&gt; Pet::Orca,</span><br><span class="line">        _ =&gt; <span class="literal">None</span> <span class="comment">//错误，不兼容的类型</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>更多关于 <code>match</code> 的用法可以看 <a href="/2021/09/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/#match">【Rust】实战突破</a> 或者 <a href="/2022/04/25/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a>。</p>
<h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a><code>if let</code></h3><p>这里还有一个 <code>if</code> 的形式，<code>if let</code> 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if let pattern = expr &#123;</span><br><span class="line">     block1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    block2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果给定的表达式 <code>expr</code> 匹配 <code>pattern</code>，那么 <code>block1</code> 将会运行；如果不匹配，<code>block2</code> 就会运行。这是一个从 <code>Option</code> 或者 <code>Result</code> 获取数据比较好的方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cookie) = request.session_cookie &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">restore_session</span>(cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = <span class="title function_ invoke__">show_cheesy_anti_robot_task</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">log_robot_attempt</span>(err);</span><br><span class="line">    <span class="title function_ invoke__">politely_accuse_user_of_being_a_robot</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">    session.<span class="title function_ invoke__">mark_as_human</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if let</code> 可以做的事情 <code>match</code> 都可以做，所以说 <code>if let</code> 只是 <code>match</code> 的一种简写方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match expr &#123;</span><br><span class="line">    pattern =&gt; &#123; block1 &#125; </span><br><span class="line">    _ =&gt; &#123; block2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>这里有四种循环表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition &#123;</span><br><span class="line">    block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while let pattern = expr &#123;</span><br><span class="line">    block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop &#123;</span><br><span class="line">    block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for pattern in itertable &#123;</span><br><span class="line">    block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 中的循环语句都是表达式，但是 <code>while</code> 和 <code>for</code> 的值永远是 <code>()</code>，所以它们不是很有用，<code>loop</code> 倒是可以返回一个值，当然只有在你声明的时候。</p>
<p><code>while</code> 循环和<code>C</code>语言很像，但是 <code>Rust</code> 中的 <code>condition</code> 必须是精确的 <code>bool</code> 类型。</p>
<p><code>while let</code> 类似于 <code>if let</code>。在每次循环迭代开始的时候，<code>expr</code> 的值如果匹配 <code>pattern</code>，那么 <code>block</code> 就会运行，负责循环就会退出。</p>
<p><code>loop</code> 经常用于去写无限循环，它会一直重复执行 <code>block</code>，直到遇到 <code>return</code>，<code>break</code> 或者 <code>panic</code>。</p>
<p><code>for</code> 循环会计算 <code>iterable</code> 表达式获得一个值，然后运行 <code>block</code> 依次。这里有许多可以迭代的类型，包括标准集合中所有类型，例如: <code>vec</code> 和 <code>HashMap</code>。</p>
<p>标准的<code>C</code>循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>; i++) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>rust</code> 中写作如下的形式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">20</span> &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>..</code> 运算符可以生成一个 <code>range</code>，它是一个具有两个字段（<code>start</code> 和 <code>end</code>）的简单结构体。<code>0..20</code> 很像标准库中的 <code>std::ops::Range &#123; start: 0, end: 20 &#125;</code>。<code>Range</code> 可以被用于 <code>for</code> 循环，是因为它实现了 <code>std::iter::IntoIterator</code>。</p>
<p>有一点需要记住的是 <code>for</code> 循环会 <code>move</code> 值得所有权并且它包含的元素，所以下面这段代码编译失败：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// each String is moved into s here...</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; error(s)&quot;</span>, strings.<span class="title function_ invoke__">len</span>()); <span class="comment">// error: use of moved value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器提示我们，由于隐式调用 <code>.into_iter()</code> 方法，<code>strings</code> 包含的值的所有权已经被转移，他已经处于未初始化状态：</p>
<pre><code>error[E0382]: borrow of moved value: `strings`
--&gt; src/main.rs:7:29
    |
2   |     let strings = vec![&quot;hello&quot;, &quot;world&quot;];
    |         ------- move occurs because `strings` has type `Vec&lt;&amp;str&gt;`, which does not implement the `Copy` trait
3   |     for s in strings {
    |              ------- `strings` moved due to this implicit call to `.into_iter()`
...
7   |     println!(&quot;{} error(s)&quot;, strings.len()); // error: use of moved value
    |                             ^^^^^^^^^^^^^ value borrowed here after move
    |
</code></pre>
</div>

<p>这看起来很不方便，改进的方式是使用引用迭代集合，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">rs</span> <span class="keyword">in</span> &amp;strings &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;String &#123;:?&#125; is at address &#123;:p&#125;.&quot;</span>, *rs, rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在迭代过程中需要对它进行更改，可以获取 <code>strings</code> 的 <code>muteable reference</code>：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> strings &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; error(s)&quot;</span>, strings.<span class="title function_ invoke__">len</span>()); <span class="comment">// error: use of moved value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行成功：</p>
<pre><code>/Users/fudenglong/.cargo/bin/cargo run --color=always --package mandelbrot --bin mandelbrot
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/mandelbrot`
hello

world

2 error(s)

Process finished with exit code 0
</code></pre>
</div>

<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a><code>break</code> 和 <code>continue</code></h3><p>可以使用 <code>break</code> 退出 <code>loop</code> 循环，在 <code>loop</code> 的循环体中，可以给 <code>break</code> 一个表达式，它的值变成 <code>loop</code> 的值，<code>loop</code> 中所有 <code>break</code> 的表达式都必须要有相同的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Each call to `next_line` returns either `Some(line)`, where</span></span><br><span class="line"><span class="comment">// `line` is a line of input, or `None`, if we&#x27;ve reached the end of </span></span><br><span class="line"><span class="comment">// the input. Return the first line that starts with &quot;answer: &quot;.</span></span><br><span class="line"><span class="comment">// Otherwise, return &quot;answer: nothing&quot;.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(line) = <span class="title function_ invoke__">next_line</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">starts_with</span>(<span class="string">&quot;answer: &quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> line; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="string">&quot;answer: nothing&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>continue</code> 表达式用于跳到下次迭代：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read some data, one line at a time.</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> input_lines &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trimmed</span> = <span class="title function_ invoke__">trim_comments_and_whitespace</span>(line); </span><br><span class="line">    <span class="keyword">if</span> trimmed.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="comment">// Jump back to the top of the loop and </span></span><br><span class="line">        <span class="comment">// move on to the next line of input. </span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于嵌套的循环，我们如何直接从内部退出。在 <code>Rust</code> 中，我们可以给循环一个<code>label</code>，用于在 <code>break</code> 时退出到哪层循环。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&#x27;search</span>:</span><br><span class="line"><span class="keyword">for</span> <span class="variable">room</span> <span class="keyword">in</span> apartment &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">spot</span> <span class="keyword">in</span> room.<span class="title function_ invoke__">hiding_spots</span>() &#123; </span><br><span class="line">        <span class="keyword">if</span> spot.<span class="title function_ invoke__">contains</span>(keys) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Your keys are &#123;&#125; in the &#123;&#125;.&quot;</span>, spot, room);</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;search</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<code>break</code> 语句也可以将表达式和<code>label</code>一起使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the square root of the first perfect square // in the series.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sqrt</span> = <span class="symbol">&#x27;outer</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">next_number</span>(); </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>.. &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">square</span> = i*i; </span><br><span class="line">        <span class="keyword">if</span> square == n &#123;</span><br><span class="line">            <span class="comment">// Found a square root.</span></span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;outer</span> i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> square &gt; n &#123;</span><br><span class="line">            <span class="comment">// `n` isn&#x27;t a perfect square, try the next break;</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>label</code> 也可以配合 <code>continue</code> 使用。</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h3><p><code>return</code> 语句用于退出当前的函数，返回值给调用者，特殊情况，<code>return;</code> 其实就是 <code>return ();</code> 的简写。 函数一般可能没有显示的 <code>return</code> 语句，函数体很像一个 <code>block</code>，如果最后一个表达式没有以 <code>;</code> 结尾，那么它就是函数的返回值，一般情况下，这是 <code>Rust</code> 函数中用于返回值得首选方式。</p>
<p>但这并不意味着 <code>return</code> 是没用的，就像 <code>break</code> 一样，<code>return</code> 可以提前结束函数的运行。例如，下面的示例，当函数调用返回错误时，我们可以提前返回：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(filename) &#123; </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(f) =&gt; f,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型 !"></a><code>never</code> 类型 <code>!</code></h3><p><a href="https://doc.rust-lang.org/stable/std/primitive.never.html"><code>!</code></a> 表示 <code>never</code> 类型。在 <code>Rust</code> 中，有些函数，可能包含死循环，<code>panic!()</code> 或者类似 <code>std::process::exit()</code> ，这些函数都无法正常完成，它们的返回值难以确定是什么类型，例如，标准库中的 <a href="https://doc.rust-lang.org/std/process/fn.exit.html"><code>std::process::exit()</code></a>，它的源码是这样的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    crate::rt::<span class="title function_ invoke__">cleanup</span>();</span><br><span class="line">    crate::sys::os::<span class="title function_ invoke__">exit</span>(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Rust</code>中，这些函数没有正常类型，未正常完成的表达式被分配到特殊类型<code>!</code>，并且它们不受类型必须匹配的规则的约束。例如我们编写下面这样的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_forever</span>(socket: ServerSocket, handler: ServerHandler) <span class="punctuation">-&gt;</span> ! &#123; </span><br><span class="line">    socket.<span class="title function_ invoke__">listen</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = socket.<span class="title function_ invoke__">accept</span>(); </span><br><span class="line">        handler.<span class="title function_ invoke__">handle</span>(s);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数和方法调用"><a href="#函数和方法调用" class="headerlink" title="函数和方法调用"></a>函数和方法调用</h3><p>函数调用和方法调用同其他的语言比较类似：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">gcd</span>(<span class="number">1302</span>, <span class="number">462</span>); <span class="comment">// function call </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">room</span> = player.<span class="title function_ invoke__">location</span>(); <span class="comment">// method call</span></span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 在引用和值之间有明显的区分，所以在传递参数时精确的类型，如果函数需要 <code>i32</code> 类型，你传入的是 <code>&amp;i32</code> 类型就会报错。但是 <code>.</code> 运算符放宽了这些规则，在 <code>player.location()</code> 的方法调用中，<code>player</code> 可能是 <code>Player</code>，<code>&amp;Player</code>，<code>Box&lt;Player&gt;</code> 或者 <code>Rc&lt;Player&gt;</code>。<code>.location()</code> 方法可以通过值或引用来获取 <code>player</code>，因为 <code>Rust</code> 的 <code>.</code> 运算符能够自动解引用或根据需要创建引用。</p>
<p>另外一种语法是和类型关联的函数，例如 <code>Vec::new()</code>，类似于面向对象语言中的静态方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// type-associated function call</span></span><br></pre></td></tr></table></figure>

<p>方法调用可以串联起来：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">    .<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:3000&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error binding server to address&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">run</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error running server&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 语法的一个怪癖是，在函数调用或方法调用中，泛型类型的常用语法 <code>Vec&lt;T&gt;</code> 不起作用：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">with_capacity</span>(<span class="number">1000</span>); <span class="comment">// error: something about chained comparisons </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ramp</span> = (<span class="number">0</span> .. n).collect&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;(); <span class="comment">// same error</span></span><br></pre></td></tr></table></figure></div>

<p>问题是表达式中的 <code>&lt;</code> 被当做小于运算符，正确的语法是：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">Vec</span>::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">with_capacity</span>(<span class="number">1000</span>); <span class="comment">// ok, using ::&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ramp</span> = (<span class="number">0</span> .. n).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;(); <span class="comment">// ok, using ::&lt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>Rust</code> 社区将 <code>::&lt;...&gt;</code> 叫做 <code>turbofish</code>，但是我们也可以省略它们，改由<code>Rust</code>进行推断：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>); <span class="comment">// ok, if the fn return type is Vec&lt;i32&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ramp</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">0</span> .. n).<span class="title function_ invoke__">collect</span>(); <span class="comment">// ok, variable&#x27;s type is given</span></span><br></pre></td></tr></table></figure></div>

<h3 id="字段和索引"><a href="#字段和索引" class="headerlink" title="字段和索引"></a>字段和索引</h3><p>结构体字段的访问和其他语言比较类似，<code>tuple</code> 采用相同的语法，只是它只能使用数字作为索引。如果 <code>.</code> 左边是个引用或者智能指针，会自动进行解引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">game.black_pawns <span class="comment">// struct field </span></span><br><span class="line">coords.<span class="number">1</span> <span class="comment">// tuple element</span></span><br></pre></td></tr></table></figure>

<p><code>[]</code> 用于访问数组，<code>slice</code> 或者 <code>vector</code> 的元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">pieces[i]</span><br></pre></td></tr></table></figure>

<p>这些变量可以被当做左值表达式，如果它们被声明为 <code>muteable</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">game.black_pawns = <span class="number">0x00ff0000_00000000_u64</span>; </span><br><span class="line">coords.<span class="number">1</span> = <span class="number">0</span>;</span><br><span class="line">pieces[<span class="number">2</span>] = <span class="title function_ invoke__">Some</span>(Piece::<span class="title function_ invoke__">new</span>(Black, Knight, coords));</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>..</code> 运算符从一个数组，<code>slice</code> 或者 <code>vector</code> 获取一个 <code>slice</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">second_half</span> = &amp;game_moves[midpoint .. end];</span><br></pre></td></tr></table></figure>

<p><code>..</code> 运算符可以省略一些操作数，总共有下面这些操作类型，区间是左闭右开类型的，例如：<code>0 .. 3</code> 是 <code>0, 1, 2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..      // RangeFull</span><br><span class="line">a ..    // RangeFrom &#123; start: a &#125;</span><br><span class="line">.. b    // RangeTo &#123; end: b &#125; 不包括b</span><br><span class="line">a .. b  // Range &#123; start: a, end: b &#125; 不包括b</span><br></pre></td></tr></table></figure>

<p><code>..=</code> 运算符可以包含右边的结束值，例如 <code>0 ..= 3</code> 是 <code>0, 1, 2, 3</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">..= b <span class="comment">// RangeToInclusive &#123; end: b &#125; </span></span><br><span class="line">a ..= b <span class="comment">// RangeInclusive::new(a, b)</span></span><br></pre></td></tr></table></figure>

<p>但是在循环中，必须要有起始位置，因为循环必须要有个起始点。不过在数组切片中，六种形式都是有用的，如果 <code>start</code> 和 <code>end</code> 被省略，就会指向 <code>slice</code> 全部。</p>
<p>下面是一个分值算法的示例，用于实现快速排序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">quicksort</span>&lt;T: <span class="built_in">Ord</span>&gt;(slice: &amp;<span class="keyword">mut</span> [T]) &#123; </span><br><span class="line">    <span class="keyword">if</span> slice.<span class="title function_ invoke__">len</span>() &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Nothing to sort. </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Partition the slice into two parts, front and back.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pivot_index</span> = <span class="title function_ invoke__">partition</span>(slice);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Recursively sort the front half of `slice`.</span></span><br><span class="line">    <span class="title function_ invoke__">quicksort</span>(&amp;<span class="keyword">mut</span> slice[.. pivot_index]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// And the back half.</span></span><br><span class="line">    <span class="title function_ invoke__">quicksort</span>(&amp;<span class="keyword">mut</span> slice[pivot_index + <span class="number">1</span> ..]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符"></a>解引用操作符</h3><p>一元 <code>*</code> 操作符被用于访问引用指向的值，由于 <code>.</code> 在访问结构体字段或者方法时会自动解引用，所以 <code>*</code> 没有太多发挥的场景。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">padovan</span>: <span class="type">Vec</span>&lt;<span class="type">u64</span>&gt; = <span class="title function_ invoke__">compute_padovan_sequence</span>(n); </span><br><span class="line"><span class="keyword">for</span> <span class="variable">elem</span> <span class="keyword">in</span> &amp;padovan &#123;</span><br><span class="line">    <span class="title function_ invoke__">draw_triangle</span>(turtle, *elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算数，位运算，比较和逻辑运算符"><a href="#算数，位运算，比较和逻辑运算符" class="headerlink" title="算数，位运算，比较和逻辑运算符"></a>算数，位运算，比较和逻辑运算符</h3><p>大多数适合是和<code>C</code>语言比较相似的，我们来看一些特别的例子。<code>-</code> 可以用于表示负数，但是没有对应的 <code>+</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, -<span class="number">100</span>);      <span class="comment">// -100</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, -<span class="number">100u32</span>);  <span class="comment">// error: can&#x27;t apply unary `-` to type `u32` </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, +<span class="number">100</span>);     <span class="comment">// error: expected expression, found `+`</span></span><br></pre></td></tr></table></figure>


<p>与 <code>C</code> 中一样， <code>a % b</code> 计算除法向零舍入的有符号余数或模数。结果与左操作数的符号相同。请注意，<code>%</code> 可用于浮点数和整数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1234.567</span> % <span class="number">10.0</span>; <span class="comment">// approximately 4.567</span></span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 也继承了 <code>C</code> 的位运算符，<code>&amp;, |, ^, &lt;&lt;, &gt;&gt;</code>，只是 <code>Rust</code> 中使用 <code>!</code> 表示 <code>NOT</code> 而不是 <code>~</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hi</span>: <span class="type">u8</span> = <span class="number">0xe0</span>; <span class="keyword">let</span> <span class="variable">lo</span> = !hi; <span class="comment">// 0x1f</span></span><br></pre></td></tr></table></figure>

<p>移位运算符在处理有符号数时进行符号扩展，在处理无符号整数时进行<code>0</code>扩展。</p>
<p>位运算符比比较运算符有更高的优先级，这点和 <code>C</code> 语言不太一样。<code>x &amp; BIT != 0</code> 表示 <code>(x &amp; BIT) != 0</code>。</p>
<p>比较运算符 <code> ==, !=, &lt;, &lt;=, &gt;, &gt;=</code> 中的两个操作数必须要有相同的类型。</p>
<p>逻辑运算符 <code>||</code> 和 <code>&amp;&amp;</code> 两个操作数必须都是<code> bool</code> 类型。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p><code>=</code> 赋值运算符用于变量的初始化，或者对可变变量，或者它们的字段，内部元素进行赋值。<code>Rust</code> 不同与其他语言，默认情况下，变量都是不可变的，也就是不能修改。</p>
<p>另外，如果值是 <code>non-copy</code> 类型，那么赋值运算符将会转移它的所有权，值原来的所有者就会变成未初始化状态。</p>
<p>除了基本的赋值运算符之外，还支持组合赋值，例如：<code>+=</code>，<code>*=</code>，<code>-=</code>等等：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">total += item.price;</span><br></pre></td></tr></table></figure>
<p>要注意的是，<code>Rust</code> 不支持<code>C</code>中的链式赋值，所以 <code>a = b = 3</code> 是不允许的，也不支持自增自减运算符 <code>++</code> 和 <code>--</code>。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><code>Rust</code> 中的类型转换需要显示的使用 <code>as</code> 关键字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">17</span>; <span class="comment">// x is type i32</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">index</span> = x <span class="keyword">as</span> <span class="type">usize</span>; <span class="comment">// convert to usize</span></span><br></pre></td></tr></table></figure>

<p>下面是几种允许显示转换的类型：</p>
<ul>
<li><p>内建的数字类型可以相互转换；将整数转换为另一种整数类型始终是明确定义的。转换为更窄的类型会导致截断。转换为更宽的有符号整数是符号扩展的，无符号整数是零扩展的，依此类推。从浮点类型转换为整数类型会向零舍入：<code>-1.99 as i32</code> 将会得到 <code>-1</code>。如果该值太大而无法放入整数类型，则强制转换会生成整数类型可以表示的最接近的值：<code>1e6 as u8</code> 将是 <code>255</code>；</p>
</li>
<li><p><code>bool</code> 或 <code>char</code> 类型或类似 <code>C</code> 的枚举类型的值可以转换为任何整数类型，但是反过来转换是不允许的，例如，禁止将 <code>u16</code> 强制转换为 <code>char</code> 类型，因为某些 <code>u16</code> 值（如 <code>0xd800</code>）对应于无效的 <code>Unicode</code> 码点，它不是有效的 <code>char</code> 值。有一个标准方法，<code>std::char::from_u32()</code>，它执行运行时检查并返回一个 <code>Option&lt;char&gt;</code>，但这种转换的需求很少。<strong>作为一个例外，<code>u8</code> 是唯一可以转换成 <code>char</code> 的类型，因为它的范围 <code>0-255</code> 都是有效的 <code>ASCII</code> 字符</strong>；</p>
</li>
</ul>
<p>我们说过转换通常需要强制转换，一些涉及引用类型的转换非常简单，即使没有强制转换，语言也会执行它们。下面是一些自动转换的场景：</p>
<ul>
<li><code>String</code> 类型的值可以自动转换为 <code>&amp;str</code> 类型；</li>
<li><code>&amp;Vec&lt;i32&gt;</code> 类型的值可以自动转换为 <code>&amp;[i32]</code> 类型；</li>
<li><code>&amp;Box&lt;Chessboard&gt;</code> 类型的值可以自动转换为 <code>&amp;Chessboard</code> 类型；</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><code>Rust</code> 有闭包，轻量级的类似函数的值。闭包通常由一个参数列表，在竖线之间给出，后跟一个表达式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">is_even</span> = |x| x % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>Rust</code> 可以推断参数类型和返回类型，当然也可以向函数那样明确写出来。但是如果指定了返回类型，则为了语法上的完整性，闭包体必须是一个块：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">is_even</span> = |x: <span class="type">u64</span>| <span class="punctuation">-&gt;</span> <span class="type">bool</span> x % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">is_even</span> = |x: <span class="type">u64</span>| <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; x % <span class="number">2</span> == <span class="number">0</span> &#125;; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>闭包的调用和函数调用语法一样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">is_even</span>(<span class="number">14</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】闭包</title>
    <url>/2023/07/07/%E3%80%90Rust%E3%80%91%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>很多语言中都有闭包，有的叫匿名函数，有的叫 <code>lambda</code> 函数，用一个最简单的例子演示闭包，例如 <code>sort_by_key</code> 传入的就是一个闭包函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    population: <span class="type">i64</span>,</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cities</span> = <span class="type">Vec</span>::&lt;City&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    cities.<span class="title function_ invoke__">sort_by_key</span>(|city| -city.population)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><p>闭包可以捕获上下文中的变量，例如，下面的闭包使用了原本属于 <code>sort_by_statistic</code> 函数中的 <code>stat</code>，我们称闭包捕获了 <code>stat</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Sort by any of several different statistics.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sort_by_statistic</span>(cities: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;City&gt;, stat: Statistic) &#123;</span><br><span class="line">    cities.<span class="title function_ invoke__">sort_by_key</span>(|city| -city.<span class="title function_ invoke__">get_statistic</span>(stat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包在捕获变量的同时，会自动创建对 <code>stat</code> 的引用，所以该闭包的生命周期不能超过 <code>stat</code>，在函数返回的时候，会自动释放 <code>stat</code>。</p>
<h3 id="变量偷取"><a href="#变量偷取" class="headerlink" title="变量偷取"></a>变量偷取</h3><p>我们来看一个复杂一些的例子，这段代码会编译错误，我们创建了一个新的线程进行排序，我们的闭包函数还引用了 <code>cities</code> 和 <code>stat</code>：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">start_sorting_thread</span>(<span class="keyword">mut</span> cities: <span class="type">Vec</span>&lt;City&gt;, stat: Statistic) <span class="punctuation">-&gt;</span> thread::JoinHandle&lt;<span class="type">Vec</span>&lt;City&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key_fn</span> = |city: &amp;City| <span class="punctuation">-&gt;</span> <span class="type">i64</span> &#123; -city.<span class="title function_ invoke__">get_statistic</span>(stat) &#125;;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        cities.<span class="title function_ invoke__">sort_by_key</span>(key_fn);</span><br><span class="line">        cities</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码编译失败是因为存在两个原因：</p>
<ol>
<li>由于 <code>start_sorting_thread</code> 中已经包含了对 <code>cities</code> 的可变引用，所以闭包不能在创建新的共享引用；</li>
<li>新创建的线程和调用者所在线程并行，<code>start_sorting_thread</code> 返回时，新线程可能还没开始，而 <code>stat</code> 由于不在作用域中，需要被释放；</li>
</ol>
</div>


<p>解决方案我们告诉 <code>Rust</code>，需要偷取闭包所使用的的变量而不是借用，使用关键字 <code>move</code> 来进行声明：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">start_sorting_thread</span>(<span class="keyword">mut</span> cities: <span class="type">Vec</span>&lt;City&gt;, stat: Statistic) <span class="punctuation">-&gt;</span> thread::JoinHandle&lt;<span class="type">Vec</span>&lt;City&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key_fn</span> = <span class="keyword">move</span> |city: &amp;City| <span class="punctuation">-&gt;</span> <span class="type">i64</span> &#123; -city.<span class="title function_ invoke__">get_statistic</span>(stat) &#125;;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        cities.<span class="title function_ invoke__">sort_by_key</span>(key_fn);</span><br><span class="line">        cities</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此，<code>Rust</code> 提供了两种使用上下文中数据的方式：引用和偷取。</p>
<h3 id="闭包和函数类型"><a href="#闭包和函数类型" class="headerlink" title="闭包和函数类型"></a>闭包和函数类型</h3><p>我们可以把函数或者闭包作为函数的参数传递，那么他们肯定是有类型的，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cities</span> = <span class="type">Vec</span>::&lt;City&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    cities.<span class="title function_ invoke__">sort_by_key</span>(|city| -city.population);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_asc</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">city_population_desc</span>(city: &amp;City) <span class="punctuation">-&gt;</span> <span class="type">i64</span> &#123;</span><br><span class="line">        -city.population</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">city_population_asc</span>(city: &amp;City) <span class="punctuation">-&gt;</span> <span class="type">i64</span> &#123;</span><br><span class="line">        -city.population</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key_sort_fn</span>: <span class="title function_ invoke__">fn</span>(&amp;City) <span class="punctuation">-&gt;</span> <span class="type">i64</span> = <span class="keyword">if</span> is_asc &#123;</span><br><span class="line">        city_population_asc</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        city_population_desc</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cities.<span class="title function_ invoke__">sort_by_key</span>(key_sort_fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>key_sort_fn</code> 的类型是：<code>fn(&amp;City) -&gt; i64</code>，我们可以把函数存储在结构体字段中，<code>fn</code> 实际上指向函数机器代码的地址，所占空间就是一个机器字，一个函数可以接受另外一个函数作为参数，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">count_selected_cities</span>(cities: &amp;<span class="type">Vec</span>&lt;City&gt;, test_fn: <span class="title function_ invoke__">fn</span>(&amp;City) <span class="punctuation">-&gt;</span> <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数没法接受闭包作为参数，因为类型不匹配，<code>fn</code> 只能表示函数，闭包虽然可调用，但不是 <code>fn</code> 类型。如果我们需要它能接受函数或者闭包同时参数，需要更改这个函数的签名，使用泛型约束 <code>F</code> 是一个 <code>Fn</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">count_selected_cities</span>&lt;F&gt;(cities: &amp;<span class="type">Vec</span>&lt;City&gt;, test_fn: F) <span class="punctuation">-&gt;</span> <span class="type">usize</span></span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">Fn</span>(&amp;City) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Fn(&amp;City) -&gt; bool</code> 会自动被相关的函和闭包数实现，相当于限定了函数的签名，因此我们可以传入匹配的函数或者闭包。</p>
<h3 id="闭包性能"><a href="#闭包性能" class="headerlink" title="闭包性能"></a>闭包性能</h3><p>在大多数语言中，闭包在堆中分配、动态分派和自动垃圾收集。因此，创建、调用和收集它们中的每一个都会花费一点点额外的 <code>CPU</code> 时间。更糟糕的是，闭包往往会禁止内联，这是编译器用来消除函数调用开销的关键技术。</p>
<p><code>Rust</code> 闭包没有这些性能缺陷，与 <code>Rust</code> 中的其他所有内容一样，它们不会在堆上分配，除非将它们放入 <code>Box</code>、<code>Vec</code> 或其他容器中。而且由于每个闭包都有不同的类型，只要 <code>Rust</code> 编译器知道你正在调用的闭包的类型，它就可以内联该特定闭包的代码。<code>Rust</code> 的闭包设计使其运行的很快，即使在性能敏感代码中也可以使用它们。</p>
<p>下图展示了不同种类的闭包在内存上的布局：</p>
<img data-src="/2023/07/07/%E3%80%90Rust%E3%80%91%E9%97%AD%E5%8C%85/closure-in-mem.png" class="" title="不同种类的闭包在内存上的布局"> 

<ul>
<li><p>闭包 (a) 使用这两个变量，在内存中，这个闭包看起来像一个包含对它使用的变量的引用的小结构；</p>
</li>
<li><p>闭包 (b) 完全一样，只是它是一个 <code>move</code> 闭包，包含了引用的值；</p>
</li>
<li><p>闭包 (c) 不使用其环境中的任何变量，所以这个闭包根本不占用任何内存。</p>
</li>
</ul>
<h3 id="FnOnce"><a href="#FnOnce" class="headerlink" title="FnOnce"></a><code>FnOnce</code></h3><p>有些闭包只能使用一次，例如，下面的代码中的，闭包将捕获的 <code>String</code> 手动通过 <code>drop</code> 丢掉了，我们在调用的时候，就会出错：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call_twice</span>&lt;F&gt;(closure: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_str</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = || <span class="title function_ invoke__">drop</span>(my_str);</span><br><span class="line">    <span class="title function_ invoke__">call_twice</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会提示我们 <code>my_str</code> 已经被释放过了，它是 <code>FnOnce</code> 类型的：</p>
<pre><code>    error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`
    --&gt; src/main.rs:13:13
    |
    13 |     let f = || drop(my_str);
    |             ^^^^^^^^------^
    |             |       |
    |             |       closure is `FnOnce` because it moves the variable `my_str` out of its environment
    |             this closure implements `FnOnce`, not `Fn`
    14 |     call_twice(f);
    |     ---------- the requirement to implement `Fn` derives from here
</code></pre>
</div>

<p>根据提示，我们需要限定 <code>F</code> 是 <code>FnOnce</code> 类型的，就像 <code>a + b</code> 是 <code>Add::add(a, b)</code> 的简写一样，闭包调用展开之后其实是 <code>closure.call()</code> 或者 <code>closure.call_once()</code>：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call_twice</span>&lt;F&gt;(closure: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_str</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = || <span class="title function_ invoke__">drop</span>(my_str);</span><br><span class="line">    <span class="title function_ invoke__">call_twice</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>如果一个闭包并不转移自己的内部数据，那么它就不是 <code>FnOnce</code>，然而，一旦它被当做 <code>FnOnce</code> 调用，之后就无法再次调用了：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Tyr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个闭包会 clone 内部的数据返回，所以它不是 FnOnce</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="keyword">move</span> |greeting: <span class="type">String</span>| (greeting, name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以 c1 可以被调用多次</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c1 call once: &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;qiao&quot;</span>.<span class="title function_ invoke__">into</span>()));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c1 call twice: &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;bonjour&quot;</span>.<span class="title function_ invoke__">into</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然而一旦它被当成 FnOnce 被调用，就无法被再次调用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result: &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">call_once</span>(<span class="string">&quot;hi&quot;</span>.<span class="title function_ invoke__">into</span>(), c1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法再次调用</span></span><br><span class="line">    <span class="comment">// let result = c1(&quot;hi&quot;.to_string());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fn 也可以被当成 FnOnce 调用，只要接口一致就可以</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result: &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">call_once</span>(<span class="string">&quot;hola&quot;</span>.<span class="title function_ invoke__">into</span>(), not_closure));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_once</span>(arg: <span class="type">String</span>, c: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(<span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">String</span>)) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">c</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">not_closure</span>(arg: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">String</span>) &#123;</span><br><span class="line">    (arg, <span class="string">&quot;Rosie&quot;</span>.<span class="title function_ invoke__">into</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Tyr&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="string">&quot;Rust&quot;</span>, <span class="string">&quot;Elixir&quot;</span>, <span class="string">&quot;Javascript&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = &amp;vec[..];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;data: &#123;:?&#125;&quot;</span>, data);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v: &#123;:?&#125;, name: &#123;:?&#125;&quot;</span>, v, name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">c</span>();</span><br><span class="line">    <span class="title function_ invoke__">c</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c 不是 FnOnce，虽然它拥有 data 和 name 的所有权</span></span><br><span class="line">    <span class="comment">// 但是它并没有转移或者消费所有权。但是 name 接下来</span></span><br><span class="line">    <span class="comment">// 是不能被继续使用的，因为它的所有权转移到了闭包中，</span></span><br><span class="line">    <span class="comment">// 会随着闭包的消失而被释放。不过 data 可以被继续使用</span></span><br><span class="line">    <span class="comment">// ，因为 data 支持 Copy，所以对于 move 而言，实际上</span></span><br><span class="line">    <span class="comment">// 闭包中的 data 是一个副本。</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;c));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data);  <span class="comment">// ok</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, data); // failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a><code>FnMut</code></h3><p>还有另一种闭包，一种包含可变数据或 <code>mut</code> 引用的闭包。<code>Rust</code> 认为非 <code>mut</code> 值可以安全地跨线程共享，但是共享包含 <code>mut</code> 数据的非 <code>mut</code> 闭包是不安全的，从多个线程调用这样的闭包可能会导致各种竞争条件，因为多个线程试图同时读取和写入相同的数据。因此，<code>Rust</code> 多了一类闭包，<code>FnMut</code>。</p>
<p>任何需要 <code>mut</code> 访问值但不删除任何值的闭包都是 <code>FnMut</code> 闭包。 例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">incr</span> = || &#123;</span><br><span class="line">    i += <span class="number">1</span>; <span class="comment">// incr borrows a mut reference to i</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Ding! i is now: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_ invoke__">call_twice</span>(incr);</span><br></pre></td></tr></table></figure>

<p>总结一下对三类 Rust 闭包的了解：</p>
<ul>
<li><p><code>Fn</code> 是一系列闭包和函数，可以不受限制地多次调用它们，还包括所有 <code>fn</code> 函数；</p>
</li>
<li><p><code>FnMut</code> 指哪些需要 <code>mut</code> 访问捕获变量，并且可多次访问的闭包；</p>
</li>
<li><p><code>FnOnce</code> 指哪些消耗值所有权，并且仅可以被调用一次的闭包；</p>
</li>
</ul>
<p>从实现上来看，<a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code>Fn</code></a> 是 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code>FnMut</code></a> 的子 <code>Trait</code>，而 <code>FnMut</code> 又是 <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> 的子<code>Trait</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Fn</span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FnMut</span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, </span><br><span class="line">        args: Args</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限制越少，范围越广泛，这使得 <code>Fn</code> 成为最独特和最强大的类别，<code>FnMut</code> 和 <code>FnOnce</code> 是更广泛的类别，包括具有使用限制的闭包。</p>
<p><code>FnMut</code> 就像结构体如果想改变数据需要用 <code>let mut</code> 声明一样，如果想改变闭包捕获的数据结构，那么就需要 <code>FnMut</code>：</p>
<div class="note success"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hola&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获 &amp;mut name</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = || &#123;</span><br><span class="line">        name.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; Tyr&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;&#125;&quot;</span>, name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获 mut name1，注意 name1 需要声明成 mut</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c1</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">        name1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;c1: &#123;&#125;&quot;</span>, name1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">c</span>();</span><br><span class="line">    <span class="title function_ invoke__">c1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">call_mut</span>(&amp;<span class="keyword">mut</span> c);</span><br><span class="line">    <span class="title function_ invoke__">call_mut</span>(&amp;<span class="keyword">mut</span> c1);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(c);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在作为参数时，FnMut 也要显式地使用 mut，或者 &amp;mut</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_mut</span>(c: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>()) &#123;</span><br><span class="line">    <span class="title function_ invoke__">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想想看，为啥 call_once 不需要 mut？</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_once</span>(c: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>()) &#123;</span><br><span class="line">    <span class="title function_ invoke__">c</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明的闭包 <code>c</code> 和 <code>c1</code> 里，我们修改了捕获的 <code>name</code> 和 <code>name1</code>。不同的是 <code>name</code> 使用了引用，而 <code>name1</code> 移动了所有权，这两种情况和其它代码一样，也需要遵循所有权和借用有关的规则。所以，如果在闭包 <code>c</code> 里借用了 <code>name</code>，你就不能把 <code>name</code> 移动给另一个闭包 <code>c1</code>。</p>
<p>这里也展示了，<code>c</code> 和 <code>c1</code> 这两个符合 <code>FnMut</code> 的闭包，能作为 <code>FnOnce</code> 来调用。我们在代码中也确认了，<code>FnMut</code> 可以被多次调用，这是因为 <code>call_mut()</code> 使用的是 <code>&amp;mut self</code>，不移动所有权。</p>
</div>

<h3 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a><code>Fn</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Fn</span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它继承了 <code>FnMut</code>，或者说 <code>FnMut</code> 是 <code>Fn</code> 的 <code>super trait</code>。这也就意味着任何需要 <code>FnOnce</code> 或者 <code>FnMut</code> 的场合，都可以传入满足 <code>Fn</code> 的闭包。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">1023</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fn，不移动所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = |x: <span class="type">u64</span>| v.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u64</span> * x;</span><br><span class="line">    <span class="comment">// Fn，移动所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c1</span> = <span class="keyword">move</span> |x: <span class="type">u64</span>| v1.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u64</span> * x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;direct call: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;direct call: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">c1</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;call: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">call</span>(<span class="number">3</span>, &amp;c));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;call: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">call</span>(<span class="number">3</span>, &amp;c1));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;call_mut: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">call_mut</span>(<span class="number">4</span>, &amp;<span class="keyword">mut</span> c));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;call_mut: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">call_mut</span>(<span class="number">4</span>, &amp;<span class="keyword">mut</span> c1));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;call_once: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">call_once</span>(<span class="number">5</span>, c));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;call_once: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">call_once</span>(<span class="number">5</span>, c1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(arg: <span class="type">u64</span>, c: &amp;<span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">c</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_mut</span>(arg: <span class="type">u64</span>, c: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">c</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_once</span>(arg: <span class="type">u64</span>, c: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(<span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">c</span>(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Copy、Clone-闭包"><a href="#Copy、Clone-闭包" class="headerlink" title="Copy、Clone 闭包"></a><code>Copy</code>、<code>Clone </code>闭包</h3><p>对于那些 <code>非 move</code> 闭包，并且只包含共享引用的闭包是可以 <code>Clone</code> 和 <code>Copy</code> 的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_y</span> = |x| x + y;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">copy_of_add_y</span> = add_y; <span class="comment">// This closure is `Copy`, so...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add_y</span>(<span class="title function_ invoke__">copy_of_add_y</span>(<span class="number">22</span>)), <span class="number">42</span>); <span class="comment">// ... we can call both.</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>move</code> 类型闭包，如果规则更简单，如果闭包中捕获的值都是可 <code>Copy</code> 的，它就是可 <code>Copy</code> 的，如果捕获的是可 <code>Clone</code> 的，那就是可 <code>Clone</code> 的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">greeting</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">greet</span> = <span class="keyword">move</span> |name| &#123;</span><br><span class="line">    greeting.<span class="title function_ invoke__">push_str</span>(name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, greeting);</span><br><span class="line">&#125;;</span><br><span class="line">greet.<span class="title function_ invoke__">clone</span>()(<span class="string">&quot;Alfred&quot;</span>);</span><br><span class="line">greet.<span class="title function_ invoke__">clone</span>()(<span class="string">&quot;Bruce&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当克隆 <code>greet</code> 的时候，它里面的每个东西都会被克隆，所以这里有两个 <code>greeting</code> 的副本，它们会被单独修改。</p>
<h3 id="闭包本质"><a href="#闭包本质" class="headerlink" title="闭包本质"></a>闭包本质</h3><p>本质上闭包是一种匿名类型，一旦声明，就会产生一个新的类型，但这个类型无法被其它地方使用。这个类型就像一个结构体，会包含所有捕获的变量。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, mem::size_of_val&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 长度为 0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || <span class="built_in">println!</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和参数无关，长度也为 0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = |i: <span class="type">i32</span>| <span class="built_in">println!</span>(<span class="string">&quot;hello: &#123;&#125;&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tyr&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name1</span> = name.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">table</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    table.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果捕获一个引用，长度为 8</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || <span class="built_in">println!</span>(<span class="string">&quot;hello: &#123;&#125;&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c4</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;hello: &#123;&#125;, &#123;:?&#125;&quot;</span>, name1, table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name2</span> = name.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// 和局部变量无关，捕获了一个 String name2，closure 长度 24</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c5</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">name3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lindsey&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello: &#123;&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, x, name2, name3);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;c1: &#123;&#125;, c2: &#123;&#125;, c3: &#123;&#125;, c4: &#123;&#125;, c5: &#123;&#125;, main: &#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">size_of_val</span>(&amp;c1),</span><br><span class="line">        <span class="title function_ invoke__">size_of_val</span>(&amp;c2),</span><br><span class="line">        <span class="title function_ invoke__">size_of_val</span>(&amp;c3),</span><br><span class="line">        <span class="title function_ invoke__">size_of_val</span>(&amp;c4),</span><br><span class="line">        <span class="title function_ invoke__">size_of_val</span>(&amp;c5),</span><br><span class="line">        <span class="title function_ invoke__">size_of_val</span>(&amp;main),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<pre><code>c1: 0, c2: 0, c3: 8, c4: 72, c5: 24, main: 0
</code></pre>
<p>说明，不带 <code>move</code> 时，闭包捕获的是对应自由变量的引用；带 <code>move</code> 时，对应自由变量的所有权会被移动到闭包结构中。闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>【Rust】集合类型</title>
    <url>/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Rust 标准库包含几个集合，用于在内存中存储数据的泛型类型。我们已经在前面使用了集合，例如 <code>Vec</code> 和 <code>HashMap</code>。在本章中，我们将详细介绍这两种类型的方法，以及其他<code>6</code>个标准集合。</p>
<p><code>Rust</code> 一共有<code>8</code>个标准集合类型，它们都是泛型：</p>
<img data-src="/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/std-collections.png" class="">

<ul>
<li><p><code>Vec&lt;T&gt;</code>：一个可增长的、堆分配的 <code>T</code> 类型值数组；</p>
</li>
<li><p><code>VecDeque&lt;T&gt;</code>：与 <code>Vec&lt;T&gt;</code> 类似，但更适合用作先进先出队列，它支持在列表的前面和后面有效地添加和删除值；</p>
</li>
<li><p><code>BinaryHeap&lt;T&gt;</code>：一个优先队列，<code>BinaryHeap</code> 中的值是有组织的，所以它总是有效地找到并删除最大值；</p>
</li>
<li><p><code>HashMap&lt;K, V&gt;</code>：键值对表，通过键查找值很快，<code>item</code> 以任意顺序存储；</p>
</li>
<li><p><code>BTreeMap&lt;K, V&gt;</code>：与 <code>HashMap&lt;K, V&gt;</code> 类似，但它保持<code>entries</code>按键排序。 <code>BTreeMap&lt;String, i32&gt;</code> 以字符串比较顺序存储其<code>entries</code>。除非需要<code>entries</code>保持排序，否则 <code>HashMap</code> 更快；</p>
</li>
<li><p><code>HashSet&lt;T&gt;</code>：一组 <code>T</code> 类型的值。添加和删除值很快，查询给定值是否在集合中也很快；</p>
</li>
<li><p><code>BTreeSet&lt;T&gt;</code>：与 <code>HashSet&lt;T&gt;</code> 类似，但它保持元素按值排序。 同样，除非需要对数据进行排序，否则 <code>HashSet</code> 更快；</p>
</li>
</ul>
<span id="more"></span>

<h3 id="Vec"><a href="#Vec" class="headerlink" title="Vec&lt;T&gt;"></a><code>Vec&lt;T&gt;</code></h3><p><code>vector</code>具有 <code>3</code> 个字段：长度、容量和指向存储元素的堆分配的指针。空 <code>vector</code>，容量为 <code>0</code>，在添加第一个元素之前，不会为其分配堆内存。和所有其他集合类型一样，<code>Vec&lt;T&gt;</code> 实现了 <code>std::iter::FromIterator</code>，所以我们可以通过 <code>.collect()</code> 方法创建，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_vec</span> = my_set.<span class="title function_ invoke__">into_iter</span>().collect::&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>我们再来回顾下 <code>vector</code> 的内存表示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create an empty vector</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="comment">// Create a vector with given contents</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">words</span> = <span class="built_in">vec!</span>[<span class="string">&quot;step&quot;</span>, <span class="string">&quot;on&quot;</span>, <span class="string">&quot;no&quot;</span>, <span class="string">&quot;pets&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">1024</span>]; <span class="comment">// 1024 zeroed-out bytes</span></span><br></pre></td></tr></table></figure>

<p>内存表示如下图：</p>
<img data-src="/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/vec-collections.png" class="">

<h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><p>最直接的访问是通过索引，如果索引越界会 <code>panic</code>，<code>vector</code> 长度和索引是 <code>usize</code> 类型，尝试使用 <code>u32</code>、<code>u64</code> 或 i<code>size</code> 作为<code>vector</code>索引是错误的，可以根据需要使用 <code>n as usize</code> 进行转换：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get a reference to an element</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first_line</span> = &amp;lines[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Get a copy of an element</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">fifth_number</span> = numbers[<span class="number">4</span>]; <span class="comment">// requires Copy</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">second_line</span> = lines[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>(); <span class="comment">// requires Clone</span></span><br><span class="line"><span class="comment">// Get a reference to a slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_ref</span> = &amp;buffer[<span class="number">4</span>..<span class="number">12</span>];</span><br><span class="line"><span class="comment">// Get a copy of a slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_copy</span> = buffer[<span class="number">4</span>..<span class="number">12</span>].<span class="title function_ invoke__">to_vec</span>(); <span class="comment">// requires Clone</span></span><br></pre></td></tr></table></figure>

<p>有几种方法可以轻松访问 <code>vector</code> 或<code>slice</code>的特定元素（请注意，所有<code>slice</code>方法也可用于数组和<code>vector</code>）：</p>
<ul>
<li><p><code>slice.first()</code>：返回第一个元素的引用以 <code>Option&lt;&amp;T&gt;</code> 的形式，如果没有就返回 <code>None</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = v.<span class="title function_ invoke__">first</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;We got one! &#123;&#125;&quot;</span>, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.last()</code>：类似于 <code>slice.first()</code>，但返回最后一个；</p>
</li>
<li><p><code>slice.get(index)</code>：返回第 <code>index</code> 个元素索引，不存在返回 <code>None</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice.<span class="title function_ invoke__">get</span>(<span class="number">2</span>), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice.<span class="title function_ invoke__">get</span>(<span class="number">4</span>), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.first_mut(), slice.last_mut(), slice.get_mut(index)</code>：前面几个的变种，只是返回可变借用：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">slice</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span> = slice.<span class="title function_ invoke__">last_mut</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// type of last: &amp;mut i32</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(*last, <span class="number">3</span>);</span><br><span class="line">    *last = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>]);</span><br></pre></td></tr></table></figure>

<p>  因为按值返回 <code>T</code> 意味着转移所有权，所以访问 <code>item</code> 的方法通常通过引用返回这些 <code>item</code>。</p>
</li>
<li><p><code>slice.to_vec()</code>：克隆整个 <code>slice</code>，返回新的，仅仅用于可以 <code>Clone</code> 的 <code>item</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">to_vec</span>(),</span><br><span class="line"><span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v[<span class="number">0</span>..<span class="number">6</span>].<span class="title function_ invoke__">to_vec</span>(),</span><br><span class="line"><span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a><code>Iteration</code></h4><p>可以通过值或者引用迭代 <code>vector</code> 或者 <code>slice</code>：</p>
<ul>
<li><p>如果迭代 <code>Vec&lt;T&gt;</code>，将返回 <code>T</code>，<code>vector</code> 中的值被溢出并且消费；</p>
</li>
<li><p>如果迭代 <code>&amp;[T; N]，&amp;[T]，&amp;Vec&lt;T&gt;</code>，将返回 <code>&amp;T</code>，引用到单独的 <code>item</code>，不会转移它们的所有权；</p>
</li>
<li><p>如果迭代 <code>&amp;mut [T; N]，&amp;mut [T]，&amp;mut Vec&lt;T&gt;</code>，将返回 <code>&amp;mut T</code>。</p>
</li>
</ul>
<h4 id="扩容缩容"><a href="#扩容缩容" class="headerlink" title="扩容缩容"></a>扩容缩容</h4><p>数组，<code>vector</code> 或者 <code>slice</code> 的长度是它包含的元素的数量，例如：</p>
<ul>
<li><p><code>slice.len()</code>：<code>slice</code> 长度，类型是 <code>usize</code>；</p>
</li>
<li><p><code>slice.is_empty()</code>：等价于 <code>slice.len() == 0</code>；</p>
</li>
</ul>
<p>下面的方法用于 <code>vector</code> 扩缩容，不能用在数组上，它们的长度在创建的时候就确定了：</p>
<ul>
<li><p><code>Vec::with_capacity(n)</code>：创建新的能容纳 <code>n</code> 个元素的 <code>vector</code>；</p>
</li>
<li><p><code>vec.capacity()</code>：返回 <code>vector</code> 的容量，<code>vec.capacity() &gt;= vec.len()</code>；</p>
</li>
<li><p><code>vec.reserve(n)</code>：确认这里有足够的的空间再容纳 <code>n</code> 个元素，即 <code>vec.capacity() &gt;= vec.len() + n</code>，如果已经满足，则什么也不做，如果不够就会申请足够的空间并且将当前的内容移进去；</p>
</li>
<li><p><code>vec.reserve_exact(n)</code>：和 <code>vec.reserve(n)</code> 类似，但是不会申请额外的空间为未来的增长，也就是扩容之后 <code>vec.capacity() = exactly vec.len() + n</code>；</p>
</li>
<li><p><code>vec.shrink_to_fit()</code>：尝试释放额外的空闲空间；</p>
</li>
</ul>
<p><code>Vec&lt;T&gt;</code> 有许多方法可以添加或删除元素，从而改变<code>vector</code>的长度。这些中的每一个都通过 <code>mut</code> 引用获取其自身参数。这两种方法在<code>vector</code>末尾添加或删除单个值：</p>
<ul>
<li><p><code>vec.push(value)</code>：将 <code>value</code> 添加到末尾；</p>
</li>
<li><p><code>vec.pop()</code>：移除和返回最后一个元素，返回类型是 <code>Option&lt;T&gt;</code>，返回的是值而不是引用；</p>
</li>
<li><p><code>vec.insert(index, value)</code>：将给定的值插入到指定的 <code>index</code> 处，并且将 <code>vec[index..]</code> 往后移动，如果 <code>index &gt; vec.len()</code>，就会 <code>panic</code>；</p>
</li>
<li><p><code>vec.remove(index)</code>：将给定索引处的值删除，并且将 <code>vec[index+1..]</code> 的值向左移动；</p>
</li>
<li><p><code>vec.resize(new_len, value)</code>：设置 <code>vec</code> 的新长度，如果这会增加长度，将会使用 <code>value</code> 填充增加的值，<code>value</code> 必须实现 <code>Clone</code>；</p>
</li>
<li><p><code>vec.resize_with(new_len, closure)</code>：像 <code>vec.resize()</code>，但是使用闭包构造新的 <code>item</code>，可以用于没有实现 <code>Clone</code> 的场景；</p>
</li>
<li><p><code>vec.truncate(new_len)</code>：设置 <code>vec</code> 的新长度为 <code>new_len</code>，删除 <code>vec[new_len..]</code>，如果 <code>vec.len() &lt; new_len</code>，啥也不做；</p>
</li>
<li><p><code>vec.clear()</code>：删除 <code>vec</code> 所有的元素，类似 <code>vec.truncate(0)</code>；</p>
</li>
<li><p><code>vec.extend(iterable)</code>：将 <code>iterable</code> 中的所有 <code>item</code> 添加到 <code>vec</code> 中；</p>
</li>
<li><p><code>vec.split_off(index)</code>：类似 <code>vec.truncate(index)</code>，但是它返回一个包含被移除值的 <code>Vec</code>，就像多次调用 <code>pop</code>；</p>
</li>
<li><p><code>vec.append(&amp;mut vec2)</code>：将 <code>vec2</code> 中的所有元素移到 <code>vec</code> 中，之后，<code>vec2</code> 就成为空的了，有点类似 <code>extend</code>，但是 <code>extend</code> 会保留 <code>vec2</code>；</p>
</li>
<li><p><code>vec.drain(range)</code>：移除区间内的 <code>item</code>，并且返回移除的元素；</p>
</li>
<li><p><code>vec.retain(test)</code>：删除所有没有通过 <code>test</code> 的 <code>item</code>，<code>test</code> 是 <code>FnMut(&amp;T) -&gt; bool</code> 类型的函数；</p>
</li>
<li><p><code>vec.dedup()</code>：删除连续重复的元素，删除完之后仍然有两个 <code>s</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">byte_vec</span> = <span class="string">b&quot;Misssssssissippi&quot;</span>.<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line">byte_vec.<span class="title function_ invoke__">dedup</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;byte_vec, <span class="string">b&quot;Misisipi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  如果要删除所有重复的 <code>item</code>，可以：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">byte_vec</span> = <span class="string">b&quot;Misssssssissippi&quot;</span>.<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">seen</span> = HashSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    byte_vec.<span class="title function_ invoke__">retain</span>(|r| seen.<span class="title function_ invoke__">insert</span>(*r));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;byte_vec, <span class="string">b&quot;Misp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vec.dedup_by(same)</code>：类似于 <code>vec.dedup()</code>，但是它使用闭包函数判断是否相等，而不是 <code>==</code>；</p>
</li>
<li><p><code>vec.dedup_by_key(key)</code>：类似于 <code>vec.dedup()</code>，判断两个元素的想等是通过 <code>key(&amp;mut elem1) == key(&amp;mut elem2)</code>，例如，如果 <code>errors</code> 是 <code>Vec&lt;Box&lt;dyn Error&gt;&gt;</code>，你可以这样写：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除具有重复 Messge 的 err</span></span><br><span class="line">errors.<span class="title function_ invoke__">dedup_by_key</span>(|err| err.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Joining"><a href="#Joining" class="headerlink" title="Joining"></a><code>Joining</code></h4><p>下面的量方法用于元素本身是数组、<code>slice</code>或<code>vector</code>的数组、<code>slice</code>或<code>vector</code>：</p>
<ul>
<li><p><code>slices.concat()</code>：连接所有的<code>item</code>并且返回新的 <code>vector</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]].<span class="title function_ invoke__">concat</span>(), <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slices.join(&amp;separator)</code>：类似于前者，但是在连接的过程中可以插入一个分割 <code>item</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]].<span class="title function_ invoke__">join</span>(&amp;<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Splitting"><a href="#Splitting" class="headerlink" title="Splitting"></a><code>Splitting</code></h4><p>由于 <code>Rust</code> 安全规则的限制，我们没法得到 <code>vector</code> 的多个可变引用，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;<span class="keyword">mut</span> v[i];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> v[j]; <span class="comment">// error: cannot borrow `v` as mutable</span></span><br><span class="line">                   <span class="comment">// more than once at a time</span></span><br><span class="line">*a = <span class="number">6</span>; <span class="comment">// references `a` and `b` get used here,</span></span><br><span class="line">*b = <span class="number">7</span>; <span class="comment">// so their lifetimes must overlap</span></span><br></pre></td></tr></table></figure></div>

<p>如果 <code>i == j</code>，就会出先可变借用了同一个 <code>item</code>。<code>Rust</code> 有几种方法可以同时借用对数组、<code>slice</code>或向量的两个或多个部分的 <code>mut</code> 引用。 与前面的代码不同，这些方法是安全的，因为根据设计，它们总是将数据拆分为不重叠的区域。 其中许多方法对于使用非 <code>mut</code> <code>slice</code>也很方便，因此每种方法都有 <code>mut</code> 和 <code>non-mut</code> 版本。</p>
<img data-src="/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/vec-multiple-mut-ref.png" class="">

<p>这些方法都没有直接修改数组、<code>slice</code>或向量。 它们只是返回对内部部分数据的新引用：</p>
<h5 id="slice-iter-、slice-iter-mut"><a href="#slice-iter-、slice-iter-mut" class="headerlink" title="slice.iter()、slice.iter_mut()"></a><code>slice.iter()</code>、<code>slice.iter_mut()</code></h5><p>生成对每个 <code>slice</code> 中 <code>item</code> 的引用，<a href="/2022/04/30/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/#iter-%E5%92%8C-iter_mut">详见</a>。</p>
<h5 id="slice-split-at-index-、slice-split-at-mut-index"><a href="#slice-split-at-index-、slice-split-at-mut-index" class="headerlink" title="slice.split_at(index)、slice.split_at_mut(index)"></a><code>slice.split_at(index)</code>、<code>slice.split_at_mut(index)</code></h5><p>将 <code>slice</code> 分成一对返回，<code>slice.split_at(index)</code> 等价于 <code>(&amp;slice[..index], &amp;slice[index..])</code>，如果长度超出越界，就会 <code>panic</code>。</p>
<h5 id="slice-split-first-、slice-split-first-mut"><a href="#slice-split-first-、slice-split-first-mut" class="headerlink" title="slice.split_first()、slice.split_first_mut()"></a><code>slice.split_first()</code>、<code>slice.split_first_mut()</code></h5><p>返回 <code>(&amp;slice[0], &amp;slice[1..])</code>，<code>slice.split_first()</code> 返回 <code>Option&lt;(&amp;T, &amp;[T])&gt;</code>，如果 <code>slice</code> 为空返回 <code>None</code>。</p>
<h5 id="slice-split-last-、slice-split-last-mut"><a href="#slice-split-last-、slice-split-last-mut" class="headerlink" title="slice.split_last()、slice.split_last_mut()"></a><code>slice.split_last()</code>、<code>slice.split_last_mut()</code></h5><p><code>slice.split_last()</code> 的返回类型是 <code>Option&lt;(&amp;T, &amp;[T])&gt;</code>。</p>
<h5 id="slice-split-is-sep-、-slice-split-mut-is-sep"><a href="#slice-split-is-sep-、-slice-split-mut-is-sep" class="headerlink" title="slice.split(is_sep)、 slice.split_mut(is_sep)"></a><code>slice.split(is_sep)</code>、<code> slice.split_mut(is_sep)</code></h5><p>将 <code>slice</code> 分割成一个或者多个子 <code>slice</code>，根据传入的 <code>is_sep</code> 函数后者闭包，输出至少包含一个子 <code>slice</code>。</p>
<h5 id="slice-rsplit-is-sep-、slice-rsplit-mut-is-sep"><a href="#slice-rsplit-is-sep-、slice-rsplit-mut-is-sep" class="headerlink" title="slice.rsplit(is_sep)、slice.rsplit_mut(is_sep)"></a><code>slice.rsplit(is_sep)</code>、<code>slice.rsplit_mut(is_sep)</code></h5><p>从右往左找 <code>split</code>。</p>
<h5 id="slice-splitn-n-is-sep-、slice-splitn-mut-n-is-sep"><a href="#slice-splitn-n-is-sep-、slice-splitn-mut-n-is-sep" class="headerlink" title="slice.splitn(n, is_sep)、slice.splitn_mut(n, is_sep)"></a><code>slice.splitn(n, is_sep)</code>、<code>slice.splitn_mut(n, is_sep)</code></h5><p>和 <code>slice.split(is_sep)</code> 相同，但是之多 <code>n</code> 个子<code>slcie</code>，多出来的放在最后的子 <code>slice</code> 中；</p>
<h5 id="slice-rsplitn-n-is-sep-、slice-rsplitn-mut-n-is-sep"><a href="#slice-rsplitn-n-is-sep-、slice-rsplitn-mut-n-is-sep" class="headerlink" title="slice.rsplitn(n, is_sep)、slice.rsplitn_mut(n, is_sep)"></a><code>slice.rsplitn(n, is_sep)</code>、<code>slice.rsplitn_mut(n, is_sep)</code></h5><p>和前面的类似，只是从右往左。</p>
<h5 id="slice-chunks-n-、slice-chunks-mut-n"><a href="#slice-chunks-n-、slice-chunks-mut-n" class="headerlink" title="slice.chunks(n)、slice.chunks_mut(n)"></a><code>slice.chunks(n)</code>、<code>slice.chunks_mut(n)</code></h5><p>返回长度为 <code>n</code> 的子 <code>slcie</code>，最后一个可以包含少于 <code>n</code> 个 <code>item</code>。</p>
<h5 id="slice-rchunks-n-、-slice-rchunks-mut-n"><a href="#slice-rchunks-n-、-slice-rchunks-mut-n" class="headerlink" title="slice.rchunks(n)、 slice.rchunks_mut(n)"></a><code>slice.rchunks(n)</code>、<code> slice.rchunks_mut(n)</code></h5><p>和前面的相同，只是从右往左。</p>
<h5 id="slice-chunks-exact-n-、slice-chunks-exact-mut-n"><a href="#slice-chunks-exact-n-、slice-chunks-exact-mut-n" class="headerlink" title="slice.chunks_exact(n)、slice.chunks_exact_mut(n)"></a><code>slice.chunks_exact(n)</code>、<code>slice.chunks_exact_mut(n)</code></h5><p>精确按照 <code>n</code> 进行分片，如果最后一个不足 <code>n</code> 个，可以通过 <code>remainder()</code> 访问。</p>
<h5 id="slice-rchunks-exact-n-、slice-rchunks-exact-mut-n"><a href="#slice-rchunks-exact-n-、slice-rchunks-exact-mut-n" class="headerlink" title="slice.rchunks_exact(n)、slice.rchunks_exact_mut(n)"></a><code>slice.rchunks_exact(n)</code>、<code>slice.rchunks_exact_mut(n)</code></h5><p>同上，只是从右往左。</p>
<h5 id="slice-windows-n"><a href="#slice-windows-n" class="headerlink" title="slice.windows(n)"></a><code>slice.windows(n)</code></h5><p>采用滑动窗口的方式返回子<code>slice</code>，例如第一个是 <code>slice[0..n]</code>，第二个就是 <code>slice[1..n+1]</code>。如果 <code>n</code> 大于 <code>slice.len()</code> 什么也不会返回，如果 <code>n == 0</code>，<code>panic</code>。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_ invoke__">windows</span>(<span class="number">2</span>).<span class="title function_ invoke__">for_each</span>(|items| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> items &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码输出：</p>
<pre><code>    1 2 2 3 3 4 4 5 
</code></pre>
<h4 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a><code>Swapping</code></h4><ul>
<li><p><code>slice.swap(i, j)</code>：交换 <code>slice[i]</code> 和 <code>slice[j]</code>；</p>
</li>
<li><p><code>slice_a.swap(&amp;mut slice_b)</code>：将两个 <code>slice</code> 完整交换，它们必须要有相同的长度；</p>
</li>
<li><p><code>vec.swap_remove(i)</code>：删除并返回 <code>vec[i]</code>，并且将最后一个元素填充到 <code>vec[i]</code>；</p>
</li>
</ul>
<h4 id="搜索和排序"><a href="#搜索和排序" class="headerlink" title="搜索和排序"></a>搜索和排序</h4><ul>
<li><p><code>slice.sort()</code>：升序排序；</p>
</li>
<li><p><code>slice.sort_by(cmp)</code>：自定义排序函数或闭包，<code>cmp</code> 必须实现 <code> Fn(&amp;T, &amp;T) -&gt; std::cmp::Ordering</code>；</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">students.<span class="title function_ invoke__">sort_by</span>(|a, b| a.last_name.<span class="title function_ invoke__">cmp</span>(&amp;b.last_name));</span><br><span class="line"></span><br><span class="line">students.<span class="title function_ invoke__">sort_by</span>(|a, b| &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a_key</span> = (&amp;a.last_name, &amp;a.first_name);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_key</span> = (&amp;b.last_name, &amp;b.first_name);</span><br><span class="line">    a_key.<span class="title function_ invoke__">cmp</span>(&amp;b_key)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.sort_by_key(key)</code>：通过自定义的闭包或者函数 <code>key</code> 升序排列，<code>key</code> 的类型是 <code> Fn(&amp;T) -&gt; K where K: Ord</code>。这个很有用当 <code>T</code> 包含一个或者多个可排序字段时：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort by grade point average, lowest first.</span></span><br><span class="line">students.<span class="title function_ invoke__">sort_by_key</span>(|s| s.<span class="title function_ invoke__">grade_point_average</span>());</span><br></pre></td></tr></table></figure>

<p>  <code>key</code> 不能返回任何元素的引用：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">students.<span class="title function_ invoke__">sort_by_key</span>(|s| &amp;s.last_name); <span class="comment">// error: can&#x27;t infer lifetime</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.reverse()</code>：就地反转 <code>slice</code>；</p>
</li>
<li><p><code>slice.binary_search(&amp;value)</code>：</p>
</li>
<li><p><code>slice.binary_search_by(&amp;value, cmp)</code>：</p>
</li>
<li><p><code>slice.binary_search_by_key(&amp;value, key)</code>：在已排序的<code>slice</code>上二分查找给定值，这些方法的返回类型是 <code>Result&lt;usize, usize&gt;</code>。 如果 <code>slice[index]</code> 在指定的排序顺序下等于 <code>value</code>，则返回 <code>Ok(index)</code>。 如果没有这样的索引，则它们返回 <code>Err(insertion_point)</code> 以便在 <code>insert_point</code> 插入值将保留顺序。</p>
</li>
<li><p><code>slice.contains(&amp;value)</code>：返回 <code>true</code> 如果 <code>slice</code> 有 <code>item</code> 等于 <code>value</code>。</p>
</li>
</ul>
<h4 id="Slice-比较"><a href="#Slice-比较" class="headerlink" title="Slice 比较"></a><code>Slice</code> 比较</h4><p>如果类型 <code>T</code> 支持 <code>==</code> 和 <code>!=</code> 运算符，那么 <code>[T; N]</code>，<code>[T]</code> 以及 <code>Vec&lt;T&gt;</code> 也支持，两个 <code>slice</code> 是相等的，如果他们的值和长度都相等；</p>
<p>如果类型 <code>T</code> 支持 <code>&lt; &lt;= &gt; &gt;=</code> 和 <code>!=</code> 运算符，那么 <code>[T; N]</code>，<code>[T]</code> 以及 <code>Vec&lt;T&gt;</code> 也支持。</p>
<p>还有两个比较方法：</p>
<ul>
<li><p><code>slice.starts_with(other)</code>：如果 <code>slice</code> 以 <code>other</code> 为前缀，返回 <code>true</code>。</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_ invoke__">starts_with</span>(&amp;[<span class="number">1</span>, <span class="number">2</span>]), <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_ invoke__">starts_with</span>(&amp;[<span class="number">2</span>, <span class="number">3</span>]), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slice.starts_with(other)</code>：如果 <code>slice</code> 以 <code>other</code> 为后缀，返回 <code>true</code>。</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_ invoke__">ends_with</span>(&amp;[<span class="number">3</span>, <span class="number">4</span>]), <span class="literal">true</span>);</span><br><span class="line">    ``</span><br><span class="line"></span><br><span class="line">#### 随机元素</span><br><span class="line"></span><br><span class="line">- `slice.<span class="title function_ invoke__">choose</span>(&amp;<span class="keyword">mut</span> rng)`：随即返回 `slice` 一个元素的引用，他返回 `<span class="type">Option</span>&lt;&amp;T&gt;`，`slice` 为空时返回 `<span class="literal">None</span>`；</span><br><span class="line"></span><br><span class="line">- `slice.<span class="title function_ invoke__">shuffle</span>(&amp;<span class="keyword">mut</span> rng)`：随机就地打乱 `slice`；</span><br><span class="line"></span><br><span class="line">    ```rust</span><br><span class="line">    <span class="keyword">use</span> rand::seq::SliceRandom;</span><br><span class="line">    <span class="keyword">use</span> rand::thread_rng;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        my_vec.<span class="title function_ invoke__">shuffle</span>(&amp;<span class="keyword">mut</span> <span class="title function_ invoke__">thread_rng</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="VecDeque"><a href="#VecDeque" class="headerlink" title="VecDeque&lt;T&gt;"></a><code>VecDeque&lt;T&gt;</code></h3><p><code>Vec</code> 仅支持在结尾高效增删元素，而 <a href="https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html"><code>std::collections::VecDeque&lt;T&gt;</code></a> 是一个双端队列，支持在两端增删元素：</p>
<ul>
<li><p><code>deque.push_front(value)</code>：用于在队列前面插入值；</p>
</li>
<li><p><code>deque.push_front(value)</code>：用于在队尾插入值；</p>
</li>
<li><p><code>deque.pop_front()</code>：删除队首元素；</p>
</li>
<li><p><code>deque.pop_back()</code>：删除队尾元素；</p>
</li>
<li><p><code>deque.front(), deque.back()</code>：获取队首或者队尾元素的引用，返回值是 <code>Option&lt;&amp;T&gt;</code>；</p>
</li>
<li><p><code>deque.front_mut(), deque.back_mut()</code> 类似于前者，只是返回值的可变借用 <code>Option&lt;&amp;mut T&gt;</code>；</p>
</li>
</ul>
<p><code>std::collections::VecDeque&lt;T&gt;</code> 的实现是一个环形 <code>buffer</code>，如下图所示：</p>
<img data-src="/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/vec-dequeue.png" class="">

<p>与<code>vector</code>一样，双端队列可以按值、共享引用或 <code>mut</code> 引用进行迭代。 它们具有三个迭代器方法 <code>.into_iter(</code>)、<code>.iter()</code> 和 <code>.iter_mut()</code>，它们可以以通常的方式被索引：<code>deque[index]</code>。</p>
<p>因为双端队列不会将它们的元素连续存储在内存中，所以它们不能继承<code>slice</code>的所有方法。 但是，如果您愿意支付转移内容的成本，<code>VecDeque</code> 提供了一种可以解决此问题的方法：</p>
<ul>
<li><p><code>deque.make_contiguous()</code>：将队列整理成连续内存的形式，返回 <code> &amp;mut [T]</code>；</p>
</li>
<li><p><code>Vec::from(deque)</code>：<code>Vec</code> 实现了 <code>From&lt;VecDeque&lt;T&gt;&gt;</code>，这将队列转换成 <code>Vec</code>；</p>
</li>
<li><p><code>VecDeque::from(vec)</code>：<code>VecDeque</code> 实现了 <code>From&lt;Vec&lt;T&gt;&gt;</code>，将 <code>vector</code> 转换成队列，这也是 <code>O(n)</code>，但它通常很快，即使向量很大，因为向量的堆内存可以简单地移动到新的双端队列；这使得从已有 <code>vector</code> 创建队列很方便：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = VecDeque::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="BinaryHeap"><a href="#BinaryHeap" class="headerlink" title="BinaryHeap&lt;T&gt;"></a><code>BinaryHeap&lt;T&gt;</code></h3><p><a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#"><code>std::collections::BinaryHeap</code></a> 是一个二叉堆实现的大顶堆，它只实现了 <code>Vec</code> 的某些方法，例如：<code>BinaryHeap::new()</code>，<code>.len()</code>，<code>.is_empty()</code>，<code>.capacity()</code>，<code>.clear()</code>和<br><code>.append(&amp;mut heap2)</code>，下面是它独有的一些方法。</p>
<ul>
<li><p><code>heap.push(value)</code>：增加元素到堆；</p>
</li>
<li><p><code>heap.pop()</code>：删除并且返回堆中的最大值，返回值是 <code>Option&lt;T&gt;</code>，如果堆是空的；</p>
</li>
<li><p><code>heap.peek()</code>：返回最大值的引用，返回类型是 <code>Option&lt;&amp;T&gt;</code>；</p>
</li>
<li><p><code>heap.peek_mut()</code>：返回类型是 <a href="https://doc.rust-lang.org/stable/std/collections/binary_heap/struct.PeekMut.html"><code>PeekMut&lt;T&gt;</code></a>，它代表了堆中最大值的可变引用，并且提供了一个类型关联方法 <code>pop()</code> 以从堆中弹出数据。用这个方法，我们可以基于最大值判断是否要从堆中弹出数据：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::binary_heap::PeekMut;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = heap.<span class="title function_ invoke__">peek_mut</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> *top &gt; <span class="number">10</span> &#123;</span><br><span class="line">        PeekMut::<span class="title function_ invoke__">pop</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>BinaryHeap</code> 是可迭代的，它有一个 <code>.iter()</code> 方法，但迭代器以任意顺序产生堆的元素，而不是从大到小。要按优先级顺序使用 <code>BinaryHeap</code> 中的值，请使用 <code>while</code> 循环：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = heap.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">handle</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap、BTreeMap"><a href="#HashMap、BTreeMap" class="headerlink" title="HashMap&lt;K, V&gt;、BTreeMap&lt;K, V&gt;"></a><code>HashMap&lt;K, V&gt;</code>、<code>BTreeMap&lt;K, V&gt;</code></h3><p><code>map</code> 是键值对的集合，叫做 <code>entries</code>，<code>map</code> 中可以高效地通过 <code>key</code> 查找，不存在两个不同的 <code>entries</code> 有相同的 <code>key</code>。<code>Rust</code> 有两种 <code>map</code> 的实现，<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>HashMap&lt;K, V&gt;</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;K, V&gt;</code></a>，它们两个有相同的方法，不同的地方在于两者如何保持<code>entries</code>排列以进行快速查找。</p>
<p><code>HashMap</code> 存储键值在<code>hash</code>表中，所以要求键的类型必须实现 <code>Hash</code> 和 <code>Eq</code>，下图展示了它在内存中的表示，深色区域是未使用的。所有键、值和缓存的哈希码都存储在单个堆分配表中。 添加<code>entries</code>最终会迫使 <code>HashMap</code> 分配一个更大的表并将所有数据移入其中。</p>
<img data-src="/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/hashmap-inmem.png" class="">

<p><code>BTreeMap</code> 将<code>entries</code>按键顺序存储在树结构中，因此它需要一个实现 <code>Ord</code> 的键类型 <code>K</code>。 下图显示了一个 <code>BTreeMap</code>。 同样，较暗的区域是未使用的备用容量。</p>
<img data-src="/2022/04/23/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/btreemap-inmem.png" class="">

<p><code>BTreeMap</code> 将其<code>entries</code>存储在节点中。<code>BTreeMap</code> 中的大多数节点只包含键值对。非叶节点，如该图所示的根节点，也为指向子节点的指针留有空间。 <code>(20, &#39;q&#39;)</code> 和 <code>(30, &#39;r&#39;)</code> 之间的指针指向包含 <code>20</code> 到 <code>30</code> 之间的键的子节点。添加<code>entries</code>通常需要将节点的一些现有<code>entries</code>向右滑动，以保持它们的排序，有时还涉及分配新节点。</p>
<p><code>Rust</code> 标准库使用 <code>BTree</code> 而不是平衡二叉树，因为 <code>BTree</code> 在现代硬件上更快。 与 <code>BTree</code> 相比，二叉树每次搜索使用的比较次数可能更少，但搜索 <code>BTree</code> 具有更好的局部性——也就是说，内存访问被分组在一起，而不是分散在整个堆中，这会提高内存缓存的命中率，这是一个显着的速度提升。</p>
<h4 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 <code>map</code></h4><ul>
<li><p><code>HashMap::new()</code>、<code>BTreeMap::new()</code>：创建空的 <code>map</code>；</p>
</li>
<li><p><code>iter.collect()</code>：可以从一个 <code>Iterator&lt;Item=(K, V)&gt;</code> 创建新的 <code>HashMap</code> 或者 <code>BTreeMap</code>；</p>
</li>
<li><p><code>HashMap::with_capacity(n)</code>：创建空的 <code>map</code> 至少能存储 <code>n</code> 个 <code>entries</code>，由于它们存储 <code>entries</code> 在一个整个的堆内存中，所以他们有容量及相关的方法 <code>hash_map.capacity()</code>，<code>hash_map.reserve(additional)</code> 和 <code>hash_map.shrink_to_fit()</code>，<code>BTreeMaps</code> 没有这些。</p>
</li>
</ul>
<h4 id="键值处理"><a href="#键值处理" class="headerlink" title="键值处理"></a>键值处理</h4><ul>
<li><p><code>map.len()</code>：返回 <code>entries</code> 的数量；</p>
</li>
<li><p><code>map.is_empty()</code>：如果 <code>map</code> 没有 <code>entries</code> 返回 <code>true</code>；</p>
</li>
<li><p><code>map.contains_key(&amp;key)</code>：返回 <code>true</code> 如果 <code>map</code> 包含指定 <code>key</code>；</p>
</li>
<li><p><code>map.get(&amp;key)</code>：在 <code>map</code> 中搜索指定 <code>key</code>。如果找到，返回 <code>Some(r)</code>，<code>r</code> 是一个指向对应值的引用。否则，返回 <code>None</code>；</p>
</li>
<li><p><code>map.get_mut(&amp;key)</code>：类似于 <code>map.get(&amp;key)</code>，但是返回指定值的可变引用。一般来说，<code>map</code>允许对存储在其中的值进行 <code>mut</code> 访问，但不能访问键。 这些值是可以随意修改的。键属于<code>map</code>本身；它需要确保它们不会改变，因为<code>entries</code>是按它们的键组织的。就地修改<code>key</code>将是一个错误；</p>
</li>
<li><p><code>map.insert(key, value)</code>：插入或者更新一个 <code>(key, entry)</code> 到 <code>map</code> 中，如果存在旧值返回；</p>
</li>
<li><p><code>map.extend(iterable)</code>：迭代 <code>iterable</code> 将得到 <code>(K, V)</code> 插入到 <code>map</code> 中；</p>
</li>
<li><p><code>map.append(&amp;mut map2)</code>：将 <code>map2</code> 的所有 <code>entries</code> 移动到 <code>map</code> 中；</p>
</li>
<li><p><code>map.remove(&amp;key)</code>：找到并且删除指定 <code>key</code>，如果存在返回删除对应 <code>key</code> 的值，返回类型是 <code>Option&lt;V&gt;</code>；</p>
</li>
<li><p><code>map.remove_entry(&amp;key)</code>：找到并且删除指定 <code>key</code>，如果存在返回删除对应键值对，返回类型是 <code>Option&lt;K, V&gt;</code>；</p>
</li>
<li><p><code>map.retain(test)</code>：删除所有未通过 <code>test</code> 函数的键值对，<code>test</code> 的类型是 <code>FnMut(&amp;K, &amp;mut V) -&gt; bool</code>。对于 <code>map</code> 的每个元素都会调用 <code>test(&amp;key, &amp;mut value)</code>，如果返回 <code>false</code>，这个 <code>key</code> 就会从 <code>map</code> 中删除；不考虑性能，就像这样写：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">map = map.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(test).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure></li>
<li><p><code>map.clear()</code>：删除所有键值对；</p>
</li>
</ul>
<p>一个 <code>map</code> 也可以通过 <code>map[&amp;key]</code> 这种形式查询，<code>map</code> 实现了内建的 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code>std::ops::Index</code></a>。但是如果给定的 <code>key</code> 不存在，就会 <code>panic</code>，这就像数组越界访问。</p>
<p>对于 <code>.contains_key()</code>，<code>.get()</code>，<code>.get_mut()</code>，<code>.remove()</code> 中的 <code>key</code>，没必要是精确的 <code>&amp;T</code> 类型，这些方法是泛型，它们可以从 <code>K</code> 借用。所以，在 <code>HashMap&lt;String, Fish&gt;</code> 中这样调用 <code>fish_map.contains_key(&quot;conger&quot;)</code> 是没有问题的，即使 <code>&quot;conger&quot;</code> 不是 <code>String</code> 类型，但是它实现了 <code>Borrow&lt;&amp;str&gt;</code>。</p>
<p>由于 <code>BTreeMap&lt;K, V&gt;</code> 按 <code>key</code>顺序存储，所以支持额外的操作：</p>
<ul>
<li><code>btree_map.split_off(&amp;key)</code>：将 <code>btree_map</code> 一分为二，键小于<code>key</code>的<code>entries</code>留在 <code>btree_map</code> 中，返回包含其他<code>entries</code>的新 <code>BTreeMap&lt;K, V&gt;</code>；</li>
</ul>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a><code>Entry</code></h4><p><code>HashMap</code> 和 <code>BTreeMap</code> 都有对应的 <a href="https://doc.rust-lang.org/stable/std/collections/hash_map/enum.Entry.html"><code>std::collections::hash_map::Entry</code></a> 或者 <a href="https://doc.rust-lang.org/stable/std/collections/btree_map/enum.Entry.html"><code>std::collections::btree_map::Entry</code></a> 类型，<code>Entry</code> 的重点是消除冗余的映射查找，例如，这里有一些获取或创建学生记录的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Do we already have a record for this student?</span></span><br><span class="line"><span class="keyword">if</span> !student_map.<span class="title function_ invoke__">contains_key</span>(name) &#123;</span><br><span class="line">    <span class="comment">// No: create one.</span></span><br><span class="line">    student_map.<span class="title function_ invoke__">insert</span>(name.<span class="title function_ invoke__">to_string</span>(), Student::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now a record definitely exists.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">record</span> = student_map.<span class="title function_ invoke__">get_mut</span>(name).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>这可以完成工作，但是访问了 <code>student_map</code> 两三次，每次都要查找，其实我们要的只是有这个 <code>key</code> 更新没有的话插入。<code>entries</code>的想法是我们只进行一次查找，生成一个<code>entries</code>值，然后用于所有后续操作。这个单行代码等效于前面的所有代码，只是它只进行一次查找：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">record</span> = student_map.<span class="title function_ invoke__">entry</span>(name.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">or_insert_with</span>(Student::new);</span><br></pre></td></tr></table></figure>

<p><code>student_map.entry(name.to_string())</code> 返回的 <code>Entry</code> 就像对 <code>map</code> 中某个位置的可变引用，该位置要么被键值对占用，要么空置，这意味着那里还没有<code>Entry</code>。如果为空，则 <code>Entry</code>的 <code>.or_insert_with()</code> 方法会插入一个新记录。</p>
<p>所有的 <code>Entry</code> 都是使用相同的方法创建的：</p>
<ul>
<li><p><code>map.entry(key)</code>：返回给定键的 <code>Entry</code>，如果<code>map</code>中没有这样的键，则返回一个空 <code>Entry</code>。此方法通过 <code>mut</code> 引用获取其 <code>self</code> 参数并返回具有匹配生命周期的 <code>Entry</code>：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">entry</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>, key: K) <span class="punctuation">-&gt;</span> Entry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;</span><br></pre></td></tr></table></figure>

<p>  <code>Entry</code> 类型有一个生命周期参数 <code>&#39;a</code>，因为它实际上是一种对<code>map</code>的 <code>mut</code> 引用，只要<code>Entry</code> 存在，它就拥有对<code>map</code>的独占访问权。</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Entry</span>&lt;<span class="symbol">&#x27;a</span>, K: <span class="symbol">&#x27;a</span>, V: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Occupied</span>(OccupiedEntry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;),</span><br><span class="line">    <span class="title function_ invoke__">Vacant</span>(VacantEntry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  不幸的是，如果<code>map</code>具有 <code>String</code> 键，则无法将 <code>&amp;str</code> 类型的引用传递给此方法。在这种情况下，<code>.entry()</code> 方法需要一个真正的字符串。</p>
</li>
</ul>
<p><code>Entry</code> 提供了三种处理空条目的方法：</p>
<ul>
<li><p><code>map.entry(key).or_insert(value)</code>：确保<code>map</code>包含具有给定键的条目，如果需要，插入具有给定值的新条目。它返回对新值或现有值的 <code>mut</code> 引用。假设我们需要统计投票，可以这样写：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ballots</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vote_counts</span>: HashMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">name</span> <span class="keyword">in</span> ballots &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = vote_counts.<span class="title function_ invoke__">entry</span>(name).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map.entry(key).or_default()</code>：确保 <code>map</code> 包含具有给定键的条目，如果需要，插入具有 <code>Default::default()</code> 返回的值的新条目。这仅适用于实现 <code>Default</code> 的类型。与 <code>or_insert</code> 一样，此方法返回对新值或现有值的<code> mut</code> 引用；</p>
</li>
<li><p><code>map.entry(key).or_insert_with(default_fn)</code>：和前两个方法相同，只是它调用 <code>default_fn()</code> 生成默认值。如果已经存在，<code>default_fn</code> 是不会调用的；假设我们想知道哪些单词出现在哪些文件中。 我们可以写：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">word_occurrence</span>: HashMap&lt;<span class="type">String</span>, HashSet&lt;<span class="type">String</span>&gt;&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">file</span> <span class="keyword">in</span> files &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> <span class="title function_ invoke__">read_words</span>(file)? &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">set</span> = word_occurrence.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert_with</span>(HashSet::new);</span><br><span class="line">        set.<span class="title function_ invoke__">insert</span>(file.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map.entry(key).and_modify(closure)</code>：如果指定 <code>key</code> 的 <code>Entry</code> 已经存在，将调用闭包并且传入 <code>Entry</code> 的可变借用，然后将 <code>Entry</code> 返回，所以它可以和其他方法串联起来使用；</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This map contains all the words in a given string,</span></span><br><span class="line"><span class="comment">// along with the number of times they occur.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">word_frequency</span>: HashMap&lt;&amp;<span class="type">str</span>, <span class="type">u32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    word_frequency</span><br><span class="line">        .<span class="title function_ invoke__">entry</span>(c)</span><br><span class="line">        .<span class="title function_ invoke__">and_modify</span>(|count| *count += <span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">or_insert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>Entry</code> 是枚举类型，例如，<code>HashMap</code> 中的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (in std::collections::hash_map)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Entry</span>&lt;<span class="symbol">&#x27;a</span>, K, V&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Occupied</span>(OccupiedEntry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;),</span><br><span class="line">    <span class="title function_ invoke__">Vacant</span>(VacantEntry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代-Map"><a href="#迭代-Map" class="headerlink" title="迭代 Map"></a>迭代 <code>Map</code></h4><p>这里还有几个迭代 <code>map</code> 的方法：</p>
<ul>
<li><p>通过值迭代， <code>for (k, v) in map</code> 产生 <code>(K，V)</code> 对，这将消费 <code>map</code>；</p>
</li>
<li><p>通过引用迭代，<code>for (k, v) in &amp;map</code> 产生 <code>(&amp;K, &amp;V)</code> 对；</p>
</li>
<li><p>通过可变引用迭代，<code>for (k, v) in &amp;mut map</code> 产生 <code>(&amp;K, &amp;mutV)</code> 对；</p>
</li>
</ul>
<p>而 <code>.iter()</code> 和 <code>.iter_mut()</code> 就像按 <code>&amp;map</code> 和 <code>&amp;mut map</code> 迭代。除此之外，还有：</p>
<ul>
<li><p><code>map.keys()</code>：返回一个所有 <code>key</code> 引用的迭代器；</p>
</li>
<li><p><code>map.values()</code>：返回一个所有 <code>value</code> 引用的迭代器；</p>
</li>
<li><p><code>map.values_mut()</code>：返回一个所有 <code>value</code> 可变引用的迭代器；</p>
</li>
</ul>
<h3 id="HashSet、BTreeSet"><a href="#HashSet、BTreeSet" class="headerlink" title="HashSet&lt;T&gt;、BTreeSet&lt;T&gt;"></a><code>HashSet&lt;T&gt;</code>、<code>BTreeSet&lt;T&gt;</code></h3><p>集合中的值都是唯一的，<code>Map</code> 和 <code>Set</code> 有不同的方法，但在实现上，<code>Set</code> 就像只有键的映射，而不是键值对。 事实上，<code>Rust</code> 的两种集合类型 <code>HashSet&lt;T&gt;</code> 和 <code>BTreeSet&lt;T&gt;</code> 被实现为 <code>HashMap&lt;T, ()&gt;</code> 和 <code>BTreeMap&lt;T, ()&gt;</code>。</p>
<p>这里有一些集合常用的方法：</p>
<ul>
<li><p><code>HashSet::new()</code>、<code>BTreeSet::new()</code>：创建新的集合；</p>
</li>
<li><p><code>iter.collect()</code>：可以用于从迭代器创建一个集合，如果迭代器产生重复值，将会被自动丢弃；</p>
</li>
<li><p><code>HashSet::with_capacity(n)</code>：创建至少能容纳 <code>n</code> 个值的集合；</p>
</li>
<li><p><code>set.len()</code>：返回集合中值的数量；</p>
</li>
<li><p><code>set.is_empty()</code>：返回 <code>true</code> 当集合为空时；</p>
</li>
<li><p><code>set.contains(&amp;value)</code>：当集合包含 <code>value</code> 是返回 <code>true</code>；</p>
</li>
<li><p><code>set.insert(value)</code>：插入集合新的值，返回 <code>true</code> 如果值被添加，如果已经存在返回 <code>false</code>；</p>
</li>
<li><p><code>set.remove(&amp;value)</code>：从集合中删除值，删除成功则返回 <code>true</code>，如果之前不存在则返回 <code>false</code>；</p>
</li>
<li><p><code>set.retain(test)</code>：删除所有没通过测试的值，<code>test</code> 的类型是 <code>FnMut(&amp;T) -&gt; bool</code>，对于集合的每个元素，将调用 <code>test(&amp;value)</code>，如果返回 <code>false</code>，这个值就会被移除；</p>
</li>
</ul>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>有两种迭代集合的方式：</p>
<ol>
<li><p>按值迭代，<code>for v in set</code> 返回集合的成员；</p>
</li>
<li><p>按共享引用迭代，<code>for v in &amp;set</code> 返回集合值的引用；</p>
</li>
</ol>
<p>通过可变引用迭代集合是不支持的，这里没有方法获取集合中值的可变引用，而 <code>set.iter()</code> 返回一个迭代器包含集合中值的引用。</p>
<p><code>HashSet</code> 迭代器，就像 <code>HashMap</code> 迭代器，以任意顺序获取它们的值，而 <code>BTreeSet</code> 迭代器产生的值是有序的。</p>
<h4 id="某些方法"><a href="#某些方法" class="headerlink" title="某些方法"></a>某些方法</h4><ul>
<li><p><code>set.get(&amp;value)</code>：返回 <code> Option&lt;&amp;T&gt;</code>，等于 <code>value</code> 的集合中成员的引用；</p>
</li>
<li><p><code>set.take(&amp;value)</code>：像 <code>set.remove(&amp;value)</code>，但是他返回移除的值；</p>
</li>
<li><p><code>set.replace(value)</code>：就像 <code>set.insert(value)</code>，但是如果集合已经包含这个值，这个会返回并替换旧的值，返回类型是 <code>Option&lt;T&gt;</code>；</p>
</li>
</ul>
<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><ul>
<li><p><code>set1.intersection(&amp;set2)</code>：返回两个集合之间的交集；</p>
</li>
<li><p><code>set1.union(&amp;set2)</code>：求集合之间的并集；</p>
</li>
<li><p><code>set1.difference(&amp;set2)</code>：求集合之间的差集；</p>
</li>
<li><p><code>set1.symmetric_difference(&amp;set2)</code>：返回只存在其中一个集合中的值的新集合；</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = HashSet::<span class="title function_ invoke__">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = HashSet::<span class="title function_ invoke__">from</span>([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print 1, 4 in arbitrary order.</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">symmetric_difference</span>(&amp;b) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">diff1</span>: HashSet&lt;_&gt; = a.<span class="title function_ invoke__">symmetric_difference</span>(&amp;b).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">diff2</span>: HashSet&lt;_&gt; = b.<span class="title function_ invoke__">symmetric_difference</span>(&amp;a).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(diff1, diff2);</span><br><span class="line"><span class="built_in">assert_eq!</span>(diff1, [<span class="number">1</span>, <span class="number">4</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">collect</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>set1.is_disjoint(set2)</code>：如果 <code>self</code> 与 <code>other</code> 没有共同的元素，则返回 <code>true</code>；</p>
</li>
<li><p><code>set1.is_subset(set2)</code>：如果 <code>set1</code> 是 <code>set2</code> 的子集，将返回 <code>true</code>；</p>
</li>
<li><p><code>set1.is_superset(set2)</code>：如果 <code>set1</code> 是 <code>set2</code> 的超集，将返回 <code>true</code>；</p>
</li>
</ul>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a><code>Hashing</code></h3><p><a href="https://doc.rust-lang.org/stable/std/hash/trait.Hash.html"><code>std::hash::Hash</code></a> 是标准库中所有可 hash 类型必须实现的，<code>HashMap</code> 的键和 <code>HashSet</code> 的元素都必须实现 <code>Hash</code> 和 <code>Eq</code>。</p>
<p>大对数内部实现了 <code>Eq</code> 的类型也都实现了 <code>Hash</code>，整数，字符和 <code>String</code> 都是可 <code>hash</code> 的，以及 <code>tuple</code>，<code>array</code>，<code>slice</code> 和 <code>vector</code>，只要他们的元素时可 <code>hash</code> 的。</p>
<p>标准库的一个原则是一个值不管存在哪里或者你如何引用，它们都有相同的<code>hash</code>值。因此，一个值和它的引用有相同的hash值，<code>Box&lt;T&gt;</code> 也和它包含的值有相同的 <code>hash</code> 值，一个 <code>vector</code> 和包含相同的数据的<code>slice</code>有同样的<code>hash</code>值。一个字符串和包含相同字符的 <code>&amp;str</code> 有相同的<code>hash</code>值。</p>
<p>结构体和枚举默认没有实现 <code>Hash</code>，但是可以自动派生，只有所有元素可 <code>hash</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, PartialEq, Eq, Hash)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MuseumNumber</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你为一个类型手动实现 <code>PartialEq</code>，你也应该手动实现 <code>Hash</code>。</p>
<h3 id="自定义-Hash-算法"><a href="#自定义-Hash-算法" class="headerlink" title="自定义 Hash 算法"></a>自定义 <code>Hash</code> 算法</h3><p><code>hash</code> 方法是通用的，因此前面显示的 <code>Hash</code> 实现可以将数据提供给任何实现 <a href="https://doc.rust-lang.org/stable/std/hash/trait.Hasher.html"><code>Hasher</code></a> 的类型，这就是 <code>Rust</code> 支持可插入哈希算法的方式。</p>
<p><code>std::hash::BuildHasher</code> 是表示散列算法初始状态的类型的特征。每个 <code>Hasher</code> 都是一次性使用的，就像一个迭代器：你使用一次就扔掉它，<code>BuildHasher</code> 是可重用的。</p>
<p>每个 <code>HashMap</code> 都包含一个 <code>BuildHasher</code>，每次需要计算哈希码时都会使用它。<code>BuildHasher</code> 值包含哈希算法每次运行时所需的键、初始状态或其他参数。完整计算一个 <code>hash</code> 值如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::hash::&#123;Hash, Hasher, BuildHasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">compute_hash</span>&lt;B, T&gt;(builder: &amp;B, value: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span></span><br><span class="line">    <span class="keyword">where</span> B: BuildHasher, T: Hash</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = builder.<span class="title function_ invoke__">build_hasher</span>(); <span class="comment">// 1. start the algorithm</span></span><br><span class="line">    value.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher); <span class="comment">// 2. feed it data</span></span><br><span class="line">    hasher.<span class="title function_ invoke__">finish</span>() <span class="comment">// 3. finish, producing a u64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code> 每次在需要计算 <code>hash</code> 值的时候会调用这三个方法，所有方法都是可以内联的，所以非常快。</p>
<p><code>Rust</code> 的默认哈希算法是 <code>SipHash-1-3</code>，<code>SipHash</code> 速度很快，并且非常擅长最小化哈希冲突。事实上，它是一种密码算法：没有已知的有效方法来生成 <code>SipHash-1-3</code> 冲突。 只要为每个哈希表使用不同的、不可预测的密钥，<code>Rust</code> 就可以抵御一种称为 <code>HashDoS</code> 的拒绝服务攻击，在这种攻击中，攻击者故意使用哈希冲突来触发服务器中最坏情况的性能。</p>
<p>但也许您的应用程序不需要它，如果要存储许多小密钥，例如整数或非常短的字符串，则可以实现更快的哈希函数，但会牺牲 <code>HashDoS</code> 安全性。 <a href="https://doc.servo.org/fnv/"><code>fnv</code></a> 实现了一种这样的算法，即 <code>FNV</code> 哈希，要尝试它，请将此行添加到您的 <code>Cargo.toml</code>：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">fnv</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后导入使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> fnv::&#123;FnvHashMap, FnvHashSet&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>《Rust 程序设计》</tag>
        <tag>集合类型</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘计算是什么？</title>
    <url>/2023/08/01/Cloud-Native/edge-computing/</url>
    <content><![CDATA[<h4 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h4><p>边缘计算是一种即将到来的计算方法，指的是一系列更接近用户的计算机网络和设备。边缘计算就是通过将数据存储在更靠近用户位置的位置来处理用户生成的数据。这确保了数据处理快速进行，从而确保大数据块得到无缝处理。这进一步帮助组织更快地做出决策。边缘计算技术的一些用例包括自动驾驶汽车、自动化零售店、机器人和智能设备。</p>
<h5 id="边缘计算技术的组成部分："><a href="#边缘计算技术的组成部分：" class="headerlink" title="边缘计算技术的组成部分："></a>边缘计算技术的组成部分：</h5><ul>
<li><strong>网络边缘</strong>：从技术上讲，边缘计算不需要单独的网络，更多的是现有网络的延伸；使连接变得容易。</li>
<li><strong>边缘设备</strong>：这些是可以快速连接到网络的设备，我们今天已经看到了此类设备的使用。例如，智能手表和无线&#x2F;智能扬声器。</li>
<li><strong>本地基础设施</strong>：这些通常是服务器、路由器和其他用于连接网络的本地设备。</li>
</ul>
<p>用创造性的方式来说，边缘计算技术帮助组织让数字世界中的事物出现在物理世界中。从商业角度来说，这意味着即使是最小的企业（例如实体公司）也可以利用在线数据和算法的力量，帮助他们为客户提供更好的体验。边缘计算有助于创建智能系统，帮助员工从这些系统中学习。如果我们观察的话，边缘计算存在于所有这些场景中。边缘计算技术通过实时数据处理帮助企业精确可靠地运行应用程序。</p>
<span id="more"></span>
<h5 id="边缘计算是如何实施？"><a href="#边缘计算是如何实施？" class="headerlink" title="边缘计算是如何实施？"></a>边缘计算是如何实施？</h5><p>第一步是定义业务和技术优势策略。这不仅仅是选择供应商的问题。更多的是找出您的企业需要边缘计算的原因。这是关于了解业务的根本原因以及导致业务走向边缘计算的技术问题。其次，边缘计算策略必须符合组织目标、业务计划、当前技术格局和未来技术路线图。最后，当涉及边缘计算的实际部署时，由于项目的最终范围和实施规模以及解决基础设施相关挑战，项目可能会出现巨大变化。</p>
<p>最后，边缘计算成功实施后的维护也很重要。这可以通过以下四个要素来实现：</p>
<ul>
<li>安全性</li>
<li>管理性</li>
<li>连接性</li>
<li>物理维护</li>
</ul>
<h4 id="移动边缘计算"><a href="#移动边缘计算" class="headerlink" title="移动边缘计算"></a>移动边缘计算</h4><p>从本质上讲，边缘计算的目标是让计算功能更接近最终用户。边缘计算不是将计算资源限制在集中式数据中心，而是跨网络分配这些资源，以加速数据传输、减少网络负载并提高整体性能。移动边缘计算（MEC）采用了边缘计算的这一原理，并将其进一步推向边缘的最边缘，甚至更接近最终用户。</p>
<h5 id="移动边缘计算中的“移动”是什么？"><a href="#移动边缘计算中的“移动”是什么？" class="headerlink" title="移动边缘计算中的“移动”是什么？"></a>移动边缘计算中的“移动”是什么？</h5><p>移动边缘计算涵盖移动设备、应用程序以及移动设备产生和消耗的所有数据。MEC 的目标是扩展边缘，在该领域引入更多计算功能。这样做意味着移动设备和应用程序生成和消耗的所有数据都可以在尽可能接近数据源（以及最终用户）的情况下近乎实时地进行处理。最终，MEC 缩短了数据传输所需的距离。数据可以在尽可能靠近无线设备的移动边缘云中生成、捕获和处理，而不是发送到数据中心进行处理。</p>
<h5 id="为什么移动边缘计算很重要"><a href="#为什么移动边缘计算很重要" class="headerlink" title="为什么移动边缘计算很重要"></a>为什么移动边缘计算很重要</h5><p>当边缘网络基础设施与无线边缘交叉时，结果是更高的带宽、更低的延迟和减少的网络拥塞。反过来，这意味着更快的响应时间、更高效的决策以及用户和运营商的整体性能增强。</p>
<p>在移动设备无处不在的互联日益紧密的世界中，对低延迟和&#x2F;或高带宽的技术、服务和体验的需求不断增长。通过将计算资源物理地移至更靠近移动设备的位置，MEC 可以满足这些对低延迟和高带宽的日益增长的要求，从而使企业、政府和消费行业的新业务成为可能。</p>
<h4 id="移动边缘计算应用场景"><a href="#移动边缘计算应用场景" class="headerlink" title="移动边缘计算应用场景"></a>移动边缘计算应用场景</h4><p>增强现实和虚拟现实 (AR&#x2F;VR) 游戏的性能增强对于日常消费者来说是一大吸引力。虽然这无疑是 MEC 的强大优势，但该标准还有可能为汽车、航运和物流、制造、农业、能源等行业带来深远的好处。特别是对于灾难恢复、军事、公共安全领域的组织而言、医疗、农村连接等，移动边缘计算项目才能真正拥有救生应用。在这些高风险、关键任务场景（例如自动驾驶汽车或远程医疗手术）中，低延迟可能是生与死的区别。自动驾驶汽车，了良好运行，这些车辆需要能够快速做出机器学习 (ML) 决策。这就是 MEC 提供帮助的地方。依靠 MEC 将大大加快这些自动驾驶汽车的决策速度，而不是将数据传输到遥远的中心并返回（并阻碍沿途实现超低延迟的目标）。</p>
<p>增强现实&#x2F;虚拟现实，例如，对于建筑和工程领域的远程工作人员来说，3D 渲染以及耳机和移动设备可以显着改善他们的日常工作流程。然而，这些效果图非常复杂且数据量大；如果通过集中式数据中心访问它们，则延迟太高，无法在现实生活中发挥作用。但转向 MEC 并消除数据中心中间商可以使这些改进成为可能。最简单地说，移动边缘计算就是扩展边缘，并通过它扩展我们在各行业取得新进展并改善移动体验的能力。</p>
<p>简单来说，边缘计算是一种隔离或分布式计算框架，帮助企业将应用程序移近数据源。这些来源包括本地边缘的服务器和物联网概念上的设备。</p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>edge computing</tag>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF 介绍</title>
    <url>/2023/09/04/Cloud-Native/ebpf/</url>
    <content><![CDATA[<h5 id="什么事eBPF"><a href="#什么事eBPF" class="headerlink" title="什么事eBPF?"></a>什么事eBPF?</h5><p><code>eBPF</code> 是一项革命性技术，起源于 <code>Linux</code> 内核，可以在特权上下文（例如操作系统内核）中运行沙盒程序。它用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。从历史上看，由于内核具有监督和控制整个系统的特权能力，操作系统一直是实现可观察性、安全性和网络功能的理想场所。同时，操作系统内核由于其核心地位，对稳定性和安全性要求较高，演化难度较大。因此，与操作系统外部实现的功能相比，操作系统级别的创新率传统上较低。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc1.png" class="">
<p><code>eBPF</code> 从根本上改变了这个公式。它允许沙盒程序在操作系统内运行，这意味着应用程序开发人员可以运行 <code>eBPF</code> 程序以在运行时向操作系统添加附加功能。然后，操作系统可以保证安全性和执行效率，就像借助即时 (<code>JIT</code>) 编译器和验证引擎进行本机编译一样。这引发了一波基于 <code>eBPF</code> 的项目，涵盖广泛的用例，包括下一代网络、可观察性和安全功能。<br>如今，<code>eBPF</code> 被广泛用于驱动各种场景：在现代数据中心和云原生环境中提供高性能网络和负载平衡，以低开销提取细粒度的安全和可观察性数据，帮助应用程序开发人员跟踪应用程序，提供性能故障排查、预防应用程序和容器运行时安全实施等方面的问题。</p>
<span id="more"></span>
<h5 id="钩子概述"><a href="#钩子概述" class="headerlink" title="钩子概述"></a>钩子概述</h5><p><code>eBPF</code> 程序是事件驱动的，当内核或应用程序通过某个挂钩点时运行。预定义的挂钩包括系统调用、函数入口&#x2F;出口、内核跟踪点、网络事件等。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc2.png" class="">
<p>如果不存在满足特定需求的预定义挂钩，则可以创建内核探针 (<code>kprobe</code>) 或用户探针 (<code>uprobe</code>) 来将 <code>eBPF</code> 程序附加到内核或用户应用程序中的几乎任何位置。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc3.png" class="">

<h5 id="eBPF程序是如何编写的？"><a href="#eBPF程序是如何编写的？" class="headerlink" title="eBPF程序是如何编写的？"></a>eBPF程序是如何编写的？</h5><p>在很多场景中，<code>eBPF</code> 并不直接使用，而是通过<code>Cilium</code>、<code>bcc</code>或<code>bpftrace</code>等项目间接使用，这些项目在 <code>eBPF</code> 之上提供抽象，不需要直接编写程序，而是提供指定基于意图的定义的能力，然后这些定义用<code>eBPF</code>实现。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc4.png" class="">
<p>如果不存在更高级别的抽象，则需要直接编写程序。<code>Linux</code> 内核期望 <code>eBPF</code> 程序以字节码的形式加载。虽然直接编写字节码当然是可能的，但更常见的开发实践是利用<code>LLVM</code>等编译器套件将伪 <code>C</code> 代码编译为 <code>eBPF</code> 字节码。</p>
<h5 id="加载器和验证架构"><a href="#加载器和验证架构" class="headerlink" title="加载器和验证架构"></a>加载器和验证架构</h5><p>当识别出所需的钩子后，可以使用 <code>bpf</code> 系统调用将 <code>eBPF</code> 程序加载到 <code>Linux</code> 内核中。这通常是使用可用的 <code>eBPF</code> 库来完成的。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc5.png" class="">
<p>当程序加载到 <code>Linux</code> 内核中时，它在附加到请求的钩子之前要经过两个步骤：验证步骤确保 <code>eBPF</code> 程序可以安全运行。它验证程序是否满足多个条件，例如：</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc6.png" class="">
<ul>
<li>加载 <code>eBPF</code> 程序的进程拥有所需的能力（特权）。除非启用非特权 <code>eBPF</code>，否则只有特权进程才能加载 <code>eBPF</code> 程序。</li>
<li>该程序不会崩溃或以其他方式损害系统。</li>
<li>程序总是运行到完成（即程序不会永远处于循环中，从而阻止进一步的处理）。<br>即时 (<code>JIT</code>) 编译步骤将程序的通用字节码转换为机器特定的指令集，以优化程序的执行速度。这使得 <code>eBPF</code> 程序的运行效率与本机编译的内核代码或作为内核模块加载的代码一样高效。<code>eBPF</code> 程序的一个重要方面是共享收集的信息和存储状态的能力。为此，<code>eBPF</code> 程序可以利用 <code>eBPF</code> 映射的概念来存储和检索各种数据结构中的数据。<code>eBPF</code> 映射可以通过系统调用从 <code>eBPF</code> 程序以及用户空间中的应用程序访问。<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc7.png" class="">
以下是支持的映射类型的不完整列表，以帮助您了解数据结构的多样性。对于各种地图类型，可以使用共享版本和每个 <code>CPU</code> 版本。</li>
<li>哈希表、数组</li>
<li>LRU（最近最少使用）</li>
<li>环形缓冲器</li>
<li>堆栈跟踪</li>
<li>LPM（最长前缀匹配）</li>
<li>…<br><code>eBPF</code> 程序无法调用任意内核函数。允许这样做会将 <code>eBPF</code> 程序绑定到特定的内核版本，并使程序的兼容性变得复杂。相反，<code>eBPF</code> 程序可以对辅助函数进行函数调用，辅助函数是内核提供的众所周知且稳定的 <code>API</code>。<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc8.png" class="">
<code>eBPF</code> 程序可以通过尾部和函数调用的概念进行组合。函数调用允许在 <code>eBPF</code> 程序中定义和调用函数。尾部调用可以调用并执行另一个 <code>eBPF</code> 程序并替换执行上下文，类似于常规进程的 <code>execve()</code> 系统调用的操作方式。<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc9.png" class=""></li>
</ul>
<h5 id="eBPF-安全"><a href="#eBPF-安全" class="headerlink" title="eBPF 安全"></a>eBPF 安全</h5><p><code>eBPF</code> 是一项极其强大的技术，现在运行在许多关键软件基础设施组件的核心。在<code>eBPF</code>的开发过程中，当考虑将<code>eBPF</code>纳入<code>Linux</code>内核时，<code>eBPF</code>的安全性是最重要的方面。<code>eBPF</code> 的安全性通过多个层面来确保：除非启用非特权 <code>eBPF</code>，否则所有打算将 <code>eBPF</code> 程序加载到 <code>Linux</code> 内核中的进程都必须在特权模式（<code>root</code>）下运行，或者需要 <code>CAP_BPF</code> 功能。这意味着不受信任的程序无法加载 <code>eBPF</code> 程序。如果启用非特权 <code>eBPF</code>，非特权进程可以加载某些 <code>eBPF</code> 程序，但功能集会减少，并且对内核的访问受到限制。</p>
<ul>
<li>程序经过验证以确保它们始终运行完成，例如，eBPF 程序可能永远不会阻塞或永远处于循环中。eBPF 程序可能包含所谓的有界循环，但只有当验证者可以确保循环包含保证为真的退出条件时，该程序才会被接受。</li>
<li>程序不得使用任何未初始化的变量或越界访问内存。</li>
<li>程序必须符合系统的大小要求。不可能加载任意大的 eBPF 程序。</li>
<li>程序必须具有有限的复杂性。验证者将评估所有可能的执行路径，并且必须能够在配置的复杂性上限范围内完成分析。</li>
</ul>
<p>验证器是一种安全工具，用于检查程序是否可以安全运行。它不是检查程序正在做什么的安全工具。成功完成验证后，<code>eBPF</code> 程序将根据程序是从特权进程还是非特权进程加载来运行强化过程。该步骤包括：</p>
<ul>
<li>程序执行保护：保存 <code>eBPF</code> 程序的内核内存受到保护并设为只读。如果由于任何原因，无论是内核错误还是恶意操纵，试图修改 <code>eBPF</code> 程序，内核将崩溃，而不是允许它继续执行损坏&#x2F;操纵的程序。</li>
<li>针对 <code>Spectre</code> 的缓解措施：据推测，<code>CPU</code> 可能会错误预测分支并留下可通过侧通道提取的可观察到的副作用。举几个例子：<code>eBPF</code> 程序屏蔽内存访问，以便将瞬态指令下的访问重定向到受控区域，验证器还遵循仅在推测执行下可访问的程序路径，并且 <code>JIT</code> 编译器在尾调用无法转换为直接调用的情况下发出 <code>Retpolines</code> 。</li>
<li>常量致盲：代码中的所有常量都被致盲，以防止 <code>JIT</code> 喷射攻击。这可以防止攻击者将可执行代码作为常量注入，在存在另一个内核错误的情况下，可能允许攻击者跳转到 <code>eBPF</code> 程序的内存部分来执行代码。</li>
</ul>
<p><code>eBPF</code> 程序无法直接访问任意内核内存。位于程序上下文之外的数据和数据结构必须通过 <code>eBPF</code> 帮助程序进行访问。这保证了数据访问的一致性，并使任何此类访问都受到 <code>eBPF</code> 程序特权的约束，例如，只有与程序类型相关的数据结构可以被读取或（有时）修改，前提是验证者可以确保在加载时绑定访问永远不会发生；或者，运行中的<code>eBPF</code>程序只有在能够保证修改安全的情况下才允许修改某些数据结构的数据。<code>eBPF</code> 程序不能随机修改内核中的数据结构。</p>
<h5 id="eBPF-对-Linux-内核的影响"><a href="#eBPF-对-Linux-内核的影响" class="headerlink" title="eBPF 对 Linux 内核的影响"></a>eBPF 对 Linux 内核的影响</h5><p>现在让我们回到 <code>eBPF</code>。为了了解 <code>eBPF</code> 对 <code>Linux</code> 内核的可编程性影响，有助于对 <code>Linux</code> 内核的架构以及它如何与应用程序和硬件交互有一个高层次的了解。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc10.png" class="">
<p><code>Linux</code>内核的主要目的是抽象硬件或虚拟硬件并提供一致的<code>API</code>（系统调用），允许应用程序运行和共享资源。为了实现这一目标，需要维护大量的子系统和层来分配这些职责。每个子系统通常允许某种级别的配置来满足用户的不同需求。如果无法配置所需的行为，则需要更改内核，从历史上看，留下两个选项：</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc11.png" class="">
<p>借助 <code>eBPF</code>，可以使用一个新选项，允许对 <code>Linux</code> 内核的行为进行重新编程，而无需更改内核源代码或加载内核模块。在很多方面，这与 <code>JavaScript</code> 和其他脚本语言如何解锁系统的演变非常相似，而系统的改变变得困难或昂贵。</p>
<h5 id="开发工具链"><a href="#开发工具链" class="headerlink" title="开发工具链"></a>开发工具链</h5><p>存在多个开发工具链来协助 eBPF 程序的开发和管理。它们都满足用户的不同需求：</p>
<h6 id="bcc"><a href="#bcc" class="headerlink" title="bcc"></a>bcc</h6><p><code>BCC</code> 是一个框架，使用户能够编写嵌入了 <code>eBPF</code> 程序的 <code>python</code> 程序。该框架主要针对涉及应用程序和系统分析&#x2F;跟踪的用例，其中 <code>eBPF</code> 程序用于收集统计数据或生成事件，而用户空间中的对应程序则收集数据并以人类可读的形式显示数据。运行<code>python</code>程序将生成<code>eBPF</code>字节码并将其加载到内核中。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc12.png" class="">

<h6 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h6><p><code>bpftrace</code> 是一种适用于 <code>Linux eBPF</code> 的高级跟踪语言，可在半新的 <code>Linux</code> 内核 (4.x) 中使用。<code>bpftrace</code> 使用 <code>LLVM</code> 作为后端将脚本编译为 <code>eBPF</code> 字节码，并利用 <code>BCC</code> 与 <code>Linux eBPF</code> 子系统以及现有的 <code>Linux</code> 跟踪功能进行交互：内核动态跟踪 (<code>kprobes</code>)、用户级动态跟踪 (<code>uprobes</code>) 和跟踪点。<code>bpftrace</code> 语言受到 <code>awk、C</code> 和前身跟踪器（例如 <code>DTrace</code> 和 <code>SystemTap</code>）的启发。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc13.png" class="">

<h6 id="eBPF-Go-库"><a href="#eBPF-Go-库" class="headerlink" title="eBPF Go 库"></a>eBPF Go 库</h6><p><code>eBPF Go</code> 库提供了一个通用的 <code>eBPF</code> 库，它将获取 <code>eBPF</code> 字节码的过程与 <code>eBPF</code> 程序的加载和管理解耦。<code>eBPF</code> 程序通常是通过编写更高级的语言来创建的，然后使用 <code>clang/LLVM</code> 编译器编译为 <code>eBPF</code> 字节码。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc14.png" class="">

<h6 id="libbpf-C-C-库"><a href="#libbpf-C-C-库" class="headerlink" title="libbpf C&#x2F;C++ 库"></a>libbpf C&#x2F;C++ 库</h6><p><code>libbpf</code> 库是一个基于 <code>C/C++</code> 的通用 <code>eBPF</code> 库，它有助于将从 <code>clang/LLVM</code> 编译器生成的 <code>eBPF</code> 目标文件加载到内核中，并通过为应用程序提供易于使用的库 <code>API</code> 来抽象与 <code>BPF</code> 系统调用的交互。</p>
<img data-src="/2023/09/04/Cloud-Native/ebpf/ebpf_desc15.png" class="">

<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.814ex;" xmlns="http://www.w3.org/2000/svg" width="7.174ex" height="4.851ex" role="img" focusable="false" viewBox="0 -1342 3171 2143.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(1335.5,676)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mrow" transform="translate(220,-719.9)"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mn" transform="translate(605,289) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(1230.8,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(2231,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g><rect width="2931" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>

<h6 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h6><ul>
<li><a href="https://cilium.readthedocs.io/en/stable/bpf/">BPF 和 XDP 参考指南</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/bpf/index.html">BPF 文档</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst">BPF 设计问答</a></li>
</ul>
<h6 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h6><ul>
<li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">学习 eBPF 跟踪：教程和示例</a></li>
<li><a href="https://github.com/xdp-project/xdp-tutorial">XDP 实践教程</a></li>
<li><a href="https://facebookmicrosites.github.io/bpf/blog/">BCC、libbpf 和 BPF CO-RE 教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Cloud Native</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>eBPF</tag>
      </tags>
  </entry>
  <entry>
    <title>构建Rust镜像</title>
    <url>/2023/07/28/Cloud-Native/rust_docker/</url>
    <content><![CDATA[<h5 id="获取示例应用"><a href="#获取示例应用" class="headerlink" title="获取示例应用"></a>获取示例应用</h5><p>克隆示例应用程序以与本指南一起使用。打开终端，将目录更改为您要工作的目录，然后运行以下命令来克隆存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/docker/docker-rust-hello</span><br></pre></td></tr></table></figure>
<h5 id="为-Rust-创建-Dockerfile"><a href="#为-Rust-创建-Dockerfile" class="headerlink" title="为 Rust 创建 Dockerfile"></a>为 Rust 创建 Dockerfile</h5><p>现在您已经有了一个应用程序，您可以<code>docker init</code>为其创建一个 Dockerfile。在<code>docker-rust-hello</code>目录中，运行<code>docker init</code>命令。请参阅以下示例来回答 中的提示<code>docker init</code>。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker init</span><br><span class="line">Welcome to the Docker Init CLI!</span><br><span class="line"></span><br><span class="line">This utility will walk you through creating the following files with sensible defaults for your project:</span><br><span class="line">  - .dockerignore</span><br><span class="line">  - Dockerfile</span><br><span class="line">  - compose.yaml</span><br><span class="line"></span><br><span class="line">Let&#x27;s get started!</span><br><span class="line"></span><br><span class="line">? What application platform does your project use? Rust</span><br><span class="line">? What version of Rust do you want to use? 1.70.0</span><br><span class="line">? What port does your server listen on? 8000</span><br></pre></td></tr></table></figure>
<p>您的目录中现在应该有以下 3 个新文件<code>docker-rust-hello</code> ：</p>
<ul>
<li>Dockerfile</li>
<li>.dockerignore</li>
<li>compose.yaml</li>
</ul>
<p>为了构建镜像，只需要 Dockerfile。在您最喜欢的 IDE 或文本编辑器中打开 Dockerfile 并查看它包含的内容。要了解有关 Dockerfile 的更多信息。当您运行时docker init，它还会创建一个.dockerignore文件。使用该.dockerignore文件指定您不想复制到图像中的模式和路径，以使图像尽可能小。</p>
<h5 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h5><p>现在您已经创建了 Dockerfile，您可以构建镜像了。为此，请使用该<code>docker build</code>命令。该<code>docker build</code>命令从 Dockerfile 和上下文构建 Docker 镜像。构建的上下文是位于指定 PATH 或 URL 中的文件集。Docker 构建过程可以访问位于此上下文中的任何文件。</p>
<p>构建命令可以选择使用一个–<code>tag</code>标志。该标签设置图像的名称和格式中的可选标签<code>name:tag</code>。如果您不传递标签，Docker 将使用“latest”作为其默认标签。构建 Docker 镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build --tag docker-rust-image .</span><br></pre></td></tr></table></figure>
<p>您应该看到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] Building 62.6s (14/14) FINISHED</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                                    0.1s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                      0.0s </span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                                                 0.1s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 2.70kB                                                                                               0.0s </span><br><span class="line"> =&gt; resolve image config for docker.io/docker/dockerfile:1                                                                           2.3s</span><br><span class="line"> =&gt; CACHED docker-image://docker.io/docker/dockerfile:1@sha256:39b85bbfa7536a5feceb7372a0817649ecb2724562a38360f4d6a7782a409b14      0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/debian:bullseye-slim                                                              1.9s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/rust:1.70.0-slim-bullseye                                                         1.7s </span><br><span class="line"> =&gt; [build 1/3] FROM docker.io/library/rust:1.70.0-slim-bullseye@sha256:585eeddab1ec712dade54381e115f676bba239b1c79198832ddda397c1f  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                                                    0.0s </span><br><span class="line"> =&gt; =&gt; transferring context: 35.29kB                                                                                                 0.0s </span><br><span class="line"> =&gt; [final 1/3] FROM docker.io/library/debian:bullseye-slim@sha256:7606bef5684b393434f06a50a3d1a09808fee5a0240d37da5d181b1b121e7637  0.0s </span><br><span class="line"> =&gt; CACHED [build 2/3] WORKDIR /app                                                                                                  0.0s</span><br><span class="line"> =&gt; [build 3/3] RUN --mount=type=bind,source=src,target=src     --mount=type=bind,source=Cargo.toml,target=Cargo.toml     --mount=  57.7s </span><br><span class="line"> =&gt; CACHED [final 2/3] RUN adduser     --disabled-password     --gecos &quot;&quot;     --home &quot;/nonexistent&quot;     --shell &quot;/sbin/nologin&quot;      0.0s</span><br><span class="line"> =&gt; CACHED [final 3/3] COPY --from=build /bin/server /bin/                                                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                              0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:f1aa4a9f58d2ecf73b0c2b7f28a6646d9849b32c3921e42adc3ab75e12a3de14                                         0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker-rust-image</span><br></pre></td></tr></table></figure>

<h5 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h5><p>要查看本地计算机上的映像列表，您有两种选择。一种是使用 Docker CLI，另一种是使用Docker Desktop。由于您已经在终端中工作，请查看使用 CLI 列出图像。要列出图像，请运行<code>docker images</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                TAG               IMAGE ID       CREATED         SIZE</span><br><span class="line">docker-rust-image         latest            8cae92a8fbd6   3 minutes ago   123MB</span><br></pre></td></tr></table></figure>
<p>您应该看到至少列出了一个镜像，包括您刚刚构建的镜像<code>docker-rust-image:latest</code>。</p>
<h5 id="标记镜像"><a href="#标记镜像" class="headerlink" title="标记镜像"></a>标记镜像</h5><p>镜像名称由斜杠分隔的名称组件组成。名称组件可以包含小写字母、数字和分隔符。分隔符可以包括句点、一个或两个下划线、或者一个或多个破折号。名称不能以分隔符开头或结尾。镜像由清单和层列表组成。此时不要太担心清单和层，除了指向这些工件的组合的“标签”之外。一张图片可以有多个标签。为您构建的镜像，创建第二个标签并查看其层。要为您构建的镜像创建新标签，请运行以下命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker tag docker-rust-image:latest docker-rust-image:v1.0.0</span><br></pre></td></tr></table></figure>
<p>该<code>docker tag</code>命令为镜像创建一个新标签。它不会创建新镜像。标签指向同一个镜像，只是引用镜像的另一种方式。现在，运行<code>docker images</code>命令以查看本地镜像的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                TAG               IMAGE ID       CREATED         SIZE</span><br><span class="line">docker-rust-image         latest            8cae92a8fbd6   4 minutes ago   123MB</span><br><span class="line">docker-rust-image         v1.0.0            8cae92a8fbd6   4 minutes ago   123MB</span><br><span class="line">rust                      latest            be5d294735c6   4 minutes ago   113MB</span><br></pre></td></tr></table></figure>
<p>您可以看到两个镜像以 开头<code>docker-rust-image</code>。您知道它们是相同的镜像，因为如果您查看该IMAGE ID列，您可以看到两个镜像的值相同。删除您刚刚创建的标签。为此，请使用该<code>rmi</code>命令。该rmi命令代表删除镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker rmi docker-rust-image:v1.0.0</span><br><span class="line">Untagged: docker-rust-image:v1.0.0</span><br></pre></td></tr></table></figure>
<p>请注意，Docker 的镜像说明Docker 并未删除该镜像，而只是“取消标记”它。您可以通过运行<code>docker images</code>命令来检查这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY               TAG               IMAGE ID       CREATED         SIZE</span><br><span class="line">docker-rust-image        latest            8cae92a8fbd6   6 minutes ago   123MB</span><br><span class="line">rust                     latest            be5d294735c6   6 minutes ago   113MB</span><br></pre></td></tr></table></figure>
<p>Docker 删除了标记为 的映像<code>:v1.0.0</code>，但该<code>docker-rust-image:latest</code>标记在您的计算机上可用。</p>
<h5 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h5><p>用于运行您在构建 Rust 镜像<code>docker run</code>中构建的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run docker-rust-image</span><br></pre></td></tr></table></figure>

<p>运行此命令后，您会发现没有返回到命令提示符。这是因为您的应用程序是一个在循环中运行的服务器，等待传入的请求，而不将控制权返回给操作系统，直到您停止容器。打开一个新终端，然后使用命令向服务器发出请求<code>curl</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8000</span><br></pre></td></tr></table></figure>
<p>您应该看到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl: (7) Failed to connect to localhost port 8000 after 2236 ms: Couldn&#x27;t connect to server</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，您的curl命令失败了。这意味着您无法连接到端口 8000 上的本地主机。这是正常的，因为您的容器是独立运行的，其中包括网络。停止容器并使用本地网络上发布的端口 8000 重新启动。要停止容器，请按 <code>ctrl-c</code>。这将使您返回到终端提示符。要为容器发布端口，您将在命令中使用标志<code>--publish</code>（<code>-p</code>简称）<code>docker run</code>。命令的格式<code>--publish为[host port]:[container port]</code>. 因此，如果您想将容器内的端口 <code>8000</code> 公开到容器外的端口 <code>3001</code>，则需要传递<code>3001:8000</code>给<code>--publish</code>标志。在容器中运行应用程序时，您没有指定端口，默认为 <code>8000</code>。如果您希望之前发送到端口 <code>8000</code> 的请求能够正常工作，可以将主机的端口 <code>3001</code> 映射到容器的端口 <code>8000</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --publish 3001:8000 docker-rust-image</span><br></pre></td></tr></table></figure>
<p>现在，重新运行<code>curl</code> 命令。记得打开一个新终端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:3001</span><br></pre></td></tr></table></figure>
<p>您应该看到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, Docker!</span><br></pre></td></tr></table></figure>

<h5 id="分离模式运行"><a href="#分离模式运行" class="headerlink" title="分离模式运行"></a>分离模式运行</h5><p>到目前为止这很棒，但是您的示例应用程序是一个 Web 服务器，您不必连接到容器。Docker 可以在分离模式或后台运行容器。为此，可以简称为<code>--detach</code>或<code>-d</code>。Docker 与以前一样启动容器，但这次将从容器“分离”并将您返回到终端提示符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 3001:8000 docker-rust-image</span><br><span class="line">ce02b3179f0f10085db9edfccd731101868f58631bdf918ca490ff6fd223a93b</span><br></pre></td></tr></table></figure>
<p>Docker 在后台启动容器并在终端上打印容器 ID。再次确保我们的容器正常运行。运行与上面相同的curl 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:3001</span><br></pre></td></tr></table></figure>

<h5 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h5><p>由于您在后台运行容器，因此如何知道您的容器是否正在运行或者您的计算机上正在运行哪些其他容器？那么，要查看计算机上运行的容器列表，请运行<code>docker ps</code>。这类似于在 Linux 中使用 <code>ps</code> 命令查看进程列表的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                   COMMAND         CREATED         STATUS         PORTS                    NAMES</span><br><span class="line">3074745e412c   docker-rust-image       &quot;/bin/server&quot;   8 seconds ago   Up 7 seconds   0.0.0.0:3001-&gt;8000/tcp   wonderful_kalam</span><br></pre></td></tr></table></figure>
<p>该<code>docker ps</code>命令提供了有关正在运行的容器的大量信息。您可以查看容器 ID、容器内运行的映像、用于启动容器的命令、创建容器的时间、状态、公开的端口以及容器的名称。您可能想知道容器的名称来自哪里。由于启动时没有为容器提供名称，因此 Docker 生成了一个随机名称。您很快就会解决这个问题，但首先您需要停止容器。要停止容器，请运行<code>docker stop</code>停止容器的命令。您需要传递容器的名称，也可以使用容器 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker stop wonderful_kalam</span><br><span class="line">wonderful_kalam</span><br></pre></td></tr></table></figure>
<p>现在，重新运行该<code>docker ps</code>命令以查看正在运行的容器的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure>

<h5 id="停止、启动和命名容器"><a href="#停止、启动和命名容器" class="headerlink" title="停止、启动和命名容器"></a>停止、启动和命名容器</h5><p>您可以启动、停止和重新启动 Docker 容器。当您停止容器时，它不会被删除，但状态会更改为已停止，并且容器内的进程也会停止。当您在上一个模块中运行<code>docker ps</code>命令时，默认输出仅显示正在运行的容器。当您通过<code>--all</code>或<code>-a</code>简称时，您会看到计算机上的所有容器，无论它们的启动或停止状态如何。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                   COMMAND                  CREATED          STATUS                      PORTS                       </span><br><span class="line">     NAMES</span><br><span class="line">3074745e412c   docker-rust-image       &quot;/bin/server&quot;            3 minutes ago    Exited (0) 6 seconds ago                                </span><br><span class="line">     wonderful_kalam</span><br><span class="line">6cfa26e2e3c9   docker-rust-image       &quot;/bin/server&quot;            14 minutes ago   Exited (0) 5 minutes ago                                </span><br><span class="line">     friendly_montalcini</span><br><span class="line">4cbe94b2ea0e   docker-rust-image       &quot;/bin/server&quot;            15 minutes ago   Exited (0) 14 minutes ago                               </span><br><span class="line">     tender_bose</span><br></pre></td></tr></table></figure>

<p>您现在应该看到列出了几个容器。这些是您启动和停止但尚未删除的容器。重新启动刚刚停止的容器。找到您刚刚停止的容器的名称，并在以下重新启动命令中替换该容器的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker restart wonderful_kalam</span><br></pre></td></tr></table></figure>
<p>现在使用该命令再次列出所有容器<code>docker ps</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps --all</span><br><span class="line">CONTAINER ID   IMAGE                   COMMAND                  CREATED          STATUS                      PORTS                       </span><br><span class="line">     NAMES</span><br><span class="line">3074745e412c   docker-rust-image       &quot;/bin/server&quot;            6 minutes ago    Up 4 seconds                0.0.0.0:3001-&gt;8000/tcp           wonderful_kalam</span><br><span class="line">6cfa26e2e3c9   docker-rust-image       &quot;/bin/server&quot;            16 minutes ago   Exited (0) 7 minutes ago                                </span><br><span class="line">     friendly_montalcini</span><br><span class="line">4cbe94b2ea0e   docker-rust-image       &quot;/bin/server&quot;            18 minutes ago   Exited (0) 17 minutes ago                               </span><br><span class="line">     tender_bose</span><br></pre></td></tr></table></figure>
<p>请注意，您刚刚重新启动的容器已以分离模式启动。另外，观察容器的状态为“Up X 秒”。当您重新启动容器时，它将以最初启动时相同的标志或命令启动。现在，停止并删除所有容器，然后看看修复随机命名问题。停止刚刚启动的容器。找到正在运行的容器的名称，并将以下命令中的名称替换为系统上容器的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker stop wonderful_kalam</span><br><span class="line">wonderful_kalam</span><br></pre></td></tr></table></figure>
<p>现在您已停止所有容器，请将其删除。当你删除一个容器时，它不再运行，也不是停止状态，但容器内的进程已经停止，容器的元数据也被删除。要删除容器，请<code>docker rm</code>使用容器名称运行命令。您可以使用单个命令将多个容器名称传递给该命令。再次，将以下命令中的容器名称替换为您系统中的容器名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker rm wonderful_kalam friendly_montalcini tender_bose</span><br><span class="line">wonderful_kalam</span><br><span class="line">friendly_montalcini</span><br><span class="line">tender_bose</span><br></pre></td></tr></table></figure>

<p>再次运行该<code>docker ps --all</code>命令可以看到 Docker 删除了所有容器。现在，是时候解决随机命名问题了。标准做法是为容器命名，原因很简单，因为可以更轻松地识别容器中运行的内容以及与它关联的应用程序或服务。要命名容器，您只需将<code>--name</code>标志传递给<code>docker run</code>命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3001:8000 --name docker-rust-container docker-rust-image</span><br><span class="line">1aa5d46418a68705c81782a58456a4ccdb56a309cb5e6bd399478d01eaa5cdda</span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID   IMAGE                   COMMAND         CREATED         STATUS         PORTS                    NAMES</span><br><span class="line">c68fa18de1f6   docker-rust-image       &quot;/bin/server&quot;   7 seconds ago   Up 6 seconds   0.0.0.0:3001-&gt;8000/tcp   docker-rust-container</span><br></pre></td></tr></table></figure>

<h5 id="在容器中运行数据库"><a href="#在容器中运行数据库" class="headerlink" title="在容器中运行数据库"></a>在容器中运行数据库</h5><p>您可以使用 PostgreSQL 的 Docker 官方映像并在容器中运行它，而不是下载 PostgreSQL、安装、配置然后将 PostgreSQL 数据库作为服务运行。在容器中运行 PostgreSQL 之前，创建一个 Docker 可以管理的卷来存储持久数据和配置。使用 Docker 提供的命名卷功能，而不是使用绑定安装。运行以下命令来创建您的卷。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker volume create db-data</span><br></pre></td></tr></table></figure>
<p>现在创建一个网络，您的应用程序和数据库将使用该网络相互通信。该网络称为用户定义的桥接网络，为您提供良好的 DNS 查找服务，您可以在创建连接字符串时使用该服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker network create postgresnet</span><br></pre></td></tr></table></figure>
<p>现在，您可以在容器中运行 PostgreSQL 并附加到创建的卷和网络。Docker 从 Hub 中提取映像并在本地运行它。在以下命令中，选项<code>--mount</code>用于启动带有卷的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --rm -d --mount \</span><br><span class="line">  &quot;type=volume,src=db-data,target=/var/lib/postgresql/data&quot; \</span><br><span class="line">  -p 5432:5432 \</span><br><span class="line">  --network postgresnet \</span><br><span class="line">  --name db \</span><br><span class="line">  -e POSTGRES_PASSWORD=mysecretpassword \</span><br><span class="line">  -e POSTGRES_DB=example \</span><br><span class="line">  postgres</span><br></pre></td></tr></table></figure>
<p>现在，确保您的 PostgreSQL 数据库正在运行并且可以连接到它。连接到容器内正在运行的 PostgreSQL 数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker exec -it db psql -U postgres</span><br></pre></td></tr></table></figure>
<p>您应该看到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psql (15.3 (Debian 15.3-1.pgdg110+1))</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure>
<p><code>psql</code>在上一个命令中，您通过将命令传递给容器来登录到 PostgreSQL 数据库db。按 <code>ctrl-d</code> 退出 PostgreSQL 交互式终端。</p>
<h5 id="获取并运行示例应用程序"><a href="#获取并运行示例应用程序" class="headerlink" title="获取并运行示例应用程序"></a>获取并运行示例应用程序</h5><ol>
<li>使用以下命令克隆示例应用程序存储库。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/docker/docker-rust-postgres</span><br></pre></td></tr></table></figure></li>
<li>在克隆存储库的目录中，运行<code>docker init</code>以创建必要的 Docker 文件。请参阅以下示例来回答 中的提示<code>docker init</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker init</span><br><span class="line">Welcome to the Docker Init CLI!</span><br><span class="line"></span><br><span class="line">This utility will walk you through creating the following files with sensible defaults for your project:</span><br><span class="line">  - .dockerignore</span><br><span class="line">  - Dockerfile</span><br><span class="line">  - compose.yaml</span><br><span class="line"></span><br><span class="line">Let&#x27;s get started!</span><br><span class="line"></span><br><span class="line">? What application platform does your project use? Rust</span><br><span class="line">? What version of Rust do you want to use? 1.70.0</span><br><span class="line">? What port does your server listen on? 8000</span><br></pre></td></tr></table></figure></li>
<li>在克隆存储库的目录中，Dockerfile在 IDE 或文本编辑器中打开以更新它。</li>
</ol>
<p><code>docker init</code>处理了 Dockerfile 中大部分指令的创建，但您需要针对您独特的应用程序更新它。除了<code>src</code>目录之外，该应用程序还包括一个<code>migrations</code>用于初始化数据库的目录。将目录的绑定挂载添加<code>migrations</code>到 Dockerfile 中的构建阶段。以下是更新后的 Dockerfile。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line"></span><br><span class="line"># Comments are provided throughout this file to help you get started.</span><br><span class="line"># If you need more help, visit the Dockerfile reference guide at</span><br><span class="line"># https://docs.docker.com/engine/reference/builder/</span><br><span class="line">   </span><br><span class="line">################################################################################</span><br><span class="line"># Create a stage for building the application.</span><br><span class="line">   </span><br><span class="line">ARG RUST_VERSION=1.70.0</span><br><span class="line">ARG APP_NAME=react-rust-postgres</span><br><span class="line">FROM rust:$&#123;RUST_VERSION&#125;-slim-bullseye AS build</span><br><span class="line">ARG APP_NAME</span><br><span class="line">WORKDIR /app</span><br><span class="line">   </span><br><span class="line"># Build the application.</span><br><span class="line"># Leverage a cache mount to /usr/local/cargo/registry/</span><br><span class="line"># for downloaded dependencies and a cache mount to /app/target/ for </span><br><span class="line"># compiled dependencies which will speed up subsequent builds.</span><br><span class="line"># Leverage a bind mount to the src directory to avoid having to copy the</span><br><span class="line"># source code into the container. Once built, copy the executable to an</span><br><span class="line"># output directory before the cache mounted /app/target is unmounted.</span><br><span class="line">RUN --mount=type=bind,source=src,target=src \</span><br><span class="line">    --mount=type=bind,source=Cargo.toml,target=Cargo.toml \</span><br><span class="line">    --mount=type=bind,source=Cargo.lock,target=Cargo.lock \</span><br><span class="line">    --mount=type=cache,target=/app/target/ \</span><br><span class="line">    --mount=type=cache,target=/usr/local/cargo/registry/ \</span><br><span class="line">    --mount=type=bind,source=migrations,target=migrations \</span><br><span class="line">    &lt;&lt;EOF</span><br><span class="line">set -e</span><br><span class="line">cargo build --locked --release</span><br><span class="line">cp ./target/release/$APP_NAME /bin/server</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line">################################################################################</span><br><span class="line"># Create a new stage for running the application that contains the minimal</span><br><span class="line"># runtime dependencies for the application. This often uses a different base</span><br><span class="line"># image from the build stage where the necessary files are copied from the build</span><br><span class="line"># stage.</span><br><span class="line">#</span><br><span class="line"># The example below uses the debian bullseye image as the foundation for    running the app.</span><br><span class="line"># By specifying the &quot;bullseye-slim&quot; tag, it will also use whatever happens to    be the</span><br><span class="line"># most recent version of that tag when you build your Dockerfile. If</span><br><span class="line"># reproducability is important, consider using a digest</span><br><span class="line"># (e.g.,    debian@sha256:ac707220fbd7b67fc19b112cee8170b41a9e97f703f588b2cdbbcdcecdd8af57).</span><br><span class="line">FROM debian:bullseye-slim AS final</span><br><span class="line">   </span><br><span class="line"># Create a non-privileged user that the app will run under.</span><br><span class="line"># See https://docs.docker.com/develop/develop-images/dockerfile_best-practices/   #user</span><br><span class="line">ARG UID=10001</span><br><span class="line">RUN adduser \</span><br><span class="line">    --disabled-password \</span><br><span class="line">    --gecos &quot;&quot; \</span><br><span class="line">    --home &quot;/nonexistent&quot; \</span><br><span class="line">    --shell &quot;/sbin/nologin&quot; \</span><br><span class="line">    --no-create-home \</span><br><span class="line">    --uid &quot;$&#123;UID&#125;&quot; \</span><br><span class="line">    appuser</span><br><span class="line">USER appuser</span><br><span class="line">   </span><br><span class="line"># Copy the executable from the &quot;build&quot; stage.</span><br><span class="line">COPY --from=build /bin/server /bin/</span><br><span class="line">   </span><br><span class="line"># Expose the port that the application listens on.</span><br><span class="line">EXPOSE 8000</span><br><span class="line">   </span><br><span class="line"># What the container should run when it is started.</span><br><span class="line">CMD [&quot;/bin/server&quot;]</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在克隆存储库的目录中，运行<code>docker build</code>以构建映像。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t rust-backend-image .</span><br></pre></td></tr></table></figure></li>
<li>使用以下选项运行<code>docker run</code>，将映像作为容器在与数据库相同的网络上运行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run \</span><br><span class="line">  --rm -d \</span><br><span class="line">  --network postgresnet \</span><br><span class="line">  --name docker-develop-rust-container \</span><br><span class="line">  -p 3001:8000 \</span><br><span class="line">  -e PG_DBNAME=example \</span><br><span class="line">  -e PG_HOST=db \</span><br><span class="line">  -e PG_USER=postgres \</span><br><span class="line">  -e PG_PASSWORD=mysecretpassword \</span><br><span class="line">  -e ADDRESS=0.0.0.0:8000 \</span><br><span class="line">  -e RUST_LOG=debug \</span><br><span class="line">  rust-backend-image</span><br></pre></td></tr></table></figure></li>
<li>应用程序以验证它是否连接到数据库。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:3001/users</span><br></pre></td></tr></table></figure>
您应该得到如下所示的响应。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;id&quot;:1,&quot;login&quot;:&quot;root&quot;&#125;]</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="使用-Compose-进行本地开发"><a href="#使用-Compose-进行本地开发" class="headerlink" title="使用 Compose 进行本地开发"></a>使用 Compose 进行本地开发</h5><p>当您运行<code>docker init</code>时，除了Dockerfile，它还会创建一个<code>compose.yaml</code>文件。这个 Compose 文件非常方便，因为您不必键入所有参数来传递给命令<code>docker run</code>。您可以使用 Compose 文件以声明方式执行此操作。在克隆存储库的目录中，<code>compose.yaml</code>在 IDE 或文本编辑器中打开文件。<code>docker init</code>处理了大部分指令的创建，但您需要针对您独特的应用程序对其进行更新。</p>
<p>您需要更新文件中的以下项目<code>compose.yaml</code>：</p>
<ul>
<li>取消所有数据库指令的注释。</li>
<li>在server服务下添加环境变量。<br>以下是更新后的compose.yaml文件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Comments are provided throughout this file to help you get started.</span><br><span class="line"># If you need more help, visit the Docker compose reference guide at</span><br><span class="line"># https://docs.docker.com/compose/compose-file/</span><br><span class="line"></span><br><span class="line"># Here the instructions define your application as a service called &quot;server&quot;.</span><br><span class="line"># This service is built from the Dockerfile in the current directory.</span><br><span class="line"># You can add other services your application may depend on here, such as a</span><br><span class="line"># database or a cache. For examples, see the Awesome Compose repository:</span><br><span class="line"># https://github.com/docker/awesome-compose</span><br><span class="line">services:</span><br><span class="line">  server:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      target: final</span><br><span class="line">    ports:</span><br><span class="line">      - 8000:8000</span><br><span class="line">    environment:</span><br><span class="line">      - PG_DBNAME=example</span><br><span class="line">      - PG_HOST=db</span><br><span class="line">      - PG_USER=postgres</span><br><span class="line">      - PG_PASSWORD=mysecretpassword</span><br><span class="line">      - ADDRESS=0.0.0.0:8000</span><br><span class="line">      - RUST_LOG=debug</span><br><span class="line"># The commented out section below is an example of how to define a PostgreSQL</span><br><span class="line"># database that your application can use. `depends_on` tells Docker Compose to</span><br><span class="line"># start the database before your application. The `db-data` volume persists the</span><br><span class="line"># database data between container restarts. The `db-password` secret is used</span><br><span class="line"># to set the database password. You must create `db/password.txt` and add</span><br><span class="line"># a password of your choosing to it before running `docker compose up`.</span><br><span class="line">    depends_on:</span><br><span class="line">      db:</span><br><span class="line">        condition: service_healthy</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    restart: always</span><br><span class="line">    user: postgres</span><br><span class="line">    secrets:</span><br><span class="line">      - db-password</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    environment:</span><br><span class="line">      - POSTGRES_DB=example</span><br><span class="line">      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password</span><br><span class="line">    expose:</span><br><span class="line">      - 5432</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [ &quot;CMD&quot;, &quot;pg_isready&quot; ]</span><br><span class="line">      interval: 10s</span><br><span class="line">      timeout: 5s</span><br><span class="line">      retries: 5</span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br><span class="line">secrets:</span><br><span class="line">  db-password:</span><br><span class="line">    file: db/password.txt</span><br></pre></td></tr></table></figure>
请注意，该文件没有为这两个服务指定网络。当您使用 Compose 时，它​​会自动创建一个网络并将服务连接到该网络。在使用 Compose 运行应用程序之前，请注意此 Compose 文件指定了一个<code>password</code>.txt文件来保存数据库的密码。您必须创建此文件，因为它不包含在源存储库中。在克隆存储库的目录中，创建一个名为 的新目录db，并在该目录内创建一个名为 的文件<code>password.txt</code>，其中包含数据库的密码。使用您喜欢的 IDE 或文本编辑器，将以下内容添加到文件中<code>password.txt</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysecretpassword</span><br></pre></td></tr></table></figure>
如果您有任何其他容器在前面的部分中运行，请立即停止它们。现在，运行以下<code>docker compose up</code>命令来启动您的应用程序。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker compose up --build</span><br></pre></td></tr></table></figure>
该命令传递<code>--build</code>标志，以便 Docker 编译您的映像，然后启动容器。现在测试您的 API 端点。打开一个新终端，然后使用<code>curl</code>命令向服务器发出请求：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8000/users</span><br></pre></td></tr></table></figure>
您应该收到以下回复：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;id&quot;:1,&quot;login&quot;:&quot;root&quot;&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="应用程序配置-CI-CD"><a href="#应用程序配置-CI-CD" class="headerlink" title="应用程序配置 CI&#x2F;CD"></a>应用程序配置 CI&#x2F;CD</h5><p>完成设置和使用 Docker GitHub Actions 来构建 Docker 映像以及将映像推送到 Docker Hub 的过程。您将完成以下步骤：</p>
<ul>
<li>在 GitHub 上创建一个新存储库。</li>
<li>定义 GitHub Actions 工作流程。</li>
<li>运行工作流程。</li>
</ul>
<p>创建 GitHub 存储库并配置 Docker Hub 密钥。</p>
<ol>
<li>创建新的 GitHub 存储库 。该存储库包含一个简单的 Dockerfile，仅此而已。如果您愿意，可以随意使用另一个包含可用 Dockerfile 的存储库。</li>
<li><code>Open the repository Settings, and go to Secrets and variables &gt; Actions</code>.</li>
<li>创建一个名为的新密钥<code>DOCKERHUB_USERNAME</code>，并将您的 Docker ID 作为值。</li>
<li>为 Docker Hub创建新的 个人访问令牌 (PAT) 。您可以命名该令牌<code>clockboxci</code>。</li>
<li>将 PAT 添加为 GitHub 存储库中的<code>second secret</code>，名称为 DOCKERHUB_TOKEN。</li>
</ol>
<p>设置 GitHub Actions 工作流程以构建映像并将其推送到 Docker Hub。</p>
<ol>
<li><p>转到 GitHub 上的存储库，然后选择“Actions”选项卡。</p>
</li>
<li><p>选择自己设置工作流程。这将带您进入一个页面，用于在存储库中创建新的 GitHub 操作工作流程文件（.github&#x2F;workflows&#x2F;main.yml默认情况下）。</p>
</li>
<li><p>在编辑器窗口中，复制并粘贴以下 YAML 配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: ci</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">push:</span><br><span class="line">   branches:</span><br><span class="line">      - &quot;main&quot;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">build:</span><br><span class="line">   runs-on: ubuntu-latest</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>：此工作流程的名称。</li>
<li><code>on.push.branches</code>：指定此工作流应在列表中分支的每个推送事件上运行。</li>
<li><code>jobs</code>：创建作业 ID ( <code>build</code>) 并声明作业应运行的机器类型。</li>
</ul>
<p>有关此处使用的 YAML 语法的更多信息，请参阅 <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions">GitHub Actions 的工作流语法</a>。</p>
</li>
</ol>
<p>定义工作流程步骤:<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jobs:</span><br><span class="line">   build:</span><br><span class="line">      runs-on: ubuntu-latest</span><br><span class="line">      steps:</span><br><span class="line">         -</span><br><span class="line">         name: Checkout</span><br><span class="line">         uses: actions/checkout@v3</span><br><span class="line">         -</span><br><span class="line">         name: Login to Docker Hub</span><br><span class="line">         uses: docker/login-action@v2</span><br><span class="line">         with:</span><br><span class="line">            username: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;</span><br><span class="line">            password: $&#123;&#123; secrets.DOCKERHUB_TOKEN &#125;&#125;</span><br><span class="line">         -</span><br><span class="line">         name: Set up Docker Buildx</span><br><span class="line">         uses: docker/setup-buildx-action@v2</span><br><span class="line">         -</span><br><span class="line">         name: Build and push</span><br><span class="line">         uses: docker/build-push-action@v4</span><br><span class="line">         with:</span><br><span class="line">            context: .</span><br><span class="line">            file: ./Dockerfile</span><br><span class="line">            push: true</span><br><span class="line">            tags: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/clockbox:latest</span><br></pre></td></tr></table></figure><br>   前面的 YAML 片段包含一系列步骤：</p>
<ol>
<li>检查构建机器上的存储库。</li>
<li>使用Docker 登录操作和您的 Docker Hub 凭据登录 Docker Hub 。</li>
<li>使用Docker Setup Buildx操作创建 BuildKit 构建器实例 。</li>
<li>使用Build and push Docker images构建容器镜像并将其推送到 Docker Hub 存储库 。</li>
</ol>
<p>   该<code>with</code>键列出了配置步骤的许多输入参数：</p>
<ul>
<li><code>context</code>：构建上下文。</li>
<li><code>file</code>：Dockerfile 的文件路径。</li>
<li><code>push</code>：告诉在构建镜像后将镜像上传到注册表的操作。</li>
<li><code>tags</code>：指定将镜像推送到何处的标签。</li>
</ul>
<p>将这些步骤添加到您的工作流程文件中。完整的工作流程配置应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: ci</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - &quot;main&quot;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      -</span><br><span class="line">        name: Checkout</span><br><span class="line">        uses: actions/checkout@v3</span><br><span class="line">      -</span><br><span class="line">        name: Login to Docker Hub</span><br><span class="line">        uses: docker/login-action@v2</span><br><span class="line">        with:</span><br><span class="line">          username: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;</span><br><span class="line">          password: $&#123;&#123; secrets.DOCKERHUB_TOKEN &#125;&#125;</span><br><span class="line">      -</span><br><span class="line">        name: Set up Docker Buildx</span><br><span class="line">        uses: docker/setup-buildx-action@v2</span><br><span class="line">      -</span><br><span class="line">        name: Build and push</span><br><span class="line">        uses: docker/build-push-action@v4</span><br><span class="line">        with:</span><br><span class="line">          context: .</span><br><span class="line">          file: ./Dockerfile</span><br><span class="line">          push: true</span><br><span class="line">          tags: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;/clockbox:latest</span><br></pre></td></tr></table></figure>

<p>运行工作流程: 保存工作流程文件并运行作业。</p>
<ol>
<li>选择提交更改…并将更改推送到main分支。推送提交后，工作流程将自动启动。</li>
<li>转到“Actions”选项卡。它显示工作流程。–选择工作流程会显示所有步骤的细分。</li>
<li>工作流程完成后，转到 Docker Hub 上的存储库。如果您在该列表中看到新的存储库，则意味着 GitHub Actions 已成功将镜像推送到 Docker Hub！</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Mesh 架构</title>
    <url>/2023/08/22/Cloud-Native/service-mesh/</url>
    <content><![CDATA[<p>微服务架构的特性</p>
<ul>
<li>围绕业务构建团队<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_1.png" class="">
<span id="more"></span></li>
<li>去中心化的数据管理<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_2.png" class=""></li>
</ul>
<p>如何管理和控制服务间的通信</p>
<ul>
<li>服务注册和发现</li>
<li>路由，流量转移</li>
<li>弹性能力（熔断、超时、重试）</li>
<li>安全（身份认证、授权）</li>
<li>可观察性（可视化）</li>
</ul>
<h5 id="Service-Mesh-演进"><a href="#Service-Mesh-演进" class="headerlink" title="Service Mesh 演进"></a>Service Mesh 演进</h5><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_3.png" class="">

<h5 id="Service-Mesh-定义"><a href="#Service-Mesh-定义" class="headerlink" title="Service Mesh 定义"></a>Service Mesh 定义</h5><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_4.png" class="">

<h5 id="Service-Mesh-产品形态"><a href="#Service-Mesh-产品形态" class="headerlink" title="Service Mesh 产品形态"></a>Service Mesh 产品形态</h5><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_5.png" class="">
<p><code>service mesh</code> 是<code>sidecar</code>的网络拓扑模式</p>
<h5 id="Service-Mesh-主要功能"><a href="#Service-Mesh-主要功能" class="headerlink" title="Service Mesh 主要功能"></a>Service Mesh 主要功能</h5><ul>
<li>流量控制：路由:（负载均衡、蓝绿部署、灰度发布、AB测试）、流量转移、超时重试、熔断、故障注入、流量镜像</li>
<li>策略：黑、白名单、流量限制</li>
<li>网络安全：授权、身份认证</li>
<li>可观测性：指标收集和展示、日志收集、分布式追踪</li>
</ul>
<h5 id="Service-Mesh-与-Kubernetes的关系"><a href="#Service-Mesh-与-Kubernetes的关系" class="headerlink" title="Service Mesh 与 Kubernetes的关系"></a>Service Mesh 与 Kubernetes的关系</h5><ul>
<li><p>kubernetes</p>
<ol>
<li>解决容器编排和调度的问题</li>
<li>本质上是管理应用的生命周期（调度器）</li>
<li>给予<code>service mesh</code> 支持和帮助</li>
</ol>
</li>
<li><p>service mesh</p>
<ol>
<li>解决服务间网络通信的问题</li>
<li>本质上是管理服务通信（代理）</li>
<li>是对<code>kubernetes</code>网络功能方面的扩展和延伸</li>
</ol>
</li>
</ul>
<h5 id="Service-Mesh-与-API网关的异同点"><a href="#Service-Mesh-与-API网关的异同点" class="headerlink" title="Service Mesh 与 API网关的异同点"></a>Service Mesh 与 API网关的异同点</h5><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_6.png" class="asset_img">
<ul>
<li>功能有重叠，但角色不同</li>
<li><code>Service Mesh</code> 在应用内，API网关在应用之上（边界）</li>
</ul>
<h5 id="Service-Mesh产品发展史"><a href="#Service-Mesh产品发展史" class="headerlink" title="Service Mesh产品发展史"></a>Service Mesh产品发展史</h5><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_7.png" class="">

<h5 id="Istio-的流量控制能力"><a href="#Istio-的流量控制能力" class="headerlink" title="Istio 的流量控制能力"></a>Istio 的流量控制能力</h5><ul>
<li>路由(负载均衡)、流量转移</li>
<li>流量进出</li>
<li>网络弹性能力（熔断、超时控制）</li>
<li>测试相关</li>
</ul>
<h6 id="核心资源"><a href="#核心资源" class="headerlink" title="核心资源"></a>核心资源</h6><ul>
<li>虚拟服务（<code>Virtual Service</code>）</li>
<li>目标规则（<code>Destination Rule</code>）</li>
<li>网关（<code>Gateway</code>）</li>
<li>服务入口（<code>Service Entry</code>）</li>
<li><code>SideCar</code></li>
</ul>
<h6 id="虚拟服务"><a href="#虚拟服务" class="headerlink" title="虚拟服务"></a>虚拟服务</h6><ul>
<li>将流量路由到给定目标地址</li>
<li>请求地址与真实的工作负载解耦</li>
<li>包含一组路由规则</li>
<li>通常和目标规则（<code>destnation rule</code>）成堆出现</li>
<li>丰富的路由匹配规则<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_8.png" class=""></li>
</ul>
<h6 id="目标规则"><a href="#目标规则" class="headerlink" title="目标规则"></a>目标规则</h6><ul>
<li>定义虚拟服务路由目标地址的真实地址，即子集（<code>subset</code>）</li>
<li>设置负载均衡的方式（随机、轮询、权重、最小请求数）<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_9.png" class=""></li>
</ul>
<h6 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h6><ul>
<li>管理进出网格的流量</li>
<li>处在网格的边界<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_10.png" class=""></li>
</ul>
<h6 id="服务入口"><a href="#服务入口" class="headerlink" title="服务入口"></a>服务入口</h6><ul>
<li>把外部服务注册到网格中</li>
<li>功能（为外部目标转发请求；添加超时重试等策略；扩展网格）<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_11.png" class=""></li>
</ul>
<h6 id="SideCar"><a href="#SideCar" class="headerlink" title="SideCar"></a>SideCar</h6><ul>
<li>调整<code>Envoy</code>代理接管的端口和协议</li>
<li>限制<code>Envoy</code>代理可访问的服务<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_12.png" class=""></li>
</ul>
<h6 id="网络弹性和测试"><a href="#网络弹性和测试" class="headerlink" title="网络弹性和测试"></a>网络弹性和测试</h6><ul>
<li>弹性能力：超时、重试、熔断</li>
<li>测试能力：故障注入、流量镜像</li>
</ul>
<h5 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h5><ul>
<li>从开发者的角度探究系统的运行状态</li>
<li>组成：指标、日志、追踪<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_13.png" class=""></li>
</ul>
<h6 id="指标（Metrics）"><a href="#指标（Metrics）" class="headerlink" title="指标（Metrics）"></a>指标（Metrics）</h6><ul>
<li>以聚合的方式监控和理解系统的行为</li>
<li><code>Istio</code>指标的分类（1.<strong>代理级别的指标</strong>,收集目标是<code>sidecar</code>代理，资源粒度上的网格监控，容许指定收集的代理，主要用于针对性的调试；2.<strong>服务级别的指标</strong>，用于监控服务通信，四个基本的服务监控需求是延迟、流量、错误、饱和，默认指标导出到<code>Prometheus</code>，并且可自定更改。可根据需求开启和关闭；3.<strong>控制平面指标</strong>，对自身组件行为的监控，用于了解网络的健康情况）</li>
</ul>
<h6 id="访问日志（Access-Logs）"><a href="#访问日志（Access-Logs）" class="headerlink" title="访问日志（Access Logs）"></a>访问日志（Access Logs）</h6><ul>
<li>通过应用产生的事件来了解系统</li>
<li>包括了完整的元数据信息（目标、源）</li>
<li>生成位置可选（本地，远端，如<code>filebeat</code>）</li>
<li>日志内容<ul>
<li>应用日志</li>
<li>Envoy日志</li>
</ul>
</li>
</ul>
<h6 id="分布式追踪（Distributed-tracing）"><a href="#分布式追踪（Distributed-tracing）" class="headerlink" title="分布式追踪（Distributed tracing）"></a>分布式追踪（Distributed tracing）</h6><ul>
<li>通过追踪请求，了解服务的调用关系</li>
<li>常用于调用链路的问题排查、性能分析</li>
<li>支持多种追踪系统（<code>jeager、Zipkin、DataDog</code>）</li>
</ul>
<h5 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h5><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_14.png" class="">

<ul>
<li>身份认证（authentication）：证书管理、证书认证，<code>You are who you say you are</code></li>
<li>访问授权（authoriztaion）：授权策略, <code>You can do what you want to do</code></li>
<li>验证（vaildation）：输入验证, <code>Input is correct</code></li>
</ul>
<h6 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h6><ul>
<li>认证方式<ul>
<li>对等认证：用于服务间身份认证。 <code>Mutual（mTLS）</code></li>
<li>请求认证：用于终端用户身份认证；<code>Json Web Token(JWT)</code></li>
</ul>
</li>
<li>认证策略<ul>
<li>配置方式：<code>yaml</code>配置文件</li>
<li>配置生效范围：网格-全网格生效、按命名空间生效、按服务（工作负载）生效</li>
<li>策略更新：</li>
</ul>
</li>
<li>支持兼容模式<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_15.png" class=""></li>
</ul>
<p>认证策略同步到数据面的方式为：<br>阶段一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对等认证-----设置mTLS----兼容模式</span><br><span class="line">                          </span><br><span class="line">                          </span><br><span class="line">                       严格模式</span><br><span class="line"></span><br><span class="line">                (新)jwt</span><br><span class="line">              /      \</span><br><span class="line">             /        \</span><br><span class="line">身份认证                 策略</span><br><span class="line">             \        /</span><br><span class="line">              \      /</span><br><span class="line">                (旧)jwt</span><br></pre></td></tr></table></figure>
<p>阶段二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对等认证-----设置mTLS----严格模式</span><br><span class="line">                          </span><br><span class="line">                          </span><br><span class="line">                       严格模式</span><br><span class="line"></span><br><span class="line">                (新)jwt</span><br><span class="line">            /      \</span><br><span class="line">           /        \</span><br><span class="line">身份认证                 策略</span><br><span class="line">           \         </span><br><span class="line">            \     </span><br><span class="line">                (旧)jwt</span><br></pre></td></tr></table></figure>

<h6 id="访问授权"><a href="#访问授权" class="headerlink" title="访问授权"></a>访问授权</h6><ul>
<li>授权级别</li>
<li>策略分发</li>
<li>授权引擎</li>
<li>无需显示启用<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_18.png" class=""></li>
</ul>
<p>大致分为三种方式：</p>
<ul>
<li>按网格授权</li>
<li>按命名空间授权</li>
<li>按服务（工作负载）授权</li>
</ul>
<p>授权策略：配置通过<code>AuthorizationPolicy</code>实现；组成部分：选择器（<code>selector</code>）;行为(<code>Action</code>); 规则列表(<code>Rules</code>)：来源（<code>from</code>）、操作(<code>to</code>)、匹配条件(<code>when</code>);范围设置：<code>metadata/namespace,selector</code>; 值匹配：精确、模糊、前缀、后缀；全部允许和拒绝；自定义条件。</p>
<h6 id="安全发现服务（SDS）"><a href="#安全发现服务（SDS）" class="headerlink" title="安全发现服务（SDS）"></a>安全发现服务（SDS）</h6><ul>
<li>身份和证书管理</li>
<li>实现安全配置自动化</li>
<li>中心化<code>SDS Server</code></li>
<li>优点：无需挂载secret卷；动态更新证书，无需重启；可监视多个证书密钥对<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_31.png" class=""></li>
</ul>
<h6 id="双向验证-mTLS"><a href="#双向验证-mTLS" class="headerlink" title="双向验证 (mTLS)"></a>双向验证 (mTLS)</h6><ul>
<li><code>TLS</code>：客户端根据服务端证书验证其身份</li>
<li><code>mTLS</code>：客户端、服务器端彼此都验证对方身份</li>
</ul>
<h6 id="身份认证及授权（JWT）"><a href="#身份认证及授权（JWT）" class="headerlink" title="身份认证及授权（JWT）"></a>身份认证及授权（JWT）</h6><ul>
<li><code>Json Web Token</code></li>
<li>以<code>json</code>格式传递信息</li>
<li>应用场景：授权和信息交换</li>
<li>组成部分：<code>Header、Payload、Signature</code><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_32.png" class=""></li>
</ul>
<h5 id="调试及测试"><a href="#调试及测试" class="headerlink" title="调试及测试"></a>调试及测试</h5><h6 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h6><ul>
<li><code>Netflix</code>的 <code>Chaos Monkey</code></li>
<li>混沌工程（<code>Chaos engineering</code>）<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_22.png" class="">
配置延迟故障<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_23.png" class=""></li>
</ul>
<h6 id="流量镜像（Traffic-Mirroring）"><a href="#流量镜像（Traffic-Mirroring）" class="headerlink" title="流量镜像（Traffic Mirroring）"></a>流量镜像（Traffic Mirroring）</h6><ul>
<li>实时复制请求到镜像服务</li>
<li>应用场景：1.线上问题排查(<code>troubleshooting</code>)；2.观察生产环境的请求处理能力(压力测试)；3.复制请求信息用于分析</li>
</ul>
<h5 id="Istio-安装部署"><a href="#Istio-安装部署" class="headerlink" title="Istio 安装部署"></a>Istio 安装部署</h5><ol>
<li>安装K8s</li>
<li>安装 <code>Istio</code></li>
<li>部署官方 <code>Demo</code> 体验 <code>Istio</code></li>
</ol>
<h6 id="安装K8S"><a href="#安装K8S" class="headerlink" title="安装K8S"></a>安装K8S</h6><p>请参见<a href="https://minikube.sigs.k8s.io/docs/start/"><code>minikubte download</code></a> 略</p>
<h6 id="下载-Istio"><a href="#下载-Istio" class="headerlink" title="下载 Istio"></a>下载 Istio</h6><ul>
<li>在线下载：<code>curl -L https://istio.io/downloadIstio | sh -</code></li>
<li>离线下载：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget https://github.com/istio/istio/releases/download/1.18.2/istio-1.18.2-linux-amd64.tar.gz</span><br><span class="line">...</span><br><span class="line">tar -zxvf istio-1.18.2-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
压缩包里包含以下内容:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@vela istio-1.18.1]<span class="comment"># ll</span></span><br><span class="line">drwxr-x---  2 root root    22 Jul 14 04:37 bin</span><br><span class="line">-rw-r--r--  1 root root 11348 Jul 14 04:37 LICENSE</span><br><span class="line">drwxr-xr-x  5 root root    52 Jul 14 04:37 manifests</span><br><span class="line">-rw-r-----  1 root root   986 Jul 14 04:37 manifest.yaml</span><br><span class="line">-rw-r--r--  1 root root  6595 Jul 14 04:37 README.md</span><br><span class="line">drwxr-xr-x 24 root root  4096 Jul 14 04:37 samples</span><br><span class="line">drwxr-xr-x  3 root root    57 Jul 14 04:37 tools</span><br><span class="line"></span><br></pre></td></tr></table></figure>
各个目录的作用：</li>
<li><code>bin</code>：存放的是 <code>istioctl</code> 工具</li>
<li><code>manifests</code>：相关 <code>yaml</code> 用于部署 <code>Istio</code></li>
<li><code>samples</code>：一些 <code>Demo</code> 用的 <code>yaml</code></li>
<li><code>tools</code>：一些工具，暂时使用不到<br>先将<code>istioctl</code>工具 <code>cp</code> 到 <code>bin</code> 目录下，便于后续使用 <code>istioctl</code> 命令。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> bin/istioctl /usr/local/bin/</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="安装-Istio"><a href="#安装-Istio" class="headerlink" title="安装 Istio"></a>安装 Istio</h6><blockquote>
<p>由于易用性的问题，Istio 废弃了以前的 Helm 安装方式，现在使用 istioctl 即可一键安装。<br><code>Istio</code> 提供了以下配置档案（<code>configuration profile</code>）供不同场景使用，查看当前内置的 <code>profile</code>：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl profile list</span><br><span class="line">Istio configuration profiles:</span><br><span class="line">    default</span><br><span class="line">    demo</span><br><span class="line">    empty</span><br><span class="line">    external</span><br><span class="line">    minimal</span><br><span class="line">    openshift</span><br><span class="line">    preview</span><br><span class="line">    remote</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体每个 <code>profile</code> 包含哪些组件，可以使用<code>istioctl profile dump</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl profile dump demo</span><br></pre></td></tr></table></figure>
<p>对于演示环境，我们直接安装 demo 版本就可以了 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo -y</span><br><span class="line"></span><br><span class="line">✔ Istiod installed                                       </span><br><span class="line">✔ Ingress gateways installed                             </span><br><span class="line">✔ Egress gateways installed                             </span><br><span class="line">✔ Installation complete</span><br><span class="line">Making this installation the default <span class="keyword">for</span> injection and validation.</span><br></pre></td></tr></table></figure>
<p>部署完成后,这里k8s先需要创建一个命名空间, 然后给命名空间打上 label，告诉 Istio 在部署应用的时候，自动注入 Envoy 边车代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create namspace `k8s-istio`</span><br><span class="line">...</span><br><span class="line">$ kubectl label namespace `k8s-istio` istio-injection=enabled</span><br></pre></td></tr></table></figure>
<p>安装后可以验证是否安装正确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先根据安装的profile导出manifest</span></span><br><span class="line">istioctl manifest generate --<span class="built_in">set</span> profile=demo &gt; <span class="variable">$HOME</span>/generated-manifest.yaml</span><br><span class="line"><span class="comment"># 然后根据验证实际环境和manifest文件是否一致</span></span><br><span class="line">istioctl verify-install -f <span class="variable">$HOME</span>/generated-manifest.yaml</span><br><span class="line"><span class="comment"># 出现下面信息则表示验证通过</span></span><br><span class="line">✔ Istio is installed and verified successfully</span><br></pre></td></tr></table></figure>
<p>查看一下安装了些什么东西：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -n istio-system</span><br><span class="line"></span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-75db994b58-jlc28    1/1     Running   0          38m</span><br><span class="line">istio-ingressgateway-79bb75ddbb-dmm87   1/1     Running   0          38m</span><br><span class="line">istiod-68cb9f5cb6-h5fcv                 1/1     Running   0          39m</span><br></pre></td></tr></table></figure>
<p>可以看到只安装了出入站网关以及最重要的 Istiod 服务。再看下 CRD 情况:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get crds |grep istio</span><br><span class="line"></span><br><span class="line">authorizationpolicies.security.istio.io    2023-08-24T05:12:04Z</span><br><span class="line">destinationrules.networking.istio.io       2023-08-24T05:12:04Z</span><br><span class="line">envoyfilters.networking.istio.io           2023-08-24T05:12:04Z</span><br><span class="line">gateways.networking.istio.io               2023-08-24T05:12:04Z</span><br><span class="line">istiooperators.install.istio.io            2023-08-24T05:12:04Z</span><br><span class="line">peerauthentications.security.istio.io      2023-08-24T05:12:04Z</span><br><span class="line">proxyconfigs.networking.istio.io           2023-08-24T05:12:04Z</span><br><span class="line">requestauthentications.security.istio.io   2023-08-24T05:12:04Z</span><br><span class="line">serviceentries.networking.istio.io         2023-08-24T05:12:04Z</span><br><span class="line">sidecars.networking.istio.io               2023-08-24T05:12:04Z</span><br><span class="line">telemetries.telemetry.istio.io             2023-08-24T05:12:04Z</span><br><span class="line">virtualservices.networking.istio.io        2023-08-24T05:12:04Z</span><br><span class="line">wasmplugins.extensions.istio.io            2023-08-24T05:12:05Z</span><br><span class="line">workloadentries.networking.istio.io        2023-08-24T05:12:05Z</span><br><span class="line">workloadgroups.networking.istio.io         2023-08-24T05:12:05Z</span><br></pre></td></tr></table></figure>
<p>这些就是 istio 需要用到的 CRD 了，比较常见的比如：</p>
<ul>
<li><code>gateways</code></li>
<li><code>virtualservices</code></li>
<li><code>destinationrules</code></li>
</ul>
<h6 id="部署-bookinfo-应用"><a href="#部署-bookinfo-应用" class="headerlink" title="部署 bookinfo 应用"></a>部署 bookinfo 应用</h6><p>官方提供了 <code>bookinfo</code> 应用来演示 <code>Istio</code> 相关功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line"></span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details created</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings created</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews created</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage created</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure>

<p><strong>部署应用</strong><br>在 <code>k8s-istio</code> 命名空间创建了应用对应的 <code>service</code> 和 <code>deployment</code>。服务启动需要一定时间，可通过以下命令进行查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   10.106.81.196   &lt;none&gt;        9080/TCP   54m</span><br><span class="line">kubernetes    ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    19h</span><br><span class="line">productpage   ClusterIP   10.103.139.13   &lt;none&gt;        9080/TCP   54m</span><br><span class="line">ratings       ClusterIP   10.102.135.80   &lt;none&gt;        9080/TCP   54m</span><br><span class="line">reviews       ClusterIP   10.103.83.28    &lt;none&gt;        9080/TCP   54m</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS              RESTARTS   AGE</span><br><span class="line">details-v1-698b5d8c98-p5kwm       0/1     ContainerCreating   0          37s</span><br><span class="line">productpage-v1-75875cf969-frn4z   0/1     ContainerCreating   0          35s</span><br><span class="line">ratings-v1-5967f59c58-zbldg       0/1     ContainerCreating   0          36s</span><br><span class="line">reviews-v1-9c6bb6658-kztz7        0/1     ContainerCreating   0          36s</span><br><span class="line">reviews-v2-8454bb78d8-jzghc       0/1     ContainerCreating   0          36s</span><br><span class="line">reviews-v3-6dc9897554-qvn7g       0/1     ContainerCreating   0          36s</span><br></pre></td></tr></table></figure>
<p>等 <code>pod</code> 都启动后，通过以下命令测试应用是否正常启动了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> <span class="string">&quot;<span class="subst">$(kubectl get pod -l app=ratings -o jsonpath=&#x27;&#123;.items[0].metadata.name&#125;&#x27;)</span>&quot;</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">&quot;&lt;title&gt;.*&lt;/title&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>输出以下内容就算成功:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Simple Bookstore App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>部署网关</strong><br>此时，BookInfo 应用已经部署，但还不能被外界访问。需要借助网关才行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure>
<p>可以看到， 这里部署了一个网关（<code>gateway</code>）和一个虚拟服务（<code>virtualservice</code>）。此时在浏览器中，输入<code>http://localhost/productpage</code>应该可以访问到具体页面了。<br>确保配置文件没有问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl analyze</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure>
<p>确定ingress的ip和端口，外部访问则需要通过 <code>NodePort</code> 访问:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl -n  istio-system get svc istio-ingressgateway</span><br><span class="line">NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.108.211.196   &lt;pending&gt;     15021:31160/TCP,80:32096/TCP,443:30055/TCP,31400:31682/TCP,15443:30083/TCP   22m</span><br></pre></td></tr></table></figure>
<p>可以看到，80 端口对应的 <code>NodePort</code> 为 32096,那么直接访问的 <code>URL</code> 就是：<code>http://$IP:32096/productpage</code>。</p>
<p>在新的终端窗口中运行此命令以启动一个 Minikube 隧道，将流量发送到 Istio Ingress Gateway。 这将为 service&#x2F;istio-ingressgateway 提供一个外部负载均衡器 EXTERNAL-IP。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ minikube tunnel</span><br><span class="line"></span><br><span class="line">Status:	</span><br><span class="line">	machine: minikube</span><br><span class="line">	pid: 1462709</span><br><span class="line">	route: 10.96.0.0/12 -&gt; 192.168.49.2</span><br><span class="line">	minikube: Running</span><br><span class="line">	services: [istio-ingressgateway]</span><br><span class="line">    errors: </span><br><span class="line">		minikube: no errors</span><br><span class="line">		router: no errors</span><br><span class="line">		loadbalancer emulator: no errors</span><br></pre></td></tr></table></figure>
<p>设置入站主机和端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.status.loadBalancer.ingress[0].ip&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].port&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].port&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>设置环境变量 GATEWAY_URL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br></pre></td></tr></table></figure>
<p>确保 IP 地址和端口均成功地赋值给了环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$GATEWAY_URL</span>&quot;</span></span><br><span class="line">192.168.99.100:32194</span><br></pre></td></tr></table></figure>
<p>用浏览器查看 Bookinfo 应用的产品页面，验证 Bookinfo 已经实现了外部访问。</p>
<h6 id="查看仪表盘（Dashboard）"><a href="#查看仪表盘（Dashboard）" class="headerlink" title="查看仪表盘（Dashboard）"></a>查看仪表盘（Dashboard）</h6><p><code>Istio</code> 也提供了 <code>Dashboard</code>，可以通过UI 界面更加方便的进行管理，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/addons</span><br></pre></td></tr></table></figure>
<p>等待安装完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl rollout status deployment/kiali -n istio-system</span><br><span class="line">...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">&quot;kiali&quot;</span> rollout to finish: 0 of 1 updated replicas are available..</span><br><span class="line">kubectl rollout status deployment/kiali -n istio-system.</span><br></pre></td></tr></table></figure>

<p>访问 bashboard：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Kiali 和其他插件，等待部署完成。</span></span><br><span class="line">$ kubectl apply -f samples/addons</span><br><span class="line">$ kubectl rollout status deployment/kiali -n istio-system</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">&quot;kiali&quot;</span> rollout to finish: 0 of 1 updated replicas are available...</span><br><span class="line">deployment <span class="string">&quot;kiali&quot;</span> successfully rolled out</span><br><span class="line"><span class="comment"># 访问 Kiali 仪表板。</span></span><br><span class="line">$ istioctl dashboard kiali</span><br></pre></td></tr></table></figure>
<p>外部访问则把 <code>service</code> 改成 <code>nodeport</code> 类型即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl -n istio-system  patch svc kiali -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;type&quot;:&quot;NodePort&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>查看修改后的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl -n istio-system get svc kiali</span><br><span class="line">NAME    TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                          AGE</span><br><span class="line">kiali   NodePort   10.101.47.41   &lt;none&gt;        20001:31989/TCP,9090:32136/TCP   4m14s</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://$IP:31989</code> 即可，在主界面可以看到部署的服务以及请求量、资源使用量等情况。在 <code>Graph</code> 界面则能够看到，服务间流量分发情况。由于之前部署的 <code>bookinfo</code> 服务没怎么访问，所以界面是空白的，先通过 <code>curl</code> 命令访问一下。在左侧的导航菜单，选择 Graph ，然后在 Namespace 下拉列表中，选择 istio-system 。</p>
<blockquote>
<p><strong>要查看追踪数据，必须向服务发送请求。请求的数量取决于 Istio 的采样率。 采样率在安装 <code>Istio</code> 时设置，默认采样速率为 1%。在第一个跟踪可见之前，您需要发送至少 100 个请求。 使用以下命令向 <code>productpage</code> 服务发送 100 个请求：</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">seq</span> 1 100`; <span class="keyword">do</span> curl -s -o /dev/null http://<span class="variable">$GATEWAY_URL</span>/productpage; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>Kiali</code> 仪表板展示了网格的概览以及 <code>Bookinfo</code> 示例应用的各个服务之间的关系。 它还提供过滤器来可视化流量的流动。</p>
<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_21.png" class="">

<h6 id="卸载-Istio"><a href="#卸载-Istio" class="headerlink" title="卸载 Istio"></a>卸载 Istio</h6><p>以下命令卸载 Istio 并删除所有相关资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl delete -f samples/addons</span><br><span class="line">$ istioctl x uninstall --purge -y</span><br></pre></td></tr></table></figure>
<p>删除 <code>namespace</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete namespace k8s-istio</span><br></pre></td></tr></table></figure>
<p>移除之前打的 <code>label</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl label namespace default istio-injection-</span><br></pre></td></tr></table></figure>
<p>到这里，Istio 的安装就结束了，后续就可以用起来了。</p>
<h5 id="Istio-遥测（Telemetry）"><a href="#Istio-遥测（Telemetry）" class="headerlink" title="Istio 遥测（Telemetry）"></a>Istio 遥测（Telemetry）</h5><p><code>Istio</code> 服务网格最受欢迎和最强大的功能之一是其高级可观察性。由于所有服务到服务的通信都是通过 <code>Envoy</code> 代理进行路由，并且 <code>Istio</code> 的控制平面能够从这些代理收集日志和指标，因此服务网格可以为我们提供有关网络状态和服务行为的数据。这为运营商提供了独特的故障排除、管理和优化服务的方法，而不会给应用程序开发人员带来任何额外的负担。</p>
<h6 id="Istio-遥测指标"><a href="#Istio-遥测指标" class="headerlink" title="Istio 遥测指标"></a>Istio 遥测指标</h6><ul>
<li><p>代理级别指标<br>代理级别指标是 <code>Envoy</code> 代理本身提供的有关所有直通流量的标准指标，以及有关代理管理功能的详细统计信息，包括配置和运行状况信息。Envoy 生成的指标存在于 Envoy 资源（例如监听器和集群）的粒度级别。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># TYPE envoy_cluster_internal_upstream_rq_200 counter</span><br><span class="line">envoy_cluster_internal_upstream_rq_200<span class="punctuation">&#123;</span>cluster_name=<span class="string">&quot;xds-grpc&quot;</span><span class="punctuation">&#125;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># TYPE envoy_cluster_upstream_rq_200 counter</span><br><span class="line">envoy_cluster_upstream_rq_200<span class="punctuation">&#123;</span>cluster_name=<span class="string">&quot;xds-grpc&quot;</span><span class="punctuation">&#125;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># TYPE envoy_cluster_upstream_rq_completed counter</span><br><span class="line">envoy_cluster_upstream_rq_completed<span class="punctuation">&#123;</span>cluster_name=<span class="string">&quot;xds-grpc&quot;</span><span class="punctuation">&#125;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># TYPE envoy_cluster_internal_upstream_rq_503 counter</span><br><span class="line">envoy_cluster_internal_upstream_rq_503<span class="punctuation">&#123;</span>cluster_name=<span class="string">&quot;xds-grpc&quot;</span><span class="punctuation">&#125;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># TYPE envoy_cluster_upstream_cx_rx_bytes_total counter</span><br><span class="line">envoy_cluster_upstream_cx_rx_bytes_total<span class="punctuation">&#123;</span>cluster_name=<span class="string">&quot;xds-grpc&quot;</span><span class="punctuation">&#125;</span> <span class="number">2056154</span></span><br><span class="line"></span><br><span class="line"># TYPE envoy_server_memory_allocated gauge</span><br><span class="line">envoy_server_memory_allocated<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> <span class="number">15853480</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务级别指标<br>除了代理级别的指标之外，<code>Istio</code> 还提供了一组面向服务的指标来监控服务通信。这些指标涵盖了四种基本服务监控需求：延迟、流量、错误和饱和度。<code>Istio</code> 附带了一组默认的仪表板，用于根据这些指标监控服务行为。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># TYPE istio_requests_total counter</span><br><span class="line">istio_requests_total<span class="punctuation">&#123;</span></span><br><span class="line">    connection_security_policy=<span class="string">&quot;mutual_tls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_app=<span class="string">&quot;analytics&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_principal=<span class="string">&quot;cluster.local/ns/backyards-demo/sa/default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_service=<span class="string">&quot;analytics.backyards-demo.svc.cluster.local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_service_name=<span class="string">&quot;analytics&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_service_namespace=<span class="string">&quot;backyards-demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_version=<span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_workload=<span class="string">&quot;analytics-v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    destination_workload_namespace=<span class="string">&quot;backyards-demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    permissive_response_code=<span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">    permissive_response_policyid=<span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">    reporter=<span class="string">&quot;destination&quot;</span><span class="punctuation">,</span></span><br><span class="line">    request_protocol=<span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">    response_code=<span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    response_flags=<span class="string">&quot;-&quot;</span><span class="punctuation">,</span></span><br><span class="line">    source_app=<span class="string">&quot;bookings&quot;</span><span class="punctuation">,</span></span><br><span class="line">    source_principal=<span class="string">&quot;cluster.local/ns/backyards-demo/sa/default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    source_version=<span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    source_workload=<span class="string">&quot;bookings-v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    source_workload_namespace=<span class="string">&quot;backyards-demo&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span> <span class="number">1855</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="Istio-遥测架构-v2"><a href="#Istio-遥测架构-v2" class="headerlink" title="Istio 遥测架构 v2"></a>Istio 遥测架构 v2</h6><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_24.png" class="">
<blockquote>
<p>根据 <code>Istio</code> 文档，新的遥测系统将延迟减少了一半 - 90% 的延迟已从 7 毫秒减少到 3.3 毫秒。不仅如此，<code>Mixer</code> 的消除还使总 <code>CPU</code> 消耗减少了 50%，达到每秒每 1,000 个请求 0.55 个 <code>vCPU</code>。</p>
</blockquote>
<h6 id="WASM架构"><a href="#WASM架构" class="headerlink" title="WASM架构"></a>WASM架构</h6><p><code>WebAssembly</code>（通常缩写为 <code>WASM</code>）是一种开放标准，它定义了可执行程序的可移植二进制代码格式、相应的文本汇编语言以及促进程序与其主机环境之间交互的接口。<code>WebAssembly</code> 的主要目标是在网页上启用高性能应用程序，但该格式也设计用于在其他环境中执行和集成。它提供了一个基于精简堆栈的虚拟机，允许 <code>Web</code> 应用程序通过利用快速加载的二进制格式以接近本机的速度运行，该格式也可以转换为文本格式以进行调试。而且，虽然 <code>WebAssembly</code> 最初是作为客户端技术出现的，但在服务器端使用它有很多优点。<code>Istio</code> 社区一直在领导 <code>Envoy</code> 的 <code>WebAssembly</code> (<code>WASM</code>) 运行时的实现。该实现使用基于 <code>Google</code> 高性能<code>V8</code> 引擎构建的 <code>WebAssembly</code> 运行时。借助 Envoy 的 <code>WebAssembly</code> 插件，开发人员可以编写自定义代码，将其编译为 <code>WebAssembly</code> 插件，并配置 <code>Envoy</code> 来执行它。</p>
<p><code>Telemetry V2</code> 中的代理内服务级别指标由两个自定义插件提供，</p>
<ul>
<li><p><code>metadata-exchange</code>：必须解决的第一个问题是如何在代理中提供有关连接两端的客户端&#x2F;服务器元数据。对于基于 <code>HTTP</code> 的流量，这是通过包含对方元数据属性的请求&#x2F;响应中的自定义 <code>HTTP</code> 标头 (<code>envoy.wasm.metadata_exchange.upstream、envoy.wasm.metadata_exchange.downstream</code>) 来完成的。对于通用 <code>TCP</code> 流量，元数据交换使用基于 <code>ALPN</code> 的隧道和基于前缀的协议。定义了一个新协议<code>istio-peer-exchange</code>，该协议由网格中的客户端和服务器 <code>sidecar</code> 进行通告和优先级排序。<code>ALPN</code> 协商将协议解析为 <code>istio-peer-exchange</code>，用于启用 <code>Istio</code> 的代理之间的连接，但不解析启用 <code>Istio</code> 的代理和任何客户端之间的连接。</p>
</li>
<li><p><code>stats</code>：<code>stats</code> 插件将传入和传出的流量指标记录到 <code>Envoy</code> 统计子系统中，并可供 <code>Prometheus</code> 抓取。以下是服务级别指标的默认标签。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">eporter<span class="punctuation">:</span> conditional((context.reporter.kind | <span class="string">&quot;inbound&quot;</span>) == <span class="string">&quot;outbound&quot;</span><span class="punctuation">,</span> <span class="string">&quot;source&quot;</span><span class="punctuation">,</span> <span class="string">&quot;destination&quot;</span>)</span><br><span class="line">source_workload<span class="punctuation">:</span> source.workload.name | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">source_workload_namespace<span class="punctuation">:</span> source.workload.namespace | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">source_principal<span class="punctuation">:</span> source.principal | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">source_app<span class="punctuation">:</span> source.labels<span class="punctuation">[</span><span class="string">&quot;app&quot;</span><span class="punctuation">]</span> | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">source_version<span class="punctuation">:</span> source.labels<span class="punctuation">[</span><span class="string">&quot;version&quot;</span><span class="punctuation">]</span> | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_workload<span class="punctuation">:</span> destination.workload.name | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_workload_namespace<span class="punctuation">:</span> destination.workload.namespace | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_principal<span class="punctuation">:</span> destination.principal | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_app<span class="punctuation">:</span> destination.labels<span class="punctuation">[</span><span class="string">&quot;app&quot;</span><span class="punctuation">]</span> | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_version<span class="punctuation">:</span> destination.labels<span class="punctuation">[</span><span class="string">&quot;version&quot;</span><span class="punctuation">]</span> | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_service<span class="punctuation">:</span> destination.service.host | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_service_name<span class="punctuation">:</span> destination.service.name | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">destination_service_namespace<span class="punctuation">:</span> destination.service.namespace | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">request_protocol<span class="punctuation">:</span> api.protocol | context.protocol | <span class="string">&quot;unknown&quot;</span></span><br><span class="line">response_code<span class="punctuation">:</span> response.code | <span class="number">200</span></span><br><span class="line">connection_security_policy<span class="punctuation">:</span> conditional((context.reporter.kind | <span class="string">&quot;inbound&quot;</span>) == <span class="string">&quot;outbound&quot;</span><span class="punctuation">,</span> <span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span> conditional(connection.mtls | <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="string">&quot;mutual_tls&quot;</span><span class="punctuation">,</span> <span class="string">&quot;none&quot;</span>))</span><br><span class="line">response_flags<span class="punctuation">:</span> context.proxy_error_code | <span class="string">&quot;-&quot;</span></span><br><span class="line">source_canonical_service</span><br><span class="line">source_canonical_revision</span><br><span class="line">destination_canonical_service</span><br><span class="line">destination_canonical_revision</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="Istio-的安全机制"><a href="#Istio-的安全机制" class="headerlink" title="Istio 的安全机制"></a>Istio 的安全机制</h6><ul>
<li>透明的安全层</li>
<li><code>CA</code>：秘钥和证书管理</li>
<li><code>API Server</code>：认证、授权策略分发</li>
<li><code>Envoy</code>：服务间安全通信（认证、加密）</li>
</ul>
<h5 id="Envoy-架构"><a href="#Envoy-架构" class="headerlink" title="Envoy 架构"></a>Envoy 架构</h5><h6 id="Envoy-流量五元组"><a href="#Envoy-流量五元组" class="headerlink" title="Envoy 流量五元组"></a>Envoy 流量五元组</h6><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_25.png" class="">

<h6 id="Envoy-调试关键字段（RESPONSE-FLAG）"><a href="#Envoy-调试关键字段（RESPONSE-FLAG）" class="headerlink" title="Envoy 调试关键字段（RESPONSE_FLAG）"></a>Envoy 调试关键字段（RESPONSE_FLAG）</h6><ul>
<li><code>UH：upstream_cluster</code> 中没有监控的<code>host</code>, 503</li>
<li><code>UF: upstream</code> 连接失败， 503</li>
<li><code>UO: upstream_overflow</code> (熔断)</li>
<li><code>NR:</code> 没有路由配置，404</li>
<li><code>URX:</code> 请求被拒绝因为限流或超过最大连接次数</li>
<li>… …</li>
</ul>
<h5 id="分布式追踪"><a href="#分布式追踪" class="headerlink" title="分布式追踪"></a>分布式追踪</h5><ul>
<li><p>分析和监控应用的监控方法</p>
</li>
<li><p>查找故障点，分析性能问题</p>
</li>
<li><p>观测请求范围内的信息</p>
</li>
<li><p>起源于<code>Google的Dapper</code></p>
</li>
<li><p><code>OpenTracing: API</code> 规范、框架、库的组合</p>
</li>
<li><p><code>Span</code>: 逻辑单元；有操作名、执行时间；嵌套、有序、因果关系</p>
</li>
<li><p><code>Trace</code>：数据&#x2F;执行路径；<code>Span</code>的组合</p>
<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_26.png" class=""></li>
</ul>
<h6 id="Jaejer-组件"><a href="#Jaejer-组件" class="headerlink" title="Jaejer 组件"></a>Jaejer 组件</h6><p><a href="https://www.jaegertracing.io/">分布式追踪框架 Jaejer</a> <code>Jaeger</code> 是<code>Uber Technologies</code>开源发布的分布式追踪平台。组件包括：</p>
<ul>
<li><code>Tracing SDKs</code>:<br>为了生成跟踪数据，必须对应用程序进行检测。受检测的应用程序在接收新请求时创建跨度，并将上下文信息（<code>trace id, span id, and baggage</code>）附加到传出请求。仅<code>ids</code>和<code>baggage</code>通过请求传播；不会传播所有其他分析数据，例如操作名称、时间、标签和日志。它会在后台异步导出到 <code>Jaeger</code> 后端。<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_27.png" class=""></li>
<li><code>Agent</code>: <blockquote>
<p><code>jaeger-agent</code>已弃用。<code>OpenTelemetry</code>数据可以直接发送到 <code>Jaeger</code> 后端，也可以使用 <code>OpenTelemetry Collector</code> 作为代理。</p>
</blockquote>
</li>
<li><code>Collector</code>: <code>jaeger-collector</code>接收跟踪的数据，通过管道处理数据以进行检验和清晰&#x2F;补全，并将跟踪的数据存储在数据库中。<code>jaeger-collector</code>内置了对多种数据库的支持,以及实现了可扩展插件框架用于自定义存储插件。</li>
<li><code>Query</code>: <code>jaeger-query</code>提供了从存储中检索跟踪的<code>API</code>，并托管用于搜索和分析跟踪的 <code>Web UI</code>。</li>
<li><code>Ingester</code>: <code>jaeger-ingester</code>是一项从 <code>Kafka</code> 读取跟踪并将其写入存储后端的服务。实际上，它是 <code>Jaeger</code> 收集器的精简版本，支持 <code>Kafka</code> 作为唯一的输入协议。</li>
</ul>
<h6 id="Jaejer-架构"><a href="#Jaejer-架构" class="headerlink" title="Jaejer 架构"></a>Jaejer 架构</h6><ul>
<li>直接存储模式<br>此部署方式，收集器从跟踪的应用程序接收数据并将其直接写入存储。存储必须能够处理平均流量和峰值流量。收集器使用内存队列来平滑短期流量峰值，但如果存储无法跟上，持续的流量峰值可能会导致数据丢失。收集器能够向 <code>SDK</code> 集中提供采样配置，称为远程采样模式。它们还可以启用自动采样配置计算，称为自适应采样。<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_28.png" class=""></li>
<li><code>Kafka</code>存储模式<br>为了防止收集器和存储之间的数据丢失，<code>Kafka</code> 可以用作中间的持久队列。需要部署一个附加组件<code>jaeger-ingester</code>来从 <code>Kafka</code> 读取数据并保存到数据库。可以部署多个<code>jaeger-ingester</code>来扩大摄取规模；他们会自动分配负载。<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_29.png" class=""></li>
<li>开放遥测模式<br><code>Jaeger Collectors</code> 可以直接从 <code>OpenTelemetry SDK</code> 接收 <code>OpenTelemetry</code> 数据。如果您已经使用 <code>OpenTelemetry Collectors</code>，例如用于收集其他类型的遥测数据或用于预处理&#x2F;丰富跟踪数据，则可以将其放置在 <code>SDK</code> 和 <code>Jaeger Collectors</code> 之间。<code>OpenTelemetry Collector</code> 可以作为应用程序边车、主机代理&#x2F;守护程序或中央集群运行。<code>OpenTelemetry Collector</code>支持<code>Jaeger</code> 的远程采样协议，可以直接从配置文件提供静态配置，也可以将请求代理到 <code>Jaeger</code> 后端（例如，当使用自适应采样时）。<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_30.png" class=""></li>
</ul>
<h5 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h5><h6 id="典型的CI-CD过程（DevOps）"><a href="#典型的CI-CD过程（DevOps）" class="headerlink" title="典型的CI&#x2F;CD过程（DevOps）"></a>典型的CI&#x2F;CD过程（DevOps）</h6><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_33.png" class="">
<h6 id="GitOps-持续集成-交付过程"><a href="#GitOps-持续集成-交付过程" class="headerlink" title="GitOps 持续集成&#x2F;交付过程"></a>GitOps 持续集成&#x2F;交付过程</h6><ul>
<li><code>GitOps</code>：集群管理和应用分发的持续交付方式</li>
<li>使用<code>git</code>作为信任源，保存声明式基础架构（<code>declarative infrastructure</code>）和应用程序</li>
<li>以git作为交付过程（<code>pipeline</code>）的中心</li>
<li>开发者只需通过<code>pull request</code>完成应用的部署和运维任务</li>
<li>优势：提高生产率、改进开发体验、一致性和标准化、安全<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_34.png" class=""></li>
</ul>
<h6 id="DevOps（push-pipeline）vs-GitOps（pull-pipeline）"><a href="#DevOps（push-pipeline）vs-GitOps（pull-pipeline）" class="headerlink" title="DevOps（push pipeline）vs GitOps（pull pipeline）"></a>DevOps（push pipeline）vs GitOps（pull pipeline）</h6><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_35.png" class="">

<p>优点：<code>GitOps（pull pipeline）</code>方式，部署时不用暴露安全相关的脚本操作</p>
<h6 id="Flux-介绍"><a href="#Flux-介绍" class="headerlink" title="Flux 介绍"></a>Flux 介绍</h6><p><code>Flux</code> 是一套开放、可扩展的 <code>Kubernetes</code> 持续渐进式交付解决方案。</p>
<ul>
<li>定义：<code>The GitOps operator for kubernetes</code></li>
<li>自动化部署工具（基于GitOps）</li>
<li>官方地址：<img data-src="https://fluxcd.io/" alt="Flux"></li>
<li>只需推送到 Git，Flux 就会完成剩下的工作</li>
<li>自动同步自动部署</li>
<li>声明式</li>
<li>基于代码（<code>Pull Request</code>），而不是容器<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_36.png" class=""></li>
</ul>
<h6 id="Flagger-自动化灰度发布-金丝雀部署"><a href="#Flagger-自动化灰度发布-金丝雀部署" class="headerlink" title="Flagger 自动化灰度发布(金丝雀部署)"></a>Flagger 自动化灰度发布(金丝雀部署)</h6><p><code>Flagger</code> 实现了一个控制循环，逐渐将流量转移到金丝雀，同时测量 <code>HTTP</code> 请求成功率、请求平均持续时间和 <code>Pod</code> 运行状况等关键性能指标。根据设置的阈值，金丝雀将被升级或中止，其分析将被推送到 <code>Slack</code> 通道。</p>
<ul>
<li>自动化的灰度发布工具</li>
<li>支持多种<code>Service Mesh</code>,包括(<code>istio</code>、<code>linkerd</code>、<code>app aws mesh</code>)</li>
<li>指标监控灰度发布状态</li>
<li>通知功能（接入<code>slack、microsoft term</code>）<img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_37.png" class=""></li>
</ul>
<p><code>Flagger</code>工作流程（状态流转）</p>
<ul>
<li><code>Initializing</code></li>
<li><code>Initialized</code></li>
<li><code>Progressing</code></li>
<li><code>Successed(Failed)</code><img data-src="/2023/08/22/Cloud-Native/service-mesh/service_mesh_38.png" class="">
官方地址：<a href="https://docs.flagger.app/">Flagger</a></li>
</ul>
<h5 id="弹性设计"><a href="#弹性设计" class="headerlink" title="弹性设计"></a>弹性设计</h5><p>系统&#x2F;服务的弹性能力直接决定了它的可用性，可用性的度量是由服务级别协议（SLA - Service Level Agreement）来计算的，可用性计算公式 $Availability &#x3D; \dfrac{MTBF}{MTBF + MTTR}$。</p>
<ul>
<li>应对故障的一种方法，让系统具有容错和适应能力。</li>
<li>防止故障（<code>Fault</code>）转化为失败（<code>Failure</code>）。</li>
<li>特点：包括1.容错性：重试、幂等；伸缩性：自动水平扩展（<code>autoscaling</code>）;过载保护：超时、熔断、降级、限流；弹性测试：故障注入</li>
</ul>
<p><code>Istio</code>提供的弹性能力包括：超时、重试、熔断、故障注入。</p>
]]></content>
      <categories>
        <category>Service Mesh</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>service mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bash 编程】命令行和参数</title>
    <url>/2023/08/01/Cloud-Native/%E3%80%90Bash%20%E7%BC%96%E7%A8%8B%E3%80%91command-parameter/</url>
    <content><![CDATA[<p>bash shell 是一个二进制程序，可以交互式或非交互式运行，通常在终端仿真器程序提供的基于文本的界面中运行。</p>
<p>当您从图形用户界面启动终端仿真器程序时，您将看到一个打开的窗口，其中包含文本。此窗口中显示的文本既是终端中运行的程序的输出，也是您使用键盘等发送到这些程序的字符。bash 程序只是可以在终端中运行的众多程序之一，因此请务必注意，bash 并不是使文本出现在屏幕上的原因。终端程序会处理这个问题，从 bash 中获取文本并将其放置在窗口中供您查看。终端可以对终端中运行的其他与 bash 完全无关的程序执行相同的操作，例如邮件程序或 IRC 客户端。</p>
<span id="more"></span>
<img data-src="/2023/08/01/Cloud-Native/%E3%80%90Bash%20%E7%BC%96%E7%A8%8B%E3%80%91command-parameter/bash_flow.png" class="">

<p>简而言之，程序是一组可以由系统内核执行的预先编写的指令。程序直接向内核发出指令。从技术上讲，内核也是一个程序，但它会不断运行并与硬件进行通信。</p>
<img data-src="/2023/08/01/Cloud-Native/%E3%80%90Bash%20%E7%BC%96%E7%A8%8B%E3%80%91command-parameter/bash_flow2.png" class="">

<p>如果一个程序需要其输出到另一个程序的输入（而不是您的显示），它将指示内核将其标准输出连接到另一个程序的标准输入。现在，它发送到其标准输出文件描述符的所有信息都将流入另一个程序的标准输入文件描述符。文件、设备和进程之间的这些信息流称为流。</p>
<p>流是在运行系统中的文件、设备和进程之间的链接中流动的信息（具体来说，字节）。它们可以传输任何类型的字节，并且接收端只能按照发送的顺序消耗它们的字节。如果我有一个程序输出连接到另一个程序的名称，则第二个程序只能在第一次从流中读取第一个名称后才能看到第二个名称。读取完第二个名称后，流中的下一个内容是第三个名称。从流中读取名称后，程序可以将其存储在某处，以备以后再次需要时使用。从流中读取名称会消耗流中的这些字节，并且流会前进。流无法倒回，名称也无法重新读取。</p>
<img data-src="/2023/08/01/Cloud-Native/%E3%80%90Bash%20%E7%BC%96%E7%A8%8B%E3%80%91command-parameter/bash_flow3.png" class="">

<p>在上面的示例中，两个 bash 进程通过流链接。第一个 bash 进程从键盘读取输入。它在标准输出和标准错误上发送输出。标准错误的输出连接到终端显示器，而标准输出的输出连接到第二个进程。请注意:第一个进程’ 如何FD 1连接到第二个进程’ FD 0? 第二个进程在从其标准输入读取时会消耗第一个进程的标准输出。第二个进程的标准输出又连接到终端的显示器。要尝试这种动态，您可以在终端中运行以下代码，其中(和)符号创建两个子 shell，并且|符号将前者连接FD 1到后者FD 0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$( <span class="built_in">echo</span> <span class="string">&quot;Your name?&quot;</span> &gt;&amp;2; <span class="built_in">read</span> name; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span>&quot;</span> ) | ( <span class="keyword">while</span> <span class="built_in">read</span> name; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>; <span class="keyword">done</span> )</span><br><span class="line">Your name？</span><br><span class="line">Maarten Billemont</span><br><span class="line">Hello，Maarten Billemont</span><br></pre></td></tr></table></figure>
<p>请注意，终端中显示的唯一文本是连接到终端显示屏的命令的输出，以及终端发送到程序的输入。<br>重要的是要理解文件描述符是特定于进程的：只有在引用特定进程时才有意义，“标准输出”才有意义。在上面的示例中，您会注意到第一个进程的标准输入与第二个进程的标准输入不同。您还会注意到，第一个进程的 FD 0（标准输出）连接到第二个进程的 FD 1（标准输入）。文件描述符不描述连接进程的流，它们仅描述可以连接这些流的进程的插头。</p>
<h4 id="命令和参数"><a href="#命令和参数" class="headerlink" title="命令和参数"></a>命令和参数</h4><h5 id="什么是-bash-命令呢？"><a href="#什么是-bash-命令呢？" class="headerlink" title="什么是 bash 命令呢？"></a>什么是 bash 命令呢？</h5><p><code>bash shell</code> 语言的核心是它的命令。你的命令一步一步、一个命令一个命令地告诉 <code>bash</code> 你需要它做什么。Bash 通常一次接受您的一个命令，执行该命令，完成后返回给您执行下一个命令。我们称之为同步命令执行。重要的是要理解，当 bash 忙于处理您给它的命令时，您无法直接与 bash 交互：您必须等待它准备好执行其命令并返回到脚本。对于大多数命令，您几乎不会注意到这一点：它们执行得如此之快，bash 将在您意识到之前返回下一个命令。</p>
<p>不过，某些命令可能需要很长时间才能完成。特别是启动可以与之交互的其他程序的命令。例如，命令可能会启动文件编辑器。当您与文件编辑器交互时，bash 会退居二线并等待文件编辑器结束（这通常意味着您退出它）。当文件编辑器程序停止运行时，命令结束，bash 通过询问您下一步要做的事情来恢复操作。您会注意到，当编辑器运行时，您不再处于 bash 提示符处。一旦编辑器退出，bash 提示符就会重新出现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ exbash <span class="built_in">command</span> to run the <span class="string">&quot;ex&quot;</span> program.</span><br><span class="line">: iex <span class="built_in">command</span> to <span class="string">&quot;insert&quot;</span> some text.</span><br><span class="line">Hello!</span><br><span class="line">.A line with just a dot tells ex to stop inserting text.</span><br><span class="line">: w greeting.txtex <span class="built_in">command</span> to <span class="string">&quot;write&quot;</span> the text to a file.</span><br><span class="line"><span class="string">&quot;greeting.txt&quot;</span> [New] 1L, 7C written</span><br><span class="line">: qex <span class="built_in">command</span> to <span class="string">&quot;quit&quot;</span> the program.</span><br><span class="line">$ <span class="built_in">cat</span> greeting.txtAnd now we<span class="string">&#x27;re back in bash!</span></span><br><span class="line"><span class="string">Hello!The &quot;cat&quot; program shows the contents of the file.</span></span><br><span class="line"><span class="string">$ </span></span><br></pre></td></tr></table></figure>
<p>我们首先向 <code>bash</code> 提供启动ex文件编辑器的命令。发出此命令后，我们的提示符发生了变化：我们现在输入的任何文本都会发送到 <code>ex</code>，而不是 <code>bash</code>。当 ex 运行时，<code>bash</code> 处于睡眠状态，等待您的 <code>ex</code> 会话结束。当您使用该命令退出 <code>ex</code> 时<code>q</code>，<code>exbash</code> 命令结束，并且 <code>bash</code> 已准备好接收新命令。为了告诉您这一点，它会再次向您显示提示符，允许您输入下一个 <code>bash</code> 命令。我们使用 <code>bash</code> 命令来完成该示例cat <code>greetings.txt</code>，该命令告诉 <code>bash</code> 运行 <code>cat</code> 程序。<code>cat</code> 命令非常适合输出文件内容。<code>greetings.txt</code>示例中的 <code>cat</code> 命令用于在使用 <code>ex</code> 程序编辑完文件后查找文件中的内容 。</p>
<blockquote>
<p>bash 命令是 bash 可以独立执行的最小代码单元。执行命令时，您无法与 bash shell 交互。一旦 bash 执行完一个命令，它就会返回给您执行下一个命令。</p>
</blockquote>
<h5 id="Bash-命令如何读取？"><a href="#Bash-命令如何读取？" class="headerlink" title="Bash 命令如何读取？"></a>Bash 命令如何读取？</h5><p><code>Bash</code> 主要是一种基于行的语言。因此，当 <code>bash</code> 读取您的命令时，它会逐行执行。大多数命令仅构成一行，除非 <code>bash</code> 命令的语法明确表明您的命令尚未完成，否则一旦您结束该行，<code>bash</code>将立即认为这是命令的结束。因此，输入一行文本并按下回车键通常会导致 <code>bash</code> 开始执行该行文本所描述的命令。</p>
<p>然而，有些命令跨越多行。这些通常是块命令或带引号的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">&quot;Your name? &quot;</span> nameThis <span class="built_in">command</span> is complete and can be started immediately.</span><br><span class="line">Your name? Maarten Billemont</span><br><span class="line">$ <span class="keyword">if</span> [[ <span class="variable">$name</span> = <span class="variable">$USER</span> ]]; thenThe <span class="string">&quot;if&quot;</span> block started but wasn<span class="string">&#x27;t finished.</span></span><br><span class="line"><span class="string">&gt;     echo &quot;Hello, me.&quot;</span></span><br><span class="line"><span class="string">&gt; else</span></span><br><span class="line"><span class="string">&gt;     echo &quot;Hello, $name.&quot;</span></span><br><span class="line"><span class="string">&gt; fiNow the &quot;if&quot; block ends and bash knows enough to start the command.</span></span><br><span class="line"><span class="string">Hello, Maarten Billemont.</span></span><br></pre></td></tr></table></figure>
<p>从逻辑上讲，bash 在拥有足够的信息来完成其工作之前无法执行命令。上面示例中命令的第一行<code>if</code>（我们稍后将更详细地介绍这些命令的作用）没有包含足够的信息，让 <code>bash</code> 无法知道测试成功或失败时该怎么做。结果，<code>bash</code> 显示了一个特殊的提示：<code>&gt;</code>。这个提示的实质意思是：你给我的命令还没有结束。我们继续为命令提供额外的行，直到到达<code>fi</code>。当我们结束该行时，bash 知道您已完成提供条件。它立即开始运行整个块中的所有代码。我们很快就会看到 <code>bash</code> 语法中定义的不同类型的命令，但是<code>if</code>我们刚刚看到的命令称为复合命令，因为它将一堆基本命令组合成一个更大的逻辑块。</p>
<p>在每种情况下，我们都会将命令传递给交互式 bash 会话。正如我们之前所解释的，bash 还可以在非交互模式下运行，它从文件或流中读取命令，而不是询问您命令。在非交互模式下，<code>bash</code> 没有提示符。除此之外，它的操作几乎相同。我们可以复制上面示例中的 <code>bash</code> 代码并将其放入文本文件中：使用您最喜欢的文本编辑器再次打开文件，并在其顶部<code>hello.txt</code>添加一个<code>hashbang</code> ，作为脚本的第一行：<code>#!/usr/bin/env bash</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Your name? &quot;</span> name</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$name</span> = <span class="variable">$USER</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, me.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>您已经创建了第一个 <code>bash</code> 脚本。什么是 <code>bash</code> 脚本？它是一个包含 <code>bash</code> 代码的文件，可以像计算机上的任何其他程序一样由内核执行。从本质上讲，它本身就是一个程序，尽管它确实需要 <code>bash</code> 解释器来完成将 bash 语言翻译成内核可以理解的指令的工作。这就是我们刚刚添加到文件中的“<code>hashbang</code>”行的用处：它告诉内核需要使用什么解释器来理解该文件中的语言，以及在哪里可以找到它。我们称其为“<code>hashbang</code>”，因为它总是以“<code>hash</code>”开头，#后跟“<code>bang</code>”!。然后，您的 <code>hashbang</code> 必须为任何能够理解文件中的语言并且可以采用单个参数的程序指定绝对路径名。不过，我们的 <code>hashbang</code> 有点特别：我们引用了程序<code>/usr/bin/env</code>，它并不是真正理解 <code>bash</code> 语言的程序。它是一个可以查找并启动其他程序的程序。在我们的例子中，我们使用一个参数告诉它找到程序<code>bash</code>并使用它来解释脚本中的语言。为什么我们使用这个名为 的“中间”程序env？它与名称之前的内容密切相关：路径。我们相对确定地知道该<code>env</code>程序位于该<code>/usr/bin</code>路径中。然而，鉴于操作系统和配置多种多样，我们无法确定<code>bash</code>程序已安装。这就是为什么我们使用该 <code>env</code>程序来为我们找到它。这有点复杂！但是现在，我们的文件在添加 <code>hashbang</code> 之前和之后有什么区别呢？&#96;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x hello.txt       <span class="comment"># Mark hello.txt as an executable program.</span></span><br><span class="line">$ ./hello.txt              <span class="comment"># Tell bash to start the hello.txt program.</span></span><br></pre></td></tr></table></figure>
<p>大多数系统要求您将文件标记为可执行文件，然后内核才允许您将其作为程序运行。一旦我们这样做了，我们就可以hello.txt像启动任何其他程序一样启动该程序。内核将查看文件内部，找到 hashbang，使用它来追踪 bash 解释器，最后使用 bash 解释器开始运行文件中的指令。Bash 通过读取行​​来获取命令。一旦读取了足够的行来组成完整的命令，bash 就会开始运行该命令。通常，命令只有一行长。交互式 bash 会话会在提示符下读取您的行。非交互式 bash 进程从文件或流中读取命令。以hashbang作为第一行（和可执行权限）的文件可以像任何其他程序一样由系统内核启动。</p>
<h5 id="bash命令的基本语法"><a href="#bash命令的基本语法" class="headerlink" title="bash命令的基本语法"></a>bash命令的基本语法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ var=value ... ] name [ arg ... ] [ redirection ... ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world.&quot;</span></span><br><span class="line">IFS=, <span class="built_in">read</span> -a fields &lt; file</span><br></pre></td></tr></table></figure>
<p>在命令名称之前，您可以选择放置一些<code>var</code>赋值。这些变量分配仅适用于该命令的环境。稍后我们将更深入地讨论变量和环境。命令的名称是第一个单词（在可选分配之后）。<code>Bash</code> 找到具有该名称的命令并启动它。稍后我们将详细了解有哪些类型的命名命令以及 <code>bash</code> 如何找到它们。命令名称后面可以选择跟随一个<code>arg</code>单词列表，即命令参数。我们很快就会了解什么是参数及其语法。最后，命令还可以应用一组重定向操作。如果您还记得我们在前面部分中对文件描述符的解释，重定向是更改文件描述符插入指向的内容的操作。他们改变连接到我们的命令进程的流。我们将在以后的部分中了解重定向的威力。</p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>Bash 附带了大量“语法糖”，使常见任务比仅使用基本语法更容易执行。管道是您将大量使用的糖的一个例子。它们是通过将第一个进程的标准输出链接到第二个进程的标准输入来“连接”两个命令的便捷方法。这是终端命令相互通信和传递信息的最常见方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[时间[ -p ]][ ! ]命令[ [ | | |&amp; ]命令2 ...]</span><br><span class="line"><span class="built_in">echo</span> Hello | rev</span><br><span class="line">! <span class="built_in">rm</span> greeting.txt</span><br></pre></td></tr></table></figure>
<p>们很少使用<code>time</code>关键字，但它可以方便地了解运行我们的命令需要多长时间。这个!关键字一开始有点奇怪，就像 time 关键字一样，它与连接命令没有太大关系。当我们讨论条件和测试命令是否成功时，我们将了解它的作用。第一个<code>command</code>和第二个<code>command2</code>可以是本节中的任何类型的命令。<code>Bash</code> 将为每个命令创建一个子 <code>shell</code>，并设置第一个命令的标准输出文件描述符，使其指向第二个命令的标准输入文件描述符。这两个命令将同时运行，<code>bash</code> 将等待这两个命令结束。</p>
<p>两个命令之间有一个|符号。这也称为“管道”符号，它告诉 bash 将第一个命令的输出连接到第二个命令的输入。或者，我们可以使用|&amp;命令之间的符号来指示我们不仅希望第一个命令的标准输出，而且还希望将其标准错误连接到第二个命令的输入。这通常是不希望的，因为标准错误文件描述符通常用于向用户传达消息。如果我们将这些消息发送到第二个命令而不是终端显示器，我们需要确保第二个命令可以处理接收这些消息。</p>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>列表是其他命令的序列。本质上，脚本是一个命令列表：一个命令接一个命令。列表中的命令由控制运算符分隔，该运算符指示 bash 在执行之前的命令时要执行的操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> control-operator [ command2 control-operator ... ]</span><br><span class="line"><span class="built_in">cd</span> music; mplayer *.mp3</span><br><span class="line"><span class="built_in">rm</span> hello.txt || <span class="built_in">echo</span> <span class="string">&quot;Couldn&#x27;t delete hello.txt.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>
<p>命令之后是控制运算符，它告诉 <code>bash</code> 如何执行该命令。最简单的控制运算符只是开始一个新行，这相当于;告诉 <code>bash</code> 仅运行该命令并等待其结束，然后再前进到列表中的下一个命令。第二个示例使用||控制运算符，它告诉 <code>bash</code> 像平常一样运行之前的命令，但在完成该命令后，仅当之前的命令失败时才移至下一个命令。如果前面的命令没有失败，<code>||</code>操作员将使 bash 跳过后面的命令。这对于在命令失败时显示错误消息很有用。我们将在后面的部分中更深入地讨论所有控制运算符。</p>
<h5 id="复合命令"><a href="#复合命令" class="headerlink" title="复合命令"></a>复合命令</h5><p>复合命令是内部具有特殊语法的命令。它们可以做很多不同的事情，但表现为命令列表中的单个命令。最明显的例子是命令块：该块本身表现为单个大命令，但其内部是一堆“子”命令。有很多不同类型的复合命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> list [ ;|&lt;newline&gt; ] <span class="keyword">then</span> list [ ;|&lt;newline&gt; ] <span class="keyword">fi</span></span><br><span class="line">    &#123; list ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">rm</span> hello.txt; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Couldn&#x27;t delete hello.txt.&quot;</span> &gt;&amp;2; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> hello.txt || &#123; <span class="built_in">echo</span> <span class="string">&quot;Couldn&#x27;t delete hello.txt.&quot;</span> &gt;&amp;2; <span class="built_in">exit</span> 1; &#125;</span><br></pre></td></tr></table></figure>
<p>两个示例执行相同的操作。第一个示例是复合命令，第二个示例是命令列表中的复合命令。我们<code>||</code>之前简单讨论过该运算符：除非它前面的命令失败，否则会跳过它右侧的命令。这是一个很好的例子，说明了复合命令的一个重要属性：它们的行为就像命令列表中的一个命令一样。第二个示例中的复合命令从 {开始，一直持续到下一个}，因此大括号内的所有内容都被视为单个命令，这意味着我们有一个包含两个命令的命令列表：命令rm后跟<code>&#123; ... &#125;</code>复合命令。如果我们忘记了大括号，我们将得到三个命令的命令列表：<code>rm</code>命令后跟<code>echo</code>命令，然后是<code>exit</code>命令。这种差异对于操作员在成功完成<code>||</code>前面的命令后决定要做什么时非常重要。<code>rm</code>如果rm成功，<code>||</code>将跳过其后的命令，如果我们省略大括号，则该命令将只是命令<code>echo</code>。大括号将 <code>echo</code>和<code>exit</code>命令组合成一个复合命令，允许在成功<code>||</code>时跳过这两个命令<code>rm</code>。</p>
<h5 id="Coprocesses"><a href="#Coprocesses" class="headerlink" title="Coprocesses"></a>Coprocesses</h5><p>协进程是更多的 <code>bash</code> 语法糖：它允许您轻松地异步运行命令（无需让 bash 等待它结束，也称为“<code>in the background</code>”），并且还可以设置一些直接连接的新文件描述符插件新命令的输入和输出。您不会太频繁地使用协进程，但是当您执行高级操作时，它们非常方便。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">coproc [ name ] <span class="built_in">command</span> [ redirection ... ]</span><br><span class="line"></span><br><span class="line">coproc auth &#123; <span class="built_in">tail</span> -n1 -f /var/log/auth.log; &#125;</span><br><span class="line"><span class="built_in">read</span> latestAuth &lt;&amp;<span class="string">&quot;<span class="variable">$&#123;auth[0]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Latest authentication attempt: <span class="variable">$latestAuth</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>该示例启动一个异步<code>tail</code>命令。当它在后台运行时，脚本的其余部分将继续。首先，脚本从名为的协进程读取一行输出<code>auth</code>（这是命令输出的第一行<code>tail</code>）。接下来，我们编写一条消息，显示从协进程读取的最新身份验证尝试。该脚本可以继续，每次从协进程管道读取时，它都会从命令中获取下一行 <code>tail</code>。</p>
<h5 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h5><p>当您在 <code>bash</code> 中声明一个函数时，您实际上是在创建一个临时的新命令，您可以稍后在脚本中调用该命令。当您在脚本中多次重复同一任务时，函数是一种将命令列表分组到自定义名称下的好方法，以方便您使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name () compound-command [ redirection ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">exists</span></span>() &#123; [[ -x $(<span class="built_in">type</span> -P <span class="string">&quot;<span class="variable">$1</span>&quot;</span> 2&gt;/dev/null) ]]; &#125;</span><br><span class="line">exists gpg || <span class="built_in">echo</span> <span class="string">&quot;Please install GPG.&quot;</span> &lt;&amp;2</span><br></pre></td></tr></table></figure>

<p><code>name</code>首先为您的函数指定这是新命令的名称，稍后您可以通过使用该名称编写一个简单的命令来运行它。命令名称后面是括号()。有些语言使用这些括号来声明函数接受的参数：<code>bash</code> 不这样做。括号应始终为空。它们只是表示您正在声明一个函数。接下来是每次运行该函数时将执行的复合命令。要在运行函数期间更改脚本的文件描述符，您可以选择指定函数的自定义文件重定向。</p>
<blockquote>
<p>Bash 命令告诉 bash 执行特定的工作单元。这些工作单元不能再细分：bash 需要知道整个命令才能执行它。不同类型的操作有不同类型的命令。某些命令将其他命令分组或测试其结果。许多命令类型都是语法糖：它们的效果可以通过不同方式实现，但它们的存在是为了使工作变得更容易。</p>
</blockquote>
<h5 id="命令的名称和运行程序"><a href="#命令的名称和运行程序" class="headerlink" title="命令的名称和运行程序"></a>命令的名称和运行程序</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ var=value ... ] name [ arg ... ] [ redirection ... ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我将仅简要提及别名：在 bash 执行此搜索之前，它首先检查您是否已通过命令名称声明了任何别名。如果您这样做了，它将在继续之前将名称替换为别名的值。别名很少有用，仅在交互式会话中起作用，并且几乎完全被函数取代。几乎在所有情况下您都应该避免使用它们。</p>
<blockquote>
<p>要运行命令，bash 使用命令的名称并搜索如何执行该命令。按照顺序，bash 将检查它是否具有该名称的函数或内置函数。如果失败，它将尝试将该名称作为程序运行。如果 bash 找不到运行命令的方法，它将输出一条错误消息。</p>
</blockquote>
<h5 id="The-PATH-to-a-program"><a href="#The-PATH-to-a-program" class="headerlink" title="The PATH to a program"></a>The PATH to a program</h5><p>我们的计算机上安装了各种各样的程序。不同的程序安装在不同的地方。有些程序随我们的操作系统一起提供，其他程序是由我们的发行版添加的，还有一些程序是由我们或我们的系统管理员安装的。在标准 <code>UNIX</code> 系统上，程序有几个标准化位置。某些程序将安装在 中<code>/bin</code>，其他程序将安装在 中<code>/usr/bin</code>，还有一些程序将安装在 中，<code>/sbin</code>依此类推。如果我们必须记住程序的确切位置，那将是一个真正的麻烦，特别是因为它们可能因系统而异。<code>PATH</code> 环境变量来救援。您的<code>PATH</code>变量包含一组应搜索程序的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ping 127.0.0.1</span><br><span class="line"></span><br><span class="line">    PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line">           │     │</span><br><span class="line">           │     ╰──▶ /sbin/ping ?  found!</span><br><span class="line">           ╰──▶ /bin/ping ?  not found.</span><br></pre></td></tr></table></figure>
<p>每当您尝试启动一个它还不知道位置的程序时，<code>Bash</code> 都会通过查看其列出的目录来搜索此变量。假设您正在尝试启动<code>ping</code>安装在 的程序<code>/sbin/ping</code>。如果您的<code>PATH</code>设置为<code>/bin:/sbin:/usr/bin:/usr/sbin</code>，则 <code>bash</code> 将首先尝试启动<code>/bin/ping</code>，而该启动并不存在。如果失败，它将尝试<code>/sbin/ping</code>。它会找到该 <code>ping</code>程序，记录其位置以备<code>ping</code>将来您再次需要时使用，然后继续为您运行该程序。</p>
<p>如果您对 bash 到底在哪里找到要运行的命令名称相关程序感到好奇，您可以使用type内置函数来查找：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">type</span> ping</span><br><span class="line">ping is /sbin/ping</span><br><span class="line">$ <span class="built_in">type</span> -a <span class="built_in">echo</span>          <span class="comment"># The -a switch tells type to show us all the possibilities</span></span><br><span class="line"><span class="built_in">echo</span> is a shell <span class="built_in">builtin</span> <span class="comment"># If we just run &#x27;echo&#x27;, bash will use the first possibility</span></span><br><span class="line"><span class="built_in">echo</span> is /bin/echo       <span class="comment"># We have an echo built-in but also a program called echo!</span></span><br></pre></td></tr></table></figure>
<p>还记得上一节中 <code>bash</code> 是如何内置一些功能的吗？其中之一是程序的功能<code>echo</code>。如果您<code>echo</code>在 <code>bash</code> 中运行该命令，甚至在 <code>bash</code> 尝试<code>PATH</code>搜索之前，它就会注意到有一个具有该名称的内置命令并使用它。<code>type</code>是可视化此查找过程的好方法。请注意，执行内置命令比启动额外程序要快得多。但是，如果您需要 的<code>echo</code>功能而不使用 <code>bash</code>，则可以使用该<code>echo</code>程序。有时您需要运行未安装在任何目录中的程序PATH。在这种情况下，您必须手动指定 <code>bash</code> 可以找到该程序的路径，而不仅仅是其名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /sbin/ping -c 1 127.0.0.1</span><br><span class="line">PING 127.0.0.1 (127.0.0.1): 56 data bytes</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.075 ms</span><br><span class="line"></span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.075/0.075/0.075/0.000 ms</span><br><span class="line">$ ./hello.txt                <span class="comment"># Remember our hello.txt script?</span></span><br><span class="line">Your name?                   <span class="comment"># We use the path &quot;.&quot; which means &quot;our current directory</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p><code>Bash</code> 仅对<code>PATH</code>不包含<code>/</code>字符的命令名称执行搜索。带斜杠的命令名称始终被视为要执行的程序的直接路径名。</p>
</div>

<p>您可以向您的PATH. 常见的做法是使用 <code>/usr/local/bin</code>和  <code>~/bin</code>（其中<code>~</code>代表用户的主目录）。请记住，这<code>PATH</code>是一个环境变量：您可以像这样更新它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$ PATH=~/bin:/usr/local/bin:/bin:/usr/bin</span><br><span class="line">_</span><br></pre></td></tr></table></figure>
<p>这将更改当前 bash shell 中的变量。不过，一旦关闭 shell，更改就会丢失。我们将在后面的部分中更深入地介绍环境变量的工作原理以及应如何配置它们。当bash需要运行一个程序时，它使用命令名来执行搜索。Bash逐一搜索PATH 环境变量中的目录，直到找到包含具有您的命令名称的程序的目录。要运行未安装在PATH目录中的程序，请使用该程序的路径作为命令的名称。</p>
<p>在您的主目录中创建一个脚本，将其添加到您的PATH中，然后作为普通命令运行该脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ex</span>                      <span class="comment"># 您可以在这里替换您最喜欢的编辑器。</span></span><br><span class="line">: i</span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world.&quot;</span></span><br><span class="line">.</span><br><span class="line">: w myscript</span><br><span class="line"><span class="string">&quot;myscript&quot;</span> [New] 2L, 40C written</span><br><span class="line">: q</span><br><span class="line">$ <span class="built_in">chmod</span> +x myscript</span><br><span class="line">$ PATH=<span class="variable">$PATH</span>:~</span><br><span class="line">$ myscript</span><br><span class="line">Hello world.</span><br></pre></td></tr></table></figure>

<h5 id="Command-arguments-and-quoting-literals"><a href="#Command-arguments-and-quoting-literals" class="headerlink" title="Command arguments and quoting literals"></a>Command arguments and quoting literals</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ var=value ... ] name [ arg ... ] [ redirection ... ]</span><br></pre></td></tr></table></figure>
<p>现在您已经了解了 <code>bash</code> 如何查找并运行您的命令，让我们学习如何将指令传递给这些命令。这些指令告诉我们的指挥部到底需要做什么。我们可能运行<code>rm</code>命令来删除文件，或者<code>cp</code>命令来复制文件，我们可能运行命令<code>echo</code>来输出字符串或<code>read</code>命令来读取一行文本。但如果没有更多细节、更多上下文，这些命令通常无法做很多事情。我们需要告诉<code>rm</code>要删除什么文件，<code>cp</code>要复制什么文件以及将副本放在哪里。<code>echo</code>想要知道您想要它输出什么，并且<code>read</code>可以知道将其读取的文本行放在哪里。我们使用参数提供这种上下文。</p>
<div class="note warning"><p><code>bash shell</code> 脚本中所有错误的主要部分是其作者没有正确理解命令参数的直接结果。通常归咎于对直觉的依赖而不是对规则的理解。</p>
</div>

<p>从命令语法中可以看出，参数位于命令名称之后。它们是由空格分隔的单词。当我们在 <code>bash</code> 上下文中说出单词时，我们指的并不是语言单词。在 <code>bash</code> 中，单词被定义为被 <code>shell</code> 视为单个单元的字符序列。单词也称为令牌。一个 <code>bash</code> 单词可以包含许多语言单词，实际上它可以包含<code>prose</code>。为了清楚起见，本指南的其余部分将在适用的地方使用术语参数，以避免术语单词的歧义。重要的是单词或参数对于 <code>shell</code> 来说是一个单元：它可以是文件名、变量名、程序名或人名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> hello.txt</span><br><span class="line">$ mplayer <span class="string">&#x27;05 Between Angels and Insects.ogg&#x27;</span> <span class="string">&#x27;07 Wake Up.ogg&#x27;</span></span><br></pre></td></tr></table></figure>
<p>请注意，它们不是语言单词，而是有意义的单位。在这种情况下，它们都指的是文件名。为了分隔多个参数，我们使用空格。可以是空格和制表符中的一个或两者。通常，您将在参数之间使用一个空格。<br>现在出现了一个问题：我们在 后面有一个空格05，将其与 分开<code>Between。shell</code> 应该如何知道你的文件名是<code>05 Between Angels and Insects.ogg</code>不是05 我们如何告诉 <code>shell</code> 后面的空格05是字面意思，而不是作为“现在分割单词”的语法？我们的目的是让整个文件名保持“在一起”。也就是说： 其中的空格不应将其拆分为单独的参数。我们需要的是一种方法来告诉 <code>shell</code> 它应该按字面意思处理某些内容；意思，按原样使用它，忽略任何语法意义。如果我们可以将空格变成字面意思，它们将不再告诉 bash 将空格05从Between，bash 会将其用作正常的普通空格字符。</p>
<p><code>bash</code>中有两种方法可以使字符变成原义字符：引用和转义。”引用是将字符包裹’在我们想要表达的文本周围的做法。逃逸是放置一个单一的实践\我们要使其字面化的字符前面的字符。上面的示例使用引号来构成整个文件名文字，但不包含文件名之间的空格。我们强烈建议您使用引号而不是转义，因为它会导致更清晰、更易读的代码。更重要的是：转义使得准确判断代码的哪些部分是文字部分、哪些部分不是文字变得更加困难。稍后在不引入错误的情况下编辑文字文本也变得更加不稳定。使用转义而不是引用，我们的示例如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mplayer</span> 05\ Between\ Angels\ and\ Insects.ogg 07\ Wake\ Up.ogg</span><br></pre></td></tr></table></figure>
<p>引用是作为 <code>bash</code> 用户需要掌握的最重要的技能之一。它的重要性怎么强调都不为过。引用的好处是，虽然有时没有必要，但引用数据很少会出错。这些都是完全有效的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l hello.txt</span><br><span class="line">-rw-r--r--  1 lhunath  staff  131 29 Apr 17:07 hello.txt</span><br><span class="line">$ <span class="built_in">ls</span> -l <span class="string">&#x27;hello.txt&#x27;</span></span><br><span class="line">-rw-r--r--  1 lhunath  staff  131 29 Apr 17:07 hello.txt</span><br><span class="line">$ <span class="built_in">ls</span> -l <span class="string">&#x27;05 Between Angels and Insects.ogg&#x27;</span> <span class="string">&#x27;07 Wake Up.ogg&#x27;</span></span><br></pre></td></tr></table></figure>
<p>你应该使用“双引号”对于任何包含扩展（例如<code>$variable</code>或<code>$(command)</code>扩展）的参数并且’单引号’对于任何其他论点。单引号确保引号中的所有内容都保持原义，而双引号仍然允许一些 <code>bash</code> 语法，例如扩展：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Good morning, <span class="variable">$USER</span>.&quot;</span>                              <span class="comment"># Double quotes allow bash to expand $USER</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;You have won SECOND PRIZE in a beauty contest.&#x27;</span>    <span class="comment"># \Single quotes prevent even the $-syntax</span></span><br><span class="line">     <span class="string">&#x27;Collect $10&#x27;</span>                                       <span class="comment"># from triggering expansion.</span></span><br></pre></td></tr></table></figure>
<p>您会发现在引用方面培养实用主义意识是一个很好的做法：只要看一眼 <code>bash</code> 代码块，未加引号的参数就会立即跳出来，并且您应该感到有一种冲动，需要先解决这些问题，然后才能允许自己继续做其他事情。引用问题是 <code>bash</code> 问题中至少十分之九的核心，也是人们寻求帮助的问题的绝大多数原因。由于引用实际上非常容易，因此有纪律的引用者无需担心太多。</p>
<div class="note success"><p>引用的黄金法则非常简单：<br>如果参数中有空格或符号，则必须引用它。<br>如果没有，引号通常是可选的，但为了安全起见，您仍然可以引用它。</p>
<p>参数不需要引用的情况极为罕见，主要是在测试内部和扩展周围。不要从你的论点中删除或省略引号，以试图使某些东西在任何其他情况下发挥作用；相反，您更有可能引入一个可怕且难以检测的错误。[[${..+..}</p>
</div>

<div class="note warning"><p>缺少引号的危险有很多，但作为一个非常简单的示例，请考虑当您不小心在输入前面放置空格时会发生什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">&#x27;Which user would you like to remove from your system? &#x27;</span> username</span><br><span class="line">Which user would you like to remove from your system?  lhunath</span><br><span class="line">$ <span class="built_in">rm</span> -vr /home/<span class="variable">$username</span></span><br><span class="line">removed <span class="string">&#x27;/home/lhunath/somefile&#x27;</span></span><br><span class="line">removed directory: <span class="string">&#x27;/home/lhunath&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;/home/bob/bobsfiles&#x27;</span></span><br><span class="line">removed directory: <span class="string">&#x27;/home/bob&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;/home/victor/victorsfiles&#x27;</span></span><br><span class="line">removed directory: <span class="string">&#x27;/home/victor&#x27;</span></span><br><span class="line">removed directory: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;lhunath&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure></div>

<p>这里发生的情况是，在输入时，因为您不小心<code>space</code>在要删除的用户名前添加了一个字符，该<code>rm</code>命令扩展为，这导致了一种可能让 <code>Victor</code> 和 <code>Bob</code> 都感到不安的情况：该命令现在首先删除整个<code>rm -vr /home/ lhunath</code>，包括其中的所有内容，随后它将删除<code>lhunath</code> 文件。如果您正确引用了该<code>rm</code>命令，则错误的输入将导致错误消息并且不会造成任何损坏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -vr <span class="string">&quot;/home/<span class="variable">$username</span>&quot;</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;/home/ lhunath&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<p>为了告诉命令要做什么，我们向它传递参数。在 <code>bash</code> 中，参数是标记（<code>token</code>），也称为单词（<code>words</code>），它们之间用空格分隔。要在参数值中包含空格，您需要引用该参数或转义其中的空格。如果做不到这一点，<code>bash</code> 将在其空白处将您的参数分解为多个参数。引用参数还可以防止其中的其他符号被意外解释为 <code>bash</code> 代码，例如’<code>$10 USD</code>‘（变量​​扩展）、”&#96;*** NOTICE ***”（文件名扩展）等。</p>
<h5 id="Managing-a-command’s-input-and-output-using-redirection"><a href="#Managing-a-command’s-input-and-output-using-redirection" class="headerlink" title="Managing a command’s input and output using redirection"></a>Managing a command’s input and output using redirection</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ var=value ... ] name [ arg ... ] [ redirection ... ]</span><br></pre></td></tr></table></figure>
<p>进程使用文件描述符连接到流。每个进程一般都会有三个标准文件描述符：标准输入（FD 0）、标准输出（FD 1）和标准错误（FD 2）。当 bash 启动一个程序时，它首先为该程序设置一组文件描述符。它通过查看自己的文件描述符并为新进程设置一组相同的描述符来实现这一点：我们说新进程“继承”” bash 的文件描述符。当您打开终端到新的 bash shell 时，终端将通过将 bash 的输入和输出连接到终端来设置 bash。这就是键盘中的字符最终出现在 bash 中以及 bash 消息的方式在你的终端窗口中。每次 bash 启动一个自己的程序时，它都会为该程序提供一组与其自身匹配的文件描述符。这样，bash 命令的消息也会出现在你的终端上，并且你的键盘输入也会显示在终端上（命令的输出和输入连接到您的终端）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Keyboard ╾──╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">                 │         2┝╾─┘</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ ls -l a b                                     # Imagine we have a file called &quot;a&quot;, but not a file called &quot;b&quot;.</span><br><span class="line">ls: b: No such file or directory                # Error messages are emitted on FD 2</span><br><span class="line">-rw-r--r--  1 lhunath  staff  0 30 Apr 14:43 a  # Results are emitted on FD 1</span><br><span class="line"></span><br><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾┬─╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">              │  │         2┝╾─┤ </span><br><span class="line">              │  ╰─────┬────╯  │</span><br><span class="line">              │        ╎       │</span><br><span class="line">              │  ╭─────┴────╮  │</span><br><span class="line">              └─╼┥0  ls    1┝╾─┤</span><br><span class="line">                 │         2┝╾─┘</span><br><span class="line">                 ╰──────────╯</span><br></pre></td></tr></table></figure>
<p>当bash启动一个<code>ls</code>进程时，它首先查看自己的文件描述符。然后，它为进程创建文件描述符ls，连接到与其自己相同的流：FD 1 和 FD 2 通向<code>Display</code>，FD 0 来自Keyboard. 因此，ls错误消息（在 FD 2 上发出）及其常规输出（在 FD 1 上发出）最终都会出现在终端显示屏上。如果我们想控制命令连接的位置，我们需要使用重定向：这是更改文件描述符的源或目标的做法。我们可以使用重定向做的一件事是将ls结果写入文件而不是终端显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾──╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">                 │         2┝╾─┘</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ ls -l a b &gt;myfiles.ls                               # We redirect FD 1 to the file &quot;myfiles.ls&quot;</span><br><span class="line">ls: b: No such file or directory                      # Error messages are emitted on FD 2</span><br><span class="line"></span><br><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾┬─╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">              │  │         2┝╾─┤</span><br><span class="line">              │  ╰─────┬────╯  │</span><br><span class="line">              │        ╎       │</span><br><span class="line">              │  ╭─────┴────╮  │</span><br><span class="line">              └─╼┥0  ls    1┝╾─╌─╼ myfiles.ls</span><br><span class="line">                 │         2┝╾─┘</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ cat myfiles.ls                                      # The cat command shows us the contents of a file</span><br><span class="line">-rw-r--r--  1 lhunath  staff  0 30 Apr 14:43 a        # The result is now in myfiles.ls</span><br></pre></td></tr></table></figure>
<p>您刚刚通过将命令的标准输出重定向到文件来执行文件重定向。重定向标准输出是使用<code>&gt;</code>运算符完成的。将其想象为将命令输出发送到文件的箭头。这是迄今为止最常见和最有用的重定向形式。重定向的另一个常见用途是隐藏错误消息。您会注意到我们的重定向ls命令仍然显示错误消息。通常这是一件好事。但有时，我们可能会发现脚本中某些命令产生的错误消息对用户来说并不重要，应该隐藏。为此，我们可以再次使用文件重定向，其方式与重定向标准输出导致ls’ 结果消失类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾──╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">                 │         2┝╾─┘</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ ls -l a b &gt;myfiles.ls 2&gt;/dev/null                # We redirect FD 1 to the file &quot;myfiles.ls&quot;</span><br><span class="line">and FD 2 to the file &quot;/dev/null&quot;</span><br><span class="line"></span><br><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾┬─╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">              │  │         2┝╾─┘</span><br><span class="line">              │  ╰─────┬────╯</span><br><span class="line">              │        ╎</span><br><span class="line">              │  ╭─────┴────╮</span><br><span class="line">              └─╼┥0  ls    1┝╾───╼ myfiles.ls</span><br><span class="line">                 │         2┝╾───╼ /dev/null</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ cat myfiles.ls                                   # The cat command shows us the contents of a file</span><br><span class="line">-rw-r--r--  1 lhunath  staff  0 30 Apr 14:43 a     # The result is now in myfiles.ls</span><br><span class="line">$ cat /dev/null                                    # The /dev/null file is empty?</span><br></pre></td></tr></table></figure>
<p><code>&gt;</code>请注意如何通过在操作员前面加上 FD 号码前缀来重定向任何 FD 。我们过去<code>2&gt;</code>将 FD 2 重定向到 ，<code>/dev/null</code>同时&gt;仍然将 FD 1 重定向到<code>myfiles.ls</code>。如果省略该数字，输出重定向默认为重定向 FD 1（标准输出）。我们的ls命令不再显示错误消息，并且结果已正确存储在<code>myfiles.ls</code>. 错误信息去哪儿了？我们已将其写入文件<code>/dev/null</code>。但是当我们显示该文件的内容时，我们看不到错误消息。出了什么问题吗？这个线索就在目录名称中。该文件<code>null</code>位于目录： 这是设备文件<code>/dev</code>的特殊目录。设备文件是代表我们系统中的设备的特殊文件。当我们向它们写入或读取时，我们是通过内核直接与这些设备通信。该设备是一个始终为空的特殊设备。您写入其中的任何内容都将丢失，并且无法从中读取任何内容。这使得它成为丢弃信息的非常有用的设备。我们将不需要的错误消息传输到设备，然后它就会消失。</p>
<p>如果我们想将终端上通常出现的所有输出保存到我​​们的<code>myfiles.ls</code>文件中该怎么办？结果和错误消息？直觉可能会建议：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l a b &gt;myfiles.ls 2&gt;myfiles.ls                  <span class="comment"># Redirect both file descriptors to myfiles.ls?</span></span><br><span class="line"></span><br><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾┬─╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">              │  │         2┝╾─┘</span><br><span class="line">              │  ╰─────┬────╯</span><br><span class="line">              │        ╎</span><br><span class="line">              │  ╭─────┴────╮</span><br><span class="line">              └─╼┥0  <span class="built_in">ls</span>    1┝╾───╼ myfiles.ls</span><br><span class="line">                 │         2┝╾───╼ myfiles.ls</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> myfiles.ls                                      <span class="comment"># Contents may be garbled depending on how streams were flushed</span></span><br><span class="line">-rw-r--r--  1 lhunath  stls: b: No such file or directoryaff  0 30 Apr 14:43 a</span><br></pre></td></tr></table></figure>
<p>但你错了！为什么这是不正确的？经过检查，<code>myfiles.ls</code>似乎一切顺利，但实际上这里发生了非常危险的事情。如果幸运的话，您会发现文件的输出并不完全符合您的预期：它可能有点乱码、无序，甚至可能是正确的。问题是，您无法预测也无法保证此命令的结果。这里发生了什么？问题是两个文件描述符现在都有自己的文件流。这是有问题的，因为流的内部工作方式，这个主题超出了本指南的范围，但足以说明，当两个流合并到文件中时，结果是流的任意混合在一起。</p>
<p>要解决此问题，您需要在同一流上发送输出和错误字节。为此，您需要知道如何复制文件描述符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l a b &gt;myfiles.ls 2&gt;&amp;1                    <span class="comment"># Make FD 2 write to where FD 1 is writing</span></span><br><span class="line"></span><br><span class="line">                 ╭──────────╮</span><br><span class="line">    Keyboard ╾┬─╼┥0  bash  1┝╾─┬─╼ Display</span><br><span class="line">              │  │         2┝╾─┘</span><br><span class="line">              │  ╰─────┬────╯</span><br><span class="line">              │        ╎</span><br><span class="line">              │  ╭─────┴────╮</span><br><span class="line">              └─╼┥0  <span class="built_in">ls</span>    1┝╾─┬─╼ myfiles.ls</span><br><span class="line">                 │         2┝╾─┘</span><br><span class="line">                 ╰──────────╯</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> myfiles.ls</span><br><span class="line"><span class="built_in">ls</span>: b: No such file or directory</span><br><span class="line">-rw-r--r--  1 lhunath  staff  0 30 Apr 14:43 a</span><br></pre></td></tr></table></figure>
<p>复制文件描述符，也称为“复制”文件描述符，是将一个文件描述符的流连接复制到另一个文件描述符的行为。结果，两个文件描述符都连接到同一个流。我们使用该&gt;&amp;运算符，在其前面加上我们要更改的文件描述符，并在其后面加上我们需要“复制”其流的文件描述符。您将相当频繁地使用此运算符，并且在大多数情况下，它将像上面那样将 FD 1 复制到 FD 2。您可以将语法<code>2&gt;&amp;1</code> 转换为 <code>Make FD 2 write(&gt;) to where FD(&amp;) 1</code>。</p>
<p>我们现在已经看到了相当多的重定向操作，我们甚至将它们组合起来。在你疯狂之前，你需要了解一个更重要的规则：重定向是从左到右评估的，方便地与我们阅读它们的方式相同。这似乎是显而易见的，但忽视这一点导致许多前辈犯了这个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l a b 2&gt;&amp;1 &gt;myfiles.ls      <span class="comment"># Make FD 2 go to FD 1 and FD 1 go to myfiles.ls?</span></span><br></pre></td></tr></table></figure>
<p>编写此代码的人可能会认为，由于 FD 2 的输出将发送到 FD 1，而 FD 1 的输出将发送到 FD <code>myfiles.ls</code>，因此错误应该最终出现在文件中。他们的推理中的逻辑错误是假设将<code>2&gt;&amp;1</code>FD 2 的输出发送到 FD 1。但事实并非如此。它将 FD 2 的输出发送到FD 1 连接到的流，此时该流可能是终端而不是文件，因为 FD 1 尚未重定向。上述命令的结果可能会令人沮丧，因为它看起来好像标准错误的重定向没有生效，而实际上，您只是将标准错误重定向到终端（标准输出的目标），这就是它的位置之前就已经指过了。还有很多其他重定向运算符，但它们并不都像您刚刚学到的那样有用。事实证明，人们学会用简单的英语阅读命令重定向是有用的。我现在将列举 bash 的重定向运算符。</p>
<ul>
<li><p><strong>文件重定向</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x]&gt;file, [x]&lt;file</span><br><span class="line"></span><br><span class="line">echo Hello &gt;~/world</span><br><span class="line">rm file 2&gt;/dev/null</span><br><span class="line">read line &lt;file</span><br></pre></td></tr></table></figure>
<p><code>Make FD x write to / read from file</code>. 打开文件流以进行写入或读取，并连接到文件描述符x。当省略<code>x</code>时，写入时默认为FD 1（标准输出），读取时默认为FD 0（标准输入）。</p>
</li>
<li><p><strong>文件描述符复制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ x ] &gt;&amp; y , [ x ] &lt;&amp; y</span><br><span class="line"></span><br><span class="line">ping 127.0.0.1 &gt;results 2&gt;&amp;1</span><br><span class="line">exec 3&gt;&amp;1 &gt;mylog; echo moo; exec 1&gt;&amp;3 3&gt;&amp;-</span><br></pre></td></tr></table></figure>
<p>使 FD x写入&#x2F;读取 FD y的流。FD y使用的流连接被复制到 FD x。第二个例子相当高级：要理解它，您需要知道<code>exec</code>可以用来更改 <code>bash</code> 本身的文件描述符（而不是新命令的文件描述符），并且如果您使用尚不存在的x ，<code>bash</code> 将使用该编号为您创建一个新的文件描述符（“插头”）。</p>
</li>
<li><p><strong>附加文件重定向</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ x ] &gt;&gt;文件</span><br><span class="line"></span><br><span class="line">echo Hello &gt;~/world</span><br><span class="line">echo World &gt;&gt;~/world</span><br></pre></td></tr></table></figure>
<p>将 FD x追加到文件末尾。打开文件流以追加模式写入，并连接到文件描述符x。常规文件重定向运算符<code>&gt;</code>在打开文件时会清空文件的内容，以便文件中只有您的字节。在追加模式 ( <code>&gt;&gt;</code>) 中，文件的现有内容将保留，流的字节将添加到文件的末尾。</p>
</li>
<li><p><strong>重定向标准输出和标准错误</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&gt;file</span><br><span class="line"></span><br><span class="line">ping 127.0.0.1 &amp;&gt;results</span><br></pre></td></tr></table></figure>
<p>将 FD 1（标准输出）和 FD 2（标准错误）都写入文件。这是一个便利运算符，它的作用与此相同，但更简洁。同样，您可以通过双击箭头来追加而不是截断：<code>&gt;file 2&gt;&amp;1&amp;&gt;&gt;file</code></p>
</li>
<li><p><strong>Here Documents</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;&lt;[-]delimiter</span><br><span class="line">        here-document</span><br><span class="line">   delimiter</span><br><span class="line"></span><br><span class="line">   cat &lt;&lt;. </span><br><span class="line">   Hello world.</span><br><span class="line">   Since I started learning bash, you suddenly seem so much bigger than you were before.</span><br><span class="line">.</span><br><span class="line">   .</span><br></pre></td></tr></table></figure>
<p>使 FD 0（标准输入）从分隔符 之间的字符串中读取。<code>Here</code> 文档是将大块文本提供给命令输入的好方法。它们从定界符之后的行开始，并在 <code>bash</code> 遇到仅包含定界符的行时结束。重要的是要记住，您的终​​止分隔符不能缩进，因为这样它就不再只是该行上的分隔符。您可以在初始分隔符声明前加上 前缀-，这将告诉 <code>bash</code> 忽略您放在定界符前面的任何制表符。这样，您可以缩进定界文档，而不会在输入字符串中显示缩进。它还允许您使用制表符缩进终止分隔符。最后，可以将变量扩展放入此处文档的字符串中。这允许您将变量数据注入此处文档中。稍后我们将了解有关变量和扩展的更多信息，但只要说如果不需要扩展，您就需要在 的初始声明周围加上引号。’<code>delimiter</code>‘。</p>
</li>
<li><p><strong>Here Strings</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;string</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;&lt;&quot;Hello world.</span><br><span class="line">Since I started learning bash, you suddenly seem so much bigger than you were before.&quot;</span><br></pre></td></tr></table></figure>
<p>使 FD 0（标准输入）从字符串 中读取。</p>
</li>
<li><p><strong>Closing file descriptors</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x&gt;&amp;-, x&lt;&amp;-</span><br><span class="line"></span><br><span class="line">exec 3&gt;&amp;1 &gt;mylog; echo moo; exec 1&gt;&amp;3 3&gt;&amp;-</span><br></pre></td></tr></table></figure>
<p>关闭 FD x。流与文件描述符<code>x</code>断开，并且文件描述符从进程中删除。在重新创建之前它不能再次使用。当省略<code>x&gt;&amp;-</code>时，默认关闭标准输出并<code>&lt;&amp;-</code>默认关闭标准输入。您很少会使用该运算符。</p>
</li>
<li><p><strong>Moving file descriptors</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x]&gt;&amp;y-, [x]&lt;&amp;y-</span><br><span class="line"></span><br><span class="line">exec 3&gt;&amp;1- &gt;mylog; echo moo; exec &gt;&amp;3-</span><br></pre></td></tr></table></figure>
<p>将 FD <code>x</code>替换为 FD <code>y</code>。<code>y</code>处的文件描述符被复制到<code>x</code>并关闭<code>y</code> 。实际上，它将<code>x</code>替换为<code>y</code>。它是一个方便的操作符。同样，您很少会使用此运算符。<code>[x]&gt;&amp;y y&gt;&amp;-</code></p>
</li>
<li><p><strong>Reading and writing with a file descriptor</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x]&lt;&gt;file</span><br><span class="line"></span><br><span class="line">exec 5&lt;&gt;/dev/tcp/ifconfig.me/80</span><br><span class="line">echo &quot;GET /ip HTTP/1.1</span><br><span class="line">Host: ifconfig.me</span><br><span class="line">&quot; &gt;&amp;5</span><br><span class="line">cat &lt;&amp;5</span><br></pre></td></tr></table></figure>
<p>打开 FD <code>x</code>以读取和写入文件。<code>x</code>处的文件描述符通过文件流打开，可用于写入和读取字节。通常您将为此使用两个文件描述符。这是有用的极少数情况之一是使用读&#x2F;写设备（例如网络套接字）设置流时。上面的示例将几行 <code>HTTP</code> 写入<code>ifconfig.me</code>端口（标准 <code>HTTP</code> 端口）的主机，然后读取从网络返回的字节，两者都使用为此设置的<code>80</code>相同文件描述符。</p>
</li>
</ul>
<p>作为关于重定向的最后一点，我想指出，对于简单命令，重定向运算符可以出现在简单命令中的任何位置。也就是说，它们不需要出现在末尾。虽然将它们保留在命令末尾是一个好主意，如果主要是为了一致性并避免在长命令中出现意外或错过操作符，但在某些情况下，有些人习惯将重定向操作符放在其他地方。特别是，为了可读性，经常将重定向运算符放在<code>echo</code>或者命令名称后面，特别是当它们有一个序列时：<code>printf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &gt;&amp;2 &quot;Usage: exists name&quot;</span><br><span class="line">echo &gt;&amp;2 &quot;   Check to see if the program &#x27;name&#x27; is installed.&quot;</span><br><span class="line">echo &gt;&amp;2</span><br><span class="line">echo &gt;&amp;2 &quot;RETURN&quot;</span><br><span class="line">echo &gt;&amp;2 &quot;   Success if the program exists in the user&#x27;s PATH and is executable.  Failure otherwise.&quot;</span><br></pre></td></tr></table></figure>
<p>默认情况下，新命令继承 <code>shell</code> 的当前文件描述符。我们可以使用重定向来更改命令输入的来源及其输出的位置。文件重定向（例如<code>2&gt;errors.log</code>）允许我们将文件描述符流式传输到文件。我们可以复制文件描述符（例如<code>2&gt;&amp;1</code>）以使它们共享一个流。还有许多其他更高级的重定向运算符。</p>
<ol>
<li><p>仅将最后一个命令的标准错误消息发送到名为errors.log. errors.log然后在终端上显示 的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /bin/bash /bob/bash 2&gt;errors.log</span><br><span class="line">/bin/bash* $ </span><br><span class="line"><span class="built_in">ls</span>: /bob/bash: 没有这样的文件或目录</span><br><span class="line"><span class="built_in">cat</span> errors.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>将最后一个命令的标准输出和错误消息附加到名为errors.log. errors.log然后再次在终端上显示 的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /bin/bash /bob/bash &gt;&gt;errors.log 2&gt;&amp;1</span><br><span class="line"><span class="variable">$cat</span> errors.log </span><br><span class="line"><span class="built_in">ls</span>: /bob/bash: 没有这样的文件或目录</span><br><span class="line"><span class="built_in">ls</span>: /bob/bash: 没有这样的文件或目录</span><br><span class="line">/bin/bash*</span><br></pre></td></tr></table></figure></li>
<li><p>Hello world.使用<code>here-string</code>在终端上显示该字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cat</span> &lt;&lt;&lt; <span class="string">&#x27;Hello world.&#x27;</span></span><br><span class="line">Hello world.</span><br></pre></td></tr></table></figure></li>
<li><p>修复此命令，以便将消息正确保存到文件中<code>log</code>，并随后正确关闭 FD <code>3：exec 3&gt;&amp;2 2&gt;log; echo &#39;Hello!&#39;; exec 2&gt;&amp;3</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$exec</span> 3&gt;&amp;1 &gt;<span class="built_in">log</span>; <span class="built_in">echo</span> <span class="string">&#x27;Hello!&#x27;</span>; <span class="built_in">exec</span> 1&gt;&amp;3 3&gt;&amp;-</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Bash Programing</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>bash programing</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bash 编程】Tests And Conditionals</title>
    <url>/2023/08/03/Cloud-Native/%E3%80%90Bash%20%E7%BC%96%E7%A8%8B%E3%80%91tests-conditionals/</url>
    <content><![CDATA[<p>与没有条件分支的线性脚本相比，带有条件分支的脚本更加广泛且多用途，就像游戏与书籍的线性叙述相比具有多用途一样。那么，为什么我们需要条件语句呢？我们需要他们编写能够动态处理不同情况的脚本，并根据情况改变其运行方式。让我们从一个非常简单的条件开始，以帮助我们正确地开始新的一天：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">&quot;Would you like some breakfast? [y/n] &quot;</span></span><br><span class="line">Would you like some breakfast? [y/n] n</span><br><span class="line">$ <span class="keyword">if</span> [[ <span class="variable">$REPLY</span> = y ]]; <span class="keyword">then</span></span><br><span class="line">&gt;     <span class="built_in">echo</span> <span class="string">&quot;Here you go, an egg sandwich.&quot;</span>              <span class="comment"># Branch #1</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt;     <span class="built_in">echo</span> <span class="string">&quot;Here, you should at least have a coffee.&quot;</span>   <span class="comment"># Branch #2</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">Here, you should at least have a coffee.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>与我们之前编写的所有代码相比，条件语句的关键在于，除非情况发生变化，否则我们现在的代码永远不会被执行。仅执行了第二个分支中的代码，即使我们在第一个分支中有实际代码，bash 也从未真正执行过它。只有当情况（在这种情况下，我们对前面问题的答案）发生变化时，脚本的执行分支才会发生变化，并且我们会看到第一个分支中的代码被执行，但同时，这将导致第二个分支分支变得“死亡”。</p>
<h5 id="The-if-compound"><a href="#The-if-compound" class="headerlink" title="The if compound."></a>The if compound.</h5><p>该if语句在编程语言中非常普遍，几乎可以肯定，当我们考虑在代码中构建一个条件时，首先想到的就是它。这并非偶然：这些陈述清晰、简单且明确。这也使它们成为我们熟悉 bash 条件语句的绝佳起点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if list [ ;|&lt;newline&gt; ] then list ;|&lt;newline&gt;</span><br><span class="line">[ elif list [ ;|&lt;newline&gt; ] then list ;|&lt;newline&gt; ] ...</span><br><span class="line">[ else list ;|&lt;newline&gt; ]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ! <span class="built_in">rm</span> hello.txt; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Couldn&#x27;t delete hello.txt.&quot;</span> &gt;&amp;2; </span><br><span class="line">    <span class="built_in">exit</span> 1; </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">rm</span> hello.txt; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Successfully deleted hello.txt.&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Couldn&#x27;t delete hello.txt.&quot;</span> &gt;&amp;2; </span><br><span class="line">    <span class="built_in">exit</span> 1; </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mv</span> hello.txt ~/.Trash/; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Moved hello.txt into the trash.&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">rm</span> hello.txt; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Deleted hello.txt.&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Couldn&#x27;t remove hello.txt.&quot;</span> &gt;&amp;2; </span><br><span class="line">    <span class="built_in">exit</span> 1; </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>该复合词的语法if虽然一开始有点冗长，但本质上非常简单。我们从关键字开始<code>if</code>，然后是命令列表。该命令列表将由 <code>bash</code> 执行，完成后，<code>bash</code> 会将最终的退出代码交给<code>if</code>要评估的化合物。如果退出代码为零<code>（0= success）</code>，则将执行第一个分支。否则，将跳过第一个分支。</p>
<p>如果跳过第一个分支，<code>if</code>复合会将执行机会传递到下一个分支。如果<code>elif</code>有一个或多个分支可用，这些分支将依次执行并评估它们自己的命令列表，如果成功，则执行它们的分支。请注意，一旦<code>if</code>执行复合的任何分支，其余分支就会自动跳过：仅执行一个分支。如果<code>if</code>两个 <code>elif</code>分支都没有资格执行，<code>else</code>则将执行该分支（如果存在）。</p>
<p>实际上，<code>if</code>复合语句是表达一系列要执行的潜在分支的语句，每个分支前面都有一个命令列表，用于评估是否应选择该分支。大多数if语句只有一个分支或一个主分支和一个<code>else</code>分支。</p>
<h5 id="Conditional-command-lists"><a href="#Conditional-command-lists" class="headerlink" title="Conditional command lists"></a>Conditional command lists</h5><p>如上所述，该<code>if</code>语句与大多数其他条件语句类似，评估<code>List</code>命令的最终退出代码，以确定是否应采用或跳过其相应的条件分支。您将遇到的几乎所有<code>if</code>条件语句和其他条件语句都只不过是一个简单命令作为其条件，但仍然可以提供简单命令的完整列表。当我们这样做时，重要的是要理解只有执行整个列表后的最终退出代码才与分支的评估相关：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">&quot;Breakfast? [y/n] &quot;</span>; <span class="keyword">if</span> [[ <span class="variable">$REPLY</span> = y ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Here are your eggs.&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">Breakfast? [y/n] y</span><br><span class="line">Here are your eggs.</span><br><span class="line">$ <span class="keyword">if</span> <span class="built_in">read</span> -p <span class="string">&quot;Breakfast? [y/n] &quot;</span>; [[ <span class="variable">$REPLY</span> = y ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Here are your eggs.&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">Breakfast? [y/n] y</span><br><span class="line">Here are your eggs.</span><br></pre></td></tr></table></figure>
<p>两者在操作上是相同的。在第一种情况下，我们的read命令先于if语句；在后者中，我们的read命令嵌入在初始分支条件中。本质上，风格或偏好的选择将决定您更喜欢哪种方法。关于此事的一些想法：</p>
<ul>
<li>嵌入数据收集命令为条件创建了一种“完整”方法：条件成为由其所有依赖项组成的单元。</li>
<li>数据收集命令之前的条件语句将两个不同的操作分开。<code>elif</code>当其他分支成为语句的一部分时，它还使条件更加对称或“平衡” 。</li>
</ul>
<h5 id="Conditional-test-commands"><a href="#Conditional-test-commands" class="headerlink" title="Conditional test commands"></a>Conditional test commands</h5><p>最常用作条件的命令是<code>testcommand</code>，也称为<code>[command</code>。这两个是同义词：它们是相同的命令，但名称不同。唯一的区别是，当您用作<code>[</code>命令名称时，必须使用尾随<code>]</code>参数来终止命令。</p>
<p>然而，在现代 <code>bash</code> 脚本中，<code>test</code>出于所有意图和目的，该命令已被它的两个弟弟所取代： <code>[[</code>和<code>((</code>关键字。该<code>test</code>命令实际上已经过时，其有缺陷且脆弱的语法无法与<code>[[bash((</code>解析器授予的特殊权力相匹配。</p>
<p><code>It may seem strange at first thought, but it is actually quite interesting a revelation to notice that [ and [[, as we&#39;ve seen them appear several times in if and other sample statements in this guide, are not some special form of if-syntax - no! They are simple, ordinary commands, just like any other command. The [[ command name takes a list of arguments and its final argument must be ]]. Similarly, [ is a command name which takes test arguments and must be closed with a trailing ] argument. This is especially noticable when we make a mistake and omit spaces between these command names and their arguments:</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ [[ Jack = Jane ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Jack is Jane&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Jack is not Jane&quot;</span></span><br><span class="line">Jack is not Jane</span><br><span class="line">$ [[Jack = Jane ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Jack is Jane&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Jack is not Jane&quot;</span></span><br><span class="line">-bash: [[Jack: <span class="built_in">command</span> not found</span><br><span class="line">$ [[ Jack=Jane ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Jack is Jane&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Jack is not Jane&quot;</span></span><br><span class="line">Jack is Jane</span><br></pre></td></tr></table></figure>
<p>第一条语句编写正确，我们得到了预期的输出。在第二条语句中，我们忘记将<code>[[</code>命令名称与第一个参数分开，导致 bash 解析器去寻找名为<code>[[Jack</code>的命令。毕竟，当 <code>bash</code> 解析此命令并将命令的名称和参数分词为标记时，第一个以空格分隔的标记是整个字符串<code>[[Jack</code>。</p>
]]></content>
      <categories>
        <category>Bash Programing</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>bash programing</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】构建基础镜像</title>
    <url>/2023/08/14/Cloud-Native/%E3%80%90Docker%E3%80%91%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h5 id="构建Nginx基础镜像"><a href="#构建Nginx基础镜像" class="headerlink" title="构建Nginx基础镜像"></a>构建Nginx基础镜像</h5><ol>
<li>使用apt或源码编译安装(1.<code>configure</code>; 2.<code>make</code>; 3.<code>make install</code>)</li>
<li>启用哪些模块</li>
<li><code>nginx</code> 初始化</li>
<li>启动容器</li>
</ol>
<p>在宿主机当前目录下目录下创建一个<code>Dockerfile-nginx</code>的文件，用<code>DockerFile</code>命令编写构建<code>nginx</code>镜像操作流程。如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos:8</span><br><span class="line">MAINTAINER www.umbrella.com</span><br><span class="line">RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-* &amp;&amp; \</span><br><span class="line">    sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-* &amp;&amp; \</span><br><span class="line">    yum update -y &amp;&amp; \</span><br><span class="line">    yum install -y gcc gcc-c++ make \</span><br><span class="line">    openssl-devel pcre-devel gd-devel \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    rm -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">RUN wget https://nginx.org/download/nginx-1.22.1.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf nginx-1.22.1.tar.gz &amp;&amp; \</span><br><span class="line">    cd nginx-1.22.1 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/nginx \</span><br><span class="line">    --with-http_ssl_module \</span><br><span class="line">    --with-http_stub_status_module &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    rm -rf /usr/local/nginx/html/* &amp;&amp; \</span><br><span class="line">    echo &quot;ok&quot; &gt;&gt; /usr/local/nginx/html/status.html &amp;&amp; \</span><br><span class="line">    cd / &amp;&amp; rm -rf nginx-1.22.1* &amp;&amp; \</span><br><span class="line">    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH $PATH:/usr/local/nginx/sbin</span><br><span class="line">#COPY nginx.conf /usr/local/nginx/conf/nginx.conf</span><br><span class="line">WORKDIR /usr/local/nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>
<p>在命令行中用容器构建命令执行Dockerfile-nginx&#96;文件脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v1 -f Dockerfile-nginx .</span><br></pre></td></tr></table></figure>
<p>执行完成之后，通过容器镜像查看命令docker images命令查看生成的nginx镜像文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY                    TAG         IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx                         v2          1363f9428d14   12 hours ago    693MB</span><br></pre></td></tr></table></figure>
<p>确认生成镜像文件之后，执行容器运行命令来启动来启动刚创建好的<code>nginx</code>镜像文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container run -d --name nginx02 -p 89:80 nginx:v2</span><br></pre></td></tr></table></figure>
<p>配置容器的名称<code>--name nginx02</code>,配置容器对外映射的端口<code>-p 89:80</code>。通过docker ps命令查看这个容器是否启动成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                  CREATED        STATUS        PORTS                               NAMES</span><br><span class="line">7934c463c7d4   nginx:v2   <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   12 hours ago   Up 12 hours   0.0.0.0:89-&gt;80/tcp, :::89-&gt;80/tcp   nginx02</span><br></pre></td></tr></table></figure>
<p>最后在宿主机上打开浏览器访问<code>http://&#123;分配的虚拟ip&#125;:89</code> 查看<code>nginx</code>镜像是否创建成功。</p>
<h5 id="Harbor-镜像仓库"><a href="#Harbor-镜像仓库" class="headerlink" title="Harbor 镜像仓库"></a>Harbor 镜像仓库</h5><p>Harbor 是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Register上进行了相应的企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制，确保镜像经过扫描且不存在漏洞，并将镜像标记为可信，帮助您跨 Kubernetes 和 Docker 等云原生计算平台一致、安全地管理工具。</p>
<p>它的特性包括：</p>
<ul>
<li>安全：安全和漏洞分析</li>
<li>安全：内容签名和验证</li>
<li>管理：多租户</li>
<li>管理：可扩展的 API 和 Web UI</li>
<li>管理：跨多个注册表（包括 <code>Harbor</code>）进行复制</li>
<li>管理：身份集成和基于角色的访问控制</li>
</ul>
<ol start="0">
<li>依赖：docker-engine、docker-compose、openssl需要下载安装</li>
<li>转至 <code>Harbor</code> 发布页面<a href="https://github.com/goharbor/harbor/releases">下载</a>。</li>
<li>下载您要安装的版本的在线或离线安装程序。<ul>
<li>在线安装程序：在线安装程序从 <code>Docker hub</code> 下载 <code>Harbor</code> 镜像。因此，安装程序的尺寸非常小。</li>
<li>离线安装程序：如果部署 <code>Harbor</code> 的主机没有连接到 <code>Internet</code>，请使用离线安装程序。离线安装程序包含构建的镜像，因此它比在线安装程序大</li>
</ul>
</li>
<li>用于tar解压安装包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar xzvf harbor-offline-installer-version.tgz</span><br></pre></td></tr></table></figure></li>
<li>配置<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> harbor</span><br><span class="line">$ vi harbor.cfg</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname = &#123;ip&#125;</span><br><span class="line">ui_url_protocol = http</span><br><span class="line">harbor_admin_password = ******</span><br></pre></td></tr></table></figure>
启动<code>harbor</code>运行脚本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./install.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="Prometheus-监控和警报系统"><a href="#Prometheus-监控和警报系统" class="headerlink" title="Prometheus 监控和警报系统"></a>Prometheus 监控和警报系统</h5><p><code>Prometheus</code> 是一个监控和警报系统。它于 2012 年由 <code>SoundCloud</code> 开源，是继 <code>Kubernetes</code> 之后第二个加入并毕业的云原生计算基金会项目。<code>Prometheus</code> 将所有指标数据存储为时间序列，即指标信息与其记录的时间戳一起存储，称为标签的可选键值对也可以与指标一起存储。</p>
<p>度量是衡量的标准。我们想要测量的内容取决于应用程序的不同。对于 Web 服务器，它可以是请求时间，对于数据库，它可以是 CPU 使用率或活动连接数等。</p>
<p>指标在理解应用程序为何以某种方式运行方面发挥着重要作用。如果您运行一个 Web 应用程序，有人走到您面前并说该应用程序速度很慢。您将需要一些信息来了解您的应用程序发生了什么。例如，当请求数量较多时，应用程序可能会变慢。如果您有请求计数指标，您可以找出原因并增加服务器数量来处理重负载。每当您为应用程序定义指标时，您都必须加入侦探并问：<strong>如果我的应用程序中出现任何问题，哪些信息对我调试很重要？</strong></p>
<p>Prometheus特点：</p>
<ul>
<li>多维数据模型：有度量名称和键值对标识的时间序列数据</li>
<li><code>PromSQL</code>: 一种灵活的查询语言，可以利用多维数据完成复杂的查询</li>
<li>不依赖于分布式存储，单个服务节点可直接工作</li>
<li>基于<code>http</code>的<code>pull</code>方式采集时间序列数据</li>
<li>推送时间序列数据通过<code>PushGateway</code>组件支持</li>
<li>通过服务发现或静态配置发现</li>
<li>多种图形模式和仪表盘支持(<code>grafana</code>)</li>
</ul>
<p>Prometheus组件：<br><code>Prometheus</code> 系统由多个组件组成，其中许多组件是可选的：</p>
<ul>
<li>Prometheus 服务器，用于抓取和存储时间序列数据</li>
<li>用于检测应用程序代码的客户端库</li>
<li>支持短期工作的推送网关</li>
<li><code>HAProxy、StatsD、Graphite</code> 等服务的特殊用途 <code>exporters</code>。</li>
<li>处理警报的警报管理器</li>
<li>各种支持工具</li>
</ul>
<p>大多数 <code>Prometheus</code> 组件都是用<code>Go</code>编写的，这使得它们很容易作为静态二进制文件构建和部署。</p>
<p>Prometheus架构</p>
<img data-src="/2023/08/14/Cloud-Native/%E3%80%90Docker%E3%80%91%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F/prometheus.png" class="">

<p><code>Prometheus</code> 直接或通过短期作业的中间推送网关从仪表化作业中获取指标。它在本地存储所有抓取的样本，并对这些数据运行规则，以聚合和记录现有数据的新时间序列或生成警报。<code>Grafana</code>或其他 API 使用者可用于可视化收集的数据。</p>
<p><code>Prometheus</code> 非常适合记录任何纯数字时间序列。它既适合以机器为中心的监控，也适合高度动态的面向服务的架构的监控。在微服务的世界中，它对多维数据收集和查询的支持是一个特殊的优势。<code>Prometheus</code> 的设计注重可靠性，是您在中断期间可以使用的系统，以便您快速诊断问题。每个 <code>Prometheus</code> 服务器都是独立的，不依赖于网络存储或其他远程服务。当基础设施的其他部分损坏时，您可以依赖它，并且无需设置大量基础设施即可使用它。</p>
<p>Prometheus 容器安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name prometheus-container -p 9090:9090 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp/prometheus.yml,target=/etc/prometheus/prometheus.yml ubuntu/prometheus:2.46.0-22.04_stable</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-e TZ=UTC</code></td>
<td align="left">时区</td>
</tr>
<tr>
<td align="left"><code>-v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml</code></td>
<td align="left">本地配置文件<code>prometheus.yml</code></td>
</tr>
<tr>
<td align="left"><code>-v /path/to/alerts.yml:/etc/prometheus/alerts.yml</code></td>
<td align="left">本地警报配置文件<code>alerts.yml</code></td>
</tr>
</tbody></table>
<p>进入容器调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it prometheus-container /bin/bash</span><br></pre></td></tr></table></figure>

<h5 id="cAdvisor（Container-Advisor）"><a href="#cAdvisor（Container-Advisor）" class="headerlink" title="cAdvisor（Container Advisor）"></a>cAdvisor（Container Advisor）</h5><p>为容器用户提供对其运行容器的资源使用情况和性能特征的了解。它是一个正在运行的守护进程，用于收集、聚合、处理和导出有关正在运行的容器的信息。具体来说，它为每个容器保留资源隔离参数、历史资源使用情况、完整历史资源使用情况的直方图和网络统计信息。</p>
<p>Docker 容器中运行 cAdvisor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run  \</span><br><span class="line">     --volume=/:/rootfs:ro \</span><br><span class="line">     --volume=/var/run:/var/run:ro  \</span><br><span class="line">     --volume=/sys:/sys:ro   \</span><br><span class="line">     --volume=/var/lib/docker/:/var/lib/docker:ro   \</span><br><span class="line">     --volume=/dev/disk/:/dev/disk:ro   \</span><br><span class="line">     --publish=8080:8080   \</span><br><span class="line">     --detach=<span class="literal">true</span>   \</span><br><span class="line">     --name=cadvisor  \</span><br><span class="line">     google/cadvisor:latest</span><br></pre></td></tr></table></figure>
<p>访问您的 cAdvisor <code>http://localhost:8080/metrics</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">container_cpu_load_average_10s</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   container_label_org_label_schema_build_date=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_label_schema_license=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_label_schema_name=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_label_schema_schema_version=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_label_schema_vendor=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_opencontainers_image_base_digest=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_opencontainers_image_created=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_opencontainers_image_licenses=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_opencontainers_image_ref_name=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_opencontainers_image_title=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>container_label_org_opencontainers_image_version=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>id=<span class="string">&quot;/&quot;</span><span class="punctuation">,</span>image=<span class="string">&quot;&quot;</span><span class="punctuation">,</span>name=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>访问您的 Prometheus 实例<code>http://localhost:9090</code>：</p>
<p>我们可以查看采集的指标：<br><code>container_cpu_cfs_periods_total</code> -&gt; <code>container_cpu_cfs_periods_total&#123;id=&quot;/aegis&quot;, instance=&quot;198.19.37.126:8080&quot;, job=&quot;docker&quot;&#125;</code><br><code>ontainer_cpu_load_average_10s</code> -&gt; <code>container_cpu_load_average_10s&#123;id=&quot;/&quot;, instance=&quot;198.19.37.126:8080&quot;, job=&quot;docker&quot;&#125;</code></p>
<h5 id="Grafana-监控仪表盘"><a href="#Grafana-监控仪表盘" class="headerlink" title="Grafana 监控仪表盘"></a>Grafana 监控仪表盘</h5><p>无需构建、安装、维护和扩展可观察性堆栈的开销即可实现可观察性。Grafana Cloud 是开放且可组合的可观测平台。</p>
<p>Docker 容器中运行 Grafana：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container run -d --name grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>

<p>访问您的 Prometheus 实例<code>http://localhost:3000</code>：</p>
<ol>
<li>选择数据源 -&gt; Prometheus</li>
<li>导入仪表盘库（193：容器实例监控仪表盘、195：宿主机实例监控仪表盘）</li>
</ol>
<img data-src="/2023/08/14/Cloud-Native/%E3%80%90Docker%E3%80%91%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F/grafana.png" class="">
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bash 编程】变量和扩展</title>
    <url>/2023/08/02/Cloud-Native/%E3%80%90Bash%20%E7%BC%96%E7%A8%8B%E3%80%91variable-expand/</url>
    <content><![CDATA[<p>假设我们要删除目录中的文件Downloads。根据我们迄今为止收集的知识，我们可以查看其中有哪些文件并删除它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Downloads</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">05 Between Angels and Insects.ogg</span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">rm</span> -v <span class="string">&#x27;05 Between Angels and Insects.ogg&#x27;</span> <span class="string">&#x27;07 Wake Up.ogg&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;05 Between Angels and Insects.ogg&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;07 Wake Up.ogg&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果我们不必把所有事情都说得那么明确，那不是很好吗？毕竟，我们的目的是清空我们的<code>Downloads</code>目录。为此，我们必须手动前往那里，找出存在哪些文件，并发出<code>rm</code>枚举每个文件名的命令。让我们改进这个工作流程，让我们的代码更加动态一些。我们想要实现的是一种可以反复使用的工作模板。职位描述描述了执行我们意图的方式，无论我们当前所处的具体情况如何。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="Pathname-Expansion"><a href="#Pathname-Expansion" class="headerlink" title="Pathname Expansion"></a>Pathname Expansion</h5><p>bash 为我们提供的多种形式的扩展中的第一种。欢迎使用路径名扩展：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Downloads</span><br><span class="line">$ <span class="built_in">rm</span> -v *</span><br><span class="line">removed <span class="string">&#x27;05 Between Angels and Insects.ogg&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;07 Wake Up.ogg&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>我们想要删除的文件名发生了什么？我们用一种模式替换了它们，告诉 bash为我们扩展路径名。扩展是用特定情况的代码替换部分命令代码的做法。在本例中，我们希望替换*为下载目录中每个文件的路径名。因此，用路径名替换模式称为路径名扩展。bash 注意到您已在命令行上期望看到参数的位置放置了路径名模式。然后，它采用此路径名模式，并在文件系统中查找它可以找到的与我们的此模式匹配的每个路径名。碰巧该模式*与当前目录中每个文件的名称相匹配。因此，bash 将命令行中的模式替换为当前目录中每个文件的路径名。我们不必再自己做这些工作了！结果，我们的下载目录按预期被清空。</p>
<div class="note warning"><p>重要的是要理解，虽然我们*在代码中看到明显的参数对于 <code>rm</code>，但我们实际上并没有传递*给<code>rm</code>。事实上，该rm命令甚至永远不会看到我们的路径名扩展模式。该模式在启动之前就由 <code>bash</code> 进行评估和扩展<code>rm</code>。据了解<code>rm</code>，它只是接收一个<code>-v</code>参数，后跟目录中每个文件的确切完整名称。扩展始终由<code>bash</code>本身执行，并且始终在实际运行命令之前执行！</p>
</div>
<p><code>Bash</code> 可以为我们执行各种路径名扩展。要执行路径名扩展，我们只需在要扩展路径名的位置编写语法<code>glob</code> 模式即可。<code>glob</code> 是 <code>bash shell</code> 支持的模式类型的名称。以下是 <code>bash shell</code> 支持的各种基本 <code>glob</code> 模式：</p>
<table>
<thead>
<tr>
<th align="left">Glob</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">星号或星号匹配任何类型的文本，甚至根本没有文本。</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">问号与任意一个字符匹配。</td>
</tr>
<tr>
<td align="left"><code>[characters]</code></td>
<td align="left">方括号内的一组字符与单个字符匹配，前提是该字符位于给定的集合中。</td>
</tr>
<tr>
<td align="left"><code>[[:classname:]]</code></td>
<td align="left">当矩形大括号内直接有一组冒号时，您可以指定一类字符的名称，而不必自己枚举每个字符。Bash 了解各种字符类。例如，如果您使用该模式，则仅当该字符是字母数字时，<code>bash</code> 才会将其与字符匹配。支持的字符类包括：<code>alnum、alpha、ascii、blank、cntrl、digit、graph、lower、print、punct、space、upper、word、xdigit[[:alnum:]]</code></td>
</tr>
</tbody></table>
<p>我们可以将这些 glob 模式组合在一起来描述各种路径名组合。我们还可以将它与文字字符结合起来，告诉 bash 模式的一部分应该包含确切的文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span>                                <span class="comment"># Without arguments, ls simply lists the full contents of a directory.</span></span><br><span class="line">myscript.txt</span><br><span class="line">mybudget.xsl</span><br><span class="line">hello.txt</span><br><span class="line">05 Between Angels and Insects.ogg</span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">ls</span> *                              <span class="comment"># While the effect is the same, this command actually enumerates every single file</span></span><br><span class="line">myscript.txt                        <span class="comment"># in the directory to the ls in its arguments!</span></span><br><span class="line">mybudget.xsl</span><br><span class="line">hello.txt</span><br><span class="line">05 Between Angels and Insects.ogg</span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">ls</span> *.txt                          <span class="comment"># When we include the literal string .txt, the only pathnames that still match the pattern</span></span><br><span class="line">myscript.txt                        <span class="comment"># are those that start with any kind of text and end with the literal string .txt.</span></span><br><span class="line">hello.txt</span><br><span class="line">$ <span class="built_in">ls</span> 0?<span class="string">&#x27; &#x27;</span>*.ogg                     <span class="comment"># Here we&#x27;re combining patterns, looking for any pathname start starts with a 0,</span></span><br><span class="line">05 Between Angels and Insects.ogg   <span class="comment"># followed by any single character, followed by a literal space, ending in .ogg.</span></span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">ls</span> [0-9]*                         <span class="comment"># In a character set, we can use - to indicate a range of characters.  This will match</span></span><br><span class="line">05 Between Angels and Insects.ogg   <span class="comment"># a pathname starting with one character between 0 and 9 followed by any other text.</span></span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">ls</span> [[:digit:]][[:digit:]]*        <span class="comment"># Character classes are really nice because they speak for us: they tell us exactly</span></span><br><span class="line">05 Between Angels and Insects.ogg   <span class="comment"># what our intent here is.  We want any pathname that start with two digits.</span></span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">ls</span> [[:digit:]][[:digit:]]         <span class="comment"># Your pattern needs to be complete!  None of our filenames is only just two digits.</span></span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>同样重要的是要了解这些 <code>glob</code> 永远不会跳转到子目录中。它们仅与自己目录中的文件名匹配。如果我们希望 <code>glob</code> 去查看不同目录中的路径名，我们需要用文字路径名显式地告诉它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> ~/Downloads/*.txt                    <span class="comment"># Enumerate all pathnames in ~/Downloads that end with .txt.</span></span><br><span class="line">/Users/lhunath/Downloads/myscript.txt</span><br><span class="line">/Users/lhunath/Downloads/hello.txt</span><br><span class="line">$ <span class="built_in">ls</span> ~/*/hello.txt                        <span class="comment"># Globs can even search through many directories!  Here bash will search</span></span><br><span class="line">/Users/lhunath/Documents/hello.txt        <span class="comment"># through all directories in our home directory for a file that&#x27;s called hello.txt.</span></span><br><span class="line">/Users/lhunath/Downloads/hello.txt</span><br></pre></td></tr></table></figure>
<p>路径名扩展是一个非常强大的工具，可以避免在参数中指定确切的路径名，或者在文件系统中查找我们需要的文件。最后，<code>bash</code> 还内置了对更高级的 <code>glob</code> 模式的支持。这些 <code>glob</code> 称为：扩展 <code>glob</code>。默认情况下，对它们的支持是禁用的，但我们可以使用以下命令在当前 <code>shell</code> 中轻松启用它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s extglob</span><br></pre></td></tr></table></figure>
<p>启用扩展 glob 后，上面的 glob 模式运算符表将扩展为以下附加运算符：</p>
<table>
<thead>
<tr>
<th align="left">全局扩展</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+(pattern[ | pattern ... ])</code></td>
<td align="left">当列表中的任何模式出现一次或多次时匹配。读作：至少其中之一……</td>
</tr>
<tr>
<td align="left"><code>*(pattern[ | pattern ... ])</code></td>
<td align="left">当列表中的任何模式出现一次、根本不出现或出现多次时匹配。读作：然而许多……。</td>
</tr>
<tr>
<td align="left"><code>?(pattern[ | pattern ... ])</code></td>
<td align="left">当列表中的任何模式出现一次或根本不出现时匹配。读作：也许其中之一……</td>
</tr>
<tr>
<td align="left"><code>@(pattern[ | pattern ... ])</code></td>
<td align="left">当列表中的任何模式仅出现一次时匹配。读作：……之一。</td>
</tr>
<tr>
<td align="left"><code>!(pattern[ | pattern ... ])</code></td>
<td align="left">仅当列表中没有出现任何模式时才匹配。读作：没有一个……。</td>
</tr>
</tbody></table>
<p>这些运算符起​​初有点难以理解，但它们是向模式添加逻辑的好方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> +([[:digit:]])<span class="string">&#x27; &#x27;</span>*.ogg               <span class="comment"># Filenames that start with one or more digits.</span></span><br><span class="line">05 Between Angels and Insects.ogg</span><br><span class="line">07 Wake Up.ogg</span><br><span class="line">$ <span class="built_in">ls</span> *.jp?(e)g                            <span class="comment"># Filenames that end either in .jpg or .jpeg.</span></span><br><span class="line">img_88751.jpg</span><br><span class="line">igpd_45qr.jpeg</span><br><span class="line">$ <span class="built_in">ls</span> *.@(jpg|jpeg)                        <span class="comment"># Same thing, perhaps written more clearly!</span></span><br><span class="line">img_88751.jpg</span><br><span class="line">igpd_45qr.jpeg</span><br><span class="line">$ <span class="built_in">ls</span> !(my*).txt                           <span class="comment"># All the .txt files that do not begin with my.</span></span><br><span class="line">hello.txt</span><br><span class="line">$ <span class="built_in">ls</span> !(my)*.txt                           <span class="comment"># Can you guess why this one matches myscript.txt?</span></span><br><span class="line">myscript.txt</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure>
<p>扩展的全局模式有时非常有用，但它们也可能令人困惑和误导。让我们关注最后一个例子：为什么要<code>!(my)*.txt</code>扩展路径名<code>myscript.txt？</code>是不是<code>!(my)</code>应该只在路径名在此位置没有时才匹配<code>？my</code>你说得对，就是这样！然而，<code>bash</code> 扩展了以my!开头的路径名。</p>
<p>这里的答案是 <code>bash</code> 很乐意将模式的这一部分与m开头的 匹配（与 不同<code>my</code>），甚至与文件名开头的空白进行匹配。这意味着为了使路径名仍然可以扩展，模式的其余部分需要与路径名的其余部分匹配。碰巧我们在 <code>glob*</code>后面有一个 <code>glob !(my)</code>，它很乐意匹配整个文件名。在这种情况下，该部分与名称开头的字符<code>!(my)</code>匹配，该部分与该部分匹配，模式的后缀与尾随的字符匹配<code>m*yscript.txt.txt</code>我们的路径名。模式与名称相匹配，因此名称被扩展！当我们在模式*内部包含该内容时<code>!()</code>，这不再有效，并且针对此路径名的匹配失败：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> !(my)*.txt</span><br><span class="line">myscript.txt</span><br><span class="line">hello.txt</span><br><span class="line">$ <span class="built_in">ls</span> !(my*).txt</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure>
<h5 id="波形符扩展"><a href="#波形符扩展" class="headerlink" title="波形符扩展"></a>波形符扩展</h5><p>它称为波形符扩展，它涉及将路径名中的波形符 ( ~) 替换为当前用户主目录的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;I live in: &#x27;</span> ~           <span class="comment"># Note that expansions must not be quoted or they will become literal!</span></span><br><span class="line">I live <span class="keyword">in</span>: /Users/lhunath</span><br></pre></td></tr></table></figure>
<p>与路径名扩展相比，波浪线扩展在 <code>bash</code> 中稍微特殊，因为它发生在解析器阶段的早期。这只是一个细节，但重要的是要注意波浪号扩展与路径名扩展不同。我们不会执行搜索并尝试将文件名与全局模式进行匹配。我们只是用显式路径名替换波形符。除了简单的波浪号之外，我们还可以通过将用户名放在波浪号后面来扩展另一个用户的主目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;My boss lives in: &#x27;</span> ~root</span><br><span class="line">My boss lives <span class="keyword">in</span>: /var/root</span><br></pre></td></tr></table></figure>
<h5 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h5><p>扩展的用途远不止于此。我们可以使用扩展将几乎任何类型的数据扩展到命令的参数中。命令替换是将数据扩展为命令参数的一种非常流行的方法。通过<code>Command Substitution</code>，我们可以有效地在命令中编写命令，并要求 <code>bash</code> 将内部命令展开到其输出中，并使用该输出作为主命令的参数数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;Hello world.&#x27;</span> &gt; hello.txt</span><br><span class="line">$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">Hello world.</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;The file &lt;hello.txt&gt; contains: <span class="subst">$(cat hello.txt)</span>&quot;</span></span><br><span class="line">The file &lt;hello.txt&gt; contains: Hello world.</span><br></pre></td></tr></table></figure>
<p>我们开始非常简单：我们创建一个名为 的文件<code>hello.txt</code>并将字符串放入<code>Hello world</code>.其中。然后我们使用cat命令输出文件的内容。我们可以看到该文件包含我们保存到其中的字符串。</p>
<p>但接下来事情就变得有趣了：我们想要在这里做的是向用户输出一条消息，用一个漂亮的句子解释我们文件中的字符串是什么。为此，我们希望使文件的内容成为我们<code>echo</code>输出的句子的“一部分”。然而，当我们为这句话编写代码时，我们并不知道文件的内容是什么，那么我们如何在脚本中打出正确的句子呢？答案是扩展：我们知道如何使用 获取文件的内容<code>cat</code>，因此这里我们将命令的输出扩展为我们的句子。<code>Bash</code> 将首先运行，获取该命令的输出（这是我们的字符串），然后扩展我们的命令替换语法<code>$(cat ...)</code>进入该输出。只有在这个扩展之后，<code>bash</code>才会尝试运行该<code>echo</code>命令。您能猜出在我们的命令替换就地扩展之后该命令的参数<code>echo</code>变成了什么吗？答案是：<code>echo &quot;The file &lt;hello.txt&gt; contains: Hello world</code>.”</p>
<p>这是我们了解到的第一种价值扩展。值扩展允许我们将数据扩展为命令参数。它们非常有用，您将一直使用它们。<code>Bash</code> 在值扩展方面具有相当一致的语法：它们都以<code>$</code>符号开头。命令替换实质上扩展了在子 shell 中执行的命令的价值。因此，语法是值扩展前缀$后跟要扩展的子 shell 的组合：(…)。子 shell 本质上是一个小型的新 bash 进程，用于在主 bash shell 等待结果时运行命令。</p>
<div class="note success"><p>非常细心的读者可能已经注意到，本指南倾向于使用单引号来引用其字符串，但在最新的示例中，对包含扩展语法的句子改用双引号。这是有意为之的：如果参数是双引号的，则所有值扩展（即所有带有<code>$</code>前缀的语法）只能在带引号的参数内扩展。单引号会将<code>$</code>语法转换为文字字符，导致 <code>bash</code> 输出美元而不是就地扩展其值！因此，对所有包含值扩展的参数加双引号非常重要。</p>
<p>值扩展 ( $…) 必须始终用双引号引起来。</p>
</div>
<div class="note warning"><p>切勿将价值扩展不加引号。如果这样做，<code>bash</code> 将使用分词来分割该值，删除其中的所有空格，并对其中的所有单词执行隐藏的路径名扩展！</p>
</div>

<h4 id="存储和重复使用数据"><a href="#存储和重复使用数据" class="headerlink" title="存储和重复使用数据"></a>存储和重复使用数据</h4><p>我们现在知道如何使用 bash 来编写和管理简单的命令。这些命令使我们能够访问系统上的许多强大的操作。我们已经了解了命令如何通过为程序创建新进程来告诉 bash 执行程序。我们甚至学会了操纵这些进程的基本输入和输出，以便我们可以读取和写入任意文件。那些真正密切关注的人甚至会发现我们如何使用诸如此处文档和此处字符串之类的结构将任意数据传递到进程中。现在最大的限制是我们无法灵活处理数据。我们可以将其写入文件，然后通过使用许多文件重定向再次将其读入，并且我们可以使用此处文档和此处字符串传入静态预定义数据。</p>
<p><strong>bash 参数</strong></p>
<p>简单地说，bash 参数是内存中的区域，您可以在其中临时存储一些信息以供以后使用。与文件不同，我们写入这些参数，并在稍后需要检索信息时从中读取。但由于我们使用系统内存而不是磁盘来写入这些信息，因此访问速度要快得多。与将输入和输出重定向到文件或从文件重定向相比，使用参数也更容易，语法也更强大。Bash 提供了几种不同类型的参数：位置参数、特殊参数和 shell 变量。后者是最有趣的类型，前两者主要使我们能够访问 bash 提供的某些信息。我们将通过变量介绍参数的实际方面和用法，然后解释位置参数和特殊参数的不同之处。</p>
<h5 id="shell-变量"><a href="#shell-变量" class="headerlink" title="shell 变量"></a>shell 变量</h5><p><code>shell</code> 变量本质上是一个有名称的 <code>bash</code> 参数。您可以使用变量来存储值，并在以后修改或读回该值以供重复使用。使用变量很容易。您可以通过变量分配在其中存储信息，并在以后随时使用参数扩展来访问该信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ name=lhunath                         <span class="comment"># Assign the value lhunath to the variable name</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>. How are you?&quot;</span>    <span class="comment"># Expand the value of name into the echo argument</span></span><br><span class="line">Hello, lhunath.  How are you?</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，赋值创建了一个名为 的变量<code>name</code>，并在其中放入了一个值。参数值的扩展是通过在名称前添加符号来完成的<code>$</code>，这会导致我们的值被注入到 <code>echo</code> 参数中。赋值使用<code>=</code>运算符。您必须了解运算符周围不能有语法空间。虽然其他语言可能允许这样做，但 bash 却不允许。请记住上一章中的空格在 <code>bash</code> 中具有特殊含义：它们将命令拆分为参数。如果我们在运算符周围放置空格&#x3D;，它们会导致 <code>bash</code> 将命令拆分为命令名称和参数，认为您想要执行程序而不是分配变量值：&#x3D;要修复此代码，我们只需删除导致分词的运算符周围的空格即可。如果我们想给以几个文字空格字符开头的变量分配一个值，我们需要使用引号来向 <code>bash</code> 发出信号，表明我们的空格是文字的，不应该触发分词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ name=lhunath</span><br><span class="line">$ item=<span class="string">&#x27;    4. Milk&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们甚至可以将此赋值语法与其他值扩展结合起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ contents=<span class="string">&quot;<span class="subst">$(cat hello.txt)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们执行命令替换，将文件的内容扩展hello.txt为我们的赋值语法，这随后导致该内容被分配给内容变量。给变量赋值很简洁，但并不是立即有用。能够随时重用这些值使得参数变得如此有趣。重用参数值是通过扩展它们来完成的。参数扩展有效地从参数中取出数据并将其内联到命令的数据中。正如我们之前简要看到的，我们通过在参数名称前加上符号来扩展参数$。每当您在 bash 中看到此符号时，可能是因为某些内容正在扩展。它可以是参数、命令的输出或算术运算的结果。此外，参数扩展允许您将大括号 ({和}) 括在扩展周围。这些大括号用于告诉 bash 参数名称的开头和结尾是什么。它们通常是可选的，因为 bash 通常可以自行计算出名称。尽管有时它们成为必需品：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ name=Britta time=23.73                        <span class="comment"># We want to expand time and add an s for seconds</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span>&#x27;s current record is <span class="variable">$times</span>.&quot;</span>      <span class="comment"># but bash mistakes the name for times which holds nothing</span></span><br><span class="line">Britta<span class="string">&#x27;s current record is .</span></span><br><span class="line"><span class="string">$ echo &quot;$name&#x27;</span>s current record is <span class="variable">$&#123;time&#125;</span>s.<span class="string">&quot;    # Braces explicitly tell bash where the name ends</span></span><br><span class="line"><span class="string">Britta&#x27;s current record is 23.73s.</span></span><br></pre></td></tr></table></figure>
<p>参数扩展非常适合将用户或程序数据插入到我们的命令指令中，但它们还有一个额外的王牌：参数扩展运算符。扩展参数时，可以将运算符应用于扩展值。该运算符可以通过多种有用方法之一修改该值。请记住，该运算符仅更改扩展的值；它不会改变变量中的原始值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ name=Britta time=23.73</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span>&#x27;s current record is <span class="variable">$&#123;time%.*&#125;</span> seconds and <span class="variable">$&#123;time#*.&#125;</span> hundredths.&quot;</span></span><br><span class="line">Britta<span class="string">&#x27;s current record is 23 seconds and 73 hundredths.</span></span><br><span class="line"><span class="string">$ echo &quot;PATH currently contains: $&#123;PATH//:/, &#125;&quot;</span></span><br><span class="line"><span class="string">PATH currently contains: /Users/lhunath/.bin, /usr/local/bin, /usr/bin, /bin, /usr/libexec</span></span><br></pre></td></tr></table></figure>
<p>上面的示例使用<code>%</code>,<code>#</code>和<code>//</code>运算符在扩展结果之前对参数值执行各种操作。参数本身没有改变；运算符仅影响扩展到位的值。您还会注意到，我们可以在这里使用 <code>glob</code> 模式，就像我们在路径名扩展期间所做的那样，来匹配参数中的值。</p>
<p>在第一种情况下，我们在展开之前使用%运算符从 的值中删除.及其后面的数字。time这样我们就只剩下了 前面的部分.，即秒。第二种情况做了类似的事情，我们使用#运算符从值的开头删除一部分<code>time</code>。最后，我们使用<code>//</code>运算符（这实际上是运算符的特例<code>/</code>）将的值:中的每个字符替换为。结果是一个目录列表，比原来的冒号分隔的目录更容易阅读。 <code>PATH, PATH</code></p>
<table>
<thead>
<tr>
<th align="left">Operator</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>$&#123;parameter#pattern&#125;</code>如果与模式匹配的最短字符串位于值的开头，则删除它。</td>
<td align="left"><code>&quot;$&#123;url#*/&#125;&quot;</code></td>
<td align="left">https:&#x2F;&#x2F;&#x2F;guide.bash.academy&#x2F;variables.html &gt; &#x2F;guide.bash.academy&#x2F;variables.html</td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter##pattern&#125;</code>如果与模式匹配的最长字符串位于值的开头，则删除它。</td>
<td align="left"><code>&quot;$&#123;url##*/&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; variables.html</td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter%pattern&#125;</code>如果与模式匹配的最短字符串位于值的末尾，则删除它。</td>
<td align="left"><code>&quot;$&#123;url%/*&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; <a href="https://guide.bash.academy/">https://guide.bash.academy</a></td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter%%pattern&#125;</code>如果与模式匹配的最长字符串位于值的末尾，则删除它。</td>
<td align="left"><code>&quot;$&#123;url%%/*&#125;&quot;</code></td>
<td align="left">https：&#x2F;&#x2F;guide.bash.academy&#x2F;variables.html &gt; https：</td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter/pattern/replacement&#125;</code>将与模式匹配的第一个字符串替换为替换内容。</td>
<td align="left"><code>&quot;$&#123;url/./-&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; <a href="https://guide-bash.academy/variables.html">https://guide-bash.academy/variables.html</a></td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter//pattern/replacement&#125;</code>将与模式匹配的每个字符串替换为替换内容。</td>
<td align="left"><code>&quot;$&#123;url//./-&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; <a href="https://guide-bash-academy/variables-html">https://guide-bash-academy/variables-html</a></td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter/#pattern/replacement&#125;</code>将与值开头的模式匹配的字符串替换为替换值。</td>
<td align="left"><code>&quot;$&#123;url/#*:/http:&#125;&quot;</code></td>
<td align="left">https：&#x2F;&#x2F;guide.bash.academy&#x2F;variables.html &gt; <a href="http://guide.bash.academy/variables.html">http://guide.bash.academy/variables.html</a></td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter/%pattern/replacement&#125;</code>将与值末尾的模式匹配的字符串替换为替换值。</td>
<td align="left"><code>&quot;$&#123;url/%.html/.jpg&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; <a href="https://guide.bash.academy/variables.jpg">https://guide.bash.academy/variables.jpg</a></td>
</tr>
<tr>
<td align="left"><code>$&#123;#parameter&#125;</code>扩展值的长度（以字节为单位）。</td>
<td align="left"><code>&quot;$&#123;#url&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; 40</td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter:start[:length]&#125;</code>展开值的一部分，从start开始，长度字节长。您甚至可以使用负值（空格后跟一个）从末尾而不是从开头开始计数。</td>
<td align="left"><code>&quot;$&#123;url:8&#125;&quot;</code></td>
<td align="left"><a href="https://guide.bash.academy/variables.html">https://guide.bash.academy/variables.html</a> &gt; guide.bash.academy&#x2F;variables.html</td>
</tr>
<tr>
<td align="left"><code>$&#123;parameter[^|^^|,|,,][pattern]&#125;</code>展开转换后的值，将与模式匹配的第一个或所有字符大写或小写。您可以省略模式来匹配任何字符。</td>
<td align="left"><code>&quot;$&#123;url^^[ht]&#125;&quot;</code></td>
<td align="left"><a href="http://guide.bash.academy/variables.html">http://guide.bash.academy/variables.html</a> &gt; HTTps:&#x2F;&#x2F;guide.basH.academy&#x2F;variables.HTml</td>
</tr>
</tbody></table>
<p><code>Shell</code> 变量是您可以自由赋值的参数。赋值是使用语法完成的<code>var=value</code>。可以扩展参数以将其数据内联到命令的参数中。参数扩展是通过在变量名前加上<code>$</code>符号来完成的。有时，您需要在参数名称周围添加<code>&#123;&#125;</code>大括号，以明确告诉 bash 参数名称的开始和结束位置（例如 <code>&quot;$&#123;time&#125;s&quot;</code>）。<br><strong>参数扩展应始终用双引号引起来，以保持一致性</strong>，并防止其中任何潜在的空格导致分词以及触发意外的路径名完成。在扩展参数时，您可以应用特殊的参数扩展运算符以某种方式改变扩展值。</p>
<ol>
<li>分配hello给变量greeting。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ greeting=hello</span><br></pre></td></tr></table></figure></li>
<li>显示变量<code>greeting</code>的内容。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$greeting</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>将字符串分配 world到变量当前内容的末尾。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ greeting=<span class="string">&quot;<span class="variable">$greeting</span> world&quot;</span></span><br><span class="line">$ greeting+=<span class="string">&quot; world&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>显示变量greeting中的最后一个单词。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;greeting##* &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>显示变量问候语的内容，第一个字符大写，.末尾有一个句点 ( )。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;greeting^&#125;</span>.&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>将变量内容中的第一个空格字符替换为big。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ greeting=<span class="variable">$&#123;greeting/ / big &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>将变量greeting的内容重定向到一个文件中，该文件的名称是该变量的值，并且末尾的空格替换为下划线( _) 和 a 。.txt<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$greeting</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$&#123;greeting// /_&#125;</span>.txt&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>显示变量问候语的内容，中间单词完全大写。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ middle=<span class="variable">$&#123;greeting% *&#125;</span> middle=<span class="variable">$&#123;middle#* &#125;</span>; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;greeting%% *&#125;</span> <span class="variable">$&#123;middle^^&#125;</span> <span class="variable">$&#123;greeting##* &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>有两个单独的空间保存变量。这些独立的空间经常被混淆，导致许多误解。您已经熟悉了第一个：shell 变量。保存变量的第二个空间是进程环境。我们将介绍环境变量并解释它们与 shell 变量的区别。</p>
<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>与 shell 变量不同，环境变量存在于进程级别。这意味着它们不是 bash shell 的功能，而是系统上任何程序进程的功能。如果我们将流程想象成您购买的一块土地，那么我们在这块土地上建造的建筑物将是在您的流程中运行的代码。你可以在土地上建造一座bash房子、一间grep棚屋或一座塔。firefox环境变量是存储在您的进程土地本身上的变量，而 shell 变量存储在您的土地上构建的 bash house 内。<br>您可以在环境中存储变量，也可以在 shell 中存储变量。环境是每个进程都拥有的，而 shell 空间仅适用于 bash 进程。通常，您应该将变量放在 shell 空间中除非您明确要求环境变量的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">╭──── bash────────────────────────╮ </span><br><span class="line">│ ╭────────────────── ─╮ │ </span><br><span class="line">│ 环境 │ SHELL │ │ │ </span><br><span class="line">│ shell_var1=值 │ │ </span><br><span class="line">│ │ shell_var2=值 │ │ </span><br><span class="line">│ ╰──────────────────╯ │ </span><br><span class="line">│ ENV_VAR1=值 │ </span><br><span class="line">│ ENV_VAR2=值 │ </span><br><span class="line">╰──────────────────────────────────╯</span><br></pre></td></tr></table></figure>
<p>当您从 shell 运行新程序时，bash 将在新进程中运行该程序。当它发生时，这个新进程将拥有自己的环境。但与shell进程不同的是，普通进程没有shell变量。他们只有环境变量。更重要的是，当创建一个新进程时，它的环境是通过创建创建进程的环境的副本来填充的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">╭──── bash ──────────────────────╮ </span><br><span class="line">│ ╭────────────────╮ │ </span><br><span class="line">│环境 │ SHELL │ │ </span><br><span class="line">│ │greeting=hello │ │ </span><br><span class="line">│ ╰────────────────╯ │ </span><br><span class="line">│ HOME=/home/lhunath │ </span><br><span class="line">│ PATH=/bin:/usr/bin │ </span><br><span class="line">╰─┬────────────────────────────╯ </span><br><span class="line">  ╎ ╭──── ls ────────── ────────────────╮ </span><br><span class="line">  └╌╌┥ │ </span><br><span class="line">     │ 环境 │ </span><br><span class="line">     │ │ </span><br><span class="line">     │ HOME=/home/lhunath │ </span><br><span class="line">     │ PATH=/bin:/usr/bin │ </span><br><span class="line">     ╰─── ──────────────────────────────╯</span><br></pre></td></tr></table></figure>
<p>一个常见的误解是，环境是所有进程共享的系统全局变量池。这种错觉通常是由于在子进程中看到相同的变量而导致的。当您在 shell 中创建自定义环境变量时，您之后创建的任何子进程都将继承该变量，因为该变量会从您的 shell 复制到子进程的环境中。但是，由于环境特定于每个进程，因此在子进程中更改或创建新变量绝不会影响父进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ╭─── bash ───────────────────────╮</span><br><span class="line">    │             ╭────────────────╮ │</span><br><span class="line">    │ ENVIRONMENT │ SHELL          │ │</span><br><span class="line">    │             │ greeting=hello │ │</span><br><span class="line">    │             ╰────────────────╯ │</span><br><span class="line">    │ HOME=/home/lhunath             │</span><br><span class="line">    │ PATH=/bin:/usr/bin             │</span><br><span class="line">    │ NAME=Bob                       │</span><br><span class="line">    ╰─┬──────────────────────────────╯</span><br><span class="line">      ╎  ╭─── bash ───────────────────────╮</span><br><span class="line">      └╌╌┥             ╭────────────────╮ │</span><br><span class="line">         │ ENVIRONMENT │ SHELL          │ │</span><br><span class="line">         │             ╰────────────────╯ │</span><br><span class="line">         │ HOME=/home/lhunath             │</span><br><span class="line">         │ PATH=/bin:/usr/bin             │</span><br><span class="line">         │ NAME=Bob                       │</span><br><span class="line">         ╰────────────────────────────────╯</span><br><span class="line"></span><br><span class="line">$ NAME=John</span><br><span class="line"></span><br><span class="line">    ╭─── bash ───────────────────────╮</span><br><span class="line">    │             ╭────────────────╮ │</span><br><span class="line">    │ ENVIRONMENT │ SHELL          │ │</span><br><span class="line">    │             │ greeting=hello │ │</span><br><span class="line">    │             ╰────────────────╯ │</span><br><span class="line">    │ HOME=/home/lhunath             │</span><br><span class="line">    │ PATH=/bin:/usr/bin             │</span><br><span class="line">    │ NAME=Bob                       │</span><br><span class="line">    ╰─┬──────────────────────────────╯</span><br><span class="line">      ╎  ╭─── bash ───────────────────────╮</span><br><span class="line">      └╌╌┥             ╭────────────────╮ │</span><br><span class="line">         │ ENVIRONMENT │ SHELL          │ │</span><br><span class="line">         │             ╰────────────────╯ │</span><br><span class="line">         │ HOME=/home/lhunath             │</span><br><span class="line">         │ PATH=/bin:/usr/bin             │</span><br><span class="line">         │ NAME=John                      │</span><br><span class="line">         ╰────────────────────────────────╯</span><br></pre></td></tr></table></figure>
<p>这种区别也清楚地表明了为什么人们会选择将某些变量放入环境中。虽然大多数变量都是普通的 shell 变量，但您可以选择将一些 shell 变量“导出”到 shell 的进程环境中。这样做时，您可以有效地将变量的数据导出到您创建的每个子进程，而这些子进程又将其环境变量导出到它们的子进程。您的系统将环境变量用于各种用途，主要是为某些进程提供状态信息和默认配置。</p>
<p>#例如，login传统上用于将用户登录到系统的程序将有关用户的信息导出到环境中（USER包含您的用户名，HOME包含您的主目录，PATH包含标准命令搜索路径等） 。现在，您登录后运行的所有进程都可以通过查看环境来了解它们正在为哪个用户运行。</p>
<p>您可以将自己的变量导出到环境中。这通常是为了配置您运行的任何程序的行为。例如，您可以导出LANG并为其分配一个值，告诉程序应该使用什么语言和字符集。环境变量通常仅对那些明确了解并支持它们的程序有用。有些变量的用途非常狭窄，例如 某些程序可以使用LSCOLORSls来对系统上文件的输出进行着色。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">╭─── bash ───────────────────────╮</span><br><span class="line">│             ╭────────────────╮ │</span><br><span class="line">│ ENVIRONMENT │ SHELL          │ │</span><br><span class="line">│             │ greeting=hello │ │</span><br><span class="line">│             ╰────────────────╯ │</span><br><span class="line">│ HOME=/home/lhunath             │</span><br><span class="line">│ PATH=/bin:/usr/bin             │</span><br><span class="line">│ LANG=en_CA                     │</span><br><span class="line">│ PAGER=less                     │</span><br><span class="line">│ LESS=-i -R                     │</span><br><span class="line">╰─┬──────────────────────────────╯</span><br><span class="line">  ╎  ╭─── rm ─────────────────────────╮           # rm uses just LANG if present to determine</span><br><span class="line">  ├╌╌┥                                │           # the language of its error messages.</span><br><span class="line">  ╎  │ ENVIRONMENT                    │</span><br><span class="line">  ╎  │                                │</span><br><span class="line">  ╎  │ HOME=/home/lhunath             │</span><br><span class="line">  ╎  │ PATH=/bin:/usr/bin             │</span><br><span class="line">  ╎  │ LANG=en_CA                     │</span><br><span class="line">  ╎  │ PAGER=less                     │</span><br><span class="line">  ╎  │ LESS=-i -R                     │</span><br><span class="line">  ╎  ╰────────────────────────────────╯</span><br><span class="line">  ╎  ╭─── man ────────────────────────╮           # In addition to LANG, man uses PAGER to determine</span><br><span class="line">  └╌╌┥                                │           # what program to use for paginating long manuals.</span><br><span class="line">     │ ENVIRONMENT                    │</span><br><span class="line">     │                                │</span><br><span class="line">     │ HOME=/home/lhunath             │</span><br><span class="line">     │ PATH=/bin:/usr/bin             │</span><br><span class="line">     │ LANG=en_CA                     │</span><br><span class="line">     │ PAGER=less                     │</span><br><span class="line">     │ LESS=-i -R                     │</span><br><span class="line">     ╰─┬──────────────────────────────╯</span><br><span class="line">       ╎  ╭─── less ───────────────────────╮      # less makes use of the LESS variable to supply</span><br><span class="line">       └╌╌┥                                │      # an initial configuration for itself.</span><br><span class="line">          │ ENVIRONMENT                    │</span><br><span class="line">          │                                │</span><br><span class="line">          │ HOME=/home/lhunath             │</span><br><span class="line">          │ PATH=/bin:/usr/bin             │</span><br><span class="line">          │ LANG=en_CA                     │</span><br><span class="line">          │ PAGER=less                     │</span><br><span class="line">          │ LESS=-i -R                     │</span><br><span class="line">          ╰────────────────────────────────╯</span><br></pre></td></tr></table></figure>

<h5 id="Shell-Initialization"><a href="#Shell-Initialization" class="headerlink" title="Shell Initialization"></a>Shell Initialization</h5><p>当您启动交互式 <code>bash</code> 会话时，<code>bash</code> 将通过从系统上的不同文件读取一些初始化命令来准备使用。您可以使用这些文件来告诉 <code>bash</code> 如何行为。其中一个特别旨在让您有机会将变量导出到环境中。该文件被调用<code>.bash_profile</code>并且位于您的主目录中。您很可能还没有此文件；如果是这种情况，您只需创建该文件，<code>bash</code> 下次查找它时就会找到它。</p>
<p>在你的最后<code>~/.bash_profile</code>，你应该有命令<code>source ~/.bashrc</code>。这是因为当<code>.bash_profile</code>存在时，<code>bash</code> 的行为有点奇怪，因为它停止寻找其标准 <code>shell</code> 初始化文件<code>~/.bashrc</code>。该source命令解决了这个奇怪的问题。</p>
<p>请注意，如果没有<code>~/.bash_profile</code>文件，<code>bash</code> 将尝试读取<code>~/.profile</code>（如果存在）。后者是通用的 <code>shell</code> 配置文件，其他 <code>shell</code> 也可以读取该文件。您可以选择将环境配置放在那里，但如果这样做，您需要注意应该限制自己使用 <code>POSIX sh</code> 语法，而不是在文件中使用任何特定于 <code>bash</code> 的 <code>shell</code> 语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login                  The login program signs the user in</span><br><span class="line">  │</span><br><span class="line">  ╰─ -bash             The login command starts the user&#x27;s login shell</span><br><span class="line">     │</span><br><span class="line">     ╰─ screen         The user runs the screen program from his login shell</span><br><span class="line">          │</span><br><span class="line">          ╰─ weechat   The screen program creates multiple windows</span><br><span class="line">          │            and allows the user to switch between them. </span><br><span class="line">          ╰─ bash      The first runs an IRC client, two others run a </span><br><span class="line">          │            non-login bash shell. </span><br><span class="line">          ╰─ bash</span><br></pre></td></tr></table></figure>
<p>该进程树描述了一个用户，该用户使用 bash 作为登录 shell，并多路复用他的终端以创建多个单独的“屏幕”，从而允许他与多个同时运行的程序进行交互。登录后，系统（login程序）确定用户的登录shell。例如，它可以通过查看来做到这一点&#x2F;etc&#x2F;passwd。在本例中，用户的登录 shell 设置为 bash。login继续运行 bash 并将其名称设置为-bash. 程序的标准过程是login在登录 shell 的名称前添加一个-（破折号）前缀，指示该 shell 它应该充当登录 shell。</p>
<p>一旦用户拥有正在运行的 bash 登录 shell，他就运行该screen程序。当 screen 运行时，它会接管用户的整个终端并模拟其中的多个终端，允许用户在它们之间切换。在每个模拟终端中，屏幕运行一个新程序。在这种情况下，用户将屏幕配置为启动一个运行 IRC 客户端的模拟终端，以及两个运行交互式（但非登录）bash shell 的模拟终端。实际情况如下：<br>我们来看看这个场景中初始化是如何发生的，以及环境变量来自哪里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login</span><br><span class="line">  │ TERM=dumb</span><br><span class="line">  │ USER=lhunath</span><br><span class="line">  │ HOME=/home/lhunath</span><br><span class="line">  │ PATH=/usr/bin:/bin</span><br><span class="line">  │</span><br><span class="line">  ╰─ -bash</span><br><span class="line">     │ TERM=dumb</span><br><span class="line">     │ USER=lhunath</span><br><span class="line">     │ HOME=/home/lhunath</span><br><span class="line">     │ PATH=/usr/bin:/bin</span><br><span class="line">     │ PWD=/home/lhunath</span><br><span class="line">     │ SHLVL=1</span><br><span class="line">     │╭──────────────╮     ╭────────────────────────╮╭──────────────────╮</span><br><span class="line">     ┝┥ login shell? ┝─yes─┥ source ~/.bash_profile ┝┥ source ~/.bashrc │</span><br><span class="line">     │╰──────────────╯     ╰────────────────────────╯╰──────────────────╯</span><br><span class="line">     │ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/libexec</span><br><span class="line">     │ EDITOR=vim</span><br><span class="line">     │ LANG=en_CA.UTF-8</span><br><span class="line">     │ LESS=-i -M -R -W -S</span><br><span class="line">     │ GREP_COLOR=31</span><br><span class="line">     │</span><br><span class="line">     ╰─ screen</span><br><span class="line">          │ TERM=dumb</span><br><span class="line">          │ TERM=screen-bce</span><br><span class="line">          │ USER=lhunath</span><br><span class="line">          │ HOME=/home/lhunath</span><br><span class="line">          │ PATH=/usr/bin:/bin</span><br><span class="line">          │ PWD=/home/lhunath</span><br><span class="line">          │ SHLVL=1</span><br><span class="line">          │ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/libexec</span><br><span class="line">          │ EDITOR=vim</span><br><span class="line">          │ LANG=en_CA.UTF-8</span><br><span class="line">          │ LESS=-i -M -R -W -S</span><br><span class="line">          │ GREP_COLOR=31</span><br><span class="line">          │ WINDOW=0</span><br><span class="line">          │</span><br><span class="line">          ╰─ weechat</span><br><span class="line">          │</span><br><span class="line">          ╰─ bash</span><br><span class="line">          │    │╭──────────────╮</span><br><span class="line">          │    ╰┥ login shell? ┝</span><br><span class="line">          │     ╰──────┰───────╯</span><br><span class="line">          │            no</span><br><span class="line">          │     ╭──────┸───────╮     ╭──────────────────╮</span><br><span class="line">          │     │ interactive? ┝─yes─┥ source ~/.bashrc │</span><br><span class="line">          │     ╰──────────────╯     ╰──────────────────╯</span><br><span class="line">          ╰─ bash</span><br><span class="line">               │╭──────────────╮</span><br><span class="line">               ╰┥ login shell? ┝</span><br><span class="line">                ╰──────┰───────╯</span><br><span class="line">                       no</span><br><span class="line">                ╭──────┸───────╮     ╭──────────────────╮</span><br><span class="line">                │ interactive? ┝─yes─┥ source ~/.bashrc │</span><br><span class="line">                ╰──────────────╯     ╰──────────────────╯</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，不同级别将自己的变量导出到环境中。每个子进程都从其父进程的环境中继承变量。反过来，它可以覆盖其中一些值或添加新变量。</p>
<p>请注意第一个（登录）bash 如何获取两者的源<del>&#x2F;.bash_profile，而</del>&#x2F;.bashrc底部的两个仅获取源<del>&#x2F;.bashrc。这是因为只有第一个 bash 进程作为“登录 shell”启动（通过-在其名称前面添加 ）。下面的两个 bash 进程是普通的交互式 shell。他们不需要采购的原因</del>&#x2F;.bash_profile现在变得更加明显：他们的职责 ~&#x2F;.bash_profile是设置 bash 的环境，而底部的两个 shell 已经从其登录 shell 祖先继承了环境。</p>
<h5 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h5><p>其中变量是带有名称的参数，位置参数是带有数字（更具体地说，正整数）的参数。我们使用正常的参数扩展语法来扩展这些参数：<code>$1, $3</code>。但值得注意的是，<code>bash</code> 要求您在超过一位数字的位置参数周围使用大括号： , <code>$&#123;10&#125;（$&#123;22&#125;</code>实际上，您很少需要显式引用这么高的位置参数）。</p>
<p>位置参数扩展到由父进程创建时作为参数发送到进程的值。例如，当您<code>grep</code>使用以下命令启动进程时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep Name registrations.txt</span><br></pre></td></tr></table></figure>
<p>您正在有效地运行<code>grep</code>带有参数Name的命令<code>registrations.txt</code>。如果<code>grep</code>是 <code>bash</code> 脚本，则第一个参数可以通过扩展在脚本中使用<code>$1</code>，第二个参数可以通过扩展使用<code>$2</code>。高于的位置参数2将被取消设置。</p>
<p>很高兴知道还有第零个位置参数。该位置参数扩展为进程的名称。进程的名称是由创建它的程序选择的，因此第零个参数实际上可以包含任何内容，并且完全取决于脚本的父级。大多数 <code>shell</code> 将使用它们运行的​​文件的绝对路径来启动进程作为进程的名称，或者用户执行的启动进程的命令。请注意，这绝不是一个要求，您不能对第零个参数的内容做出任何可靠的假设：出于所有意图和目的，最好避免这样做。</p>
<p>很好而且非常方便：到目前为止我们学到的关于可变参数的大部分知识也适用于位置参数：我们可以扩展它们，并且可以在这些扩展上应用参数扩展运算符来改变结果值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The Name Script&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;usage: names &#x27;My Full Name&#x27;&quot;</span>; <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">first=<span class="variable">$&#123;1%% *&#125;</span> last=<span class="variable">$&#123;1##* &#125;</span> middle=<span class="variable">$&#123;1#$first&#125;</span> middle=<span class="variable">$&#123;middle%$last&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your first name is: <span class="variable">$first</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your last name is: <span class="variable">$last</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your middle names are: <span class="variable">$middle</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果您将此脚本保存在名为 的文件中<code>names</code>，并根据使用说明运行它，通过向其传递单个参数，您将看到该脚本分析您的姓名并告知您姓名的哪一部分构成了第一个、最后一个和中间部分名称。当我们在语句中扩展变量时，我们使用变量<code>first</code>、<code>last</code>和<code>middle</code>来存储这些信息<code>echo</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x names</span><br><span class="line">$ ./names <span class="string">&#x27;Maarten Billemont&#x27;</span></span><br><span class="line">The Name Script</span><br><span class="line">usage: names <span class="string">&#x27;My Full Name&#x27;</span></span><br><span class="line"></span><br><span class="line">Your first name is: Maarten</span><br><span class="line">Your last name is: Billemont</span><br><span class="line">Your middle names are: </span><br><span class="line">$ ./names <span class="string">&#x27;James Tiberius &quot;Jim&quot; Kirk&#x27;</span></span><br><span class="line">The Name Script</span><br><span class="line">usage: names <span class="string">&#x27;My Full Name&#x27;</span></span><br><span class="line"></span><br><span class="line">Your first name is: James</span><br><span class="line">Your last name is: Kirk</span><br><span class="line">Your middle names are:  Tiberius <span class="string">&quot;Jim&quot;</span></span><br></pre></td></tr></table></figure>
<p>重要的是要理解，与大多数变量不同，位置参数是只读参数。经过反思，您可能会认为人们无法从脚本内部更改脚本的参数。因此，这是一个语法错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 1=<span class="string">&#x27;New First Argument&#x27;</span></span><br><span class="line">-bash: 1=New First Argument: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>
<p>虽然错误消息有点令人困惑，但它表明 bash 甚至不认为该语句是试图为变量赋值（因为参数不是变量1），而是认为您已经给了它命令的名称你想跑。</p>
<p>然而，我们可以使用一个内置命令来更改位置参数集的值。虽然这是缺乏 bash 更高级功能的古代 shell 中的常见做法，但在 bash 中您很少需要这样做。要修改当前的位置参数集，请使用该set命令并在参数后面指定新的位置参数作为参数–：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -- <span class="string">&#x27;New First Argument&#x27;</span> Second Third <span class="string">&#x27;Fourth Argument&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1: <span class="variable">$1</span>, 2: <span class="variable">$2</span>, 4: <span class="variable">$4</span>&quot;</span></span><br><span class="line">1: New First Argument, 2: Second, 4: Fourth Argument</span><br></pre></td></tr></table></figure>
<p>除了更改位置参数集之外，还有shift可用于“推送”我们的位置参数集的内置函数。当我们移动位置参数时，我们实际上将它们全部推向开头，导致前几个位置参数被撞掉，为其他参数让路：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">New First Argument Second Third Fourth Argument</span><br><span class="line">$ <span class="built_in">shift</span> 2                              <span class="comment"># Push the positional parameters back 2.</span></span><br><span class="line">Third Fourth Argument &lt;----</span><br></pre></td></tr></table></figure>
<p>最后，当使用命令启动新的 <code>bash shell</code> 时<code>bash</code>，有一种方法可以传入位置参数。这是将参数列表传递给内联 <code>bash</code> 脚本的非常有用的方法。稍后，当您将内联 <code>bash</code> 代码与其他实用程序结合使用时，您将使用此方法，但就目前而言，这是试验位置参数的好方法，而无需创建单独的脚本来调用和传递参数（就像我们在示例中所做的那样 <code>names</code>）多于）。以下是如何运行内联 <code>bash</code> 命令并传入参数列表来填充位置参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -c <span class="string">&#x27;echo &quot;1: $1, 2: $2, 4: $4&quot;&#x27;</span> -- <span class="string">&#x27;New First Argument&#x27;</span> Second Third <span class="string">&#x27;Fourth Argument&#x27;</span></span><br><span class="line">1: New First Argument, 2: Second, 4: Fourth Argument</span><br></pre></td></tr></table></figure>
<p>我们运行该bash命令，传递-c选项，后跟包含一些 bash shell 代码的参数。这将告诉 bash，您不想启动新的交互式 bash shell，而只想让 shell 运行提供的 bash 代码并完成。在 shell 代码之后，我们指定用于填充位置参数的参数。我们示例中的第一个参数是–，虽然从技术上讲该参数用于填充第零个位置参数，但–为了兼容性并明确 bash 参数与 bash 参数之间的区别，始终使用它是一个好主意。你的外壳代码。在此参数之后，每个参数都会按照您的预期填充标准位置参数。</p>
<div class="note success"><p>请注意，我们包含 bash 代码的参数是’single-quoted’：</p>
<p>每当我们将代码放入字符串中时（例如将其作为参数传递的情况），代码都应该用单引号引起来。不要用于<code>&quot;double quotes&quot;</code>包装代码字符串。这很重要，因为单引号在制作包装数据文字方面比双引号可靠得多。</p>
</div>
<p>如果我们在上面的示例中使用双引号，则我们在其中键入命令的 <code>shell bash</code>会展开<code>$1,$2</code>和<code>$4</code>扩展，从而导致该<code>-c</code>选项的参数损坏。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -vc <span class="string">&#x27;echo &quot;1: $1, 2: $2, 4: $4&quot;&#x27;</span> -- \          <span class="comment"># We pass the -v argument to bash to show us the code it is going to run before the result.</span></span><br><span class="line"><span class="string">&#x27;New First Argument&#x27;</span> Second Third <span class="string">&#x27;Fourth Argument&#x27;</span>   <span class="comment"># We can use \ at the end of a line to resume on a new line.</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1: <span class="variable">$1</span>, 2: <span class="variable">$2</span>, 4: <span class="variable">$4</span>&quot;</span>                            <span class="comment"># Here is the code it is going to run.</span></span><br><span class="line">1: New First Argument, 2: Second, 4: Fourth Argument  <span class="comment"># And this is the result.</span></span><br></pre></td></tr></table></figure>

<p><code>-c</code>如果我们在参数周围使用双引号而不是单引号会发生什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -vc <span class="string">&quot;echo &quot;</span>1: <span class="variable">$1</span>, 2: <span class="variable">$2</span>, 4: <span class="variable">$4</span><span class="string">&quot;&quot;</span> -- \          <span class="comment"># The outer double-quotes conflict with the inner double-quotes, leading to ambiguity.</span></span><br><span class="line"><span class="string">&#x27;New First Argument&#x27;</span> Second Third <span class="string">&#x27;Fourth Argument&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> 1:                                               <span class="comment"># As a result, the argument to -c is no longer the entire bash code but only the first word of it.</span></span><br><span class="line">1:</span><br><span class="line">$ bash -vc <span class="string">&quot;echo \&quot;1: <span class="variable">$1</span>, 2: <span class="variable">$2</span>, 4: <span class="variable">$4</span>\&quot;&quot;</span> -- \        <span class="comment"># Even if we fix the quoting ambiguity, the $1, $2 and $4 are now evaluated by the shell we&#x27;re typing this command into,</span></span><br><span class="line"><span class="string">&#x27;New First Argument&#x27;</span> Second Third <span class="string">&#x27;Fourth Argument&#x27;</span>   <span class="comment"># not the shell we pass the arguments to.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1: , 2: , 4: &quot;</span>                                  <span class="comment"># Since $1, $2 and $4 are likely empty in your interactive shell, they will expand empty and disappear from the -c argument.</span></span><br><span class="line">1: , 2: , 4:</span><br></pre></td></tr></table></figure>
<p>我们甚至可以通过反斜杠转义所有特殊字符（包括双引号和美元符号）来解决双引号内的所有问题。这可以解决问题，但会使 shell 代码看起来极其复杂且难以阅读。维护像这样以特殊方式转义的 shell 代码是一场噩梦，并且会导致难以发现的意外错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -vc <span class="string">&quot;echo \&quot;1: \$1, 2: \$2, 4: \$4\&quot;&quot;</span> -- \</span><br><span class="line"><span class="string">&#x27;New First Argument&#x27;</span> Second Third <span class="string">&#x27;Fourth Argument&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1: <span class="variable">$1</span>, 2: <span class="variable">$2</span>, 4: <span class="variable">$4</span>&quot;</span></span><br><span class="line">1: New First Argument, 2: Second, 4: Fourth Argument</span><br></pre></td></tr></table></figure>

<h5 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h5><p>了解位置参数对理解特殊参数变得更加容易：它们非常相似。特殊参数是名称为单个符号字符的参数，它们用于从 <code>bash shell</code> 请求某些状态信息。以下是不同类型的特殊参数及其包含的信息：</p>
<table>
<thead>
<tr>
<th align="left">Parameter</th>
<th align="left">Example</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&quot;$*&quot;</code></td>
<td align="left"><code>echo &quot;Arguments: $*&quot;</code></td>
<td align="left">扩展单个<code>string</code>，将所有位置参数连接成一个，并用IFS中的第一个字符（默认情况下为空格）分隔。注意：除非您明确打算连接所有参数，否则切勿使用此参数。你几乎总是想用它<code>@</code>来代替。</td>
</tr>
<tr>
<td align="left"><code>&quot;$@&quot;</code></td>
<td align="left"><code>rm &quot;$@&quot;</code></td>
<td align="left">将位置参数扩展为单独参数的列表。</td>
</tr>
<tr>
<td align="left"><code>&quot;$#&quot;</code></td>
<td align="left"><code>echo &quot;Count: $#&quot;</code></td>
<td align="left">展开为一个数字，指示可用位置参数的数量。</td>
</tr>
<tr>
<td align="left"><code>&quot;$?&quot;</code></td>
<td align="left"><code>(( $? == 0 )) | echo &quot;Error: $?&quot;</code></td>
<td align="left">展开刚刚完成的最后一个（同步）命令的退出代码。退出代码 0 表示命令成功，任何其他数字表示命令失败的原因。</td>
</tr>
<tr>
<td align="left"><code>&quot;$-&quot;</code></td>
<td align="left"><code>[[ $- = *i* ]]</code></td>
<td align="left">扩展为当前在 shell 中处于活动状态的选项标志集。选项标志配置 <code>shell</code> 的行为，该示例测试该标志是否存在i，表明 <code>shell</code> 是交互式的（有提示）并且没有运行脚本。</td>
</tr>
<tr>
<td align="left"><code>&quot;$$&quot;</code></td>
<td align="left"><code>echo &quot;$$&quot; &gt; /var/run/myscript.pid</code></td>
<td align="left">扩展一个数字，该数字是 shell 进程（正在解析代码）的唯一进程标识符。</td>
</tr>
<tr>
<td align="left"><code>&quot;$!&quot;</code></td>
<td align="left"><code>kill &quot;$!&quot;</code></td>
<td align="left">展开一个数字，该数字是在后台（异步）启动的最后一个进程的唯一进程标识符。该示例向后台进程发出信号，表明该终止了。</td>
</tr>
<tr>
<td align="left"><code>&quot;$_&quot;</code></td>
<td align="left"><code>mkdir -p ~/workspace/projects/myscripts &amp;&amp; cd &quot;$_&quot;</code></td>
<td align="left">扩展到上一个命令的最后一个参数。</td>
</tr>
</tbody></table>
<p>就像位置参数一样，特殊参数是只读的：您只能使用它们来扩展信息，而不能存储信息。</p>
<h5 id="Shell-内部变量"><a href="#Shell-内部变量" class="headerlink" title="Shell 内部变量"></a>Shell 内部变量</h5><p>您已经知道什么是 <code>shell</code> 变量。您是否知道 <code>bash shell</code> 还为您创建了一些变量？这些变量用于各种任务，并且可以方便地从 <code>shell</code> 查找某些状态信息或更改某些 <code>shell</code> 行为。</p>
<div class="note success"><p>内部 <code>shell</code> 变量是名称全部大写的 <code>shell</code> 变量。几乎所有环境变量都是如此。重要的是要确保当我们开始创建自己的 <code>shell</code> 变量时，我们不会意外地使用我们不知道的 <code>shell</code> 变量的名称，这个错误将导致各种危险和意外的行为。值得庆幸的是，<code>shell</code> 变量名称区分大小写，因此为了避免意外覆盖 <code>shell</code> 内部变量或同名的系统导出变量，一般规则是：</p>
<p>您应该将所有自己的 <code>shell</code> 变量设置为小写。如果创建环境变量，请为其指定一个全大写名称。</p>
</div>
<p>虽然 <code>bash</code> 实际上定义了相当多的内部 <code>shell</code> 变量，但其中大多数都不是很有用。其他的可以使用，但仅在非常特定的情况下使用。其中许多变量要求您了解更高级的 <code>bash</code> 概念。我将简要提及一些现阶段值得了解的内部 <code>shell</code> 变量。内部 <code>shell</code> 变量的完整列表可以在 中找到<code>man bash</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BASH	                     /usr/local/bin/bash</span><br><span class="line">This variable contains the full pathname of the command that started the bash you are currently in.</span><br><span class="line"></span><br><span class="line">BASH_VERSION	            4.4.0(1)-release</span><br><span class="line">A version number that describes the currently active version of bash.</span><br><span class="line"></span><br><span class="line">BASH_VERSINFO	            [ 4, 4, 0, 1, release, x86_64-apple-darwin16.0.0 ]</span><br><span class="line">An array of detailed version information on the currently active version of bash.</span><br><span class="line"></span><br><span class="line">BASH_SOURCE	               myscript</span><br><span class="line">This contains all the filenames of the scripts that are currently running. The first is the script that&#x27;s currently running.Usually it is either empty (no scripts running) or contains just the pathname of your script.</span><br><span class="line"></span><br><span class="line">BASHPID	                  5345</span><br><span class="line">This contains the process ID of the bash that is parsing the script code.</span><br><span class="line"></span><br><span class="line">UID	                     501</span><br><span class="line">Contains the ID number of the user that&#x27;s running this bash shell.</span><br><span class="line"></span><br><span class="line">HOME	                     /Users/lhunath</span><br><span class="line">Contains the pathname of the home directory of the user running the bash shell.</span><br><span class="line"></span><br><span class="line">HOSTNAME	                  myst.local</span><br><span class="line">The name of your computer.</span><br><span class="line"></span><br><span class="line">LANG	                     en_CA.UTF-8</span><br><span class="line">Used to indicate your preferred language category.</span><br><span class="line"></span><br><span class="line">MACHTYPE	                  x86_64-apple-darwin16.0.0</span><br><span class="line">A full description of the type of system you are running.</span><br><span class="line"></span><br><span class="line">PWD	                     /Users/lhunath</span><br><span class="line">The full pathname of the directory you are currently in.</span><br><span class="line"></span><br><span class="line">OLDPWD	                  /Users/lhunath</span><br><span class="line">The full pathname of the directory you were in before you came to the current directory.</span><br><span class="line"></span><br><span class="line">RANDOM	                  12568</span><br><span class="line">Expands a new random number between 0 and 32767, every time.</span><br><span class="line"></span><br><span class="line">SECONDS	                  338217</span><br><span class="line">Expands the number of seconds your bash shell has been running for.</span><br><span class="line"></span><br><span class="line">LINES	                     48</span><br><span class="line">Contains the height (amount of rows or lines) of your terminal display.</span><br><span class="line"></span><br><span class="line">COLUMNS	                  178</span><br><span class="line">Contains the width (amount of single-character spaces) of a single row in your terminal display.</span><br><span class="line"></span><br><span class="line">IFS	                     $&#x27; \t\n&#x27;</span><br><span class="line">The &quot;Internal Field Separator&quot; is a string of characters that bash uses for word-splitting of data. By default, bash splits on spaces, tabs and newlines.</span><br><span class="line"></span><br><span class="line">PATH	                     /Users/lhunath/.bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/libexec</span><br><span class="line">The list of paths bash will search for executable programs when you run a command.</span><br><span class="line"></span><br><span class="line">PS1	                     \s-\v\$ </span><br><span class="line">This contains a string that describes what the interactive bash shell&#x27;s prompt should look like.</span><br><span class="line"></span><br><span class="line">PS2	                     &gt; </span><br><span class="line">This contains a string that describes what the interactive bash shell&#x27;s secondary prompt should look like. The secondary prompt is used when you finish a command line but the command isn&#x27;t yet complete.</span><br></pre></td></tr></table></figure>
<p>正如我所提到的，还有许多其他内部 <code>shell</code> 变量，但它们每个都服务于目前并不有趣的非常具体的高级案例。如果您正在寻找有关 <code>bash</code> 当前如何运行的一些信息，您很可能可以在其内部 <code>shell</code> 变量之一中找到它。</p>
<ol>
<li>启动一个新的 bash shell，输出其第一个参数并Hello World!作为参数传递给它。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -c <span class="string">&#x27;echo &quot;$1&quot;&#x27;</span> -- <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>启动一个 bash shell，输出传入的参数数量并传入参数1,2和The Third。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -c <span class="string">&#x27;echo &quot;$#&quot;&#x27;</span> -- 1 2 <span class="string">&#x27;The Third&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>启动一个 bash shell，将位置参数移走，然后输出第一个。传入参数1,2和The Third。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -c <span class="string">&#x27;shift; echo &quot;$1&quot;&#x27;</span> -- 1 2 <span class="string">&#x27;The Third&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>启动一个 bash shell，输出最后传入的参数并传入参数1,2和The Third。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -c <span class="string">&#x27;echo &quot;$&#123;@: -1&#125;&quot;&#x27;</span> -- 1 2 <span class="string">&#x27;The Third&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>最后但同样重要的是，我们可能会遇到最有趣的 bash 参数：数组。</p>
<h5 id="数组的作用"><a href="#数组的作用" class="headerlink" title="数组的作用"></a>数组的作用</h5><p>数组是一个奇特的词，指的是参数，它不能容纳一个字符串，而是容纳一整串字符串。存储事物列表的概念并不新鲜 - 我们之前在本指南中已经看到过它，例如PATH存储 bash 的目录路径名列表以查找命令程序。然而，引入数组是为了解决使用简单字符串变量存储事物列表时出现的一个非常重要的问题。</p>
<p>在简单变量中存储事物列表的问题是，当您对此列表的单独元素感兴趣时，您不可避免地需要将这个单个变量拆分为这些单独的元素。然而，我们大多数人甚至没有注意到这是一个问题：作为人类，我们非常擅长根据具体情况做到这一点。当我们看到诸如 的名字时Leonard Cohen，我们认识到它由两个单独的名字组成，这两个名字一起构成一个人的全名。现在，当我们查看诸如 之类的字符串时Leonard Cohen - Adam Cohen - Lorca Cohen，我们立即将其识别为三个不同名称的列表：我们立即识别出该字符串中用破折号分隔名称的模式。事实上，我们非常擅长这一点，以至于当我们看到诸如此类的名称列表时，我们通常甚至不需要停下来思考Susan Q. - Mary T. - Steven S. - Anne-Marie D. - Peter E.。我们甚至擅长在较大的字符串中找到相关的上下文单元，例如由行和段落组成的诗歌。但不幸的是，当我们开始考虑让计算机为我们处理数据时，我们需要停止思考我们优秀的人类抽象，并穿上我们的认知婴儿鞋。计算机不知道这Susan Q. - Mary T. - Steven S. - Anne-Marie D. - Peter E.是一个名称列表，它当然也不知道这些名称是用破折号分隔的，并且它绝对无法猜测这是一个单一的名称，Anne-Marie而不是其中两个不同的人的名称。列表。<br>明确列表中单独元素的一个好方法是使用命令的参数。还记得我们什么时候学过引用吗？事实上，这是回顾我们的引用课程的好时机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l 05 Between Angels and Insects.ogg</span><br></pre></td></tr></table></figure>
<p>在此命令中，我们向命令传递ls一个包含许多参数的列表，bash 会将每个参数假定为单独的文件名。这显然不是预期的效果，但 bash 并不像我们人类那样擅长从任意数据中获取上下文意义。因此，我们必须明确列表中的元素是什么，这一点很重要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l <span class="string">&quot;05 Between Angels and Insects.ogg&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在我们已经清楚地向 bash 表明我们的列表仅包含一个文件名，并且该文件名本身包含多个单词，该ls命令能够正确完成其工作。变量也存在同样的问题。如果我们想创建一个包含我们要删除的所有文件的列表的变量怎么办？我们如何创建这样一个列表，然后我们可以将该列表中的每个不同元素传递给命令进行rm删除，而不会冒 bash 误解我们的文件名需要如何解释的风险？<br>答案是数组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$ _files=( myscript hello.txt <span class="string">&quot;05 Between Angels and Insects.ogg&quot;</span> )</span><br><span class="line"><span class="built_in">rm</span> -v <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了创建数组变量，bash 引入了一个略有不同的赋值运算符<code>：=( )</code>。与标准一样&#x3D;，我们将变量的名称放在运算符的左侧，但是，分配给该变量的值列表应该很好地放在大括号和大(括号之间)。</p>
<p>您可能还记得我们关于变量赋值的部分，重要的是我们不要在赋值值周围放置语法空格：<code>bash</code> 之后的空格将赋值拆分为命令名称和参数对；我们的赋值值中不带引号的空格会导致 bash 将值拆分为部分赋值，后跟命令名称。使用这种新的数组赋值语法，大括号内可以自由地允许空格，事实上，它们用于分隔数组值列表的许多元素。但就像常规变量赋值一样，当空格需要成为变量数据的一部分时，必须用引号引起来，以便 <code>bash</code> 将空格解释为文字。请注意，在上面的示例中，我们使用语法myscript和之间的间距hello.txt，允许 bash 将这两个单词理解为列表中不同的元素，而我们在单词和之间使用文字间距- 这里的空格是文件名的一部分，它不应该导致 bash 将单词分成单独的列表elements：空格是字面意思，因此我们引用了它。</p>
<p>事实上，这些语法规则并不是什么新鲜事。我们已经知道如何将不同的参数传递给我们的命令，并且将不同的元素传递给我们的数组赋值运算符也没有什么不同。</p>
<p>#最后，创建文件列表后，我们扩展命令的参数rm。如果您还记得上面的参数扩展部分，扩展是通过在参数名称前加上$- 符号来进行的。然而，与常规参数扩展相反，我们对扩展单个参数不感兴趣：我们想要做的是将列表中的每个元素扩展为命令的单独且不同的参数rm。为此，我们将参数名称添加为后缀<code>[@]</code>，现在需要使用花括号 ( ) 将整个参数括起来{ }，以确保 bash 将整个参数理解为单个参数扩展单元。files使用语法扩展参数<code>&quot;$&#123;files[@]&#125;&quot;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;myscript&#x27;</span></span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;hello.txt&#x27;</span></span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;05 Between Angels and Insects.ogg&#x27;</span>      <span class="comment">#rm -v myscript hello.txt &quot;05 Between Angels and Insects.ogg&quot;</span></span><br></pre></td></tr></table></figure>
<p>Bash 巧妙地将数组列表中的每个单独元素扩展为命令的单独参数<code>rm!</code></p>
<div class="note warning"><p>与所有参数扩展一样，将所有数组参数扩展用双引号括起来至关重要。与常规参数扩展一样，如果无法对扩展进行双引号引用，则会导致 <code>bash</code> 对完全不同的数组项列表中的所有值进行分词，从而导致命令的单词参数列表损坏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -v <span class="variable">$&#123;files[@]&#125;</span></span><br><span class="line">removed <span class="string">&#x27;myscript&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;hello.txt&#x27;</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;05&#x27;</span>: No such file or directory</span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;Between&#x27;</span>: No such file or directory</span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;Angels&#x27;</span>: No such file or directory</span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;and&#x27;</span>: No such file or directory</span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;Insects.ogg&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<p>回想一下我们之前学过的引用规则：如果你的参数中有空格或符号，你必须引用双引号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -v <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>除了数组赋值和数组扩展之外，bash 还提供了一些我们可以对数组执行的其他操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$files</span>+=( selfie.png )        <span class="comment"># 使用+=( )运算符，我们可以将项目列表附加到数组的末尾。</span></span><br><span class="line"><span class="variable">$files</span>=( *.txt )              <span class="comment"># 就像在命令的参数中一样，我们可以在这里扩展全局模式。</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">&quot;<span class="variable">$&#123;files[0]&#125;</span>&quot;</span>           <span class="comment"># 要扩展数组中的单个项目，请指定该项目的序号。</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">&quot;<span class="variable">$files</span>&quot;</span>                <span class="comment"># 如果我们忘记了数组扩展语法，bash 将仅扩展第一项。</span></span><br><span class="line"><span class="variable">$unset</span> <span class="string">&quot;files[3]&quot;</span>             <span class="comment"># 要从数组中删除特定项目，我们使用unset.</span></span><br><span class="line">                              <span class="comment"># 但请注意：我们在这里不使用 @ $，因为我们没有扩展该值！</span></span><br></pre></td></tr></table></figure>
<p>除了[@]将数组元素扩展为不同参数的后缀之外，bash 还可以将所有数组元素扩展为单个参数。这是使用<code>[*]</code>后缀完成的。bash 如何将所有单独的元素合并到一个参数中？我们可能希望它通过多种方式来做到这一点——它是否创建一个以空格分隔的字符串？它是否将所有元素挤压在一起形成一个长字符串，没有任何元素分隔？也许它可以创建一个字符串，其中每个元素都位于单独的行上？事实是，由于上述所有原因，没有一种策略可以将不同的元素合并到单个字符串中而不出现问题。因此该运营商非常可疑<code>[@]</code>并且在几乎所有情况下都应该避免！</p>
<p>事实上，<code>bash</code> 允许您在使用<code>[*]</code>: 时通过查看IFS内部 shell 变量的当前值来选择如何将元素合并到单个字符串中。<code>Bash</code> 使用此变量的第一个字符（默认情况下是空格）来分隔结果字符串中的元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ names=( <span class="string">&quot;Susan Quinn&quot;</span> <span class="string">&quot;Anne-Marie Davis&quot;</span> <span class="string">&quot;Mary Tate&quot;</span> )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Invites sent to: &lt;<span class="variable">$&#123;names[*]&#125;</span>&gt;.&quot;</span>                    <span class="comment"># Results in a single argument where elements are separated by a literal space.</span></span><br><span class="line">Invites were sent to: &lt;Susan Quinn Anne-Marie Davis Mary Tate&gt;.</span><br><span class="line">$ ( IFS=<span class="string">&#x27;,&#x27;</span>; <span class="built_in">echo</span> <span class="string">&quot;Invites sent to: &lt;<span class="variable">$&#123;names[*]&#125;</span>&gt;.&quot;</span> )       <span class="comment"># When we change IFS to a ,, the distinct elements become more clear.</span></span><br><span class="line">Invites were sent to: &lt;Susan Quinn,Anne-Marie Davis,Mary Tate&gt;.</span><br></pre></td></tr></table></figure>
<p>由于包含多个不同元素的单个字符串几乎总是有缺陷的，并且不如那些元素很好分离的数组变量有用，因此后缀的实际用途很少<code>[*]</code>。但有一个例外：该运算符对于向用户显示元素列表非常有用。当我们尝试向人类显示数组的值时，我们不必太担心输出的语法正确性。在上面的示例中，<code>IFS</code>被更改以,说明向用户显示数组中的值的常见方法。</p>
<div class="note warning"><p>在修改内部 bash shell 变量时（例如上面使用IFS 的示例），务必要非常小心：<br>当我们更改内部 shell 变量时，我们需要认识到我们正在改变 bash 的运行方式。将IFS的值更改为逗号 ( ,) 以便使用[*]后缀扩展文件是可以的，但是如果您继续执行脚本，同时将IFS设置为其非默认值“ ,”，则许多其他事情基于IFS值的 bash 会突然出现故障。</p>
<p>正是由于这个原因，您应该始终将内部 shell 配置更改的范围限制在尽可能缩小的脚本区域内。您可能已经注意到，在上面的示例中，我们( )在代码周围引入了大括号。这些大括号创建一个子 shell，在其中执行代码，当大括号结束时，具有非标准IFS值的子 shell 也随之结束。因此，原始脚本的 bash shell 从未修改过其 IFS变量，我们避免了这些意外故障。</p>
</div>
<p>最后，我们之前了解的所有特殊参数扩展运算符也可以应用于数组扩展，但我们将重新迭代其中一些，因为它们的效果在扩展多个不同元素的上下文中非常有趣。对于初学者来说，该<code>$&#123;parameter[@]/pattern/replacement&#125;</code>运算符及其所有变体在扩展时都将其替换逻辑明确应用于每个元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ names=( <span class="string">&quot;Susan Quinn&quot;</span> <span class="string">&quot;Anne-Marie Davis&quot;</span> <span class="string">&quot;Mary Tate&quot;</span> )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;names[@]/ /_&#125;</span>&quot;</span>                                    <span class="comment"># Replace spaces by underscores in each name.</span></span><br><span class="line">Susan_Quinn Anne-Marie_Davis Mary_Tate</span><br><span class="line">$ ( IFS=<span class="string">&#x27;,&#x27;</span>; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;names[*]/#/Ms &#125;</span>&quot;</span> )                     <span class="comment"># More interestingly: replace the start of each name with Ms ,</span></span><br><span class="line">Ms Susan Quinn,Ms Anne-Marie Davis,Ms Mary Tate             <span class="comment"># effectively prefixing every element with a string as we expand them</span></span><br></pre></td></tr></table></figure>
<p>运算<code>$&#123;#parameter&#125;</code>符与后缀相结合<code>[@]</code>给出了元素的计数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;#names[@]&#125;</span>&quot;</span></span><br><span class="line">3</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;#names[1]&#125;</span>&quot;</span>            <span class="comment"># But we can still get the length of a string by specifying directly</span></span><br><span class="line">16                               <span class="comment"># which string element in the array we want to get the length of.</span></span><br></pre></td></tr></table></figure>
<p>最后，该<code>$&#123;parameter[@]:start:length&#125;</code>运算符可用于获取数组的切片或“子集”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;names[@]:1:2&#125;</span>&quot;</span></span><br><span class="line">Anne-Marie Davis Mary Tate</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;names[@]: -2&#125;</span>&quot;</span>         <span class="comment"># Specifying a negative start allows us to count backwards from the end!</span></span><br><span class="line">Anne-Marie Davis Mary Tate       <span class="comment"># While omitting the length yields &quot;all remaining elements&quot; from the start</span></span><br></pre></td></tr></table></figure>
<p>请注意，在负起始值前面包含一个空格很重要：如果我们省略空格，<code>bash</code> 会感到困惑，并认为您正在尝试调用运算符，只要参数的值为空，该运算符就会替换默认值<code>$&#123;parameter:-value&#125;</code>。<code>value</code>这显然不是我们想要的。</p>
<p>就是这样！您已经牢牢掌握了 <code>bash shell</code> 语言绝对最重要和最有用的方面：它的参数和扩展，以及我们可以将运算符应用于扩展值并根据我们的各种需求塑造它们的多种方式。</p>
]]></content>
      <categories>
        <category>Bash Programing</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>bash programing</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 架构</title>
    <url>/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>Kubernetes(简称：k8s) 最初源于谷歌内部的 Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes 的目标旨在消除编排物理 &#x2F; 虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。</p>
<p>Kubernetes 具备完善的<strong>集群管理能力</strong>，包括<strong>多层次的安全防护和准入机制</strong>、<strong>多租户应用支撑能力</strong>、透明的<strong>服务注册和服务发现机制</strong>、内建<strong>负载均衡器、故障发现和自我修复能力</strong>、<strong>服务滚动升级和在线扩容</strong>、<strong>可扩展的资源自动调度机制、多粒度的资源配额管理能力</strong>。Kubernetes 还提供<strong>完善的管理工具，涵盖开发、部署测试、运维监控</strong>等各个环节。</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/kubernetes_architecture.png" class="" title="Kubernetes 架构">

<p>Kubernetes是一个分布式服务，所有从架构上可以为Control Plane(Master) Node 和Worker Node，这也是分布式架构的主要特点。</p>
<span id="more"></span>

<p>控制面节点（Control Plane Node）负责容器编排并维护集群的所需状态，它具有以下组件：</p>
<ol>
<li><code>kube-apiserver</code></li>
<li><code>etcd</code></li>
<li><code>kube-scheduler</code></li>
<li><code>kube-controller-manager</code></li>
<li><code>cloud-controller-manager</code></li>
</ol>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/kube-api-server.drawio-1.png" class="" title="kube-apiserver">

<p>工作面节点（Worker Node）负责运行容器化应用程序,它具有以下组件。</p>
<ol>
<li><code>kubelet</code></li>
<li><code>kube-proxy</code></li>
<li><code>container runtime</code></li>
</ol>
<h4 id="Control-Plane-Node-组件"><a href="#Control-Plane-Node-组件" class="headerlink" title="Control Plane Node 组件"></a>Control Plane Node 组件</h4><h5 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h5><p>kube-apiserver 是实现API Server主要组件，它可以进行水平扩展，API Server 开放了Kubernetes API，它是Kubernetes 控制面节点的前端组件。当您使用 kubectl 管理集群时，在后端，您实际上是通过HTTP REST API与 API 服务器进行通信。然而，内部集群组件（如调度程序、控制器等）使用gRPC与 API 服务器通信。API 服务器与集群中其他组件之间的通信通过 TLS 进行，以防止对集群进行未经授权的访问。kube-apiserver负责以下工作：</p>
<ol>
<li>API管理：公开集群API并处理所有API请求。</li>
<li>身份验证（使用客户端证书、不记名令牌和 HTTP 基本身份验证）和授权（ABAC 和 RBAC 评估）</li>
<li>处理 API 请求并验证 API 对象（如 Pod、服务等）的数据（验证和变更准入控制器）</li>
<li>它是唯一与 etcd 通信的组件，采用gRPC框架通信。</li>
<li>kube-apiserver 协调控制面节点与工作节点之间的所有进程。</li>
<li>kube-apiserver 有一个内置的代理，它是kube-apiserver进程的一部分。</li>
</ol>
<h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><p>Kubernetes 是一个分布式系统，它需要像 etcd 这样高效的分布式数据库来支持其分布式特性。它既充当后端服务发现又充当数据库。etcd是一个开源的强一致性、分布式k-v数据库。etcd具有以下特性：</p>
<ul>
<li>强一致性：如果对一个节点进行更新，强一致性将确保它立即更新到集群中的所有其他节点。</li>
<li>分布式：etcd 被设计为作为集群在多个节点上运行，而不牺牲一致性。</li>
<li>键值存储：将数据存储为键和值的非关系数据库。它还公开了一个键值 API。该数据存储构建在BboltDB之上，BboltDB 是 BoltDB 的一个分支。</li>
</ul>
<p>etcd 使用raft 共识算法 来实现强一致性和可用性。它以Leader-follower的方式工作，以实现高可用性并承受节点故障。</p>
<ol>
<li>etcd 存储 Kubernetes 对象的所有配置、状态和元数据（pod、秘密、守护进程集、部署、配置映射、状态集等）。</li>
<li>etcd 允许客户端使用 API 订阅事件Watch() 。kube-apiserver 使用 etcd 的监视功能来跟踪对象状态的变化。</li>
<li>etcd使用gRP开方调用获取键&#x2F;值的API 。此外，gRPC 网关是一个 RESTful 代理，它将所有 HTTP API 调用转换为 gRPC 消息。它使其成为 Kubernetes 的理想数据库。</li>
<li>etcd 以键值格式存储&#x2F;registry目录键下的所有对象。etcd 是控制面节点中唯一的Statefulset（部署有状态应用和将数据保存到永久性存储空间的聚簇应用）组件。</li>
</ol>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/etcd-component.png" class="">

<h5 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h5><p>kube-scheduler 负责调度工作节点上的 pod。部署 Pod 时，需要指定 Pod 指标要求，例如 CPU、内存、关联性、优先级、持久卷 (PV) 等。调度程序的主要任务是识别创建请求并为 Pod 选择最佳节点。下图显示了调度程序如何工作的：</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/kube-scheduler.png" class="">

<p>kube-scheduler的工作原理：</p>
<ol>
<li>为了选择最佳节点，Kube 调度程序使用过滤和评分操作。</li>
<li>在过滤中，调度程序找到最适合调度 Pod 的节点。例如，如果有五个具有资源可用性的工作节点来运行 pod，则它会选择所有五个节点。如果没有节点，则 Pod 不可调度并移至调度队列。如果它是一个大型集群，假设有 100 个工作节点，并且调度程序不会迭代所有节点。有一个名为 的调度程序配置参数percentageOfNodesToScore。默认值通常为50%。</li>
<li>在评分阶段，调度程序通过为过滤后的工作节点分配分数来对节点进行排名。调度器通过调用多个调度插件来进行评分。最后，将选择排名最高的工作节点来调度 Pod。如果所有节点的等级相同，则将随机选择一个节点。</li>
<li>一旦选择了节点，调度程序就会在 API 服务器中创建一个绑定事件。意思是绑定 pod 和节点的事件。</li>
</ol>
<p><strong>它是一个监听 kube-apiserver中 pod 创建事件的控制器。调度程序有两个阶段。调度周期 和 绑定周期。它们一起被称为调度上下文。 调度 周期选择一个工作节点，绑定周期将该更改应用于集群。调度程序始终将高优先级 pod 放在低优先级 pod 之前进行调度。此外，在某些情况下，Pod 开始在所选节点中运行后，Pod 可能会被驱逐或移动到其他节点。您可以创建自定义调度程序并在集群中与本机调度程序一起运行多个调度程序。部署 Pod 时，您可以在 Pod 清单中指定自定义调度程序。因此，将根据自定义调度程序逻辑做出调度决策。调度器有一个可插拔的调度框架。这意味着，您可以将自定义插件添加到调度工作流程中</strong>。</p>
<h5 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h5><blockquote>
<p>在 Kubernetes 中，控制器是控制循环，用于监视集群的状态，然后在需要时进行或请求更改。每个控制器都会尝试使当前集群状态更接近所需状态。</p>
</blockquote>
<p>假设您想要创建一个部署，您可以在清单 YAML 文件中指定所需的状态（声明性方法）。例如，2 个副本、1 个卷挂载、configmap 等。内置的部署控制器可确保部署始终处于所需状态。如果用户使用 5 个副本更新部署，部署控制器会识别它并确保所需状态为 5 个副本。</p>
<p>kube-controller-manager 是管理所有Kubernetes控制器的组件。Kubernetes 资源&#x2F;对象（例如 pod、命名空间、作业、副本集）由各自的控制器管理。另外，kube调度器也是一个由Kube控制器管理器管理的控制器。kube调度器也是一个由kube-controller-manager管理的控制器。</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/kube-controller-manager.png" class="">

<p>内置 Kubernetes 控制器的列表:</p>
<ol>
<li><code>Deployment controller</code></li>
<li><code>Replicaset controller</code></li>
<li><code>DaemonSet controller </code></li>
<li><code>Job Controller (Kubernetes Jobs)</code></li>
<li><code>CronJob Controller</code></li>
<li><code>endpoints controller</code></li>
<li><code>namespace controller</code></li>
<li><code>service accounts controller</code></li>
<li><code>Node controller</code></li>
</ol>
<p>kube-controller-manager 管理所有控制器，控制器将集群保持在所需的状态, 可以使用与自定义资源定义关联的自定义控制器来扩展 Kubernetes。</p>
<h5 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h5><p>当kubernetes部署在云环境中时，云控制器管理器充当云平台API和Kubernetes集群之间的桥梁。这样，kubernetes 核心组件就可以独立工作，并允许云提供商使用插件与 kubernetes 集成。kube-controller-manager 允许 Kubernetes 集群配置云资源，例如实例（用于节点）、负载均衡器（用于服务）和存储卷（用于持久卷）。</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/cloud-controller-manager.png" class="">

<p>kube-controller-manager 包含一组特定于云平台的控制器，可确保特定于云的组件（节点、负载均衡器、存储等）的所需状态。以下是属于云控制器管理器一部分的三个主要控制器。</p>
<ol>
<li><code>Node controller</code>: 该控制器通过与云提供商 API 对话来更新节点相关信息。例如，节点标记和注释、获取主机名、CPU 和内存可用性、节点健康状况等。</li>
<li><code>Route controller</code>: 负责在云平台上配置网络路由。这样不同节点中的 Pod 就可以互相通信。</li>
<li><code>Service controller</code>: 它负责为 kubernetes 服务部署负载均衡器、分配 IP 地址等。</li>
</ol>
<blockquote>
<p>部署负载均衡器类型的 Kubernetes 服务。这里 Kubernetes 提供了一个特定于云的负载均衡器并与 Kubernetes 服务集成。为云存储解决方案支持的 Pod 供应存储卷 (PV)。</p>
</blockquote>
<h4 id="Worker-Node-组件"><a href="#Worker-Node-组件" class="headerlink" title="Worker Node 组件"></a>Worker Node 组件</h4><h5 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h5><p>Kubelet 是一个代理组件，运行在集群中的每个节点上。Kubelet 不作为容器运行，而是作为守护进程运行，由 systemd 管理。</p>
<p>它负责向 kube-apiserver注册工作节点，并主要使用来自 kube-apiserver的 podSpec（Pod 规范 - YAML 或 JSON）。podSpec 定义了应该在 Pod 内运行的容器、它们的资源（例如 CPU 和内存限制）以及其他设置，例如环境变量、卷和标签。然后，通过创建容器将 podSpec 调整到所需的状态。</p>
<p>kubelet工作范围：</p>
<ol>
<li>创建、修改和删除 Pod 的容器。</li>
<li>负责处理活跃度、就绪度和启动探测。</li>
<li>负责通过读取 pod 配置并在主机上创建相应的目录来挂载卷。</li>
<li>通过调用 kube-apiserver 来收集和报告节点和 Pod 状态。</li>
</ol>
<p>Kubelet 也是一个控制器，它监视 Pod 更改并利用节点的容器运行时来拉取镜像、运行容器等。除了来自 API 服务器的 PodSpec 之外，kubelet 还可以接受来自文件、HTTP endpoint和 HTTP 服务器的 podSpec。</p>
<p><strong>Kubelet 使用 CRI（容器运行时接口）gRPC 接口与容器运行时进行通信。它还公开一个 HTTP endpoint来收集日志并为客户端提供执行会话。使用CSI（容器存储接口）gRPC 配置块存储卷。使用集群中配置的 CNI 插件来分配 Pod IP 地址并为 Pod 设置必要的网络路由和防火墙规则。</strong></p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/kubelet-architecture.png" class="">

<h5 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h5><p>Kubernetes 中的服务是一种向内部或外部流量公开一组 Pod 的方法。当您创建服务对象时，它会获得分配给它的虚拟 IP。它被称为 clusterIP。它只能在 Kubernetes 集群内访问。</p>
<p>Endpoint对象包含Service对象下所有Pod组的IP地址和端口。Endpoint Controller 负责维护 Pod IP 地址（端点）列表。Service controller 负责配置服务的Endpoint。</p>
<p>您无法 ping ClusterIP，因为它仅用于服务发现，与可 ping 通的 pod IP 不同。Kube-proxy 是一个守护进程，作为daemonset在每个节点上运行。它是一个代理组件，为 Pod 实现 Kubernetes 服务概念。（一组具有负载平衡功能的 Pod 的单个 DNS）。它主要代理 UDP、TCP 和 SCTP，不支持HTTP。当您使用服务 (ClusterIP) 公开 Pod 时，Kube-proxy 会创建网络规则以将流量发送到分组在 Service 对象下的后端 Pod（Endpoint）。这意味着，所有负载平衡和服务发现都由 Kube 代理负责。</p>
<p>Kube-proxy 工作原理：</p>
<p>kube-proxy 与 kube-apiserver 通信以获取有关服务 (ClusterIP) 以及相应 pod IP 和端口（Endpoint）的详细信息。它还监视服务和Endpoint的变化。Kube-proxy 使用以下任一模式来创建&#x2F;更新规则，以将流量路由到服务后端的 Pod。</p>
<ol>
<li><code>IPTables</code>：这是默认模式。在 IPTables 模式下，流量由 IPtable 规则处理。在这种模式下，kube-proxy 会随机选择后端 pod 进行负载均衡。一旦建立连接，请求就会发送到同一个 pod，直到连接终止。</li>
<li><code>IPVS</code>: 对于服务超过1000个的集群，IPVS提供性能提升。它支持后端负载均衡算法: 1. <code>rr：round-robin</code> ：这是默认模式; 2. <code>lc</code>：最少连接（打开连接的最小数量）; 3. <code>dh</code>: 目的地哈希; <code>sh</code>: 源哈希; <code>sed</code>：最短的预期延迟; <code>nq</code>: 从不排队。</li>
<li>用户空间（遗留且不推荐）</li>
<li>Kernelspace：此模式仅适用于 Windows 系统。</li>
</ol>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/kube-proxy.png" class="">

<h5 id="container-runtime"><a href="#container-runtime" class="headerlink" title="container runtime"></a>container runtime</h5><p>您可能了解Java 运行时 (JRE)。它是在主机上运行Java程序所需的软件。同样，容器运行时是运行容器所需的软件组件。容器运行时运行在 Kubernetes 集群中的所有节点上。它负责从容器注册表中提取镜像、运行容器、为容器分配和隔离资源以及管理主机上容器的整个生命周期。</p>
<ul>
<li><p><strong>容器运行时接口（CRI）</strong>：它是一组 API，允许 Kubernetes 与不同的容器运行时交互。它允许不同的容器运行时与 Kubernetes 互换使用。CRI 定义了用于创建、启动、停止和删除容器以及管理镜像和容器网络的 API。</p>
</li>
<li><p><strong>开放容器倡议（OCI）</strong>：它是一组容器格式和运行时的标准。</p>
</li>
</ul>
<p>Kubernetes 支持多种符合容器运行时接口(CRI)的容器运行时（CRI-O、Docker Engine、containerd 等）。这意味着，所有这些容器运行时都实现 CRI 接口并公开 gRPC CRI API（运行时和图像服务端点）。正如我们在 Kubelet 部分中了解到的，kubelet 代理负责使用 CRI API 与容器运行时交互，以管理容器的生命周期。它还从容器运行时获取所有容器信息并将其提供给控制面Node。让我们以CRI-O容器运行时接口为例。以下是容器运行时如何与 kubernetes 配合使用的高级概述。</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E6%9E%B6%E6%9E%84/cri-o.png" class="">

<ol>
<li>当 kube-apiserver 对 pod 发出新请求时，kubelet 与 CRI-O 守护进程通信，通过 Kubernetes 容器运行时接口启动所需的容器。</li>
<li>CRI-O 检查并从配置的容器注册表中提取所需的容器映像containers&#x2F;image。</li>
<li>然后，CRI-O 为容器生成 OCI 运行时规范 (JSON)。</li>
<li>最后，CRI-O 启动与 OCI 兼容的运行时 (runc)，以根据运行时规范来启动容器进程。</li>
</ol>
<h4 id="Kubernetes-集群插件组件"><a href="#Kubernetes-集群插件组件" class="headerlink" title="Kubernetes 集群插件组件"></a>Kubernetes 集群插件组件</h4><p>除了核心组件之外，kubernetes 集群还需要附加组件才能完全运行。选择插件取决于项目要求和用例。以下是集群上可能需要的一些流行插件组件。</p>
<ol>
<li>CNI插件（容器网络接口）</li>
<li>CoreDNS（用于 DNS 服务器）： CoreDNS 充当 Kubernetes 集群内的 DNS 服务器。通过启用此插件，您可以启用基于 DNS 的服务发现。</li>
<li>Metrics Server（用于资源指标）：此插件可帮助您收集集群中节点和 Pod 的性能数据和资源使用情况。</li>
<li>Web UI（Kubernetes 仪表板）：此插件使 Kubernetes 仪表板能够通过 Web UI 管理对象。</li>
</ol>
<h5 id="CNI插件"><a href="#CNI插件" class="headerlink" title="CNI插件"></a>CNI插件</h5><p>CNI（容器网络接口）， 云原生计算基金会项目包含用于编写插件以在 Linux 和 Windows 容器中配置网络接口的规范和库，以及许多受支持的插件。CNI 只关心容器的网络连接，并在删除容器时删除分配的资源。由于这一重点，CNI 拥有广泛的支持，并且规范易于实现。它是一个基于插件的架构，具有供应商中立的规范和库，用于为容器创建网络接口。它并非特定于 Kubernetes。通过 CNI，容器网络可以在 Kubernetes、Mesos、CloudFoundry、Podman、Docker 等容器编排工具之间实现标准化。</p>
<p>当谈到容器网络时，企业可能有不同的需求，如网络隔离、安全、加密等。随着容器技术的进步，许多网络提供商为容器创建了基于 CNI 的解决方案，并具有广泛的网络功能。您可以将其称为 CNI-Plugins。这使得用户可以从不同的提供商中选择最适合其需求的网络解决方案。CNI 插件如何与 Kubernetes 配合使用？</p>
<ol>
<li><code>Kube-controller-manager</code> 负责为每个节点分配 pod CIDR。每个 Pod 从 Pod CIDR 获取唯一的 IP 地址。</li>
<li><code>Kubelet</code> 与容器运行时交互以启动&#96;预定的 pod。CRI 插件是容器运行时的一部分，它与 CNI 插件交互来配置 Pod 网络。</li>
<li><code>CNI</code> 插件支持使用覆盖网络在相同或不同节点上分布的 Pod 之间进行联网。</li>
</ol>
<p>CNI 插件的高级功能：</p>
<ul>
<li><code>Pod Networking</code></li>
<li><code>Pod</code> 网络安全和隔离使用网络策略来控制 Pod 之间以及命名空间之间的流量。</li>
</ul>
<p>一些流行的 CNI 插件包括：</p>
<ul>
<li><code>Calico</code></li>
<li><code>Flannel</code></li>
<li><code>Weave Net</code></li>
<li><code>Cilium</code> (Uses eBPF)</li>
<li><code>Amazon VPC CNI</code> (For AWS VPC)</li>
<li><code>Azure CNI</code>(For Azure Virtual network)Kubernetes networking is a big topic and it differs based on the hosting platforms.</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 高可用</title>
    <url>/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>Kubernetes 是一个分布式系统，容易出现多种故障。对于组织而言，拥有高度可用的 Kubernetes 对于提供良好的客户体验至关重要。如果发生意外中断，如果您的集群在一个或多个组件发生故障的情况下无法继续运行，则停机可能会导致收入损失、声誉问题等。</p>
<p>通过在 Kubernetes 中实施 HA，可以降低停机风险，集群上运行的应用程序和服务仍然可供用户访问，并且系统可以快速从故障中恢复，无需人工干预。在较高级别上，这可以通过部署控制平面组件的多个副本以及跨越多个可用区或区域的网络拓扑来实现。</p>
<span id="more"></span>

<h4 id="Kubernetes-控制面节点的高可用性"><a href="#Kubernetes-控制面节点的高可用性" class="headerlink" title="Kubernetes 控制面节点的高可用性"></a>Kubernetes 控制面节点的高可用性</h4><p>Kubernetes 控制面节点具有以下核心组件：</p>
<ul>
<li><code>API server</code></li>
<li><code>Kube controller manager</code></li>
<li><code>Kube Scheduler</code></li>
<li><code>Cloud Controller Manager (Optional)</code></li>
</ul>
<p>运行单个控制面节点可能会导致所有控制平面组件出现单点故障。要拥有高度可用的 Kubernetes 控制平面，您应该至少拥有三个 quoram 控制平面节点，并在所有三个节点之间复制控制平面组件。</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E9%AB%98%E5%8F%AF%E7%94%A8/kubernetes-ha.png" class="">

<p>现在，了解每个控制平面组件在跨节点部署为多个副本时的性质非常重要。因为当部署为多个副本时，很少有组件会使用领导者选举。</p>
<h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><p>当谈到etcd HA架构时，有两种模式。</p>
<ul>
<li><strong>堆叠式 etcd</strong>：etcd 与控制平面节点一起部署</li>
<li><strong>外部etcd集群</strong>：运行专用节点的Etcd集群。该模型的优点是管理良好的备份和恢复选项。</li>
</ul>
<p>为了具有容错能力，您应该拥有至少三节点的 etcd 集群。下表展示了etcd集群的容错能力。当涉及到生产部署时，定期备份 etcd非常重要。</p>
<h5 id="API-server"><a href="#API-server" class="headerlink" title="API server"></a>API server</h5><p>API 服务器是一个无状态应用程序，主要与 etcd 集群交互以存储和检索数据。这意味着 API 服务器的多个实例可以跨不同的控制平面节点运行。为了确保集群 API 始终可用，应该在 API 服务器副本之前放置一个负载均衡器。工作节点、最终用户和外部系统使用此负载均衡器端点与集群进行交互</p>
<h5 id="Kube-Scheduler"><a href="#Kube-Scheduler" class="headerlink" title="Kube Scheduler"></a>Kube Scheduler</h5><p>当您运行 kube 调度程序的多个实例时，它遵循领导者选举方法。这是因为，schedler 组件涉及 pod 调度活动，并且一次只有一个实例可以做出决策。因此，当您运行调度程序的多个副本时，一个实例将被选为领导者，其他实例将被标记为追随者。</p>
<p>这确保了始终有一个活动的调度程序来做出调度决策，并避免冲突和不一致。如果是领导者，追随者将被选举为领导者并接管所有调度决策。这样，您就拥有了具有一致调度的高度可用的调度程序。</p>
<h5 id="Kube-controller-manager"><a href="#Kube-controller-manager" class="headerlink" title="Kube controller manager"></a>Kube controller manager</h5><p>Kuber 控制器管理器也遵循相同的领导者选举方法。从许多副本中，选出一个控制器管理器，并将领导者和其他人标记为追随者。领导者控制器负责控制集群的状态。</p>
<h5 id="Cloud-Controller-Manager"><a href="#Cloud-Controller-Manager" class="headerlink" title="Cloud Controller Manager"></a>Cloud Controller Manager</h5><p>云控制器管理器 (CCM) 是一个 Kubernetes 组件，它运行与云提供商特定的 API 交互的控制器，以管理负载均衡器、持久卷和路由等资源。就像调度程序和 kube-controller 一样，CCM 也使用领导者选举来确保一次只有一个活动副本做出决策并与云提供商 API 进行交互。</p>
<h4 id="Kubernetes-工作节点的高可用性"><a href="#Kubernetes-工作节点的高可用性" class="headerlink" title="Kubernetes 工作节点的高可用性"></a>Kubernetes 工作节点的高可用性</h4><p>为了获得工作节点高可用性，您需要运行应用程序所需的多个工作节点。当存在 pod 扩展活动或节点故障时，其他工作节点上应该有足够的容量来调度 pod。在云平台上，您可以使用自动缩放来缩放工作节点。因此，当存在扩展活动或资源需求时，工作节点可以扩展到所需的容量。</p>
<h4 id="Kubernetes-集群可用性测量"><a href="#Kubernetes-集群可用性测量" class="headerlink" title="Kubernetes 集群可用性测量"></a>Kubernetes 集群可用性测量</h4><p>假设没有计划停机时间，下表来自Google SRE 书籍，显示了根据不同可用性级别允许的停机时间的计算。每个组织都会有用于集群可用性的 SLO。如果您使用管理服务，服务提供商将制定与 SLO 一致的 SLA。</p>
<img data-src="/2023/07/31/Cloud-Native/%E3%80%90kubernetes%E3%80%91%E9%AB%98%E5%8F%AF%E7%94%A8/kube-sla.png" class="">

<p>如果 Kubernetes 集群中的 DNS 服务失败会发生什么？<br>如果像 Core DNS 这样的 DNS 服务出现故障，可能会对集群中运行的应用程序的可用性和功能产生重大影响。它可能会破坏服务发现、外部访问、负载平衡、监控和日志记录以及滚动更新，从而导致应用程序故障、错误和中断。</p>
<p>控制平面故障期间会发生什么？<br>即使控制平面发生故障，工作节点上现有的工作负载也会继续处理请求。但是，如果出现节点故障，Pod 调度活动或任何类型的更新活动都不会发生。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】概述</title>
    <url>/2023/07/23/Cloud-Native/%E3%80%90Docker%E3%80%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h3><p>简而言之，容器是计算机的沙盒进程，与主机上的所有其他进程隔离，这种隔离利用了<code>内核命名空间和cgroup</code>，这些功能在<code>linux</code>中已经存在很长时间了。<code>Docker</code>正是利用了这些能力。总而言之，容器包括以下这些能力：</p>
<ul>
<li>是一个可运行的镜像实例，你可以使用<code>Docker API</code>或<code>CLI</code>创建、启动、停止、移动或删除容器。</li>
<li>可以在本地机器、虚拟机、云上部署和运行。</li>
<li>是跨平台并且可移植的。</li>
<li>与其他容器隔离运行自己的应用、二进制文件以及配置。</li>
</ul>
<h3 id="什么是容器镜像？"><a href="#什么是容器镜像？" class="headerlink" title="什么是容器镜像？"></a>什么是容器镜像？</h3><p>运行容器时，它使用隔离的文件系统。该自定义文件系统由容器镜像提供。由于镜像包含容器的文件系统，因此它必须包含运行应用程序所需的所有内容-所有依赖项、配置、脚本、二进制文件等。镜像还包含容器的其它配置，例如环境变量、要运行的默认命令和其它元数据。</p>
<h3 id="将应用程序在容器中部署"><a href="#将应用程序在容器中部署" class="headerlink" title="将应用程序在容器中部署"></a>将应用程序在容器中部署</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>在机器上下载&amp;安装<code>Docker</code></li>
<li>在机器上下载&amp;安装<code>git</code>客户端</li>
<li>在机器上安装一个编辑文件的IDE或文本编辑器，这里建议下载&amp;安装<code>Visual Studio Code</code></li>
</ul>
<span id="more"></span>

<h4 id="下载应用程序"><a href="#下载应用程序" class="headerlink" title="下载应用程序"></a>下载应用程序</h4><p>在运行应用程序之前，你需要将应用程序源代码下载的你的机器里。</p>
<ol>
<li><p>使用以下命令下载应用程序源码：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:docker/getting-started.git</span><br></pre></td></tr></table></figure></li>
<li><p>查看源码，在<code>getting-started/app</code>目录中，你应该看到<code>package.json</code>和两个子目录（<code>src</code>和<code>spec</code>）。</p>
</li>
</ol>
<img data-src="/2023/07/23/Cloud-Native/%E3%80%90Docker%E3%80%91%E6%A6%82%E8%BF%B0/ide-screenshot.png" class="">

<h4 id="构建应用程序的容器镜像"><a href="#构建应用程序的容器镜像" class="headerlink" title="构建应用程序的容器镜像"></a>构建应用程序的容器镜像</h4><ol>
<li><p>在应用的<code>app</code>目录下创建一个<code>Dockerfile</code>文件，你可以使用以下命令创建<code>Dockerfile</code>文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure></li>
<li><p>使用文本编辑器或IDE，讲一下内容添加到<code>Dockerfile</code>文件中</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line">   </span><br><span class="line">FROM node:18-alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN yarn install --production</span><br><span class="line">CMD [&quot;node&quot;, &quot;src/index.js&quot;]</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以下命令创建容器镜像：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd getting-started/app</span><br></pre></td></tr></table></figure>

<p> 构建容器镜像</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t getting-started .</span><br></pre></td></tr></table></figure>
<p> <code>docker build</code>命令使用 <code>Dockerfile</code> 构建新的容器镜像。您可能注意到<code>Docker</code>下载了很多”层”。只是因为你指定构建器要从<code>node:18-alpine</code>镜像开始。但我们的机器上没有此镜像。因此<code>Docker</code>需要下载该镜像。</p>
<p> <code>Docker</code>下载该镜像后，<code>Dockerfile</code>中的指令会被复制到你的应用程序中并用<code>yarn</code>安装应用程序的依赖项。该<code>CMD</code>指令指定了从镜像启动容器时要运行的默认命令。</p>
<p> 最后<code>-t</code>参数标记你的镜像名称为：<code>getting-started</code>, 因此你可以在运行容器时引用该镜像。命令末尾的<code>.</code>是告诉<code>Docker</code>执行<code>docker build</code>命令应该在当前目录中查找<code>Dockerfile</code>文件。</p>
</li>
</ol>
<h4 id="在容器中启动应用程序"><a href="#在容器中启动应用程序" class="headerlink" title="在容器中启动应用程序"></a>在容器中启动应用程序</h4><p>现在你已经有了镜像，你可以在容器中运行应用程序。为此，你将使用<code>docker run</code>命令。</p>
<ol>
<li><p>使用以下命令启动容器<code>docker run</code> 并指定刚刚创建的镜像名称：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 127.0.0.1:3000:3000 getting-started</span><br></pre></td></tr></table></figure>
<p> 该<code>-d</code>参数（缩写：<code>--detach</code>）在后台运行容器。该<code>-p</code>参数（<code>--publish</code>）在主机和容器之间创建端口映射。该<code>-p</code>参数采用的格式是字符串值<code>HOST:CONTAINER</code>，其中<code>HOST</code>是主机上的地址，<code>CONTAINER</code>是容器的端口，此处的命令是将容器的端口<code>3000</code>发布到主机上<code>127.0.0.1:3000</code>。<code>127.0.0.1:3000</code>如果没有端口映射，则无法从主机访问应用。</p>
</li>
<li><p>几秒钟后，打开<code>web</code>浏览器访问<code>http://localhost:3000</code>，您应该会看到你的应用程序。</p>
</li>
</ol>
<p>如果你想快速查看一下容器，你应该会看到至少有一个在使用的<code>getting-started</code>镜像，是在<code>port:3000</code>上运行的容器，要查看容器可以使用<code>CLI</code>或 <code>Docker Desktop</code>图形界面。</p>
<p><code>CLI</code>, 在终端中运行 <code>docker ps</code> 命令，列出你的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps </span><br></pre></td></tr></table></figure>
<p>应该输出以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">df784548666d        getting-started     &quot;docker-entrypoint.s…&quot;   2 minutes ago       Up 2 minutes        127.0.0.1:3000-&gt;3000/tcp   priceless_mcclintock</span><br></pre></td></tr></table></figure>

<h4 id="更新应用程序"><a href="#更新应用程序" class="headerlink" title="更新应用程序"></a>更新应用程序</h4><p><strong>更新源码</strong></p>
<p>在下面的步骤中，您将在没有任何待办事项列表项时将“空文本”更改为“您还没有待办事项！上面加一个！</p>
<ol>
<li><p>在<code>src/static/js/app.js</code>文件中，更新第56行使用新的空文本。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- &lt;p className=&quot;text-center&quot;&gt;No items yet! Add one above!&lt;/p&gt;</span><br><span class="line">+ &lt;p className=&quot;text-center&quot;&gt;You have no todo items yet! Add one above!&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>docker build</code>使用您第2部分中使用相同命令构建镜像的更新版本</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t getting-started .</span><br></pre></td></tr></table></figure></li>
<li><p>使用更新的代码启用一个新容器。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 127.0.0.1:3000:3000 getting-started</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你可能会看到这样一个错误（ID会不同）</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint laughing_burnell </span><br><span class="line">        (bb242b2ca4d67eba76e79474fb36bb5125708ebdabd7f45c8eaf16caaabde9dd): Bind for 127.0.0.1:3000 failed: port is already allocated.</span><br></pre></td></tr></table></figure>
</code></pre>
<p>发生错误的原因是您无法在旧容器仍在运行时启动新容器。原因是旧容器已经在使用主机的3000端口，并且机器上只有一个进程（包括容器）可以监听特定端口。要解决此问题，你需要删除此容器。</p>
<p><strong>删除旧容器</strong></p>
<p>要删除容器，你首先要停止它。一旦停止，你就可以将其删除。你可以使用<code>CLI</code>或<code>Docker Desktop</code>图形界面来删除旧容器</p>
<ol>
<li><p>使用命令获取容器ID <code>docker ps</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure></li>
<li><p>使用docker stop命令停止容器，将 <code>&lt;the-container-id&gt;</code> 替换为 中的 <code>ID docker ps</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker stop &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>容器停止后，你可以使用<code>docker rm</code>命令将其删除</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker rm &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你可以用一条命令来停止&amp;删除容器<code>docker rm -f &lt;the-container-id&gt;</code></p>
<p><strong>启动更新后的应用程序容器</strong></p>
<ol>
<li><p>现在，使用命令启动更新后的应用程序<code>docker run</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 127.0.0.1:3000:3000 getting-started</span><br></pre></td></tr></table></figure></li>
<li><p>在<a href="http://localhost:3000上刷新浏览器，你应该会看到更新后的帮助文本。">http://localhost:3000上刷新浏览器，你应该会看到更新后的帮助文本。</a></p>
</li>
</ol>
<h4 id="共享应用程序"><a href="#共享应用程序" class="headerlink" title="共享应用程序"></a>共享应用程序</h4><p>现在你已经构建了镜像，你可以共享它，要共享<code>Docker</code>镜像，你必须使用<code>Docker</code>注册表。默认注册表是<code>Docker Hub</code>，你使用的所有镜像都来自于此。</p>
<blockquote>
<p>Docker ID 允许您访问 Docker Hub，这是世界上最大的容器镜像库和社区。如果您没有Docker ID，请免费创建一个。</p>
</blockquote>
<p><strong>创建一个仓库</strong></p>
<p>要推送镜像，首先要在 <code>Docker Hub</code> 创建一个存储库</p>
<ol>
<li><p>注册&#x2F;登录<a href="https://hub.docker.com/">Docker Hub</a>。</p>
</li>
<li><p>选择创建仓库按钮。</p>
</li>
<li><p>对于仓库的名称，请使用 <code>getting-started</code> 确保可见性，请选择<code>Public</code>。</p>
</li>
<li><p>选择创建按钮。</p>
</li>
</ol>
<p><strong>推送</strong></p>
<ol>
<li><p>在命令行中，运行你在<code>Docker Hub</code>上看到的命令。请注意，你的命令将使用你的命名空间，而不是<code>docker</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push docker/getting-started</span><br><span class="line">The push refers to repository [docker.io/docker/getting-started]</span><br><span class="line">An image does not exist locally with the tag: docker/getting-started</span><br></pre></td></tr></table></figure>
<p> 为什么报错了？ Push命令正在寻找名为<code>docker/getting-started</code> 的镜像，但没有找到，要解决此问题，你需要“标记”你构建的现有镜像，为其指定另一个名称。</p>
</li>
<li><p>使用命令登录<code>Docker Hub</code> <code>docker login -u YOUR-USER-NAME</code>。</p>
</li>
<li><p>使用该<code>docker tag</code> 命令为镜像指定 <code>getting-started</code> 新名称。请务必更换 <code>YOUR-USER-NAME</code>为您的 <code>Docker ID</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker tag getting-started YOUR-USER-NAME/getting-started</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在再次尝试推送命令。如果您从<code>Docker Hub</code> 复制该值，则可删除 <code>tagname</code> 部分，因为你没有想镜像添加标签。如果你不指定标签，<code>Docker</code>将使用名为<code>latest</code>的标签。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker push YOUR-USER-NAME/getting-started</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>在新实例上运行镜像</strong></p>
<p>现在你的镜像已构建并推送到注册表中，请尝试在从未见过此容器映像的全新实例上运行您的应用程序。为此，您将使用 <code>Play with Docker</code>。</p>
<ol>
<li><p>打开浏览器访问<a href="https://labs.play-with-docker.com/">Docker</a></p>
</li>
<li><p>选择“登录”，然后从下拉列表中选择“docker” 。</p>
</li>
<li><p>连接您的 <code>Docker Hub</code> 帐户。</p>
</li>
<li><p>登录后，选择左侧栏上的“添加新实例”选项。如果您没有看到它，请将您的浏览器设置得更宽一些。几秒钟后，浏览器中将打开一个终端窗口。</p>
 <img data-src="/2023/07/23/Cloud-Native/%E3%80%90Docker%E3%80%91%E6%A6%82%E8%BF%B0/pwd-add-new-instance.png" class="">
</li>
<li><p>在终端中，启动新推送的应用程序。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 0.0.0.0:3000:3000 YOUR-USER-NAME/getting-started</span><br></pre></td></tr></table></figure></li>
<li><p>当 3000 徽章出现时，选择它，您应该会看到经过修改的应用程序。如果 3000 徽章未显示，您可以选择“打开端口”按钮并输入 3000。</p>
</li>
</ol>
<h4 id="容器的文件系统"><a href="#容器的文件系统" class="headerlink" title="容器的文件系统"></a>容器的文件系统</h4><p>当容器运行时，它会使用镜像中的各个层作为其文件系统。每个容器还拥有自己的“临时空间”来创建&#x2F;更新&#x2F;删除文件。即使它们使用了相同的镜像。任何更改都不会再另一个容器中生效。</p>
<p>要查看实际效果，我们启动两个容器并在每个容器中创建一个文件。你将看到的是，一个容器中创建的文件在另一个容器中不可用。</p>
<ol>
<li><p>启动一个<code>ubuntu</code>容器，该容器将创建一个1到10000之间的随机数命名的文件<code>/data.txt</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu bash -c &quot;shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null&quot;</span><br></pre></td></tr></table></figure>
<p> 如果你对该命令感到好奇，你可以启动<code>bash shell</code>并调用两个命令 (为什么有<code>&amp;&amp;</code>) 。第一部分选择一个随机数将其写入<code>/data.txt</code>，第二个命令只是监视一个文件以保持容器运行。</p>
</li>
<li><p>验证你是否可以通过访问容器中的终端来查看输出。为此，你可以使用CLI 或 Docker Desktop 的图形界面。</p>
</li>
</ol>
<p>在命令行上可以使用<code>docker exec</code>命令访问容器，你需要获取容器的ID（使用<code>docker ps</code>来获取）。在MAC或Linux终端中，或者Windows命令提示符或PowerShell中，使用以下命令获取内容。</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker exec &lt;container-id&gt; cat /data.txt</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>现在启动一个<code>ubuntu</code>（相同的镜像），你会发现没有相同的文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -it ubuntu ls /</span><br></pre></td></tr></table></figure>
<p> 这种情况下，该命令列出容器根目录下的文件，那里没有<code>data.txt</code>！这是因为它们仅写入第一个容器的暂存空间。</p>
</li>
<li><p>继续使用<code>docker rm -f &lt;container-id&gt;</code> 命令删除第一个容器。</p>
</li>
</ol>
<p>通过之前的实验，您看到每个容器每次启动时都从图像定义开始。虽然容器可以创建、更新和删除文件，但当您删除容器时，这些更改将会丢失，并且 Docker 会隔离对该容器的所有更改。有了卷，你就可以改变这一切。</p>
<p>卷提供了将容器的特定文件系统路径连接回主机的能力。如果在容器中挂载目录，则该目录中的更改也会在主机上看到。如果您在容器重新启动时挂载相同的目录，您将看到相同的文件。卷有两种主要类型。您最终将使用两者，但您将从卷安装开始。</p>
<p><strong>保存数据</strong></p>
<p>默认情况下，<code>todo</code> 应用程序将其数据存储在 <code>/etc/todos/todo.db</code>容器文件系统的 <code>SQLite</code> 数据库中。如果您不熟悉 <code>SQLite</code>，不用担心！它只是一个将所有数据存储在单个文件中的关系数据库。虽然这对于大型应用程序来说不是最好的，但它适用于小型演示。稍后您将了解如何将其切换到不同的数据库引擎。</p>
<p>由于数据库是单个文件，如果您可以将该文件保留在主机上并将其可供下一个容器使用，那么它应该能够从上一个容器停止的地方继续。通过创建卷并将其附加（通常称为“安装”）到存储数据的目录，您可以保留数据。当容器写入文件时<code>todo.db</code>，它将数据保存到卷中的主机。您将使用卷安装。将卷挂载视为不透明的数据桶。Docker 完全管理卷，包括磁盘上的存储位置。您只需要记住卷的名称即可。</p>
<p><strong>创建一个卷并启动容器</strong></p>
<p>您可以使用 CLI 或 Docker Desktop 的图形界面创建卷并启动容器。</p>
<ol>
<li><p>使用<code>docker volume create</code>命令创建卷。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker volume create todo-db</span><br></pre></td></tr></table></figure></li>
<li><p>再次停止并删除待办事项应用程序容器<code>docker rm -f &lt;id&gt;</code>，因为它仍在运行而不使用持久卷。</p>
</li>
<li><p>启动 todo 应用程序容器，但添加–mount指定卷安装的选项。为卷命名，并将其安装到&#x2F;etc&#x2F;todos容器中，该容器捕获在该路径中创建的所有文件。在 Mac 或 Linux 终端中，或者在 Windows 命令提示符或 PowerShell 中，运行以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 127.0.0.1:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>验证数据是否持续存在</strong></p>
<ol>
<li><p>容器启动后，打开应用程序并将一些项目添加到您的待办事项列表中。</p>
</li>
<li><p>停止并删除待办事项应用程序的容器。使用 Docker Desktop 或<code>docker ps</code>获取 ID，然后<code>docker rm -f &lt;id&gt;</code>将其删除。</p>
</li>
<li><p>使用与上面相同的步骤启动一个新容器。</p>
</li>
<li><p>打开应用程序。您应该会看到您的项目仍在列表中。</p>
</li>
<li><p>检查完清单后，请继续移除容器。</p>
</li>
</ol>
<p>很多人经常问“当我使用卷时，<code>Docker</code> 将我的数据存储在哪里？” 如果你想知道，可以使用<code>docker volume inspect</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker volume inspect todo-db</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2019-09-26T02:18:36Z&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;todo-db&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这Mountpoint是磁盘上数据的实际位置。请注意，在大多数计算机上，您需要具有 root 访问权限才能从主机访问此目录。但是，那就是它所在的地方。</p>
<blockquote>
<p>在 Docker Desktop 中运行时，Docker 命令实际上是在计算机上的小型虚拟机内运行。如果您想查看挂载点目录的实际内容，则需要查看该虚拟机的内部。</p>
</blockquote>
<h4 id="绑定挂载"><a href="#绑定挂载" class="headerlink" title="绑定挂载"></a>绑定挂载</h4><p>绑定挂载是另一种类型的挂载，它允许你将主机文件系统中的目录共享到容器当中。在处理应用程序时，你可以使用绑定挂载将源代码挂载到容器中。一旦你保存文件，容器就会立即看到你所做的更改。这意味着你可以在容器中运行进程来监视文件系统更改并对其作出响应。卷挂载与绑定挂载之间的区别：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Name volumes</th>
<th align="left">Bind mounts</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Host location</td>
<td align="left">Docker chooses</td>
<td align="left">You decide</td>
</tr>
<tr>
<td align="left">Mount example (using –mount)</td>
<td align="left">type&#x3D;volume,src&#x3D;my-volume,target&#x3D;&#x2F;usr&#x2F;local&#x2F;data</td>
<td align="left">type&#x3D;bind,src&#x3D;&#x2F;path&#x2F;to&#x2F;data,target&#x3D;&#x2F;usr&#x2F;local&#x2F;data</td>
</tr>
<tr>
<td align="left">Populates new volume with container contents</td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Supports Volume Drivers</td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody></table>
<ol>
<li><p>打开终端并将目录更改为<code>app</code> 入门存储库的目录。</p>
</li>
<li><p>运行以下命令以bash在ubuntu具有绑定挂载的容器中启动。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -it --mount type=bind,src=&quot;$(pwd)&quot;,target=/src ubuntu bash</span><br></pre></td></tr></table></figure>
<p> 该–mount选项告诉 Docker 创建绑定挂载，其中<code>src</code>是主机上的当前工作目录 ( <code>getting-started/app</code>)， target也是该目录应出现在容器内的位置 ( <code>/src</code>)。</p>
</li>
<li><p>运行命令后，Docker 将<code>bash</code>在容器文件系统的根目录中启动交互式会话。</p>
</li>
<li><p>将目录更改为该src目录。这是启动容器时安装的目录。列出此目录的内容将显示与 <code>getting-started/app</code>主机上的目录中相同的文件。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ac1237fad8db:/# pwd</span><br><span class="line">/</span><br><span class="line">root@ac1237fad8db:/# ls</span><br><span class="line">bin   dev  home  media  opt   root  sbin  srv  tmp  var</span><br><span class="line">boot  etc  lib   mnt    proc  run   src   sys  usr</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个名为 的新文件<code>myfile.txt</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ac1237fad8db:/src# touch myfile.txt</span><br><span class="line">root@ac1237fad8db:/src# ls</span><br><span class="line">Dockerfile  myfile.txt  node_modules  package.json  spec  src  yarn.lock</span><br></pre></td></tr></table></figure></li>
<li><p>打开app主机上的目录，观察该<code>myfile.txt</code>目录下有文件。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── app/</span><br><span class="line">│ ├── Dockerfile</span><br><span class="line">│ ├── myfile.txt</span><br><span class="line">│ ├── node_modules/</span><br><span class="line">│ ├── package.json</span><br><span class="line">│ ├── spec/</span><br><span class="line">│ ├── src/</span><br><span class="line">│ └── yarn.lock</span><br></pre></td></tr></table></figure>
</li>
<li><p>从主机中删除该<code>myfile.txt</code>文件。</p>
</li>
<li><p><code>app</code>在容器中，再次列出目录的内容。观察到该文件现在已经消失了。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ac1237fad8db:/src# ls</span><br><span class="line">Dockerfile  node_modules  package.json  spec  src  yarn.lock</span><br></pre></td></tr></table></figure></li>
<li><p><code>Ctrl + D</code> 停止交互式容器会话</p>
</li>
</ol>
<p><strong>在容器中运行应用</strong></p>
<p>以下步骤描述了如何使用执行以下操作的绑定安装来运行开发容器：</p>
<ul>
<li>将源代码挂载到容器中</li>
<li>安装所有依赖项</li>
<li>开始<code>nodemon</code>监视文件系统更改</li>
</ul>
<ol>
<li><p>确保当前没有任何<code>getting-started</code>容器正在运行。</p>
</li>
<li><p>从目录运行以下命令<code>getting-started/app</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 127.0.0.1:3000:3000 \</span><br><span class="line">-w /app --mount type=bind,src=&quot;$(pwd)&quot;,target=/app \</span><br><span class="line">node:18-alpine \</span><br><span class="line">sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br></pre></td></tr></table></figure>
<p> 以下是该命令的细分：</p>
<ul>
<li>-<code>dp 127.0.0.1:3000:3000</code>- 和之前一样。以分离（后台）模式运行并创建端口映射</li>
<li>-<code>w /app</code>- 设置“工作目录”或命令将从中运行的当前目录</li>
<li>–<code>mount type=bind,src=&quot;$(pwd)&quot;</code>,<code>target=/app</code>- 将当前目录从主机绑定挂载到&#x2F;app容器中的目录</li>
<li><code>node:18-alpine</code>- 要使用的镜像。请注意，这是来自 Dockerfile 的应用程序的基础镜像</li>
<li><code>sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</code>- 命令。sh您正在使用（<code>alpine</code>没有<code>bash</code>）启动<code>shell</code>并运行<code>yarn install</code>以安装软件包。然后运行<code>yarn run dev</code>以启动开发服务器。如果您查看<code>package.json</code>，您将看到<code>dev</code>脚本启动<code>nodemon</code>。</li>
</ul>
</li>
<li><p>您可以使用查看日志<code>docker logs &lt;container-id&gt;</code>。当您看到以下内容时，您就会知道您已准备好出发：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker logs -f &lt;container-id&gt;</span><br><span class="line">nodemon src/index.js</span><br><span class="line">[nodemon] 2.0.20</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching dir(s): *.*</span><br><span class="line">[nodemon] starting `node src/index.js`</span><br><span class="line">Using sqlite database at /etc/todos/todo.db</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure>
<p> 查看完日志后，按<code>Ctrl+C</code>退出。</p>
</li>
<li><p>在<code>src/static/js/app.js</code>文件的第 109 行，将“添加项目”按钮更改为简单地说“添加”：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- &#123;submitting ? <span class="string">&#x27;Adding...&#x27;</span> : <span class="string">&#x27;Add Item&#x27;</span>&#125;</span><br><span class="line">+ &#123;submitting ? <span class="string">&#x27;Adding...&#x27;</span> : <span class="string">&#x27;Add&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新网络浏览器中的页面，您应该会立即看到更改的反映。节点服务器可能需要几秒钟才能重新启动。如果出现错误，请尝试在几秒钟后刷新。</p>
</li>
<li><p>请随意进行您想要进行的任何其他更改。每次进行更改并保存文件时，该<code>nodemon</code>过程都会自动重新启动容器内的应用程序。完成后，停止容器并使用以下命令构建新映像：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t getting-started .</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="多容器应用"><a href="#多容器应用" class="headerlink" title="多容器应用"></a>多容器应用</h4><p>到目前为止，您一直在使用单容器应用程序。但是，现在您将把 MySQL 添加到应用程序堆栈中。经常会出现以下问题：“MySQL 将在哪里运行？安装在同一个容器中还是单独运行？” 一般来说，每个容器应该做一件事，并且做好。以下是单独运行容器的几个原因：</p>
<ul>
<li>您很有可能必须以不同于数据库的方式扩展 API 和前端。</li>
<li>单独的容器允许您隔离版本和更新版本。</li>
<li>虽然您可以在本地使用数据库容器，但您可能希望在生产中使用数据库托管服务。那么您不想将数据库引擎与您的应用程序一起提供。</li>
<li>运行多个进程将需要一个进程管理器（容器只启动一个进程），这增加了容器启动&#x2F;关闭的复杂性。</li>
</ul>
<p>如下图所示，最好在多个容器中运行您的应用程序。</p>
<pre><code>&#123;% asset_img multi-app-architecture.png %&#125;
</code></pre>
<p><strong>容器网络</strong></p>
<p>默认情况下，容器是独立运行的，并且不了解同一台计算机上的其他进程或容器。那么，如何允许一个容器与另一个容器通信呢？答案是网络。如果将两个容器放在同一网络上，它们就可以相互通信。</p>
<p><strong>启动mysql</strong></p>
<p>将容器放到网络上有两种方法:</p>
<ul>
<li>启动容器时分配网络。</li>
<li>将已运行的容器连接到网络。</li>
</ul>
<p>在以下步骤中，您将首先创建网络，然后在启动时附加 MySQL 容器。</p>
<ol>
<li><p>创建网络。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker network create todo-app</span><br></pre></td></tr></table></figure></li>
<li><p>启动 MySQL 容器并将其连接到网络。您还将定义数据库将用于初始化数据库的一些环境变量。要了解有关 MySQL 环境变量的更多信息，请参阅MySQL Docker Hub 列表中的“环境变量”部分。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line"> --network todo-app --network-alias mysql \</span><br><span class="line"> -v todo-mysql-data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line"> -e MYSQL_DATABASE=todos \</span><br><span class="line"> mysql:8.0</span><br></pre></td></tr></table></figure>
<p> 在上面的命令中，您将看到该<code>--network-alias</code>标志。在后面的部分中，您将了解有关此标志的更多信息。</p>
</li>
</ol>
<blockquote>
<p>您会注意到上面命令中命名的卷todo-mysql-data安装在&#x2F;var&#x2F;lib&#x2F;mysql，这是 MySQL 存储其数据的位置。但是，您从未运行过docker volume create命令。Docker 识别出您想要使用命名卷并自动为您创建一个。</p>
</blockquote>
<ol start="3">
<li><p>要确认数据库已启动并正在运行，请连接到数据库并验证其是否已连接。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker exec -it &lt;mysql-container-id&gt; mysql -u root -p</span><br></pre></td></tr></table></figure>
<p> 当出现密码提示时，输入<code>secret</code>。在 MySQL <code>shell</code> 中，列出数据库并验证您是否看到该<code>todos</code>数据库。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>
<p> 您应该看到如下所示的输出：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| todos              |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>退出 MySQL <code>shell</code> 以返回到您计算机上的 <code>shell</code>。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> exit</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>连接mysql</strong></p>
<p>现在您知道 MySQL 已启动并正在运行，您可以使用它了。但是，你如何使用它呢？如果在同一网络上运行另一个容器，如何找到该容器？请记住，每个容器都有自己的 IP 地址。<br>为了回答上述问题并更好地理解容器网络，您将使用<code>nicolaka/netshoot</code>容器，它附带了许多可用于排除或调试网络问题的工具。</p>
<ol>
<li>使用 <code>nicolaka/netshoot</code> 镜像启动一个新容器。确保将其连接到同一网络。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -it --network todo-app nicolaka/netshoot</span><br></pre></td></tr></table></figure></li>
<li>在容器内，您将使用该<code>dig命</code>令，这是一个有用的 DNS 工具。您将查找主机名的 IP 地址<code>mysql</code>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig mysql</span><br></pre></td></tr></table></figure>
 您应该得到如下所示的输出。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.18.8 &lt;&lt;&gt;&gt; mysql</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32162</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;mysql.				IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">mysql.			600	IN	A	172.23.0.2</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.11#53(127.0.0.11)</span><br><span class="line">;; WHEN: Tue Oct 01 23:47:24 UTC 2019</span><br><span class="line">;; MSG SIZE  rcvd: 44</span><br></pre></td></tr></table></figure>
 在“答案部分”中，您将看到解析为的A记录 （您的 IP 地址很可能具有不同的值）。虽然通常不是有效的主机名，但 Docker 能够将其解析为具有该网络别名的容器的 IP 地址。请记住，您使用的是 较早的。<code>mysql 172.23.0.2 mysql --network-alias</code> 这意味着您的应用程序只需要连接到名为 的主机<code>mysql</code>，它就会与数据库通信。</li>
</ol>
<p><strong>使用 MySQL 运行您的应用程序</strong></p>
<p>todo 应用程序支持设置一些环境变量来指定 MySQL 连接设置。他们是：</p>
<ul>
<li>MYSQL_HOST- 正在运行的 MySQL 服务器的主机名</li>
<li>MYSQL_USER- 用于连接的用户名</li>
<li>MYSQL_PASSWORD- 用于连接的密码</li>
<li>MYSQL_DB- 连接后使用的数据库</li>
</ul>
<ol>
<li><p>指定上面的每个环境变量，并将容器连接到您的应用程序网络。<code>getting-started/app</code>运行此命令时请确保您位于该目录中。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -dp 127.0.0.1:3000:3000 \</span><br><span class="line">-w /app -v &quot;$(pwd):/app&quot; \</span><br><span class="line">--network todo-app \</span><br><span class="line">-e MYSQL_HOST=mysql \</span><br><span class="line">-e MYSQL_USER=root \</span><br><span class="line">-e MYSQL_PASSWORD=secret \</span><br><span class="line">-e MYSQL_DB=todos \</span><br><span class="line">node:18-alpine \</span><br><span class="line">sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>如果您查看容器 ( ) 的日志<code>docker logs -f &lt;container-id&gt;</code>，您应该会看到类似于以下内容的消息，这表明它正在使用 <code>mysql</code> 数据库。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodemon src/index.js</span><br><span class="line">[nodemon] 2.0.20</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching dir(s): *.*</span><br><span class="line">[nodemon] starting `node src/index.js`</span><br><span class="line">Connected to mysql db at host mysql</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure></li>
<li><p>在浏览器中打开应用程序，然后将一些项目添加到您的待办事项列表中。</p>
</li>
<li><p>连接到 <code>mysql</code> 数据库并证明项目正在写入数据库。请记住，密码是<code>secret</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker exec -it &lt;mysql-container-id&gt; mysql -p todos</span><br></pre></td></tr></table></figure>
<p> 在 mysql shell 中，运行以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from todo_items;</span><br><span class="line">+--------------------------------------+--------------------+-----------+</span><br><span class="line">| id                                   | name               | completed |</span><br><span class="line">+--------------------------------------+--------------------+-----------+</span><br><span class="line">| c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! |         0 |</span><br><span class="line">| 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome!        |         0 |</span><br><span class="line">+--------------------------------------+--------------------+-----------+</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="使用-Docker-Compose"><a href="#使用-Docker-Compose" class="headerlink" title="使用 Docker Compose"></a>使用 Docker Compose</h4><p>Docker Compose是一款旨在帮助定义和共享多容器应用程序的工具。使用 Compose，我们可以创建一个 YAML 文件来定义服务，并且使用单个命令就可以启动或拆除所有内容。</p>
<p>使用 Compose 的一大优势是您可以在文件中定义应用程序堆栈，将其保存在项目存储库的根目录中（现在是版本控制的），并轻松的让其他人为您的项目做出贡献。有人只需要克隆你的存储库并启动编写应用程序。</p>
<p><strong>安装 Docker Compose</strong></p>
<ol>
<li><p>更新包索引，并安装最新版本的 <code>Docker Compose</code>：</p>
<ul>
<li>对于 Ubuntu 和 Debian，运行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-compose-plugin</span><br></pre></td></tr></table></figure></li>
<li>对于基于 RPM 的发行版，运行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum update</span><br><span class="line">$ sudo yum install docker-compose-plugin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过检查版本来验证 Docker Compose 是否正确安装。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker compose version</span><br><span class="line">Docker Compose version vN.N.N</span><br></pre></td></tr></table></figure>
<p><strong>创建 Compose 文件</strong></p>
</li>
<li><p>在文件夹的根目录下<code>/getting-started/app</code>，创建一个名为<code>docker-compose.yml</code>.</p>
</li>
<li><p>在撰写文件中，我们首先定义要作为应用程序一部分运行的服务（或容器）列表。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br></pre></td></tr></table></figure>
<p><strong>定义应用服务</strong></p>
</li>
</ol>
<p>请记住，这是我们用来定义应用程序容器的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -dp 127.0.0.1:3000:3000 \</span><br><span class="line">  -w /app -v &quot;$(pwd):/app&quot; \</span><br><span class="line">  --network todo-app \</span><br><span class="line">  -e MYSQL_HOST=mysql \</span><br><span class="line">  -e MYSQL_USER=root \</span><br><span class="line">  -e MYSQL_PASSWORD=secret \</span><br><span class="line">  -e MYSQL_DB=todos \</span><br><span class="line">  node:18-alpine \</span><br><span class="line">  sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>首先，我们定义容器的服务入口和镜像。我们可以为该服务选择任何名称。该名称将自动成为网络别名，这在定义我们的 MySQL 服务时非常有用。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        image: node:18-alpine</span><br></pre></td></tr></table></figure></li>
<li><p>通常，您会看到<code>command</code>接近<code>image</code>定义的内容，但没有顺序要求。那么，让我们继续将其移至我们的文件中。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        image: node:18-alpine</span><br><span class="line">        command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>让我们通过定义服务来迁移<code>-p 127.0.0.1:3000:3000</code>命令的一部分。<code>ports</code>我们将在这里使用 短语法，但也有更详细的 长语法可用。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        image: node:18-alpine</span><br><span class="line">        command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br><span class="line">        ports:</span><br><span class="line">            - 127.0.0.1:3000:3000</span><br></pre></td></tr></table></figure></li>
<li><p>接下来，我们将使用和定义迁移工作目录 ( <code>-w /app</code>) 和卷映射 ( ) 。<code>Volumes</code> 也有短语法和长语法。<code>-v &quot;$(pwd):/app&quot;working_dirvolumes</code></p>
<p> Docker Compose 卷定义的优点之一是我们可以使用当前目录的相对路径。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        image: node:18-alpine</span><br><span class="line">        command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br><span class="line">        ports:</span><br><span class="line">            - 127.0.0.1:3000:3000</span><br><span class="line">        working_dir: /app</span><br><span class="line">        volumes:</span><br><span class="line">            - ./:/app</span><br></pre></td></tr></table></figure></li>
<li><p>我们需要使用<code>environment</code>密钥迁移环境变量定义。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        image: node:18-alpine</span><br><span class="line">        command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br><span class="line">        ports:</span><br><span class="line">            - 127.0.0.1:3000:3000</span><br><span class="line">        working_dir: /app</span><br><span class="line">        volumes:</span><br><span class="line">            - ./:/app</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_HOST: mysql</span><br><span class="line">            MYSQL_USER: root</span><br><span class="line">            MYSQL_PASSWORD: secret</span><br><span class="line">            MYSQL_DB: todos</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>定义 MySQL 服务</strong></p>
<p>现在，是时候定义 MySQL 服务了。我们用于该容器的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --network todo-app --network-alias mysql \</span><br><span class="line">  -v todo-mysql-data:/var/lib/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line">  -e MYSQL_DATABASE=todos \</span><br><span class="line">  mysql:8.0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>我们将首先定义新服务并为其命名，<code>mysql</code>以便它自动获取网络别名。我们将继续指定要使用的镜像。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        # The app service definition</span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:8.0</span><br></pre></td></tr></table></figure></li>
<li><p>接下来，我们将定义卷映射。当我们使用 运行容器时<code>docker run</code>，会自动创建命名卷。但是，使用 Compose 运行时不会发生这种情况。我们需要在顶级 <code>volumes:</code>部分定义卷，然后在服务配置中指定挂载点。只需仅提供卷名称，即可使用默认选项。不过还有更多的选择。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        # The app service definition</span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:8.0</span><br><span class="line">    volumes:</span><br><span class="line">        - todo-mysql-data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">    todo-mysql-data:</span><br></pre></td></tr></table></figure></li>
<li><p>最后，我们只需要指定环境变量即可。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        # The app service definition</span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:8.0</span><br><span class="line">    volumes:</span><br><span class="line">        - todo-mysql-data:/var/lib/mysql</span><br><span class="line">    environment:</span><br><span class="line">        MYSQL_ROOT_PASSWORD: secret</span><br><span class="line">        MYSQL_DATABASE: todos</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">    todo-mysql-data:</span><br></pre></td></tr></table></figure></li>
<li><p>此时，我们的完整内容<code>docker-compose.yml</code>应该是这样的：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    app:</span><br><span class="line">        image: node:18-alpine</span><br><span class="line">        command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br><span class="line">        ports:</span><br><span class="line">            - 127.0.0.1:3000:3000</span><br><span class="line">        working_dir: /app</span><br><span class="line">        volumes:</span><br><span class="line">            - ./:/app</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_HOST: mysql</span><br><span class="line">            MYSQL_USER: root</span><br><span class="line">            MYSQL_PASSWORD: secret</span><br><span class="line">            MYSQL_DB: todos</span><br><span class="line"></span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:8.0</span><br><span class="line">        volumes:</span><br><span class="line">            - todo-mysql-data:/var/lib/mysql</span><br><span class="line">        environment:</span><br><span class="line">        MYSQL_ROOT_PASSWORD: secret</span><br><span class="line">        MYSQL_DATABASE: todos</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">    todo-mysql-data:</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>运行应用程序</strong></p>
<p>现在我们有了<code>docker-compose.yml</code>文件，我们可以启动它了！</p>
<ol>
<li><p>确保应用程序&#x2F;数据库的其他副本没有首先运行（<code>docker ps</code>和<code>docker rm -f &lt;ids&gt;</code>）。</p>
</li>
<li><p>使用命令启动应用程序<code>docker compose up</code>。我们将添加<code>-d</code>标志以在后台运行所有内容。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker compose up -d</span><br></pre></td></tr></table></figure>
<p> 当我们运行它时，我们应该看到如下输出：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating network &quot;app_default&quot; with the default driver</span><br><span class="line">Creating volume &quot;app_todo-mysql-data&quot; with default driver</span><br><span class="line">Creating app_app_1   ... done</span><br><span class="line">Creating app_mysql_1 ... done</span><br></pre></td></tr></table></figure>
<p> 您会注意到卷和网络都已创建！默认情况下，<code>Docker Compose`` 会自动创建一个专门用于应用程序堆栈的网络（这就是我们没有在 </code>compose&#96; 文件中定义网络的原因）。</p>
</li>
<li><p>让我们使用命令查看日志<code>docker compose logs -f</code>。您将看到每个服务的日志交织到单个流中。当您想要观察与计时相关的问题时，这非常有用。该<code>-f</code>标志“跟随”日志，因此会在生成时为您提供实时输出。</p>
<p> 如果您已经运行该命令，您将看到如下所示的输出：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_1  | 2019-10-03T03:07:16.083639Z 0 [Note] mysqld: ready for connections.</span><br><span class="line">mysql_1  | Version: &#x27;8.0.31&#x27;  socket: &#x27;/var/run/mysqld/mysqld.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br><span class="line">app_1    | Connected to mysql db at host mysql</span><br><span class="line">app_1    | Listening on port 3000</span><br></pre></td></tr></table></figure>
<p> 服务名称显示在行的开头（通常是彩色的）以帮助区分消息。如果要查看特定服务的日志，可以将服务名称添加到日志命令的末尾（例如 <code>docker compose logs -f app</code>）。</p>
</li>
<li><p>此时，您应该能够打开应用程序并看到它正在运行。</p>
</li>
</ol>
<p>当您准备好将其全部卸载时，只需运行<code>docker compose down</code>整个应用程序或点击 Docker 仪表板上的垃圾桶即可。容器将停止，网络将被删除。一旦卸载，您可以切换到另一个项目，运行<code>docker compose up</code>并准备好为该项目做出贡献！真的没有比这更简单的了！</p>
<blockquote>
<p>默认情况下，运行时不会删除 compose 文件中的命名卷docker compose down。如果要删除卷，则需要添加该–volumes标志。</p>
</blockquote>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p><strong>镜像分层</strong></p>
<p>您知道您可以查看镜像的组成部分吗？使用该<code>docker image history</code> 命令，您可以看到用于在图像中创建每个镜像层的命令。</p>
<ol>
<li><p>使用该<code>docker image history</code>命令查看<code>getting-started</code>您在本教程前面创建的图像中的镜像层。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker image history getting-started</span><br></pre></td></tr></table></figure>
<p> 您应该得到如下所示的输出（日期&#x2F;ID 可能不同）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">a78a40cbf866        18 seconds ago      /bin/sh -c #(nop)  CMD [&quot;node&quot; &quot;src/index.j…    0B                  </span><br><span class="line">f1d1808565d6        19 seconds ago      /bin/sh -c yarn install --production            85.4MB              </span><br><span class="line">a2c054d14948        36 seconds ago      /bin/sh -c #(nop) COPY dir:5dc710ad87c789593…   198kB               </span><br><span class="line">9577ae713121        37 seconds ago      /bin/sh -c #(nop) WORKDIR /app                  0B                  </span><br><span class="line">b95baba1cfdb        13 days ago         /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;docker-entry…   0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B                </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c apk add --no-cache --virtual .bui…   5.35MB              </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.21.1      0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c addgroup -g 1000 node     &amp;&amp; addu…   74.3MB              </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV NODE_VERSION=12.14.1     0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop) ADD file:e69d441d729412d24…   5.59MB</span><br></pre></td></tr></table></figure>
<p> 每条线代表镜像中的一个层。这里的显示显示底部位于底部，最新层位于顶部。使用它，您还可以快速查看每层的大小，帮助诊断大镜像。</p>
</li>
<li><p>您会注意到有几行被截断。如果添加该<code>--no-trunc</code>标志，您将获得完整的输出.</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker image history --no-trunc getting-started</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>层缓存</strong></p>
<p>现在您已经了解了分层的实际效果，接下来需要学习一个重要的课程，以帮助减少容器映像的构建时间。一旦层发生变化，所有下游层也必须重新创建.</p>
<p>让我们再看一次我们使用的 Dockerfile…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line">FROM node:18-alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN yarn install --production</span><br><span class="line">CMD [&quot;node&quot;, &quot;src/index.js&quot;]</span><br></pre></td></tr></table></figure>
<p>回到镜像历史输出，我们看到 Dockerfile 中的每个命令都成为镜像中的一个新层。您可能还记得，当我们对图像进行更改时，必须重新安装纱线依赖项。有没有办法来解决这个问题？每次构建时都传递相同的依赖项没有多大意义，对吧？</p>
<p>为了解决这个问题，我们需要重构 Dockerfile 以帮助支持依赖项的缓存。对于基于节点的应用程序，这些依赖项在文件中定义<code>package.json</code>。那么，如果我们首先只复制该文件，安装依赖项，然后复制其他所有内容会怎么样？然后，如果<code>package.json</code> ？</p>
<ol>
<li><p>更新 Dockerfile 以首先复制<code>package.json</code>，安装依赖项，然后复制其他所有内容。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line">FROM node:18-alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY package.json yarn.lock ./</span><br><span class="line">RUN yarn install --production</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;node&quot;, &quot;src/index.js&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p><code>.dockerignore</code>在与 Dockerfile 相同的文件夹中创建一个包含以下内容的文件。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure></li>
<li><p><code>.dockerignore</code>文件是有选择地仅复制图像相关文件的简单方法。您可以在此处阅读有关此内容的更多信息 。在这种情况下，<code>node_modules</code>应在第二步中省略该文件夹<code>COPY</code>，否则可能会覆盖该RUN步骤中命令创建的文件。</p>
</li>
<li><p>使用 构建新图像<code>docker build</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t getting-started .</span><br></pre></td></tr></table></figure>
<p> 你应该看到这样的输出……</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] Building 16.1s (10/10) FINISHED</span><br><span class="line">=&gt; [internal] load build definition from Dockerfile</span><br><span class="line">=&gt; =&gt; transferring dockerfile: 175B</span><br><span class="line">=&gt; [internal] load .dockerignore</span><br><span class="line">=&gt; =&gt; transferring context: 2B</span><br><span class="line">=&gt; [internal] load metadata for docker.io/library/node:18-alpine</span><br><span class="line">=&gt; [internal] load build context</span><br><span class="line">=&gt; =&gt; transferring context: 53.37MB</span><br><span class="line">=&gt; [1/5] FROM docker.io/library/node:18-alpine</span><br><span class="line">=&gt; CACHED [2/5] WORKDIR /app</span><br><span class="line">=&gt; [3/5] COPY package.json yarn.lock ./</span><br><span class="line">=&gt; [4/5] RUN yarn install --production</span><br><span class="line">=&gt; [5/5] COPY . .</span><br><span class="line">=&gt; exporting to image</span><br><span class="line">=&gt; =&gt; exporting layers</span><br><span class="line">=&gt; =&gt; writing image     sha256:d6f819013566c54c50124ed94d5e66c452325327217f4f04399b45f94e37d25</span><br><span class="line">=&gt; =&gt; naming to docker.io/library/getting-started</span><br></pre></td></tr></table></figure>
<p> 您会看到所有镜像层都已重建。非常好，因为我们对 Dockerfile 做了很多修改。</p>
</li>
<li><p>现在，对文件进行更改<code>src/static/index.html</code>（例如将其更改<code>&lt;title&gt;</code>为“The Awesome Todo App”）。</p>
</li>
<li><p>现在再次使用构建 Docker 映像<code>docker build -t getting-started .</code>。这次，您的输出应该看起来有点不同。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] Building 1.2s (10/10) FINISHED</span><br><span class="line">=&gt; [internal] load build definition from Dockerfile</span><br><span class="line">=&gt; =&gt; transferring dockerfile: 37B</span><br><span class="line">=&gt; [internal] load .dockerignore</span><br><span class="line">=&gt; =&gt; transferring context: 2B</span><br><span class="line">=&gt; [internal] load metadata for docker.io/library/node:18-alpine</span><br><span class="line">=&gt; [internal] load build context</span><br><span class="line">=&gt; =&gt; transferring context: 450.43kB</span><br><span class="line">=&gt; [1/5] FROM docker.io/library/node:18-alpine</span><br><span class="line">=&gt; CACHED [2/5] WORKDIR /app</span><br><span class="line">=&gt; CACHED [3/5] COPY package.json yarn.lock ./</span><br><span class="line">=&gt; CACHED [4/5] RUN yarn install --production</span><br><span class="line">=&gt; [5/5] COPY . .</span><br><span class="line">=&gt; exporting to image</span><br><span class="line">=&gt; =&gt; exporting layers</span><br><span class="line">=&gt; =&gt; writing image     sha256:91790c87bcb096a83c2bd4eb512bc8b134c757cda0bdee4038187f98148e2eda</span><br><span class="line">=&gt; =&gt; naming to docker.io/library/getting-started</span><br></pre></td></tr></table></figure>
<p> 首先，您应该注意到构建速度快得多！而且，您会看到有几个步骤正在使用以前缓存的图层。我们正在使用构建缓存。推送和拉取此映像及其更新也会快得多。</p>
</li>
</ol>
<p><strong>多阶段构建</strong></p>
<p>虽然我们不会在本教程中深入探讨它，但多阶段构建是一个非常强大的工具，可以帮助使用多个阶段来创建镜像。他们有几个优点：</p>
<ul>
<li>将构建时依赖项与运行时依赖项分开</li>
<li>通过仅传送应用程序需要运行的内容来减小整体镜像大小</li>
</ul>
<p>Maven&#x2F;Tomcat 示例</p>
<p>构建基于 Java 的应用程序时，需要 <code>JDK</code> 将源代码编译为 Java 字节码。但是，生产中不需要该 JDK。此外，您可能会使用 <code>Maven</code> 或 <code>Gradle</code> 等工具来帮助构建应用程序。我们的最终图像中也不需要这些。多阶段构建有帮助。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line">FROM maven AS build</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN mvn package</span><br><span class="line"></span><br><span class="line">FROM tomcat</span><br><span class="line">COPY --from=build /app/target/file.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure>
<p>在此示例中，我们使用一个阶段（称为<code>build</code>）来使用 Maven 执行实际的 Java 构建。在第二阶段（从 开始<code>FROM tomcat</code>），我们从阶段复制文件<code>build</code>。最终图像只是创建的最后一个阶段（可以使用<code>--target</code>标志覆盖）。</p>
<p>React 示例</p>
<p>在构建 React 应用程序时，我们需要一个 Node 环境来将 <code>JS</code> 代码（通常是 <code>JSX</code>）、<code>SASS</code> 样式表等编译为静态 <code>HTML、JS</code> 和 <code>CSS</code>。如果我们不进行服务器端渲染，我们甚至不需要 Node 环境来进行生产构建。为什么不在静态 <code>nginx</code> 容器中传送静态资源？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line">FROM node:18 AS build</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY package* yarn.lock ./</span><br><span class="line">RUN yarn install</span><br><span class="line">COPY public ./public</span><br><span class="line">COPY src ./src</span><br><span class="line">RUN yarn run build</span><br><span class="line"></span><br><span class="line">FROM nginx:alpine</span><br><span class="line">COPY --from=build /app/build /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用<code>node:18</code>镜像来执行构建（最大化层缓存），然后将输出复制到 <code>nginx</code> 容器中。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【混沌工程】介绍</title>
    <url>/2023/08/07/Cloud-Native/%E3%80%90%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B%E3%80%91%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="混沌工程（Chaos-Engineering）"><a href="#混沌工程（Chaos-Engineering）" class="headerlink" title="混沌工程（Chaos Engineering）"></a>混沌工程（Chaos Engineering）</h4><p>“<code>If something hurts, do it more often.</code>“</p>
<h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ul>
<li><code>Build a Hypothesis around Steaday State Behavior</code>.</li>
<li><code>Vary Real-World events</code>.</li>
<li><code>Run experiment in Production</code>.</li>
<li><code>Automate Experiments to Run Continuously</code>.</li>
<li><code>Minimize Blast Radius</code>.</li>
</ul>
<p>[<a href="http://principlesofchaos.org]">http://principlesofchaos.org]</a></p>
<h5 id="一些开源项目"><a href="#一些开源项目" class="headerlink" title="一些开源项目"></a>一些开源项目</h5><p>[<a href="https://github.com/Netflix/chaosmonkey]">https://github.com/Netflix/chaosmonkey]</a><br>[<a href="https://github.com/easierway/service_decorators/blob/master/README.md]">https://github.com/easierway/service_decorators/blob/master/README.md]</a><br>[<a href="https://martinfowler.com/articles/lmax.html]">https://martinfowler.com/articles/lmax.html]</a></p>
]]></content>
      <categories>
        <category>Chaos Engineering</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>chaos engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2022/05/02/Design-Patterns/OOP/</url>
    <content><![CDATA[<p>几年前在面试的时候，还经常被面试官问 <code>OOP</code> 的四个特征是什么以及他们背后代表的意思，几年过去了，除了不支持面向对象的语言之外，面向对象编程思想已经深入到了每个开发者的灵魂，只是做的好与不好罢了。</p>
<p>面向对象编程中有两个非常基础的概念，类和对象，面向对象编程是一种编程范式或者说编程风格，它以类或者对象作为组织代码的基本单元，并将封装，继承，抽象，多态作为代码设计和实现的基石，不像面向过程编程语言，以函数为程序中的基本单元。</p>
<p>面向对象编程只是一种编程思想，可以用不同的语言进行实现，即使我们用面向对象语言，也完全可以写出面向过程风格的代码。至于什么是面向对象编程语言，并没有严格的定义，只要它能实现 <code>OOP</code> 的四大特性，那它就是面向对象编程语言，例如：<code>Rust</code>，<code>C++</code>，<code>GO</code>，<code>Java</code>，<code>Python</code> 以及 <code>PHP</code> 等，</p>
<p>面向对象编程的前提是面向对象分析（<code>OOA</code>）和面向对象设计（<code>OOD</code>），这样才能进行面向对象编程（<code>OOP</code>），具备完整的面向对象编程的思维。面向对象分析和设计两个阶段的产物应该是类的设计，包括应用程序应该被分为哪些类，每个类该有哪些属性和方法，类与类之间如何交互等等，它们比较贴近代码，非常具体，容易落地实现。</p>
<p>在 <code>OOA</code> 和 <code>OOD</code> 的过程中，我们会经常用到 <code>UML（Unified Model Language）</code> 工具辅助我们进行工作。<code>UML</code> 是一种比较复杂的工具，除了包括我们常见的类图，还有用例图，顺序图，活动图，状态图，组件图等，即使是类图，类之间的关系就有泛化，实现，关联，聚合，组合以及依赖等，熟练掌握难度比较大，即便你掌握了，你同事不一定掌握，沟通成本依然很高，大多时候，我们会用草图实现我们的设计过程。</p>
<span id="more"></span>

<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装，也叫做信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。下面是一个钱包的 <code>Java</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> balanceLastModifiedTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wallet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">        <span class="built_in">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.id; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCreateTime</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.createTime; &#125;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.balance; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBalanceLastModifiedTime</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.balanceLastModifiedTime;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseBalance</span><span class="params">(BigDecimal increasedAmount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (increasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(increasedAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseBalance</span><span class="params">(BigDecimal decreasedAmount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decreasedAmount.compareTo(<span class="built_in">this</span>.balance) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(decreasedAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们可以发现，<code>Wallet</code>类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，<code>id</code> 表示钱包的唯一编号，<code>createTime</code> 表示钱包创建的时间，<code>balance</code> 表示钱包中的余额，<code>balanceLastModifiedTime</code> 表示上次钱包余额变更的时间。</p>
<p>我们根据封装的目的，对钱包的这四个属性的访问方式进行了限制，调用者只允许通过上面六个方法来访问或者修改钱包里的数据。之所以这样设计，是因为从业务的角度来说，<code>id</code>、<code>createTime</code>在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在<code>Wallet</code>类中，暴露<code>id</code>、<code>createTime</code>这两个属性的任何修改方法，比如<code>set</code>方法。而且，这两个属性的初始化设置，对于<code>Wallet</code>类的调用者来说，也应该是透明的，所以，我们在<code>Wallet</code>类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。</p>
<p>封装意味着我们需要控制类的灵活性，仅通过暴露必要的操作，提高类的易用性。</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>封装的目的是隐藏数据和信息，抽象的目的是隐藏方法实现，让调用这只需知道类提供了哪些能力，而不关注其具体实现。在不同的语言中，对于抽象有不同的实现，例如，<code>Go</code> 和 <code>Java</code> 中的接口，<code>Rust</code> 中的 <code>Trait</code> 或者其他语言中的抽象类。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Picture <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PictureStorager <span class="keyword">interface</span> &#123;</span><br><span class="line">	SavePicture(picture *Picture)</span><br><span class="line">	GetPicture(id <span class="type">string</span>) *Picture</span><br><span class="line">	DeletePicture(id <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemoryStorage <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MemoryStorage)</span></span> SavePicture(picture *Picture) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MemoryStorage)</span></span> GetPicture(id <span class="type">string</span>) *Picture &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Picture&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MemoryStorage)</span></span> DeletePicture(id <span class="type">string</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的这段代码中，对于调用者而言，在使用图片存储功能的时候，只需要了解 <code>PictureStorager</code> 这个接口暴露了哪些方法，而不用去查看具体类对应方法的实现逻辑。</p>
<p>抽象作为一个非常宽泛的设计思想，在代码设计中，起到了非常重要的指导作用，很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则，代码解耦等。我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如<code>getAliyunPictureUrl()</code>就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作<code>getPictureUrl()</code>，那即便内部存储方式修改了，我们也不需要修改命名。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。</p>
<p>集成呈现的是一种 <code>is-a</code> 关系，我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。例如，我们代码中有一个猫类，有一个哺乳动物类，猫属于哺乳动物，它们之间就属于集成关系。</p>
<p>从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p>
<p>为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如<code>Java</code>使用<code>extends</code>关键字来实现继承，<code>C++</code>使用冒号（<code>class B : public A</code>），<code>Python</code>使用<code>parentheses ()</code>，<code>Ruby</code>使用<code>&lt;</code>。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> DEFAULT_CAPACITY;</span><br><span class="line">  <span class="keyword">protected</span> Integer[] elements = <span class="keyword">new</span> <span class="title class_">Integer</span>[DEFAULT_CAPACITY];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.size; &#125;</span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> elements[index];&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    elements[size++] = e;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...如果数组满了就扩容...代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = size-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) &#123; <span class="comment">//保证数组中的数据有序</span></span><br><span class="line">      <span class="keyword">if</span> (elements[i] &gt; e) &#123;</span><br><span class="line">        elements[i+<span class="number">1</span>] = elements[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[i+<span class="number">1</span>] = e;</span><br><span class="line">    ++size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray dynamicArray)</span> &#123;</span><br><span class="line">    dynamicArray.add(<span class="number">5</span>);</span><br><span class="line">    dynamicArray.add(<span class="number">1</span>);</span><br><span class="line">    dynamicArray.add(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;</span><br><span class="line">      System.out.println(dynamicArray.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">DynamicArray</span> <span class="variable">dynamicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortedDynamicArray</span>();  <span class="comment">// 使用子类替换父类</span></span><br><span class="line">    test(dynamicArray); <span class="comment">// 打印结果：1、3、5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p>
<ol>
<li>编程语言要支持父类对象可以引用子类对象，也就是可以将<code>SortedDynamicArray</code>传递给<code>DynamicArray</code>；</li>
<li>编程语言要支持继承，也就是<code>SortedDynamicArray</code>继承了<code>DynamicArray</code>，才能将<code>SortedDyamicArray</code>传递给<code>DynamicArray</code>；</li>
<li>编程语言要支持子类可以重写（<code>override</code>）父类中的方法，也就是<code>SortedDyamicArray</code>重写了<code>DynamicArray</code>中的<code>add()</code>方法；</li>
</ol>
<p>对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用<code>duck-typing</code>语法。不过，并不是每种编程语言都支持接口类或者<code>duck-typing</code>这两种语法机制，比如<code>C++</code>就不支持接口类语法，而<code>duck-typing</code>只有一些动态语言才支持，比如<code>Python</code>、<code>JavaScript</code>等。</p>
<h5 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">arrayIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    print(arrayIterator);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">linkedListIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    print(linkedListIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>Iterator</code>是一个接口类，定义了一个可以遍历集合数据的迭代器。<code>Array</code>和<code>LinkedList</code>都实现了接口类<code>Iterator</code>。我们通过传递不同类型的实现类（<code>Array</code>、<code>LinkedList</code>）到<code>print(Iterator iterator)</code>函数中，支持动态的调用不同的<code>next()</code>、<code>hasNext()</code>实现。</p>
<h5 id="duck-typing-实现多态"><a href="#duck-typing-实现多态" class="headerlink" title="duck-typing 实现多态"></a>duck-typing 实现多态</h5><p><code>duck-typing</code> 实现多态的方式非常灵活，即使两个没有继承关系，也没有接口实现关系，只要有相同的方法就能表示它们有相同的特征。也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的<code>duck-typing</code>，是一些动态语言所特有的语法机制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(“I write a log into file.”)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(“I insert data into db. ”)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">recorder</span>):</span><br><span class="line">    recorder.record()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    logger = Logger()</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p>
<p>相比之下，面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。面向过程编程语言最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。</p>
<p>从代码示例中可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</p>
<div class="tabs" id="面向对象和面向过程"><ul class="nav-tabs"><li class="tab active"><a href="#面向对象和面向过程-1">面向过程</a></li><li class="tab"><a href="#面向对象和面向过程-2">面向对象</a></li></ul><div class="tab-content"><div class="tab-pane active" id="面向对象和面向过程-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> User <span class="title function_">parse_to_user</span><span class="params">(<span class="type">char</span>* text)</span> &#123;</span><br><span class="line">  <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成结构体struct User</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">format_to_text</span><span class="params">(<span class="keyword">struct</span> User user)</span> &#123;</span><br><span class="line">  <span class="comment">// 将结构体struct User格式化成文本（&quot;小王\t28\t男&quot;）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_users_by_age</span><span class="params">(<span class="keyword">struct</span> User users[])</span> &#123;</span><br><span class="line">  <span class="comment">// 按照年龄从小到大排序users</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="面向对象和面向过程-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String gender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">praseFrom</span><span class="params">(String userInfoText)</span> &#123;</span><br><span class="line">    <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成类User</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">formatToText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将类User格式化成文本（&quot;小王\t28\t男&quot;）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。</p>
<p>相比起面向过程语言，面向对象语言有以下优势：</p>
<ol>
<li><p>思维方式上的变更，在面向过程语言的编程中，我们首先考虑的是流程的划分，将整个程序要实现的功能分成几大模块，模块内的流程该如何划分。面向对象编程是以类为思考对象，在进行面向对象编程的时候，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰；</p>
</li>
<li><p>面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。类就是一种非常好的组织些函数和数据结构的方式，是一种将代码模块化的有效手段；</p>
</li>
<li><p>代码更加容易维护，封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性；</p>
</li>
<li><p>代码更加容易扩展，借助面向对象的抽象特性，我们隐藏函数的具体实现，在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性；</p>
</li>
<li><p>代码更容易复用，继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性；</p>
</li>
<li><p>基于多态特性，在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性；</p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有几个在面向对象编程中常犯的错误，会导致最终写出的代码跟面向过程没什么却别。</p>
<ol>
<li><p>不要滥用 <code>getter</code> 和 <code>setter</code> 方法，面向对象语言提供了封装特性，可以将一些数据进行隐藏，不对外公开，为的是对重要数据的保护。但是如果我们对所有内部状态都提供一个 <code>getter</code> 和 <code>setter</code> 方法，相当于公开属性了。例如：</p>
 <div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> itemsCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> totalPrice;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemsCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.itemsCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemsCount</span><span class="params">(<span class="type">int</span> itemsCount)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.itemsCount = itemsCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.totalPrice;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPrice</span><span class="params">(<span class="type">double</span> totalPrice)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.totalPrice = totalPrice;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(ShoppingCartItem item)</span> &#123;</span><br><span class="line">    items.add(item);</span><br><span class="line">    itemsCount++;</span><br><span class="line">    totalPrice += item.getPrice();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...省略其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>itemsCount</code>和<code>totalPrice</code>。虽然我们将它们定义成<code>private</code>私有属性，但是提供了<code>public</code>的<code>getter</code>、<code>setter</code>方法，这就跟将这两个属性定义为<code>public</code>公有属性，没有什么两样了。外部可以通过<code>setter</code>方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用<code>setter</code>方法，来重新设置<code>itemsCount</code>、<code>totalPrice</code>属性的值，这也会导致其跟<code>items</code>属性的值不一致。</p>
<p>面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的<code>setter</code>方法，明显违反了面向对象的封装特性。</p>
<p>对于<code>items</code>这个属性，我们定义了它的<code>getter</code>方法和<code>addItem()</code>方法，并没有定义它的<code>setter</code>方法。这样的设计貌似看起来没有什么问题，但实际上并不是。对于<code>itemsCount</code>和<code>totalPrice</code>这两个属性来说，定义一个<code>public</code>的<code>getter</code>方法，确实无伤大雅，毕竟<code>getter</code>方法不会修改数据。但是，对于<code>items</code>属性就不一样了，这是因为<code>items</code>属性的<code>getter</code>方法，返回的是一个<code>List</code>集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改<code>items</code>中的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppCart</span>();</span><br><span class="line">...</span><br><span class="line">cart.getItems().clear(); <span class="comment">// 清空购物车</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要滥用全局变量和全局方法。在使用<code>C</code>语言这样的面向过程语言开发时，应该随处可见全局变量和全局方法。在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量是归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 <code>Constants</code> 类中，静态方法一般用来操作静态变量或者外部数据。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。当然不能说面向过程风格就不好，有时候一些必要的 <code>Utils</code> 类（没有自己的属性），定义了一大部分静态方法处理公共数据能极大提高我们的开发效率。</p>
</li>
<li><p>不要定义数据和方法分离的类。不过话虽这么说，干<code>WEB</code>的程序员应该都知道，前后端分离的项目一般被分为：<code>Controller</code>层、<code>Service</code>层、<code>Repository</code>层，<code>Controller</code>层负责暴露接口给前端调用，<code>Service</code>层负责核心业务逻辑，<code>Repository</code>层负责数据读写。而在每一层中，我们又会定义相应的<code>VO（View Object）</code>、<code>BO（Business Object）</code>、<code>Entity</code>。一般情况下，<code>VO</code>、<code>BO</code>、<code>Entity</code>中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的<code>Controller</code>类、<code>Service</code>类、<code>Repository</code>类中。这就是典型的面向过程的编程风格。</p>
</li>
</ol>
<h3 id="接口、抽象类"><a href="#接口、抽象类" class="headerlink" title="接口、抽象类"></a>接口、抽象类</h3><p>不同的编程语言对接口和抽象类的定义可能有些区别，但是大多数面向对象语言都支持接口。抽象类有以下特点：</p>
<ul>
<li>抽象类不允许被实例化，只能被继承；</li>
<li>抽象类可以包含属性和方法，方法既可以包含代码实现，也可以不包含代码实现，不包含代码实现的方法叫作抽象方法；</li>
<li>子类继承抽象类，必须实现抽象类中的所有抽象方法；</li>
</ul>
<p>相比抽象类，接口简单很多：</p>
<ul>
<li>接口不能包含属性（也就是成员变量）；</li>
<li>接口只能声明方法，方法不能包含代码实现；</li>
<li>类实现接口的时候，必须实现接口中声明的所有方法；</li>
</ul>
<p>抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码，结合了抽象和继承的优点。</p>
<p>如果我们要表示一种<code>is-a</code>的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种<code>has-a</code>关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p>
<p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p>
<h3 id="基于接口编程"><a href="#基于接口编程" class="headerlink" title="基于接口编程"></a>基于接口编程</h3><p>基于接口而非实现编程这条原则的另一个表述方式，是基于抽象而非实现编程。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<p>举个例子，假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的<code>AliyunImageStore</code>类，供整个系统来使用。具体的代码实现如下所示：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> &#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">    <span class="comment">// ...创建bucket代码逻辑...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span> &#123;</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span> &#123;</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;ai_images_bucket&quot;</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    <span class="type">AliyunImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliyunImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> imageStore.generateAccessToken();</span><br><span class="line">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>整个上传流程包含三个步骤：创建<code>bucket</code>（你可以简单理解为存储目录）、生成<code>access token</code>访问凭证、携带<code>access token</code>上传图片到指定的<code>bucket</code>中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p>
<p>但是，如果随着需求的变化，我们要将图片上传到私有云，所以我们可能会实现一个 <code>PrivateImageStore</code> 类，并且将原来的 <code>AliyunImageStore</code> 替换，这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说细节是魔鬼。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的魔鬼细节：</p>
<ul>
<li><p><code>AliyunImageStore</code>类中有些函数命名暴露了实现细节，比如，<code>uploadToAliyun()</code>和<code>downloadFromAliyun()</code>。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到<code>PrivateImageStore</code>类中，显然是不合适的；如果我们在新类中重新命名<code>uploadToAliyun()</code>、<code>downloadFromAliyun()</code>这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大；</p>
</li>
<li><p>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产<code>access token</code>，而私有云不需要<code>access token</code>。一方面，<code>AliyunImageStore</code>中定义的<code>generateAccessToken()</code>方法不能照抄到<code>PrivateImageStore</code>中；另一方面，我们在使用<code>AliyunImageStore</code>上传、下载图片的时候，代码中用到了<code>generateAccessToken()</code>方法，如果要改为私有云的上传下载流程，这些代码都需要做调整；</p>
</li>
</ul>
<p>解决这个问题的根本方法就是，在编写代码的时候，要遵从基于接口而非实现编程的原则，具体来讲，我们需要做到下面这<code>3</code>点：</p>
<ol>
<li>函数的命名不能暴露任何实现细节。比如，前面提到的<code>uploadToAliyun()</code>就不符合要求，应该改为去掉<code>aliyun</code>这样的字眼，改为更加抽象的命名方式，比如：<code>upload()</code>；</li>
<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用；</li>
<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程；</li>
</ol>
<p>重构之后的代码如下：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">  String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span>;</span><br><span class="line">  Image <span class="title function_">download</span><span class="params">(String url)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken();</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片在阿里云上的地址(url)...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken();</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>  &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="comment">//...上传图片到私有云...</span></span><br><span class="line">    <span class="comment">//...返回图片的url...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="comment">//...从私有云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;ai_images_bucket&quot;</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...;<span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>基于接口而非实现编程，并不是说需要给每个实现类都定义对应的接口，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。</p>
<p>至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p>
<p>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p>
<p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p>
<p>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</p>
<h3 id="组合或许优于继承"><a href="#组合或许优于继承" class="headerlink" title="组合或许优于继承"></a>组合或许优于继承</h3><p>继承是面向对象的四大特性之一，用来表示类之间的 <code>is-a</code> 关系，可以解决代码复用的问题，但是如果继承层次过深，过复杂，继承了不必要的功能，也会影响到代码的可维护性。</p>
<p>举个例子，我们如果要写一个关于鸟的类，首先定义一个 <code>AbsctractBird</code>，具体的麻雀，鸽子，乌鸦都会继承自这个类，那么我们能否在这个抽象类中定义一个 <code>fly()</code> 方法？当然不能，因为还有不会飞的鸟，比如说鸵鸟。如果鸵鸟类继承自 <code>AbsctractBird</code>，鸵鸟就能飞了，不符合事实。有人可能说，我们重写 <code>fly()</code> 让它抛出异常岂不是就可以了，可以是可以，但是不够优雅：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsctractBird</span> &#123;</span><br><span class="line">  <span class="comment">// ... 省略其他方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">AbsctractBird</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnSupportedMethodException</span>(<span class="string">&quot;I cant&#x27;t fly&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而且，不会飞的鸟有很多，还有企鹅，我们都需要重写 <code>fly()</code> 方法，抛出异常。到这里，支持继承的一方可能还会提出，可将鸟类分成能飞的鸟（<code>AbsctractFlyableBird</code>），和不能飞的鸟（<code>AbsctractUnFlyableBird</code>），它们都继承自 <code>AbsctractBird</code>，那么再实现具体类，这个时候继承深度已经达到三层了。如果再要区分能不能下蛋，能不能叫，我们就得设计能飞能下蛋能叫的鸟这种抽象类，继承爆炸：</p>
<img data-src="/2022/05/02/Design-Patterns/OOP/%E7%BB%A7%E6%89%BF%E7%88%86%E7%82%B8.png" class="">

<p>如何使用组合来优化这种继承爆炸的问题呢？我们可以将飞，叫，下蛋定义为一种能力，哪种鸟有就给哪种鸟加上。我们会使用接口，组合，委托的技术来实现我们的诉求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略，TweetAbility 和 EgglayAbility 的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pigeon</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable, Flyable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">FlyAbility</span> <span class="variable">flyAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyAbility</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">EgglayAbility</span> <span class="variable">egglayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EgglayAbility</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    flyAbility.fly();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">    tweetAbility.tweet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">    egglayAbility.layEgg();  <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的三个作用：表示 <code>is-a</code> 关系，支持多态，代码复用。这三个作用都可以通过其他技术手段来实现。例如，我们可以用组合和接口的 <code>has-a</code> 来实现 <code>is-a</code>，多态可以用接口来实现；代码复用可以用组合和委托来实现。</p>
<p>上面的例子虽然证明了组合优于继承，但不是说继承一无是处。如果类的继承结构稳定，继承层次比较浅，继承关系也不复杂，我们可以用继承。反之，如果系统不稳定，继承层次还比较深，继承关系比较复杂，我们就考虑使用组合替换它。</p>
<p>关于继承可以实现代码复用，需要就具体情况具体分析，因为继承首先表明一种 <code>is-a</code> 关系，然后才考虑复用，例如，我们可以将能飞的鸟，飞，这个功能提取到父类中，实现代码复用。但是，对于 <code>Crawler</code> 和 <code>PageAnalyzer</code> 这两个都用到了 <code>URL</code> 拼接功能的类，我们没法抽象出一个父类，将这个公共的方法提取到父类中达到代码复用的目的，因为这个两个类不同宗也不同源，没有任何关系，硬生生扯出一个公共的类，只会影响代码的可读性。</p>
<p>所以，结论是，虽然鼓励多用组合少用继承，但组合也并不完美，继承也不是说一无是处，实际项目中，还要根据具体的情况进行分析。</p>
<h3 id="类之间的交互关系"><a href="#类之间的交互关系" class="headerlink" title="类之间的交互关系"></a>类之间的交互关系</h3><p><code>UML</code> 统一建模语言中定义了六种类之间的关系：泛化、实现、关联、聚合、组合、依赖。其中泛化可以理解位简单的继承关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>实现指的是接口和实现类之间的关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>聚合是一种包含关系，<code>A</code> 类的对象包含 <code>B</code> 类的对象，<code>B</code> 类对象的生命周期可以不依赖 <code>A</code> 类对象的生命周期，也就是说可以单独销毁 <code>A</code> 类对象但是不影响 <code>B</code> 类对象，比如学生和课程之间的关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合也是一种包含关系，但是如果 <code>A</code> 类对象包含 <code>B</code> 类对象，<code>B</code> 类对象的生命周期依赖 <code>A</code> 类对象的生命周期，<code>B</code> 类对象不可以单独存在，比如，鸟和翅膀的关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联是一种非常弱的关系，包含聚合和组合两种关系，具体到代码里面，如果 <code>B</code> 类对象是 <code>A</code> 类对象的成员变量，那 <code>B</code> 类和 <code>A</code> 类就是关联关系。具体到 <code>Java</code> 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖是一种比关联关系更加弱的关系，包含关联关系。不管是 <code>B</code> 类对象是 <code>A</code> 类对象的成员变量，还是 <code>A</code> 类的方法使用 <code>B</code> 类对象作为参数或者返回值、局部变量，只要 <code>A</code> 类对象使用到了 <code>B</code> 类对象，我们都称它们有依赖关系。具体到 <code>Java</code> 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(B b)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实用的角度来说，我们只保留泛化、实现、依赖和组合即可。</p>
]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>开发、运维、投资模式</title>
    <url>/2023/08/29/Design-Patterns/dev-invest-ops/</url>
    <content><![CDATA[<p>云平台的出现，深刻地影响了开发模式。无论是技术选型、系统架构、研发组织架构还是基础设施，都要为上云做好准备。</p>
<h4 id="新开发模式"><a href="#新开发模式" class="headerlink" title="新开发模式"></a>新开发模式</h4><h5 id="微服务（Micro-Service）"><a href="#微服务（Micro-Service）" class="headerlink" title="微服务（Micro Service）"></a>微服务（Micro Service）</h5><p>对于上云的应用，微服务几乎是必然之选，因为云平台的基础功能之一就在于动态调配计算资源（CPU、内存等）。我们知道，在一个应用中的不同部分，所需要的计算资源是不一样的。比如“查看商品”功能的使用频度通常远高于“支付订单”。如果使用传统的方式，把所有功能都放在一个运行单元中（即单体应用），那么就只能将其整体扩容（复制多份，负载共担）才能实现，这将浪费大量的计算资源。而微服务技术可以把使用频度不同的功能拆分成不同的运行单元，每个运行单元称之为一个微服务。比如当“查看商品”功能的使用频度很高时，就可以只对它所在的运行单元进行扩容；当使用频度降低时，就可以释放不再需要的运行单元，把计算资源释放回资源池。但微服务也需要相应的技术储备。</p>
<span id="more"></span>
<h5 id="微服务与架构"><a href="#微服务与架构" class="headerlink" title="微服务与架构"></a>微服务与架构</h5><p>要想实现微服务，首先要解决的问题就是如何合理地设计系统架构。从“便于扩容”的目的出发来做架构设计是个很自然的想法，但这还远远不够。“便于扩容”在架构设计的术语中称为“延展性”或“弹性”。而在架构设计中，总是要在架构的各种属性之间做出一定的权衡和取舍，延展性也不例外。我们必须找到一种更加自然、更加科学的方式来确定架构中模块的弹性边界。通常来说，对于长线项目，扩展性（也就是容易增加新功能）高于延展性。因为前者的成本主要在于程序员，而后者的成本主要在于硬件平台。当两者冲突的时候，除非延展性已经到了投入再多资源也没有效果的阶段，否则还是程序员方面的人力成本更高一些。</p>
<p>因此，我们可以遵循一个原则：在架构设计上优先考虑扩展性，扩展性满足要求的前提下，针对延展性做局部的优化。比如，先针对扩展性做一级模块，然后找出这个一级模块对弹性要求最高的部分，单独提取成二级模块。那么，如何实现扩展性优先的架构设计呢？</p>
<p>首先，我们要弄明白”扩展“的来源，一个系统为什么需要扩展呢？最简单直接的回答是”因为业务需求变了“，所以，我们得到了一个前提：”充分理解业务及其领域知识，包括业务及其领域知识的现状和发展趋势“。然后我们要想清楚”扩展“的成本来自于哪里？为什么扩展会很昂贵？这有两方面的因素：技术上的和管理上的。</p>
<p>从技术上看，当业务需求发生变化时，就需要对现有代码进行调整。这种调整最好聚焦在一个较小的范围内，这样一来它所需的设计、开发、测试、部署等工作量都比较小。这个“较小的范围”，最好集中在一个或少数几个微服务。当然，也不要因此而设计过大的微服务，那样就会导致很多不相关的代码在变更时被迫“陪绑”。</p>
<p>从管理上看，当业务需求发生变化时，就需要和相关的开发团队进行沟通。在开发过程中，这些开发团队之间还需要互相沟通，而这些沟通都是额外的成本，当需要做的跨团队沟通很多时，这些成本就会出现非线性增长。因此，我们应该得到这样一个架构：无论从技术视角看还是从管理视角看，这个架构都应该对齐到业务自身的本征架构。这样一来，只要业务的变化只会发生在局部，那么对代码的调整也只会发生在局部，对团队的影响也同样只会发生在局部。所以，问题归结为一个：“如何准确的认识和表达业务自身的本征架构”。而答案也很简单：“交给专家”。让领域专家来识别并表达业务自身的领域知识，从这些领域知识中提炼出其本征架构。</p>
<h5 id="架构、DDD-与演进式架构"><a href="#架构、DDD-与演进式架构" class="headerlink" title="架构、DDD 与演进式架构"></a>架构、DDD 与演进式架构</h5><p>然而，简单的答案往往意味着复杂的行动。领域专家在自身的业务领域固然是专家，但是往往也只懂其业务领域的一小部分，整合多位领域专家的知识，是一大难题。即使我们能整合，如何通过领域模型把它准确全面地表达出来又是一个更大的难题。因为业务专家不一定都有很强的逻辑性，如果没有受过专门的训练，很难驾驭和表达复杂的领域知识，更不用说大规模的领域知识了。那么，还有更大的难题吗？有！那就是长期维护这个领域模型。前两个问题的答案就是“领域驱动设计”，也就是最近大火的 DDD；而后一个问题的答案是“演进式架构”。</p>
<p>“领域驱动设计”的基本思想，是让业务方面的领域专家和软件技术方面的架构师来共同梳理领域知识，以便建立一个容易被开发团队成员理解的领域模型。而演进式架构则是强调，不要把架构看做静态的、一成不变的产物，不要追求一步到位，而应该用各种手段来监测、守护它，提早发现架构问题的时机，降低发现和修正架构问题的成本。</p>
<h4 id="新投资模式"><a href="#新投资模式" class="headerlink" title="新投资模式"></a>新投资模式</h4><p>在云生态下，大量采用按需付费模式。在这种模式下，基本上不需要多少前期投入 —— 用户量小的时候就少买资源，随着用户规模的提升，逐渐扩大投入即可。这样可以降低试验新商业应用的成本和风险。<br>按需付费通常又分为三种子模式：</p>
<h5 id="按需付费模式"><a href="#按需付费模式" class="headerlink" title="按需付费模式"></a>按需付费模式</h5><p>这种模式非常简单：边用边计费，随时停用随时停止计费。一般精确到小时或秒级（取决于资源类型）。但是，像流量这样的资源比较特殊，它的按需计费不是按小时或秒计费，而是按实际流量计费。但是要注意，不同的资源的停用标准不一样，比如 ECS（相当于虚拟机）只要停止就会针对 CPU、内存等停止计费，但是挂载的云硬盘、IP 地址、包年包月带宽等仍然会继续计费。要想释放这些，就要专门把它们停用。另外，由于运营成本的不同，所在可用区对计费，甚至开通的服务也有着显著影响。一般来说，发达地区的可用区比较贵，偏远地区则比较便宜。具体的选择要视多方面的因素而定，必要时可以先做一下测速。<br>另外，由于运营成本的不同，所在可用区对计费，甚至开通的服务也有着显著影响。一般来说，发达地区的可用区比较贵，偏远地区则比较便宜。具体的选择要视多方面的因素而定，必要时可以先做一下测速。按需计费类似于零售模式，因此单位费率通常都是最高的，只适合做一些短于一个月的试验性项目。</p>
<h5 id="包年包月模式"><a href="#包年包月模式" class="headerlink" title="包年包月模式"></a>包年包月模式</h5><p>相当于按需计费的批发模式。在按需计费的基础上，包年包月模式会提供一些额外的优惠。但要注意，包年包月的流量是根据最大带宽档位进行逐月逐年计费的。对于流量很小的应用，这种方式的实际费用反倒会高于按需付费模式。因此，对于流量很小的应用，即使要长期运营，也可能要选择按需付费模式的流量。当然，对于大部分应用来说，包年包月总是要比按需付费便宜一些的。</p>
<p>这就意味着，要用不确定性来换取优惠。因此，它的适用场景和前两种模式有着显著的差异。竞价计费模式通常用于一些随时可以启停的批处理任务，比如一些非紧急统计报表的生成任务。云平台会保证竞价计费的单价不会超过按需计费模式，可以放心尝试。</p>
<h5 id="竞价计费模式"><a href="#竞价计费模式" class="headerlink" title="竞价计费模式"></a>竞价计费模式</h5><p>这是一种闲置资源拍卖模式。选择竞价计费时，你的出价并不是你的实际出价，而是你愿意为保留实例而出的最高价。平台会定期对竞拍者按出价进行排序，然后依次分配资源使用权，那些分配不到使用权的，就会自动被平台释放。</p>
<p>这就意味着，要用不确定性来换取优惠。因此，它的适用场景和前两种模式有着显著的差异。竞价计费模式通常用于一些随时可以启停的批处理任务，比如一些非紧急统计报表的生成任务。云平台会保证竞价计费的单价不会超过按需计费模式，可以放心尝试。</p>
<h4 id="新运维模式"><a href="#新运维模式" class="headerlink" title="新运维模式"></a>新运维模式</h4><p>云平台会帮你完成服务器、网络等基础设施的运维，通过这种集约化的运维方式，可以省去全部硬件运维工作以及大部分系统运维工作。但是应用层的运维仍然只能由运维人员自己做。不过，好在云平台基本上都提供了应用运维平台，比如华为云就提供了“应用管理与运维平台 <code>ServiceStage</code>”，它提供了应用开发、构建、发布、监控及运维等一站式解决方案。当运维任务比较重的时候，可以考虑按需采购此项服务。如果预算有限，可以考虑基于开源软件来自行搭建，有的平台（比如华为云 <code>CCE</code>）提供了插件。比如：</p>
<ul>
<li>用 <code>ELK</code> 来支持日志收集与分析工作，通过日志，可以对应用的运行状况进行剖析，定位并诊断错误，识别潜在威胁等。</li>
<li>用 <code>Prometheus</code> 对系统和应用的运维数据进行监控和预警，以便触发对特定运维事件的自动化处理。</li>
<li>用 <code>Grafana</code> 对运维监控数据进行可视化，以便让各个干系人可以凭直觉发现运维问题，主动提供不同力度的人为介入。</li>
</ul>
<p>这些软件通常会搭配使用，但其自身需要有人维护，而且其整体性仍然不理想，对运维数据的挖掘也不够深入。如果应用系统更加复杂，那就不能指望这些通用的应用运维平台了，而应该在应用系统的设计之初就直接把特有的运维需求包含进去。对于开源方案，可以更好地进行深度定制，不过需要的技术水平通常会比较高。对于云平台方案，由于进行了专门的 <code>API</code> 封装，通常可以更简单地进行定制，但是深度受限。</p>
<p>云平台的意义，不仅仅在于代替了传统的开发方式和基础设施，更重要的是它打开了许多未曾设想的道路。比如：不再自建数据库，而是直接使用云平台提供的数据库服务，这样一来，数据库本身的运维工作也交给云平台去“集约化”了。对于流量波动巨大的系统，不需要再基于最大流量自建消息队列，而是把这部分容量交给云平台来统一调配。对于像人工智能这样的“新兴”技术，不需要再自己搭建和运维，而是让云平台来搭建这些基础设施，自己只做应用层开发即可。甚至连应用层编码都不必做，而是直接使用云平台提供的可视化工具，由业务专家来进行分析和预测。这种模式称为 <code>PaaS</code>（平台即服务）。</p>
<p>对于一些中小企业，甚至可以考虑不再自建应用软件，而是使用云平台提供的 CRM 等在线版软件，自己只需要在其中开一个租户即可。但是，如果涉及到商业机密数据，就必须找一个可信的提供商，保证自己的数据不会被软件的运营方泄露。非专业用户很难判断运营方的可靠性，只能靠运营方的商誉和运营记录来判断了。</p>
<p>不过，对于中小企业，除非自身非常有特色，否则通常不用过早担心数据泄露问题。等成长到一定级别，可以花钱请软件提供商进行私有化部署，把运营权限完全收归自己。甚至可以重新开发一套私有系统。</p>
<p>这种模式称为 <code>SaaS</code>（软件即服务）。<br>除此之外，还有一种更激进的 <code>FaaS</code>（函数即服务）模式。在这种模式下，应用开发者甚至都不必关心部署、运维等细节，只需要关心业务逻辑就可以了。不过，这部分的能力和方法论体系还不如 <code>IaaS、SaaS、PaaS</code> 那样成熟，因此可以做一些技术储备，但是要想落地还需要谨慎评估。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>多运行时微服务架构</title>
    <url>/2023/08/30/Design-Patterns/multi-runtime-architecture/</url>
    <content><![CDATA[<h5 id="服务化演进中的问题"><a href="#服务化演进中的问题" class="headerlink" title="服务化演进中的问题"></a>服务化演进中的问题</h5><p>自从数年前微服务的概念被提出，到现在基本成了技术架构的标配。微服务的场景下衍生出了对分布式能力的大量需求：各服务之间需要相互协作和通信，以及共享状态等等，因此就有了各种中间件来为业务服务提供这种分布式能力。</p>
<span id="more"></span>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma14.png" class="">
<p>我们熟知的”<code>Spring Cloud</code> 全家桶“正是凭借着对各种中间件优秀的集成与抽象能力，成为了当时炙手可热的项目。然而随着业务的快速发展，组织规模的不断扩大，微服务越来越多，系统规模越来越大则是服务化体系架构演进的必然。这就带来了两方面复杂度的上升：</p>
<ul>
<li><strong>服务治理与接入的复杂度</strong>: 服务治理代表了系统中服务资源的地图及其获取途径，例如通过注册发现服务提供图谱能力，路由、网关、负载均衡服务提供获取途径。服务接入则代表了如何使用系统中的服务能力，例如通过中间件提供的API 协议或是封装的 SDK 来接入该中间件。各种业务服务越多、中间件越复杂，整个系统服务治理与接入的复杂度就会急剧上升。</li>
<li><strong>团队协作的复杂度</strong>: 该复杂度主要体现在团队的认知负载上，复杂的依赖、沟通、协作将明显拖慢交付进度。正如康威定律所述的，由于服务复杂度的上升，团队之间的交互成本也随之上升。<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma15.png" class="">
当系统中的中间件都通过 <code>SDK</code> 作为其外化能力的控制方式，来封装协议、数据结构与操作方法。随着中间件数量和种类不断增多，大量孤立的 <code>SDK</code> 被绑定在业务服务上，导致两方面问题：</li>
</ul>
<ol>
<li>版本升级困难：<code>SDK</code> 与业务服务的强依赖性导致想要升级 <code>SDK</code> 版本变得异常复杂与缓慢</li>
<li>业务服务难以异构：<code>SDK</code> 所支持的语言反向限制了业务服务所能选择的语言，例如 <code>Spring Cloud</code> 几乎没有官方的多语言支持</li>
</ol>
<p>如何治理这种不断上升的复杂度呢？复杂问题归一化是一种不错的手段。</p>
<h5 id="什么是多运行时微服务架构？"><a href="#什么是多运行时微服务架构？" class="headerlink" title="什么是多运行时微服务架构？"></a>什么是多运行时微服务架构？</h5><p>多运行时微服务架构（<code>Multi-Runtime Microservice Architecture</code>）也被简称为多运行时架构，是由 <code>Red Hat</code> 的首席架构师 <code>Bilgin Ibryam</code> 在 2020 年初所提出的一种微服务架构形态，它相对完整地从理论和方法的角度阐述了多运行时架构的模型（实际上，在 2019 年末，微软的 <code>Dapr v0.1.0</code> 就已经发布）。<code>Bilgin Ibryam</code> 梳理了分布式应用的各类需求后，将其划分到了四个领域内：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/Multi-Runtime-Microservices-Architecture.png" class="">

<p>（来源：<a href="https://www.infoq.com/articles/multi-runtime-microservice-architecture/">Multi Runtime Microservices Architecture</a>）</p>
<ul>
<li><strong>生命周期</strong>：即应用从开发态到运行态之间进行打包、部署、扩缩容等需求。</li>
<li><strong>网络</strong>：分布式系统中各应用之间的服务发现、容错、灵活的发布模式、流量管理、跟踪和遥测等需求。</li>
<li><strong>状态</strong>：我们期望服务是无状态的，但业务本身一定需要有状态，因此包含对缓存、编排调度、幂等、事务等需求。</li>
<li><strong>绑定</strong>：与外部服务之间进行集成可能面临的交互适配、协议转换等需求。</li>
</ul>
<p><code>Bilgin Ibryam</code> 认为，应用之间对分布式能力的需求，无外乎这四大类。且在 <code>Kubernetes</code> 成为云原生场景下运行时的事实标准后，对生命周期这部分的需求已经基本被覆盖到了。因此实际上我们更关注的是如何归一化其他三种需求。</p>
<h6 id="与单机应用的类比"><a href="#与单机应用的类比" class="headerlink" title="与单机应用的类比"></a>与单机应用的类比</h6><p>单机应用一般大都是以用户态进程的形式运行在操作系统上。显然，与微服务类似，单机应用的核心关注点也是业务逻辑，与业务关系不大的支撑能力，都要依赖操作系统来完成。因此上述由 Bilgin 归纳的分布式应用四大类需求，其实我们很容易就可以和单机应用进行合理的类比：</p>
<table>
<thead>
<tr>
<th align="left">支撑能力</th>
<th align="left">单机应用</th>
<th align="left">分布式应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">生命周期</td>
<td align="left">用户态进程</td>
<td align="left">Kubernetes</td>
</tr>
<tr>
<td align="left">网络</td>
<td align="left">网络协议、域名解析、路由服务</td>
<td align="left">服务发现&#x2F;注册、负载均衡、流量管理</td>
</tr>
<tr>
<td align="left">状态</td>
<td align="left">文件系统</td>
<td align="left">数据库、对象存储、块存储</td>
</tr>
<tr>
<td align="left">绑定</td>
<td align="left">标准库、系统调用</td>
<td align="left">事件分发、分布式事务、消息路由</td>
</tr>
</tbody></table>
<p>从上述类比来看我们发现，单单是 <code>Kubernetes</code> 可能还不足以称为是 “云原生操作系统”，除非有一种解决方案，能在分布式环境下，把其他几项支撑能力也进行归一化整合。</p>
<h6 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h6><p><code>Service Mesh</code> 在近几年的高速发展，让我们认识到网络相关的需求是如何被归一化并与业务本身解耦的：<br>通过流量控制能力实现多变的发布模式以及对服务韧性的灵活配置，通过安全能力实现的开箱即用的 <code>mTLS</code> 双向认证来构建零信任网络，通过可观察性能力实现的网络层<code>Metrics，Logging</code> 和 <code>Tracing</code> 的无侵入式采集。而上述服务治理能力，全部被代理到 <code>Sidecar</code> 进程中完成。这就实现了 <code>codebase level</code> 的解耦，网络相关的分布式能力完全抛弃 <code>SDK</code>。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma1.png" class="">
<p>伴随着 <code>Service Mesh</code> 的成功，我们不禁会想到，是否可以将另外的两种需求——状态和绑定 ——也进行 <code>Mesh</code> 化改造呢？</p>
<h6 id="分布式能力-Mesh-化"><a href="#分布式能力-Mesh-化" class="headerlink" title="分布式能力 Mesh 化"></a>分布式能力 Mesh 化</h6><p>基于对 <code>Service Mesh</code> 的拓展，我们大可以将其他的能力也进行 <code>Mesh</code> 化，每一类能力都以 <code>Sidecar</code> 的形式部署和运作：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma2.png" class="">
<p>在业界也有不少从某些能力角度切入的方案：<code>istio(networking)、dapr(state，binding)、kubernetes(lifecycle)</code>。我们可以发现，各类方案都有自己的一套对某些能力需求的 <code>Mesh</code> 化方案，合理地选择它们，的确满足了分布式能力 <code>Mesh</code> 化的要求，但却引入了新的问题：</p>
<ul>
<li>复杂度从业务服务下沉到了 <code>Mesh</code> 层：多种 <code>Mesh</code> 化方案之间缺乏一致性，导致选型和运维的成本很高</li>
<li>多个 <code>Sidecar</code> 进程会带来不小的资源开销，很多解决方案还需要搭配控制面进程，资源消耗难以忽视</li>
</ul>
<p>对业务复杂度上升的归一化，现在变成了对 Mesh 复杂度上升的归一化。</p>
<h6 id="Multi-Runtime-Micrologic-Mecha"><a href="#Multi-Runtime-Micrologic-Mecha" class="headerlink" title="Multi-Runtime &#x3D; Micrologic + Mecha"></a>Multi-Runtime &#x3D; Micrologic + Mecha</h6><p><code>Bilgin Ibryam</code> 在多运行时微服务架构中，对前述讨论的各种问题点进行了整合，提出了 <code>Micrologic + Mecha</code> 的架构形态：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma3.png" class="">
<p>在 <code>Micrologic</code> 中只包含业务逻辑，尽可能的把分布式系统层面的需求剥离出去，放到 <code>Mecha</code> 中。从 <code>Mecha</code> 的命名就可以明白它的功能：由提供各种分布式能力的 “机甲” 组成的 <code>Sidecar</code> 进程，与 “裸奔的” 业务逻辑一起部署。因为是 <code>Micrologic</code> 进程和 <code>Mecha</code> 进程共同部署的这种多个 “运行时” 的架构，所以称之为 “多运行时架构”。<code>Mecha</code> 不仅成功地将分布式能力从耦合的业务进程中抽取出来，还整合了方案，避免了多种方案混合的额外成本。可以说 <code>Mecha</code> 在本质上提供了一个分布式能力抽象层。</p>
<p>因此与其叫 “多运行时架构”，不如叫 “面向能力的架构”。</p>
<h6 id="微软的尝试：Dapr"><a href="#微软的尝试：Dapr" class="headerlink" title="微软的尝试：Dapr"></a>微软的尝试：Dapr</h6><p><code>Dapr</code> 是微软主导开发并开源的一种 <code>Mecha runtime</code>，从宏观上看它处在整个架构的中间层：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma4.png" class="">
<p>自上而下分别是业务层、<code>Dapr Runtime</code>层、基础设施层。<code>Dapr</code> 通过 <code>Http</code> 或 <code>gRPC API</code> 向业务层提供分布式能力抽象，通过称为 “<code>Component</code>” 的接口定义，实现对具体基础设施的插件式管理。</p>
<h6 id="云和边缘的微服务构建块-Building-Blocks"><a href="#云和边缘的微服务构建块-Building-Blocks" class="headerlink" title="云和边缘的微服务构建块(Building Blocks)"></a>云和边缘的微服务构建块(Building Blocks)</h6><p>作为一个合格的 <code>Mecha</code>，最关键的就是如何定义分布式能力抽象层。如何把各类中间件提供的分布式能力定义清楚是一项挑战。<code>Dapr</code> 中定义的分布式能力抽象层，称为 <code>Building Blocks</code>。顾名思义，就是一系列的 “构建块”，每一个块定义了一种分布式能力。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma5.png" class="">
<p>其中有一些 <code>Blocks</code> 的能力由 <code>Dapr</code> 自己就能实现，有一些则需要由实际的基础设施或中间件来实现。选取几个典型举例说明：</p>
<ul>
<li><code>Service-to-service Invocation</code>：提供服务间调用的能力，其中也隐含了服务的注册与发现。该 <code>Block</code> 的能力由 <code>Dapr</code> 直接实现。</li>
<li><code>State management</code>：提供状态管理能力，最简单的就是存取状态。该 <code>Block</code> 需要其他基础设施通过 <code>Component</code> 的形式实现，例如定义一个 <code>Redis Component</code>。</li>
<li><code>Publish and subscribe</code>：提供消息发布和订阅的能力，这是非常典型的一种分布式能力。也需要通过基础设施来实现，如定义一个 <code>Kafka Component</code>。</li>
</ul>
<h6 id="Dapr-的限制与挑战"><a href="#Dapr-的限制与挑战" class="headerlink" title="Dapr 的限制与挑战"></a>Dapr 的限制与挑战</h6><p><code>Dapr</code> 期望通过定义一个能容纳所有需求的分布式能力抽象层，来彻底解放业务逻辑。从归一化的角度看，不得不说这是一种大胆而富有野心的尝试，理想条件下的确能非常优雅地解决问题。但现实总是充斥着各种跳脱出理想的情况，<code>Dapr</code> 在推广的过程中遇到了很多限制与挑战。</p>
<h6 id="与-Service-Mesh-整合"><a href="#与-Service-Mesh-整合" class="headerlink" title="与 Service Mesh 整合"></a>与 Service Mesh 整合</h6><p>作为面向开发侧提供的能力抽象层，<code>Dapr</code> 在网络能力上包含了 <code>mTLS、Observability</code> 与 <code>Resiliency</code>（即超时重试熔断等），但并没有包含诸如负载均衡、动态切换、金丝雀发布等运维侧的流量管理能力。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma6.png" class="">
<p>因此对于不断走向成熟的业务系统，可能既要 <code>Service Mesh</code> 在运维侧的流量管理能力，又要 <code>Dapr</code> 在开发侧的分布式抽象能力，不管谁先谁后，都将面临一个问题：怎样搭配使用它们才是正确的？某些场景下可以做适配，如：</p>
<ul>
<li>对于 <code>distributed tracing</code> 的能力，如果采用 <code>Service Mesh</code> 来实现，则需要考虑将原本 <code>Dapr</code> 直连的中间件也加入 <code>mesh</code> 网络，否则会 <code>trace</code> 不到。但从 <code>distributed tracing</code>本身功能角度讲，更应该使用 <code>Dapr</code>。</li>
<li><code>mTLS</code> 应该只在 <code>Dapr</code> 或者 <code>Service Mesh</code> 中开启，而不应该都开启。</li>
</ul>
<p>但 <code>Dapr</code> 与 <code>Service Mesh</code> 配合使用中难以避免的是开销的问题，包括资源开销和性能开销。每个应用 <code>Pod</code> 携带两种 <code>sidecar</code>，再加上 <code>Dapr</code> 和 <code>Service Mesh </code>自己的控制面应用（高可用方案主备或多副本），这些资源开销是无法忽略，甚至是非常可观的。而由于 <code>Service Mesh</code> 网络代理的流量劫持，网络调用需要先经过 <code>Dapr sidecar</code>，再经过网络代理 <code>sidecar</code>，被代理两次，也会造成一定的性能开销。</p>
<p>简单计算一下就会发现，当拥有 1000 个业务实例时，<code>dapr + istio</code> 的 <code>Sidecar</code> 进程可能会消耗 <code>800+ vCPU</code> 和 <code>60+ GiB</code> 内存。随着分布式能力抽象层的不断扩展，到底哪些属于开发侧，哪些属于运维侧，也许不会像现在这样泾渭分明了。因此已经有对 <code>Multi-Runtime</code> 与 <code>Service Mesh</code> 能力边界越来越模糊的讨论。</p>
<h6 id="Sidecarless？"><a href="#Sidecarless？" class="headerlink" title="Sidecarless？"></a>Sidecarless？</h6><p>从上一节的表格我们发现，资源消耗以及性能的问题其实不只是 <code>Dapr</code> 下的场景，实际上它是 <code>sidecar</code> 模式自有的限制，因此在 <code>Service Mesh</code> 领域的讨论中，已经有提出 <code>Sidecarless</code> 的概念了，即通过 <code>DaemonSet</code> 而不是 <code>Sidecar</code> 的形式来部署网络代理。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma7.png" class="">
<p>对于网络代理的 <code>Sidecarless</code> 化，支持方认为它能带来高性能、低资源消耗的优点，而反对方则认为它会导致安全性与隔离性差、故障的爆炸半径过大等缺点。那么，<code>Mecha</code> 是否也可能会走向 <code>Sidecarless</code> 呢？</p>
<p>就像今年 <code>Cilium</code> 发布支持 <code>Service Mesh</code> 能力的办法，通过 <code>eBPF</code> 在内核态实现 <code>L3 L4</code> 层能力，而对应的 <code>L7</code> 层能力则交给用户态的 <code>Envoy</code> 处理这种将问题一分为二的思想，也许多运行时架构的未来方案也可能是折中或是多种方式结合的。例如采用在 <code>Node</code> 上按 <code>Service Account</code> 或 <code>Namespace</code> 运行多实例，或是轻量级 <code>Sidecar</code> 做协议转换＋<code>DaemonSet</code> 做流量管理和网络调用。当然 <code>DaemonSet</code> 也有其固有的缺陷，资源被共享从而降低消耗的同时，故障也被共享了，而且故障产生的伤害面也变大了，此外还会导致 <code>DaemonSet</code> 被应用使用的争抢问题，以及应用之间的数据暴露风险。到底后续将会如何演进，我们拭目以待。</p>
<h6 id="定义抽象能力的（API）的困境"><a href="#定义抽象能力的（API）的困境" class="headerlink" title="定义抽象能力的（API）的困境"></a>定义抽象能力的（API）的困境</h6><p>分布式能力抽象层，是对分布式场景下需求的抽象性定义，抽象作为一种共识，其要义就在于保留共性而排除个性。但实际当中会发现，同类型中间件的差异化恰恰体现在了一些高级的、细分的专有特性上，很多业务对中间件选型的原因也在于这些专有特性上。这就引出了一个困境：抽象能力所覆盖的需求，其丰富程度与可移植性成反比。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma8.png" class="">
<p>就如上图所示，如果抽象能力范围只覆盖到红色的部分，则组件 <code>ABC</code> 的专有特性都无法被引入，而如果抽象能力范围覆盖到绿色，那么就无法迁移到组件C。定义抽象能力的困境，本质上是一种对能力收敛的权衡，这种权衡可能是与具体的业务需要高度相关的。然而，在企业实际的场景下，这个“全集”的规模可能并不一定像我们想象的那么庞大，因此就有可能提供额外的一种思路，即对分布是抽象层进行扩展，将有限规模的“个性”全部包含进去，形成 “并集” 从而规避上述问题。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma9.png" class="">

<h6 id="蚂蚁金服的方案：layotto"><a href="#蚂蚁金服的方案：layotto" class="headerlink" title="蚂蚁金服的方案：layotto"></a>蚂蚁金服的方案：layotto</h6><p>蚂蚁金服作为 <code>Dapr</code> 的早起使用者，在落地的过程中结合遇到的问题及业务思考，在 2021 年年中推出了自研的 <code>Mecha</code> 方案：<code>layotto</code>。</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma10.png" class="">
<p>由于 <code>layotto</code> 在运行态上是与 <code>MOSN</code> 绑定在一个 <code>Sidecar</code> 内的，因此就减少了一部分前文提到的两个 <code>Sidecar</code> 之间通信的开销。当然 <code>layotto</code> 可以这样做也有一部分原因在于 <code>MOSN</code> 本身已经在蚂蚁内部大规模落地，同时蚂蚁也有足够的研发强度来支撑 <code>layotto</code> 的开发。</p>
<h6 id="“私有协议”与“可信协议”"><a href="#“私有协议”与“可信协议”" class="headerlink" title="“私有协议”与“可信协议”"></a>“私有协议”与“可信协议”</h6><p><code>Layotto</code> 的开发者，在讨论多运行时架构以及 <code>layotto</code> 落地实践的文章中，尝试对可移植性的概念进行了扩展，将支撑分布式能力的协议划分为“可信协议”与“私有协议”。其中，可信协议指代的是一类影响力很大的协议如 <code>Redis</code> 协议、<code>S3</code> 协议、<code>SQL</code> 标准等。这一类协议由于用户众多，且被各类云厂商所支持，因此可以认为它们本身就具有可移植性。私有协议则指代一些企业内部自研的、闭源或影响力小的开源软件提供的协议。显然这一类协议才更需要考虑抽象与可移植性。因此实际上的所谓分布式能力抽象层可能会是如下图所示的样子：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma11.png" class="">
<p>各类可信协议不再二次抽象，而是直接支持，对其余的私有协议再进行抽象。这种直接支持开源协议的思路，部分缓解了定义抽象能力的困境问题。</p>
<h6 id="灵活的扩展模型"><a href="#灵活的扩展模型" class="headerlink" title="灵活的扩展模型"></a>灵活的扩展模型</h6><p>前文提到的 <code>API</code> 扩展形成 “并集”，<code>Layotto</code> 通过提供 <code>In-Tree</code> 形式的私有 <code>API</code> 注册点，实现了不修改 <code>Layotto</code> 代码就能扩展 <code>API</code> 能力：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma12.png" class="">
<p>从代码角度看，<code>Layotto</code> 是通过暴露 <code>API</code> 注册钩子、启动入口，来允许用户自行扩展代码，之后再调用启动函数启动进程。这样扩展 <code>API</code> 代码与 <code>Layotto package</code> 级隔离，但编译后可形成同一个二进制文件。另外，通过 <code>MOSN</code> 的 <code>WASM</code> 插件能力，<code>Layotto</code> 也支持通过 <code>WASM</code> 镜像来扩展 <code>API Filter</code>。</p>
<h5 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h5><p>虽然多运行时架构这种理念从提出到现在只有两年，但已经很少有人会否认它所带来的价值，不论是 Dapr 还是 layotto 的快速发展，都明确了头部企业对这一领域的投资逻辑。</p>
<p>当然目前从理论到实践可能都不够成熟，大家在落地实践的过程中也都会或多或少遇到前文提到的一些局限。但这些局限所处的层次大都是工程化、技术选择等具体的问题，相信随着各方技术的不断整合，实践的不断完善，问题都能解决。对多运行时架构实践的未来，结合当下的限制、挑战以及趋势，我们也许能勾勒出某种未来可能的架构形态：</p>
<img data-src="/2023/08/30/Design-Patterns/multi-runtime-architecture/mrma13.png" class="">
<p>在这一架构形态下：</p>
<ul>
<li>分布式能力抽象层提供标准能力抽象，以及灵活扩展的私有协议的能力</li>
<li>既成标准协议（对前文 “可信协议” 的另一种提法）作为 “既成的” 抽象能力，在<code>Mecha</code> 层只做协议转换或直接透传</li>
<li><code>Mecha</code> 与网络代理层进程级耦合，各类特性不再明确区分开发侧与运维侧</li>
<li>进程在 <code>Node</code> 上按租户<code>/namespace</code> 以及高可用要求划分多实例</li>
<li>接入现代化的可观测性体系，提升对故障的洞察分析能力，降低由于架构分层带来的问题诊断困难</li>
</ul>
<p>总之，不管是架构形态怎么变、能力怎么抽象，让业务逻辑不断内聚，越来越面向接口、面向能力编程的趋势不会改变，服务化体系的未来值得期待。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计蓝图</title>
    <url>/2023/07/19/Design-Patterns/system-design-blueprint/</url>
    <content><![CDATA[<img data-src="/2023/07/19/Design-Patterns/system-design-blueprint/Sd_Blueprint.png" class="">

<span id="more"></span>

<img data-src="/2023/07/19/Design-Patterns/system-design-blueprint/system-design-blueprint.png" class="">]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>UML2.5 统一建模语言</title>
    <url>/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p><code>UML</code> 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/uml-language.png" class="">

<span id="more"></span>


<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>面向对象程序设计(Object-Oriented Programming， 缩写为 <code>OOP</code>) 是一种范式， 其基本理念是将数据块及与数据相关的行为封装成为特殊的、 名为对象的实体， 同时对象实体的生成工作则是基于程序员给出的一系列蓝图， 这些蓝图就是类，在UML中，类图专门是用来描述这种实体的。如下图所示：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-cat.png" class="" title="类图-猫">

<p>类之间是有相互关系的，就像猫属于动物，动物和植物又属于生物体：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-level.png" class="" title="类之间的层次结构">

<p>类之间的关系可以更细分的划分为这几种：依赖，关联，聚合，组合。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>依赖是类之间最基础的、也是最微弱的关系类型。 如果修改一个类的定义可能会造成另一个类的变化，那么这两个类之 间就存在依赖关系。当你在代码中使用具体类的名称时， 通 常意味着存在依赖关系。 例如在指定方法签名类型时， 或是通过调用构造函数对对象进行初始化时等。 通过让代码依赖接口或抽象类(而不是具体类)，你可以降低其依赖程度。</p>
<p>通常情况下，UML 图不会展示所有依赖——它们在真实代码中的数量太多了。 为了不让依赖关系破坏 UML 图， 你必须对其进行精心选择，仅展示那些对于沟通你的想法来说重要 的依赖关系。</p>
<p>在UML中，依赖关系用一个虚线的箭头表示，从依赖者到被依赖者，例如教授依赖课程资料：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-depend.png" class="" title="授依赖于课程资料">

<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>关联是一个对象使用另一对象或与另一对象进行交互的关系。 在 UML 图中， 关联关系用起始于一个对象并指向其所使用 的对象的简单箭头来表示。 顺带一提， 双向关联也是完全正常的， 这种情况就用双向箭头来表示。 关联可视为一种特殊类型的依赖，即一个对象总是拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。</p>
<p>一般来说， 你可以使用关联关系来表示类似于类成员变量的东西。这个关系将一直存在，因此你总能通过<code>订单</code>来获 取其<code>顾客</code>。 但是它并非一定是成员变量。如果你根据接口来创建类，它也可以表示为一个可返回<code>订单</code>的<code>顾客</code>的方法。</p>
<p>为了区分关联和依赖，举如下的例子，<code>Professor</code> 依赖 <code>Course</code> 提供的 <code>c.getKnowledge</code> 方法获取知识，将其传授给关联的 <code>Student</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Professor is</span><br><span class="line">    field Student student //...</span><br><span class="line">    method teach(Course c) is</span><br><span class="line">    // ...</span><br><span class="line">    this.student.remember(c.getKnowledge())</span><br></pre></td></tr></table></figure>

<p>如果有人修改了 课程 类的 getKnowledge (获取知识)方法(修改方法名或添加一些 必须的参数等)，代码将会崩溃。这就是依赖关系。</p>
<p>让我们来看看名为 <code>student</code> (学生)的成员变量，以及如何在 <code>teach</code> 方法中使用该变量。我们可以肯定学生 (<code>Student</code>)类是教授类的依赖: 如果 <code>remember</code> 方法被修改， 教授的代码也将崩溃。但由于教授的所有方法总能访问 <code>student</code> 成员变量，所以学生类就不仅是依赖，而也是关联了。</p>
<p>UML图中，经常用一个单向的箭头表示关联关系：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-association.png" class="">

<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>聚合是一种特殊类型的关联， 用于表示多个对象之间的<code>一对多</code>、<code>多对多</code>或<code>整体对部分</code>的关系 。 普通关联仅用于描述两个对象之间的关系。通常在聚合关系中， 一个对象<code>拥有</code> 一组其他对象， 并扮演着容器或集合的角色。组件可以独立于容器存在， 也可以同时连接多个容器。 在 UML 图中，聚合关系使用一端是空心菱形，另一端指向组件的箭头来表示。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-juhe.png" class="" title="院系包含教授">


<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>组合是一种特殊类型的聚合， 其中一个对象由一个或多个其他对象实例构成。 组合与其他关系的区别在于组件仅能作为容器的一部分存在。 在 <code>UML</code> 图中，组合与聚合关系的符号相同，但箭头起始处的菱形是实心的。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-zuhe.png" class="" title="大学由院系构成">


<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>面向对象程序设计的四个基本概念使其区别于其他程序设计范式，他们分别是：抽象，多态，封装以及继承。</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>当使用面向对象程序设计的理念开发一款程序时， 我们会将大部分时间用于根据真实世界对象来设计程序中的对象。但是，程序中的对象并不需要能够百分之百准确地反映其原型(极少情况下才需要做到这一点)。实际上，你的对象只需模拟真实对象的特定属性和行为即可，其他内容可以忽略。</p>
<p>例如， 飞行模拟器和航班预订程序中都可能会包含一个飞机 <code>Airplane</code> 类。 但是前者需包含与实际飞行相关的详细信息，而后者则只关心座位图和哪些座位可供预订。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-airplane.png" class="" title="同一个真实世界对象的不同模型">

<p>抽象是一种反映真实世界对象或现象中特定内容的模型， 它 能高精度地反映所有与特定内容相关的详细信息， 同时忽略其他内容。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指一个对象对其他对象隐藏其部分状态和行为， 而仅向程序其他部分暴露有限的接口的能力。</p>
<p>如果想要启动一辆车的发动机， 你只需转动钥匙或按下按钮即可， 无需打开引擎盖手动接线、转动曲轴和气缸并启动发动机的动力循环。 这些细节都隐藏在引擎盖下，你只会看到一些简单的接口: 启动开关、方向盘和一些踏板。 </p>
<p>对象的接口——它是对象的公有部分，能够同其他对象进行交互。</p>
<p>封装某个内容意味着使用关键字 <code>private</code> 来对其进行修饰， 这样仅有其所在类中的方法才能访问这些内容。 还有一种限制程度较小的关键字 <code>protected</code> 保护 ， 其所修饰的对象仅允许父类访问其类中的成员。</p>
<p>绝大部分编程语言的接口和抽象类(或方法)都基于抽象和 封装的概念。 在现代面向对象的编程语言中， 接口机制(通常使用 <code>interface</code> 或 <code>protocol</code> 关键字来声明)允许你定义对象之间的交互协议。这也是接口仅关心对象行为，以及你不能在接口中声明成员变量的原因之一。</p>
<p>假如航空运输 <code>FlyingTransport</code> 接口中有一个 <code>fly(origin, destination, passengers)</code> 方法 (即以起点、 终点以及乘客为参数的飞行方法)。 在设计航空运输模拟器时， 你可以对机场 <code>Airport</code> 做出限制， 使其仅与实现了航空运输接口的对象进行交互。此后，你可以确保 传递给机场对象的任何对象——无论是<code>飞机</code>、 <code>直升机</code>、还是可怕的<code>家养狮鹫</code> —— 都能到达或离开这种类型的机场。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-inbox.png" class="" title="多个类实现一个接口的 UML 图">

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是指在根据已有类创建新类的能力。 继承最主要的好处是代码复用。如果你想要创建的类与已有的类差异不大， 那也没必要重复编写相同的代码。你只需扩展已有的类并将额外功能放入生成的子类(它会继承父类的成员变量和方法) 中即可。</p>
<p>使用继承后，子类将拥有与其父类相同的接口。如果父类中声明了某个方法，那么你将无法在子类中隐藏该方法。你还必须实现所有的抽象方法，即使它们对于你的子类而言没有意义。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-jicheng.png" class="" title="多个类实现一个接口的 UML 图">

<p>在绝大多数编程语言中， 子类仅能对一个父类进行扩展。 另一方面， 任何类都可以同时实现多个接口。 但是正如我之前提到的那样， 如果父类实现了某个接口， 那么其所有子类都 必须实现该接口。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>绝大部分动物 <code>Animals</code> 可以发出声音。 我们需要所有子类都重写基类的 <code>makeSound</code> 发出声音方法，让每个子类都发出正确的声音，因此我们可以马上将其声明为抽象。 这让我们得以忽略父类中该方法的所有默认实现，从而强制要求所有子类自行提供该方法的实现。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-polymorphism.png" class="">

<p>假如将几只猫和狗放入一个大袋子中。 然后，我们闭上眼睛，将动物一个一个地从袋中取出。 我们并不知道自己取出的是何种动物。 但如果我们好好地摸摸它们的话， 它就会根据自己的具体类发出特殊的欢快叫声。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bag = [new Cat(), new Dog()]; </span><br><span class="line">foreach (Animal a : bag)</span><br><span class="line">    a.makeSound()</span><br><span class="line"></span><br><span class="line">//喵喵!</span><br><span class="line">//汪汪!</span><br></pre></td></tr></table></figure>

<p>程序并不知道 <code>a</code> 变量中所包含的对象的具体类型，但幸亏有被称为多态的特殊机制， 程序可以追踪对象的子类并调用其方法，从而执行恰当的行为。</p>
<p>多态是指程序能够检测对象所属的实际类，并在当前上下文不知道其真实类型的情况下调用其实现的能力。</p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML图经过各种大型工程的实践，被证明是一种极其有用的方式来描述可视化系统，数据可系统及其他软件系统，所有的软件开发人员都应该学习并掌握它。从种类上来说，它有以下几种类型：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML%E5%9B%BE%E7%A7%8D%E7%B1%BB.png" class="" title="UML图种类">


<h4 id="类图（Class-Diagram）"><a href="#类图（Class-Diagram）" class="headerlink" title="类图（Class Diagram）"></a>类图（Class Diagram）</h4><p><code>Class</code> 经常被用用来描述某个具体的或者抽象的对象，这个对象经常具有一些属性和方法，而且这些属性和方法都具有不同的访问限制规则，例如一个用来描述 <code>Dog</code> 的类图：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-dog.png" class="">

<p>可以看到的是在每个属性或者方法之前都有一个 <code>+</code> 或者 <code>-</code>，这个就是访问限制规则，一共有四种：</p>
<ul>
<li><code>+</code>：Public，可公开访问</li>
<li><code>-</code>：Private</li>
<li><code>#</code>：Protected</li>
<li><code>~</code>：Package Local</li>
</ul>
<p>而且对于方法而言，可以通过 <code>in</code>，<code>inout</code> 或者 <code>out</code> 标识参数的意义：</p>
<ul>
<li><code>in</code>: 该参数仅作为输入参数，不应该被修改；</li>
<li><code>inout</code>: 该参数即可作为输入参数，也可以被内部修改；</li>
<li><code>out</code>: 该参数仅用于作为输出参数存储库，就像传入一个地址，然后内部可以对其进行赋值；</li>
</ul>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-myclass.png" class="">

<p>就像现实世界中不同对象之间有不同的关系一样，类图中也有描述不同类之间关系的方式，一般存在六种关系，分别是关联，继承，实现，依赖，聚合和组合。</p>
<p>例如，学生从老师那里学习知识，这种关系就可以表示位简单的关联关系，在表示的时候使用一个联系表示即可，也可以适当添加描述信息：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-student-tutor.png" class="">

<p>继承有时候也可以称为泛化，用一个空心箭头从子类指向父类，父类可能是抽象类或者具体类：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-relation-inherit.png" class="">

<p>实现一般是指具体类型和接口之间关系，用一个虚线实心箭头表示：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-relationships-realization.png" class="">

<p>当一个对象在其方法中使用另一个类的对象，并且未存储在任何字段中时，就表示存在依赖关系，例如，<code>Person</code> 有一个方法 <code>Read</code> 接收一个 <code>Book</code> 的实例 <code>book</code> 作为参数，调用 <code>Book</code> 的 <code>getknowledge</code> 方法获取知识：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-relationships-dependency.png" class="">

<p>聚合和组合比较相近，都表示一对多的关系，而聚合通常用来表示用类的聚合，而组合表示整体和部分的关系；例如学校有很多老师，这种表示聚合关系；而学校也有很多不同的学院，计算机学院，土木工程等，这种表示组合关系，不同类型；在表示上聚合使用空心菱形箭头，组合使用实心菱形箭头表示。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-Class-relationships-aggr-composition.png" class="">

<p>类图是UML 结构图，它在类和 接口 级别显示设计系统的结构 ，显示它们的特性、 约束 和关系—— 关联、 泛化、 依赖等。常见的类图有：领域模型图、实现类图。</p>
<p>领域模型图:</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_1.png" class="">

<p>实现类图:</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_2.png" class="">

<h5 id="标准UML类的构造形态"><a href="#标准UML类的构造形态" class="headerlink" title="标准UML类的构造形态"></a>标准UML类的构造形态</h5><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>«Auxiliary»</code></td>
<td align="left">辅助类是支持核心或基础类的类，通常通过实现辅助逻辑或控制流来支持。 辅助支持的类可以使用焦点类显式定义，也可以通过依赖关系隐式定义。辅助类通常用于在设计阶段指定组件的辅助业务逻辑或控制流。</td>
</tr>
<tr>
<td align="center"><code>«Focus»</code></td>
<td align="left">焦点是定义一个或多个支持类的核心逻辑或控制流的类。 支持类可以使用辅助类显式定义，也可以通过依赖关系隐式定义。焦点类通常用于在设计阶段指定组件的核心业务逻辑或控制流。</td>
</tr>
<tr>
<td align="center"><code>«ImplementationClass»</code></td>
<td align="left">在某些编程语言（例如 <code>C++、Smalltalk、Java</code>）中类的实现，其中一个实例不能有多个类。这与 <code>UML</code> 类相反，在 <code>UML</code> 类中，一个实例可能同时具有多个类，并且随着时间的推移可能会获得或丢失类，而一个对象可能会动态地具有多个类。一个实现类可以实现多种不同的类型。 实现类的物理属性和关联不必与其实现的任何分类器的物理属性和关联相同，并且实现类可以根据其物理属性和关联为其操作提供方法。</td>
</tr>
<tr>
<td align="center"><code>«Metaclass»</code></td>
<td align="left">其实例也是类。</td>
</tr>
<tr>
<td align="center"><code>«Type»</code></td>
<td align="left">类型是指定对象域以及适用于对象的操作的类，但不定义这些对象的物理实现。类型可以具有属性和关联。 类型操作的行为规范可以使用例如活动图来表达。 一个对象最多可以有一个实现类，但是它可以符合多种不同的类型。</td>
</tr>
<tr>
<td align="center"><code>«Utility»</code></td>
<td align="left">工具类是仅具有类范围的静态属性和操作的类。 因此，工具类通常没有实例。</td>
</tr>
</tbody></table>
<h5 id="类的模版"><a href="#类的模版" class="headerlink" title="类的模版"></a>类的模版</h5><p><code>UML</code> 类可以被模板化或绑定。下面的示例显示了具有两个形式模板参数的模板类 <code>Array</code>。 第一个模板参数 <code>T</code> 是不受约束的类模板参数。 第二模板参数<code>n</code>是整数表达式模板参数。绑定类 <code>Customers</code> 的模板绑定将无约束类 <code>T</code> 替换为类 <code>Customer</code>，边界 <code>n</code> 替换为整数值 <code>24</code>。因此，绑定类 <code>Customers</code> 是包含 <code>24</code> 个 <code>Customer</code> 类对象的数组。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_3.png" class="">

<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口是一个 分类器 ，声明一组连贯的公共功能和义务。接口指定契约。实现（实现）接口的任何分类器实例都必须履行该契约，从而提供契约所描述的服务。由于接口是声明，因此它们不可实例化。相反，接口规范是通过可实例化分类器的实例来实现的，这意味着可实例化分类器呈现出符合接口规范的公共外观。任何给定的分类器都可以实现多个接口。接口可以由许多不同的分类器来实现。接口可以使用矩形符号来显示，并且名称前面带有关键字<code>“interface”</code>。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_4.png" class="">

<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p><strong>数据类型</strong>是一个分类器(类似于类), 其实例“仅通过其值来标识”。数据类型的典型用途是表示业务领域的 值类型、编程语言的原始类型或结构化类型。例如，日期&#x2F;时间、性别、货币、地址可以定义为数据类型。数据类型实例的所有副本以及具有相同值的该数据类型的任何实例都被视为相等实例。数据类型使用带有关键字<code>&lt;&lt;dataType&gt;&gt;</code>的矩形符号显示。数据类型可以包含 支持结构化数据类型 建模的属性 和操作。如果结构相同并且相应属性的值相等，则结构化数据类型的实例被认为是相等的。当数据类型被引用时，例如，作为类属性的类型，它简单地显示为数据类型的名称。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_5.png" class="">

<p><strong>原始数据类型</strong>是表示原子数据值（即没有部分或结构的值）的数据类型。原始数据类型可以具有在 <code>UML</code> 外部定义的精确语义和操作，例如数学上的, 标准 <code>UML</code> 原始数据类型包括: <code>Boolean、Integer、UnlimitedNatural、String、Real</code>，原始数据类型的实例没有标识。如果两个实例具有相同的表示，那么它们是无法区分的。原始数据类型在原始数据类型名称上方或之前有关键字<code>&lt;&lt;primitive&gt;&gt;</code>。</p>
<p><strong>枚举</strong>是一种数据类型，其值在模型中作为用户定义的枚举文字。可以使用带有关键字<code>«enumeration»</code> 的分类器符号（矩形）来显示枚举。枚举的名称位于上部隔间中。列出枚举属性的隔间放置在名称隔间下方。列出枚举操作的隔间放置在属性隔间下方。可以将枚举文字列表逐行放置在底部隔间中。属性和操作隔间可以被限制，并且通常如果它们是空的则被限制。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_6.png" class="">

<h5 id="UML属性"><a href="#UML属性" class="headerlink" title="UML属性"></a>UML属性</h5><p>属性是一种结构特征，属性表示分类器结构的某些命名部分。例如，<code>Patient</code> 类可以将 <code>id</code>、姓名、性别、出生日期等作为其属性。创建分类器的实例时，每个非静态属性都成为该实例状态的一部分，并通过将属性名称映射到构成实例状态的一个或多个特定值来实现。每个属性的值都有特定的类型，并分配在实例的槽中或与该实例关联。</p>
<p>属性的一般语法如下所示：</p>
<p>属性::&#x3D; [可见性] [‘&#x2F;‘]   属性名称   [ ‘:’属性类型 ] [ ‘[‘多重性 ‘]’ ] [ ‘&#x3D;’默认值] [属性修饰符]<br>可见性::&#x3D; ‘ +’ | ‘~’| ‘#’| ‘-‘<br>属性修饰符::&#x3D; ‘{‘属性修饰符   [ ‘,’   属性修饰符] * ‘}’<br>属性修饰符::&#x3D; ‘id’ | ‘只读’ | ‘已订购’ | ( ‘seq’ | ‘序列’ ) | ‘独特’| ‘非独特’ | ‘联盟’ | “重新定义”   属性名称  | ‘子集’   属性名称  |  属性约束  </p>
<p>请注意，没有默认的可见性。此外，即使可见性在模型中具有某些值，也可能会抑制在图表上显示可见性。因此，如果图表上未显示可见性，则说明它未指定或被限制。正斜杠<code>“/”</code>表示该属性是 派生的。属性类型是由分类器名称表示，属性可以有多重性。多重界限，限制属性值集合的大小。默认情况下最大界限为 1。默认值 选项是属性的默认值或值的表达式。属性修饰符：</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="left">属性是拥有该属性的类的标识符的一部分。</td>
</tr>
<tr>
<td align="center">readOnly</td>
<td align="left">属性是只读的（isReadOnly &#x3D; true）。</td>
</tr>
<tr>
<td align="center">ordered</td>
<td align="left">属性是有序的 (isOrdered &#x3D; true)。</td>
</tr>
<tr>
<td align="center">nonunique</td>
<td align="left">多值属性没有重复值 (isUnique &#x3D; true)。</td>
</tr>
<tr>
<td align="center">nonunique</td>
<td align="left">多值属性可能具有重复值 (isUnique &#x3D; false)。</td>
</tr>
<tr>
<td align="center">sequence (or seq)</td>
<td align="left">属性是一个有序包（isUnique &#x3D; false 且 isOrdered &#x3D; true）。</td>
</tr>
<tr>
<td align="center">union</td>
<td align="left">属性是其子集的派生联合。</td>
</tr>
<tr>
<td align="center">redefines property-name</td>
<td align="left">Property 重新定义了名为property-name的继承属性。</td>
</tr>
<tr>
<td align="center">subsets property-name</td>
<td align="left">Property 是名为property-name的属性的子集。</td>
</tr>
<tr>
<td align="center">property-constraint</td>
<td align="left">适用于属性的约束</td>
</tr>
</tbody></table>
<p>分类器拥有的属性 表示分类器的属性。属性的上下文是所属分类器。允许使用关联表示法来显示属性:</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_7.png" class="">

<p>关联的所有权结束于关联的 <code>Patient</code> 类，由小实心圆圈（也称为点）以图形方式表示。另请注意，连接到类的关联端没有修饰。当属性是关联端时，属性的一个或多个值与关联另一端的一个或多个实例相关。关联拥有的属性代表关联的属性，并命名为<code>member end</code>。在关联端上下文中是关联的另一端或两端的类型集。当关联端由分类器 拥有时，分类器 属性可以表示该关联端。关联分类器对关联端的所有权可以通过小实心圆（又名点） 以图形方式表示 。点绘制在直线与分类器相交的点处。它可以解释为表明该模型包含由点所触及的分类器表示的类型的属性。该属性由另一端的分类器拥有。</p>
<h5 id="UML操作"><a href="#UML操作" class="headerlink" title="UML操作"></a>UML操作</h5><p>操作是一种行为特征，可能由接口、 数据类型或类 拥有。操作也可以被 模板化 并用作模板参数。可以在其特征分类器的实例上直接调用操作。 该操作指定此类调用的 名称、类型、参数和约束。<br><code>operation ::= [ visibility ]   signature   [ oper-properties ]</code>。 操作的可见性是可选的，如果存在，它应该是以下之一：<code>visibility ::= &#39;+&#39; | &#39;-&#39;| &#39;#&#39;| &#39;~&#39;</code> ，操作的签名具有可选的参数列表和返回规范。</p>
<p><code>signature ::= operation-name  &#39;(&#39;  [ parameter-list ]   &#39;)&#39;   [ &#39;:&#39; return-spec ]</code></p>
<p><code>operation-name</code>是操作的名称。参数列表是操作的参数列表，格式如下：</p>
<p><code>parameter-list ::= parameter   [   &#39;,&#39;   parameter   ]*</code><br><code>parameter ::= [ direction   ]   parm-name &#39;:&#39; type-expression   [   &#39;[&#39; multiplicity &#39;]&#39;   ]   [ &#39;=&#39; default ]   [ parm-properties ]</code></p>
<p><code>parm-name</code>是参数的名称。<code>type-expression</code>是指定参数类型的表达式。重数是参数的重数。<code>Default</code> 是一个表达式，定义参数默认值的值规范。</p>
<p>操作的属性是可选的，如果存在应遵循规则：</p>
<p><code>oper-properties ::= &#39;&#123;&#39; oper-property   [   &#39;,&#39; oper-property ]*   &#39;&#125;&#39;</code><br><code>oper-property ::=   &#39;redefines&#39;   oper-name   |   &#39;query&#39;   |   &#39;ordered&#39;   |   &#39;unique&#39;   |   oper-constraint</code></p>
<p>操作的属性一般定义为：</p>
<ul>
<li><code>redefines oper-name</code> - 操作重新定义由操作名标识的继承操作；</li>
<li><code>query</code> - 操作不会改变系统的状态；</li>
<li><code>ordered</code> - 返回参数的值是有序的；</li>
<li><code>unique</code> - 参数返回的值没有重复项；</li>
<li><code>oper-constraint</code> - 是应用于操作的约束。</li>
</ul>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_8.png" class="">

<h5 id="UML多重性和多重性元素"><a href="#UML多重性和多重性元素" class="headerlink" title="UML多重性和多重性元素"></a>UML多重性和多重性元素</h5><p><code>UML</code>中的多重性允许指定某些元素集合的基数（即元素数量）。多重性元素 定义了一些元素的集合，并且包括多重性以及集合元素的顺序和唯一性的规范。多重性是某些元素集合的基数（即元素数量）的定义，通过提供非负整数的包含区间来指定所描述元素的允许实例数。重数区间有一些下限和上限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multiplicity-range ::= [ lower-bound &#x27;..&#x27; ] upper-bound</span><br><span class="line">lower-bound ::= natural-value-specification</span><br><span class="line">upper-bound ::= natural-value-specification | &#x27;*&#x27;</span><br></pre></td></tr></table></figure>
<p>下限和上限可以是自然常量或计算为自然（非负）数的常量表达式。上限也可以指定为星号“*”，表示元素数量不受限制。上限应大于或等于下限。</p>
<table>
<thead>
<tr>
<th align="center">多重性</th>
<th align="left">选项</th>
<th align="left">基数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0..0</td>
<td align="left">0</td>
<td align="left">集合必须为空</td>
</tr>
<tr>
<td align="center">0..1</td>
<td align="left"></td>
<td align="left">无实例或只有一个实例</td>
</tr>
<tr>
<td align="center">1..1</td>
<td align="left">1</td>
<td align="left">恰好有一个实例</td>
</tr>
<tr>
<td align="center">0..*</td>
<td align="left"></td>
<td align="left">零个或多个实例</td>
</tr>
<tr>
<td align="center">1..*</td>
<td align="left"></td>
<td align="left">至少一个实例</td>
</tr>
<tr>
<td align="center">5..5</td>
<td align="left">5</td>
<td align="left">恰好 5 个实例</td>
</tr>
<tr>
<td align="center">m..n</td>
<td align="left"></td>
<td align="left">至少 m 但不超过 n 个实例</td>
</tr>
</tbody></table>
<p>如果多重性与符号为文本字符串（例如类属性） 的元素关联，则多重性范围将作为该文本字符串的一部分放在方括号内。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_9.png" class="">

<p>如果多重性与显示为符号（例如用例或类） 的元素关联 ，则显示多重性范围时不带方括号。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_10.png" class="">

<p><strong>多重性元素</strong>定义了一些元素的集合，并且包括多重性 以及集合元素的顺序和唯一性的规范。多重性元素的一些子类是 结构特征、 操作、 参数、引脚。集合属性可以使用以下非规范语法规则来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">collection-type ::= multiplicity-range  [ &#x27;&#123;&#x27; collection-options &#x27;&#125;&#x27; ]</span><br></pre></td></tr></table></figure>
<p>集合选项指定元素实例化中的值是否应该是唯一的和&#x2F;或有序的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">collection-options ::= order-designator [ &#x27;,&#x27;  uniqueness-designator ] |  uniqueness-designator [ &#x27;,&#x27;  order-designator ]</span><br><span class="line">order-designator ::= &#x27;ordered&#x27; | &#x27;unordered&#x27;</span><br><span class="line">uniqueness-designator ::= &#x27;unique&#x27; | &#x27;nonunique&#x27;</span><br></pre></td></tr></table></figure>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_11.png" class="">

<p>如果多重性元素是多值的并且指定为有序的，则该元素的实例化中的值的集合是按顺序排序的。默认情况下，集合没有排序。如果多重性元素是多值的并且指定为<code>unique</code>，则该元素实例化中的值集合中的每个值都必须是唯一的。默认情况下，集合中的每个值都是唯一的。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_12.png" class="">

<h5 id="UML约束"><a href="#UML约束" class="headerlink" title="UML约束"></a>UML约束</h5><p>约束是一个可封装的元素，它表示与某个元素 （拥有该约束）或多个元素相关的某些条件、限制或断言。约束通常由布尔表达式指定，该表达式的计算结果必须为 <code>true</code> 或 <code>false</code>。系统的正确设计必须满足约束（即评估为<code>true</code>）。约束通常用于类图上的各种元素。一般来说，约束有多种可能的所有者。所属元素必须有权访问受约束元素以验证约束。约束的所有者将决定何时评估约束。例如，操作 可以具有前置条件和&#x2F;或后置条件约束。约束可以有一个可选名称，但通常是匿名的。约束根据以下语法显示为花括号中的文本字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constraint ::= &#x27;&#123;&#x27; [  name &#x27;:&#x27; ] boolean-expression &#x27;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><code>OCL</code>是 <code>UML</code> 中预定义的约束语言，但如果使用某些 UML 工具来绘制图表，则可以应用该工具支持的任何约束语言。对于符号为文本字符串（例如类属性）的元素，约束字符串属性后的花括号中定义。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_13.png" class="">

<p>对于应用于单个元素（例如类 或关联路径）的约束，约束字符串可以放置在元素的符号附近，最好靠近名称（如果有）。<code>UML</code> 工具必须能够确定受约束的元素。对于应用于两个元素（例如两个类或两个关联）的约束，该约束可以显示为大括号中的约束字符串标记的元素之间的 虚线。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_14.png" class="">

<p>约束字符串可以放置在注释符号中（与注释所用的相同），并通过虚线附加到受约束元素。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_15.png" class="">

<h5 id="UML关联"><a href="#UML关联" class="headerlink" title="UML关联"></a>UML关联</h5><p>关联是分类器之间的一种关系 ，用于表明分类器的实例可以相互链接，也可以在逻辑上或物理上合并成某种聚合。<code>UML</code>规范将关联归类为语义关系。其他一些 <code>UML</code>源也将关联归类为结构关系。关联 可以用于不同类型的 <code>UML</code> 结构图：</p>
<ul>
<li>类图关联</li>
<li>用例图关联</li>
<li>部署图构件关联</li>
<li>部署图通信路径。</li>
</ul>
<p>与关联相关的有几个概念：</p>
<ul>
<li>关联最终所有权</li>
<li>导航性</li>
<li>关联性</li>
<li>聚合类型</li>
</ul>
<p>二元关联关联两个类型实例。它通常呈现为连接两个分类器的实线，或将单个分类器连接到其自身的实线（两端是不同的）。该线可以由一个或多个连接的线段组成。链接是关联的一个实例。它是一个元组，关联的每一端都有一个值，其中每个值都是该端类型的实例。关联至少有两个末端，由属性（末端属性）表示。链接使用与关联相同的符号来呈现。实线连接实例 而不是分类器。链接名称可以显示为下划线，但这不是必需的。可以显示 结束名称（角色）和导航箭头。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_16.png" class="">

<h5 id="UML泛化"><a href="#UML泛化" class="headerlink" title="UML泛化"></a>UML泛化</h5><p>泛化是 更一般的 分类器（超类）和更具体的分类器（子类） 之间的二元分类（即与分类相关） 定向关系。特定分类器的每个实例也是通用分类器的间接实例，因此我们可以说“患者是一个人”，“储蓄帐户是一个帐户”等。正因为如此，泛化关系也被非正式地称为“是”一种“关系”。泛化归特定分类器所有。括显示为一条线，在表示所涉及分类器的符号之间带有空心三角形作为箭头。箭头指向代表通用分类器的符号。这种表示法称为“单独目标样式”。</p>
<h5 id="UML依赖"><a href="#UML依赖" class="headerlink" title="UML依赖"></a>UML依赖</h5><p>依赖性是一种有向关系 ，用于表明某个 <code>UML</code> 元素或一组元素需要、需要或依赖于其他模型元素来进行规范或实现。因此，依赖性被称为供应商-客户关系，其中供应商向客户提供某些东西，因此客户在某种意义上是不完整的，同时在语义或结构上依赖于供应商元素。供应商的修改可能会影响客户元素。依赖关系是命名元素 之间的关系 ，在 <code>UML</code> 中包括许多不同的元素，例如 类、 接口、 组件、 构件、 包等。下图显示了几种依赖关系。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_17.png" class="">

<ul>
<li><code>Usage</code> 是一种依赖关系，其中一个命名元素 （客户端）需要另一个命名元素（供应商）来完成其完整定义或实现。</li>
<li><code>Abstraction</code> 涉及代表相同概念但处于不同抽象级别的两个元素 。</li>
<li><code>Deployment</code> 是一种依赖关系， 它显示工件到部署目标的分配。</li>
</ul>
<p>依赖项通常显示为虚线箭头，从尾部的客户端（依赖项）指向箭头处的供应商（提供者）。箭头可以标有可选的构造型和可选的名称。因为箭头的方向与我们通常期望的方向相反，所以我通常将其定型为客户“依赖于”供应商。可以为客户或供应商提供一组元素。在这种情况下，一个或多个尾部位于客户端的箭头连接到一个或多个头部位于供应商的箭头的尾部。如果需要，可以在连接处放置一个小点。应在连接点附上有关依赖性的注释。</p>
<p><code>Required interface</code>的接口指定分类器执行其功能并履行其对客户端的义务所需的服务。它由分类器和相应接口之间的使用依赖关系来指定。从分类器到接口的使用依赖性通过用半圆或插座表示接口来显示，用接口名称标记，用实线连接到需要该接口的分类器。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_18.png" class="">

<p>如果接口使用矩形表示法表示，则接口使用 依赖关系用依赖箭头表示。箭头尾部的分类器 使用（需要）箭头头部的接口。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_19.png" class="">

<h5 id="UML嵌套分类器"><a href="#UML嵌套分类器" class="headerlink" title="UML嵌套分类器"></a>UML嵌套分类器</h5><p>UML中的类或接口可以用作其他分类器的命名空间。这种分类器的嵌套将类或接口中定义的分类器的可见性限制在命名空间的范围内。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_20.png" class="">

<p>嵌套分类器是在类或接口（的命名空间）内定义的分类器。请注意，<code>UML 2.x</code> 规范使用“定义于”、“嵌套于”和“拥有于”作为同义词，这会导致一些混乱。命名空间和嵌套分类器之间的关系称为命名空间所有权。</p>
<h5 id="UML类图实例-图书馆领域模型"><a href="#UML类图实例-图书馆领域模型" class="headerlink" title="UML类图实例 - 图书馆领域模型"></a>UML类图实例 - 图书馆领域模型</h5><p>图书馆域模型描述了可在分析阶段使用的主要类和关系，以更好地理解集成图书馆系统（<code>ILS</code>）（也称为 图书馆管理系统（<code>LMS</code>） 的域区域。每个实体图书馆的物品——书籍、磁带、<code>CD、DVD</code> 等都可以有自己的物品编号。为了支持它，物品可能带有条形码。条形码的目的是提供唯一且可扫描的标识符，将条形码物理项目链接到目录中的电子记录。条形码必须物理附加到物品上，并且条形码编号输入到电子物品记录中的相应字段中。图书馆物品上的条形码可以被<code>RFID</code>标签取代。<code>RFID</code>标签可以包含物品的标识符、标题、材料类型等。它由<code>RFID</code>阅读器读取，无需打开书本封面或<code>CD/DVD</code>盒用条形码阅读器扫描。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_21.png" class="" title="库域模型的UML类图示例">

<p>图书馆图书属性<code>ISBN</code>和主题 继承自<code>Book</code>，并以前置 插入符号<code>“^”</code>显示。<code>title</code>属性显式地 重新定义 <code>name</code>。虽然属性的类型相同，但名称不同。<code>lang</code>属性被显式地重新定义为不同的类型。原始类型是自由文本字符串，而重新定义的属性是更具体（例如枚举）的语言类。在这种情况下，我们使用显式重定义，因为属性类型<code>String和Language</code>不相关。语言是 枚举类型。图书馆对于哪些内容可以借阅以及哪些内容仅供参考有一些规定。还规定了顾客可以借阅多少本书以及可以保留多少本书的规则。图书馆图书属性<code>loanPeriod、dueDate和isOverdue</code>是派生的。图书馆图书的借阅期限（借阅期限）取决于图书馆政策，并根据图书种类和借阅者的不同而有所不同。例如，在大学图书馆，本科生可以借书 <code>30</code> 天，研究生可以借书一个季度，教职员工可以借书一年。在公共图书馆，一本书的正常借阅期限可能是 <code>3</code> 周，而新书的借阅期限可能会缩短至 <code>2</code> 周。还书到期日根据借阅日期和借阅期限计算。如果截止日期超过当前日期，则默认为 <code>false</code> 的 <code>isOverdue</code>布尔值将设置为<code>true</code>。图书馆目录为图书馆顾客和工作人员提供有关图书馆馆藏的所有信息源的访问权限，允许按特定作者、特定主题或图书馆拥有的特定格式进行搜索。它告诉用户在哪里可以找到满足其特定需求的材料。</p>
<h5 id="UML类图实例-网上购物领域模型"><a href="#UML类图实例-网上购物领域模型" class="headerlink" title="UML类图实例 - 网上购物领域模型"></a>UML类图实例 - 网上购物领域模型</h5><p>这里我们提供了一个<code>UML</code>类图的示例 ，它显示了在线购物的域模型。该图的目的是介绍网上购物的一些常用术语“词典” —— 客户、网络用户、帐户、购物车、产品、订单、付款等以及之间的关系。它可以用作业务分析师和软件开发人员之间的沟通。每个客户都有唯一的<code>ID</code>，并且与一个帐户 相关联。帐户拥有购物车和订单。客户可以注册为网络用户，以便能够在线购买商品。客户可以没有网络用户，因为也可以通过电话或从目录订购进行购买。<code>Web</code>用户具有登录名，该登录名也用作唯一 <code>ID</code>。<code>Web</code>用户可能处于多种状态 - 新的、活跃的、临时停用的或被禁止的，并且链接到购物车。购物车属于帐户。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/class-diagram_22.png" class="" title="在线购物领域UML类图示例">

<p>账户拥有客户订单。客户可能没有订单。客户订单已排序且唯一。每个订单可能涉及多笔付款，也可能没有。每笔付款都有唯一的<code>ID</code>，并且与一个帐户相关。每个订单都有当前订单状态。订单和购物车都有关联到特定产品项目。每个产品项目都归属于一种产品。一个产品可以与许多产品项目相关联，也可以没有任何产品项目关联。</p>
<h4 id="状态图（State-Diagram）"><a href="#状态图（State-Diagram）" class="headerlink" title="状态图（State Diagram）"></a>状态图（State Diagram）</h4><p><code>UML</code> 状态图是图表本身的名称，主要用于描述对象具有的各种状态、状态之间的转换过程以及触发状态转换的各种事件和条件。UML 状态图描述了一个状态机，可以被定义为一台机器，它定义了一个对象，这些状态控制外部或内部事件的不同状态，状态机由状态、转换、事件、活动和动作五部分组成。</p>
<ul>
<li>状态：状态指的是对象在其生命周期中的一种状况，处于某个特定状态中的对象必然会满足某些条件、执行某些动作或者是等待某些事件。一个状态的生命周期是一个有限的时间阶段；</li>
<li>转换：转换指的是两个不同状态之间的一种关系，表明对象在第一个状态中执行一定的动作，并且在满足某个特定条件下由某个事件触发进入第二个状态；</li>
<li>事件：事件指的是发生在时间和空间上的对状态机来讲有意义的那些事情。事件通常会引起状态的变迁，促使状态机从一种状态切换到另一种状态，如信号、定时器，某个条件被处罚等；</li>
<li>活动：活动指的是状态机中进行的非原子操作；</li>
<li>动作：动作指的是状态机中可以执行的哪些原子操作。所谓原子操作，指的是他们在运行的过程中不能被其他消息中断，必须一直执行下去，以至最终导致状态的变更或者返回一个值；</li>
</ul>
<p>一个状态图（Statechart Diagram）本质上就是一个状态机，或者是状态机的特殊情况，它基本上是一个状态机中元素的一个投影，这也就意味着状态图包括状态机的所有特征。</p>
<p>状态图描述了一个实体基于事件反映的动态行为，显示了该实体是如何根据当前所处的状态对不同的事件作出反应的。</p>
<p>在UML中，状态图由表示状态的节点和表示状态之间转换的带箭头的直线组成。状态的转换由事件触发，状态和状态之间由转换箭头连接。每一个状态图都有一个初始状态（实心圆），用来表示状态机的开始。还有一个中止状态（半实心圆），用来表示状态机的终止。状态图主要由元素状态、转换、初始状态、中止状态和判定等组成。</p>
<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>状态用于对实体在其生命周期中的各种状况进行建模，一个实体总是在有限的一段时间内保持一个状态。状态由一个带圆角的矩形表示，状态的描绘素应该包括名称、入口和出口动作、内部转换和嵌套状态。如下图，为一个简单状态：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/uml-state-diagram-state.png" class="">

<ul>
<li>状态名指的是状态的名字，通常用字符串表示，其中每个单词的首字母大写。状态名可以包含任意数量的字母、数字和除了冒号“：”以外的一些字符，可以较长，甚至连续几行。但是一定要注意一个状态的名称在状态图所在的上下文中应该是唯一的，能够把该状态和其他状态区分开。</li>
<li>入口和出口动作一个状态可以具有或者没有入口和出口动作。入口和出口动作分别指的是进入和退出一个状态时所执行的“边界”动作。</li>
<li>内部转换指的是不导致状态改变的转换。内部转换中可以包含进入或者退出该状态应该执行的活动或动作。</li>
<li>嵌套状态状态分为简单状态（Simple State）和组成状态（Composite State）。简单状态是指在语义上不可分解的、对象保持一定属性值的状况，简单状态不包含其他状态：而组成状态是指内部嵌套有子状态的状态，在组成状态的嵌套状态图部分包含的就是此状态的子状态。</li>
</ul>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><p>在UML的状态建模机制中，转换用带箭头的直线表示，一端连接源状态，箭头指向目标状态。转换还可以标注与此转换相关的选项，如事件、监护条件和动作等，如下图所示。注意：如果转换上没有标注触发转换的事件，则表示此转换自动进行。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/uml-state-diagram-state-transmit.png" class="">

<p>在状态转换机制中需要注意的五个概念如下：</p>
<ul>
<li>状态源（Source State）：指的是激活转换之间对象处于的状态。如果一个一个状态处于源状态，当它接收到转换的触发事件或满足监护条件时，就激活了一个离开的转换。</li>
<li>目标状态（Event State）：指的是转换完成后对象所处的状态。</li>
<li>事件触发器（Event Trigger）：指的是引起源状态转换的事件。事件不是持续发生的，它只发生在时间的一点上，对象接收到事件，导致源状态发生变化，激活转换并使监护条件得到满足。</li>
<li>监护条件（Guard Condition）：是一个布尔表达式。当接收到触发事件要触发转换时，要对该表达式求值。如果表达式为真，则激活转换：如果表达式为假，则不激活转换，所接收到的触发事件丢失。</li>
<li>动作（Action）：是一个可执行的原子计算。</li>
</ul>
<h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>每个状态图都应该有一个初始状态，它代表状态图的起始位置。初始状态是一个伪状态（一个和普通状态有连接的假状态），对象不可能保持在初始状态，必须要有一个输出的无触发转换（没有事件触发器的转换）。通常初始状态上的转换是无监护条件的，并且初始状态只能作为转换的源，而不能作为转换的目标。在UML中，一个状态图只能有一个初始状态，用一个实心圆表示。</p>
<h5 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h5><p>终止状态是一个状态图的终点，一个状态图可以拥有一个或者多个终止状态。对象可以保持在终止状态，但是终止状态不可能有任何形式的和触发转换，它的目的就是为了激发封装状态上的转换过程的结束。因此，终止状态只能作为转换的目标而不能作为转换的源，在UML中，终止状态用一个含有实心圆的空心圆表示。</p>
<h5 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h5><p>活动图和状态图中都有需要根据给定条件进行判断，然后根据不同的判断结果进行不同转换的情况。实际就是工作流在此处按监护条件的取值发生分支，在UML中，判定用空心菱形表示。</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-State.png" class="" title="状态图">

<h4 id="序列图（Sequence-Diagram）"><a href="#序列图（Sequence-Diagram）" class="headerlink" title="序列图（Sequence Diagram）"></a>序列图（Sequence Diagram）</h4><p>序列图也叫时序图，是交互图的一种，用于捕获系统运行中对象之间有时间顺序的交互，是由生命线和消息组成。时序图将交互关系表示为一个二维图。纵向是时间轴，时间沿竖线向下延伸。横向轴代表了在协作中各独立对象的类元角色。类元角色用生命线表示。当对象存在时，角色用一条虚线表示，当对象的过程处于激活状态时，生命线是一个双道线。消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。</p>
<ul>
<li><p>Actor（角色：代表某个由人或者设备扮演的角色，它不一定代表某个具体的实体，一般由一个小人代替；</p>
</li>
<li><p>Lifetime（生命线）：在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。</p>
</li>
<li><p>Activation（活动条&#x2F;激活）：在生命线的徐线上可以用活动条表示某种行为的开始和结束，一般用小矩形来表示。</p>
</li>
<li><p>同步消息：意味着阻塞和等待。如：A向B 发送一个消息后，对象A 必须一直等到B执行完成后返回才能继续往下执行。这就是同步消息。用实心箭头表示</p>
</li>
<li><p>异步消息：就意味着是非阻塞。如：A向B发送消息后，直接可以执行下面代码，无需等待B的执行。</p>
</li>
<li><p>返回消息：在从A发送消息到达B之后，B的回复消息称之为返回消息。</p>
</li>
</ul>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/uml-sequence-diagram-message.png" class="">

<p>UML在2.0时在时序图中加入了交互框。交互框用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/uml-2.0-interaction-1.png" class="">
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/uml-2.0-interaction-2.png" class="">

<p>举几个示例：</p>
<img data-src="/2022/05/05/Design-Patterns/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML-interaction-loop-alt-opt.png" class="">

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.youtube.com/watch?v=WnMQ8HlmeXc">UML Diagrams Full Course (Unified Modeling Language)</a></li>
<li><a href="https://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html">UML建模之状态图（Statechart Diagram）</a></li>
<li><a href="https://www.w3cschool.cn/uml_tutorial/uml_tutorial-jnf328y2.html">UML状态图</a></li>
<li><a href="https://segmentfault.com/a/1190000040836364">UML时序图&#x2F;序列图</a></li>
</ol>
]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID 设计原则</title>
    <url>/2022/05/03/Design-Patterns/solid-design-principles/</url>
    <content><![CDATA[<p><code>SOLID</code> 设计原则并非单纯的一个原则，它实际上包含5个设计原则：单一职责原则、开闭原则、里氏替换替换原则，接口隔离原则和依赖反转原则。</p>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（<code>SRP</code>）</h3><p><code>SRP(Single Responsibility Principle)</code> 这个原则的意思是一个类或者一个模块只负责完成一个功能。所以，这里有两种理解方式，一种理解是把模块看做比类更加抽象的概念，类也可以看做是模块。另一种理解是把类看做是比类更加粗粒度的代码块，模块中包含多个类。</p>
<p>单一职责原则定义非常简单，不难理解。一个类只负责完成一个职责或者功能，也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个雷包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。举例来讲，如果一个类包含了用户和订单的一些操作，而用户和订单又是独立的业务领域模型，我们将它们放到一起就违反了单一职责原则，我们就需要进行拆分。</p>
<p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对于同一个类的职责是否单一，可能会有不用的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，代码行数过度，函数或者属性过多都可能是违反单一职责原则的表象。</p>
<p>例如，下面的 <code>UserInfo</code> 类，这个类里面除了用户的基本信息，还有地址信息。或许一个观点是都属于用户的基本信息应该放在一起，另一个观点是可以拆分出 <code>UserAddress</code> 类，<code>UserInfo</code> 只保留除 <code>Address</code> 之外的其他信息，拆分之后两个类的职责更加单一。是否应该拆分，取决于具体情况，如果实际中地址信息和基本信息总是同时出现，那放在一起没有问题。但是如果地址信息单独在其他模块中使用，就应该单独抽象成 <code>UserAddress</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String telephone;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> String provinveOfAddress;</span><br><span class="line">  <span class="keyword">private</span> String cityOfAddress;</span><br><span class="line">  <span class="keyword">private</span> String regionOfAddress;</span><br><span class="line">  <span class="keyword">private</span> String detailedAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单一职责原则指导设计粒度较小的类，职责清晰的类，类的依赖以及被依赖的其他类也很会变少，从而降低代码的耦合性，实现高内聚、低耦合。但是如果拆分的过细，可能会适得其反，影响代码的可维护性。</p>
<span id="more"></span>

<h3 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（<code>OCP</code>）</h3><p><code>OCP(Open Closed Principle)</code> 它的意思是软件实体应该对修改关闭，对扩展开放。详细描述就是，添加一个新功能应该是在已有代码基础上扩展代码（新增模块，类，方法等），而不是修改已有代码。</p>
<p>下面是一个 <code>API</code> 监控告警的例子，其中，<code>AlertRule</code> 存储告警规则，可以自由设置。<code>Notification</code> 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。<code>NotificationEmergencyLevel</code> 表示通知的紧急程度，包括 <code>SEVERE</code>（严重）、<code>URGENCY</code>（紧急）、<code>NORMAL</code>（普通）、<code>TRIVIAL</code>（无关紧要），不同的紧急程度对应不同的发送渠道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rule = rule;</span><br><span class="line">    <span class="built_in">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String api, <span class="type">long</span> requestCount, <span class="type">long</span> errorCount, <span class="type">long</span> durationOfSeconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码非常简单，业务逻辑主要集中在 <code>check()</code> 函数中。当接口的 <code>TPS</code> 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警。</p>
<p>现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。最能想到的则是下面的这种修改方案，主要的改动有两处：</p>
<ol>
<li>修改 <code>check()</code> 函数的入参，添加一个新的统计数据 <code>timeoutCount</code>，表示超时接口请求数；</li>
<li>在 <code>check()</code> 函数中添加新的告警逻辑；</li>
</ol>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略AlertRule/Notification属性和构造函数...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 改动一：添加参数timeoutCount</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String api, <span class="type">long</span> requestCount, <span class="type">long</span> errorCount, <span class="type">long</span> timeoutCount, <span class="type">long</span> durationOfSeconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeoutTps</span> <span class="operator">=</span> timeoutCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>这种修改方案存在两个问题：</p>
<ol>
<li>我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改；</li>
<li>另一方面，修改了 <code>check()</code> 函数，相应的单元测试都需要修改;</li>
</ol>
<p>这种代码的改动就是基于“修改”的方式来实现新功能，我们再来看一种基于 <code>OCP</code> 原则修改代码，但是这种修改需要对原有的代码进行重构，包含两方面：</p>
<ol>
<li>将 <code>check()</code> 函数的多个入参封装成 <code>ApiStatInfo</code> 类；</li>
<li>引入 <code>handler</code> 的概念，将 <code>if</code> 判断逻辑分散在各个 <code>handler</code> 中；</li>
</ol>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiStatInfo</span> &#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">protected</span> Notification notification;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rule = rule;</span><br><span class="line">    <span class="built_in">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码是对 <code>Alert</code> 的重构，我们再来看下，重构之后的 <code>Alert</code> 该如何使用呢？具体的使用代码我也写在这里了。其中，<code>ApplicationContext</code> 是一个单例类，负责 <code>Alert</code> 的创建、组装（<code>alertRule</code> 和 <code>notification</code> 的依赖注入）、初始化（添加 <code>handlers</code>）工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeBeans</span><span class="params">()</span> &#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> <span class="title class_">AlertRule</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> <span class="title class_">Alert</span>();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TpsAlertHandler</span>(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">ErrorAlertHandler</span>(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Alert <span class="title function_">getAlert</span><span class="params">()</span> &#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 饿汉式单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ApplicationContext</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationContext</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApiStatInfo</span> <span class="variable">apiStatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiStatInfo</span>();</span><br><span class="line">    <span class="comment">// ...省略设置apiStatInfo数据值的代码</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们就容易扩展多了，主要的改动有下面四处。</p>
<ol>
<li>第一处改动是：在 <code>ApiStatInfo</code> 类中添加新的属性 <code>timeoutCount</code>；</li>
<li>第二处改动是：添加新的 <code>TimeoutAlertHander </code>类；</li>
<li>第三处改动是：在 <code>ApplicationContext</code> 类的 <code>initializeBeans()</code> 方法中，往<code> alert</code> 对象中注册新的 <code>timeoutAlertHandler</code>；</li>
<li>第四处改动是：在使用 <code>Alert</code> 类的时候，需要给 <code>check()</code> 函数的入参 <code>apiStatInfo</code> 对象设置 <code>timeoutCount</code> 的值；</li>
</ol>
<p>完整代码如下所示：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiStatInfo</span> &#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> durationOfSeconds;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AlertHandler</span> &#123; <span class="comment">//代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="comment">// 改动二：添加新的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">//省略代码...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeBeans</span><span class="params">()</span> &#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> <span class="title class_">AlertRule</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> <span class="title class_">Alert</span>();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TpsAlertHandler</span>(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">ErrorAlertHandler</span>(alertRule, notification));</span><br><span class="line">    <span class="comment">// 改动三：注册handler</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TimeoutAlertHandler</span>(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他未改动代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApiStatInfo</span> <span class="variable">apiStatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiStatInfo</span>();</span><br><span class="line">    <span class="comment">// ...省略apiStatInfo的set字段代码</span></span><br><span class="line">    apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置tiemoutCount值</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 <code>handler</code> 类即可，不需要改动原来的 <code>check()</code> 函数的逻辑。而且，我们只需要为新的 <code>handler</code> 类添加单元测试，老的单元测试都不会失败，也不用修改。</p>
<p><code>OCP</code> 原则实际上不是不让改，而是通过添加属性、类、方法等方式扩展代码，这个原则实际上讲的就是代码的扩展性问题。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p>
<p>为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。</p>
<p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p>
<p>在识别出代码可变部分和不可变部分之后，我们要<strong>将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用</strong>。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p>
<p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：<strong>多态、依赖注入、基于接口而非实现编程</strong>，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。其中，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>我们要实现一个基于 <code>kafka</code> 来发送异步消息的功能。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（<code>Kafka</code>）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 <code>Kafka</code> 替换成 <code>RocketMQ</code>，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这一部分体现了抽象意识</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageQueue</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaMessageQueue</span> <span class="keyword">implements</span> <span class="title class_">MessageQueue</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQMessageQueue</span> <span class="keyword">implements</span> <span class="title class_">MessageQueue</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageFromatter</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonMessageFromatter</span> <span class="keyword">implements</span> <span class="title class_">MessageFromatter</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtoBufMessageFromatter</span> <span class="keyword">implements</span> <span class="title class_">MessageFromatter</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueue msgQueue; <span class="comment">// 基于接口而非实现编程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(MessageQueue msgQueue)</span> &#123; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="built_in">this</span>.msgQueue = msgQueue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// msgFormatter：多态、依赖注入</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(Notification notification, MessageFormatter msgFormatter)</span> &#123;</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（<code>LSP</code>）</h3><p><code>LSP(Liskov Substitution Principle)</code> ，这条原则用中文描述出来，是这样的：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<p>举例说明，如下代码中，父类 <code>Transporter</code> 使用 <code>org.apache.http</code> 库中的 <code>HttpClient</code> 类来传输网络数据。子类 <code>SecurityTransporter</code> 继承父类 <code>Transporter</code>，增加了额外的功能，支持传输 <code>appId</code> 和 <code>appToken</code> 安全认证信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(HttpClient httpClient)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.httpClient = httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String appId;</span><br><span class="line">  <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(httpClient);</span><br><span class="line">    <span class="built_in">this</span>.appId = appId;</span><br><span class="line">    <span class="built_in">this</span>.appToken = appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoFunction</span><span class="params">(Transporter transporter)</span> &#123;    </span><br><span class="line">    <span class="type">Reuqest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line">    <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> transporter.sendRequest(request);</span><br><span class="line">    <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> <span class="title class_">SecurityTransporter</span>(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类 <code>SecurityTransporter</code> 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p>
<p>从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。还是通过刚才这个例子来解释一下。不过，我们需要对 <code>SecurityTransporter</code> 类中 <code>sendRequest()</code> 函数稍加改造一下。改造前，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，我们就不做校验；改造后，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，则直接抛出 <code>NoAuthorizationRuntimeException</code> 未授权异常。改造前后的代码对比如下所示：</p>
<div class="tabs" id="里氏替换改造前后"><ul class="nav-tabs"><li class="tab active"><a href="#里氏替换改造前后-1">改造前</a></li><li class="tab"><a href="#里氏替换改造前后-2">改造后</a></li></ul><div class="tab-content"><div class="tab-pane active" id="里氏替换改造前后-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="里氏替换改造前后-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoAuthorizationRuntimeException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>在改造之后的代码中，如果传递进 <code>demoFunction()</code> 函数的是父类 <code>Transporter</code> 对象，那 <code>demoFunction()</code> 函数并不会有异常抛出，但如果传递给 <code>demoFunction()</code> 函数的是子类 <code>SecurityTransporter</code> 对象，那 <code>demoFunction()</code> 有可能会有异常抛出。尽管代码中抛出的是运行时异常（<code>Runtime Exception</code>），我们可以不在代码中显式地捕获处理，但子类替换父类传递进 <code>demoFunction</code> 函数之后，整个程序的逻辑行为有了改变。</p>
<p>虽然改造之后的代码仍然可以通过 <code>Java</code> 的多态语法，动态地用子类 <code>SecurityTransporter</code> 来替换父类 <code>Transporter</code>，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，<code>SecurityTransporter</code> 的设计是不符合里式替换原则的。</p>
<p><strong>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</strong></p>
<p>里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是 <code>Design By Contract</code>，中文翻译就是按照协议来设计。</p>
<p>子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定，甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p>
<p>常见的违反里氏替换原则的几个误区：</p>
<ol>
<li><p>子类违背父类声明要实现的功能：<br> 父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p>
</li>
<li><p>子类违背父类对输入、输出、异常的约定：</p>
<ul>
<li>在父类中，某个函数约定：运行出错的时候返回 <code>null</code>；获取数据为空的时候返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回 <code>null</code>。那子类的设计就违背里式替换原则；</li>
<li>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则；</li>
<li>在父类中，某个函数约定，只会抛出 <code>ArgumentNullException</code> 异常，那子类的设计实现中只允许抛出 <code>ArgumentNullException</code> 异常，任何其他异常的抛出，都会导致子类违背里式替换原则；</li>
</ul>
</li>
<li><p>子类违背父类注释中所罗列的任何特殊说明<br> 父类中定义的 <code>withdraw()</code> 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 <code>withdraw()</code> 函数之后，针对 <code>VIP</code> 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p>
</li>
</ol>
<p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p>
<p>里式替换这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。</p>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（<code>ISP</code>）</h3><p><code>ISP(Interface Segregation Principle)</code>，客户端不应该被强迫依赖它不需要的接口。其中的客户端，可以理解为接口的调用者或者使用者。</p>
<p>接口这个名词可以用在很多场合中，在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的 <code>API</code> 接口，还可以特指面向对象编程语言中的接口等。理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西： 一组 <code>API</code> 接口集合；单个 <code>API</code> 接口或函数；<code>OOP</code> 中的接口概念。</p>
<h4 id="把“接口”理解为一组-API-接口集合"><a href="#把“接口”理解为一组-API-接口集合" class="headerlink" title="把“接口”理解为一组 API 接口集合"></a>把“接口”理解为一组 <code>API</code> 接口集合</h4><p>举个例子，微服务用户系统提供了一组跟用户相关的 <code>API</code> 给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？你可能会说，这不是很简单吗，我只需要在 <code>UserService</code> 中新添加一个 <code>deleteUserByCellphone()</code> 或 <code>deleteUserById()</code> 接口就可以了。这个方法可以解决问题，但是也隐藏了一些安全隐患。</p>
<p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 <code>UserService</code> 中，那所有使用到 <code>UserService</code> 的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p>
<p>当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。不过，如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 <code>RestrictedUserService</code> 中，然后将 <code>RestrictedUserService</code> 只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RestrictedUserService</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">deleteUserByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, RestrictedUserService &#123;</span><br><span class="line">  <span class="comment">// ...省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p>
<h4 id="把“接口”理解为单个-API-接口或函数"><a href="#把“接口”理解为单个-API-接口或函数" class="headerlink" title="把“接口”理解为单个 API 接口或函数"></a>把“接口”理解为单个 <code>API</code> 接口或函数</h4><p>把接口理解为单个接口或函数，那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。接下来，我们还是通过一个例子来解释一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Long max;</span><br><span class="line">  <span class="keyword">private</span> Long min;</span><br><span class="line">  <span class="keyword">private</span> Long average;</span><br><span class="line">  <span class="keyword">private</span> Long sum;</span><br><span class="line">  <span class="keyword">private</span> Long percentile99;</span><br><span class="line">  <span class="keyword">private</span> Long percentile999;</span><br><span class="line">  <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Statistics <span class="title function_">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123;</span><br><span class="line">  <span class="type">Statistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Statistics</span>();</span><br><span class="line">  <span class="comment">//...省略计算逻辑...</span></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>count()</code> 函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，我们应该把 <code>count()</code> 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Long <span class="title function_">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure>

<p>在某种意义上讲，<code>count()</code> 函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。实际上，判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p>
<p>如果在项目中，对每个统计需求，<code>Statistics</code> 定义的那几个统计信息都有涉及，那 <code>count()</code> 函数的设计就是合理的。相反，如果每个统计需求只涉及 <code>Statistics</code> 罗列的统计信息中一部分，比如，有的只需要用到 <code>max</code>、<code>min</code>、<code>average</code> 这三类统计信息，有的只需要用到 <code>average</code>、<code>sum</code>。而 <code>count()</code> 函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，<code>count()</code> 函数的设计就有点不合理了，我们应该按照第二种设计思路，将其拆分成粒度更细的多个统计函数。</p>
<blockquote class="blockquote-center">
<p>接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。 </p>

</blockquote>

<h4 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 <code>OOP</code> 中的接口概念</h4><p>还可以把“接口”理解为 <code>OOP</code> 中的接口概念，比如 <code>Java</code> 中的 <code>interface</code>。假设我们的项目中用到了三个外部系统：<code>Redis</code>、<code>MySQL</code>、<code>Kafka</code>。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 <code>Configuration</code> 类：<code>RedisConfig</code>、<code>MysqlConfig</code>、<code>KafkaConfig</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">//配置中心（比如zookeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisConfig</span><span class="params">(ConfigSource configSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他get()、init()方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//从configSource加载配置到address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> &#123; <span class="comment">//...省略... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> &#123; <span class="comment">//...省略... &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们有一个新的功能需求，希望支持 <code>Redis</code> 和 <code>Kafka</code> 配置信息的热更新。所谓“热更新（<code>hot update</code>）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 <code>RedisConfig</code>、<code>KafkaConfig</code> 类中）。但是，因为某些原因，我们并不希望对 <code>MySQL</code> 的配置信息进行热更新。</p>
<p>为了实现这样一个功能需求，我们设计实现了一个 <code>ScheduledUpdater</code> 类，以固定时间频率（<code>periodInSeconds</code>）来调用 <code>RedisConfig</code>、<code>KafkaConfig</code> 的 <code>update()</code> 方法更新配置信息。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> implemets Updater &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> &#123; <span class="comment">//...省略其他属性和方法... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledUpdater</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScheduleUpdater</span><span class="params">(Updater updater, <span class="type">long</span> initialDelayInSeconds, <span class="type">long</span> periodInSeconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updater = updater;</span><br><span class="line">        <span class="built_in">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="built_in">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.initialDelayInSeconds, <span class="built_in">this</span>.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mysqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlConfig</span>(configSource);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledUpdater</span> <span class="variable">redisConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    <span class="type">ScheduledUpdater</span> <span class="variable">kafkaConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    kafkaConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要增加通过Web查看 <code>MySQL</code> 和 <code>Redis</code> 的配置信息时，我们可以在项目中开发一个内嵌的 <code>SimpleHttpServer</code>，输出项目的配置信息到一个固定的 <code>HTTP</code> 地址，比如：<code>http://127.0.0.1:2389/config</code>。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露 <code>MySQL</code> 和 <code>Redis</code> 的配置信息，不想暴露 <code>Kafka</code> 的配置信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Viewer</span> &#123;</span><br><span class="line">  String <span class="title function_">outputInPlainText</span><span class="params">()</span>;</span><br><span class="line">  Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> implemets Updater, Viewer &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">outputInPlainText</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span> &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> <span class="keyword">implements</span> <span class="title class_">Viewer</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">outputInPlainText</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span> &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHttpServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleHttpServer</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mysqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlConfig</span>(configSource);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">redisConfigUpdater</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">kafkaConfigUpdater</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SimpleHttpServer</span> <span class="variable">simpleHttpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpServer</span>(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
<p>我们设计了两个功能非常单一的接口：<code>Updater</code> 和 <code>Viewer</code>。<code>ScheduledUpdater</code> 只依赖 <code>Updater</code> 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 <code>Viewer</code> 接口，满足接口隔离原则。同理，<code>SimpleHttpServer</code> 只依赖跟查看信息相关的 <code>Viewer</code> 接口，不依赖不需要的 <code>Updater</code> 接口，也满足接口隔离原则。</p>

</blockquote>

<p>但是如果设计一个大而全的 <code>Config</code> 接口又有什么错呢？</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">outputInPlainText</span><span class="params">()</span>;</span><br><span class="line">  Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">implements</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> <span class="keyword">implements</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledUpdater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法..</span></span><br><span class="line">  <span class="keyword">private</span> Config config;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ScheduleUpdater</span><span class="params">(Config config, <span class="type">long</span> initialDelayInSeconds, <span class="type">long</span> periodInSeconds)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.config = config;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHttpServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Config&gt;&gt; viewers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleHttpServer</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewer</span><span class="params">(String urlDirectory, Config config)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Config&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    viewers.get(urlDirectory).add(config);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多。原因如下：</p>
<div class="tabs" id="接口隔离"><ul class="nav-tabs"><li class="tab active"><a href="#接口隔离-1">原因一</a></li><li class="tab"><a href="#接口隔离-2">原因二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="接口隔离-1"><p>第一种设计思路更加灵活、易扩展、易复用。因为 <code>Updater</code>、<code>Viewer</code> 职责更加单一，<strong>单一就意味了通用、复用性好</strong>。比如，我们现在又有一个新的需求，开发一个 <code>Metrics</code> 性能统计模块，并且希望将 <code>Metrics</code> 也通过 <code>SimpleHttpServer</code> 显示在网页上，以方便查看。这个时候，尽管 <code>Metrics</code> 跟 <code>RedisConfig</code> 等没有任何关系，但我们仍然可以让 <code>Metrics</code> 类实现非常通用的 <code>Viewer</code> 接口，复用 <code>SimpleHttpServer</code> 的代码实现。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiMetrics</span> <span class="keyword">implements</span> <span class="title class_">Viewer</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbMetrics</span> <span class="keyword">implements</span> <span class="title class_">Viewer</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mySqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ApiMetrics</span> <span class="variable">apiMetrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiMetrics</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DbMetrics</span> <span class="variable">dbMetrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DbMetrics</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleHttpServer</span> <span class="variable">simpleHttpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpServer</span>(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, mySqlConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/metrics&quot;</span>, apiMetrics);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/metrics&quot;</span>, dbMetrics);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="接口隔离-2"><p>第二种设计思路在代码实现上做了一些无用功。因为 <code>Config</code> 接口中包含两类不相关的接口，一类是 <code>update()</code>，一类是 <code>output()</code> 和 <code>outputInPlainText()</code>。理论上，<code>KafkaConfig</code> 只需要实现 <code>update()</code> 接口，并不需要实现 <code>output()</code> 相关的接口。同理，<code>MysqlConfig </code>只需要实现 <code>output()</code> 相关接口，并需要实现 <code>update()</code> 接口。但第二种设计思路要求<code> RedisConfig</code>、<code>KafkaConfig</code>、<code>MySqlConfig</code> 必须同时实现 <code>Config</code> 的所有接口函数（<code>update</code>、<code>output</code>、<code>outputInPlainText</code>）。除此之外，如果我们要往 <code>Config </code>中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。</p></div></div></div>

<h3 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h3><p>在 <code>SOLID</code> 最后一个原则依赖反转中，经常会提到另外两个相似的概念，控制反转(<code>IOC</code>) 和依赖注入。</p>
<h4 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（<code>IOC</code>）</h4><p>控制反转的英文翻译是 <code>Inversion Of Control</code>，缩写为 <code>IOC</code>，请看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//这部分逻辑可以放到框架中</span></span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doTest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitApplication</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(TestCase testCase)</span> &#123;</span><br><span class="line">    testCases.add(testCase);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) &#123;</span><br><span class="line">      <span class="keyword">case</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是 <code>TestCase</code> 类中的 <code>doTest()</code> 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 <code>main()</code> 函数了。 具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> <span class="title class_">UserServiceTest</span>();</span><br></pre></td></tr></table></figure>

<p>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p>
<p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p>
<p>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，<strong>控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</strong></p>
<h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（<code>DI</code>）</h4><p>依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是 <code>Dependency Injection</code>，缩写为 <code>DI</code>。用一句话来概括就是：<strong>不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</strong></p>
<p>举个例子，<code>Notification</code> 类负责消息推送，依赖 <code>MessageSender</code> 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</p>
<div class="tabs" id="依赖注入"><ul class="nav-tabs"><li class="tab active"><a href="#依赖注入-1">非依赖注入方式</a></li><li class="tab"><a href="#依赖注入-2">依赖注入方式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="依赖注入-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非依赖注入实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender = <span class="keyword">new</span> <span class="title class_">MessageSender</span>(); <span class="comment">//此处有点像hardcode</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="built_in">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Notification</span></span><br><span class="line"><span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="依赖注入-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖注入的实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过构造函数将messageSender传递进来</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">(MessageSender messageSender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="built_in">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line"><span class="type">MessageSender</span> <span class="variable">messageSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageSender</span>();</span><br><span class="line"><span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure></div></div></div>

<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 <code>MessageSender</code> 定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">(MessageSender messageSender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsSender</span> <span class="keyword">implements</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站内信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboxSender</span> <span class="keyword">implements</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line"><span class="type">MessageSender</span> <span class="variable">messageSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>();</span><br><span class="line"><span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>

<h4 id="依赖注入框架"><a href="#依赖注入框架" class="headerlink" title="依赖注入框架"></a>依赖注入框架</h4><p>在采用依赖注入实现的 <code>Notification</code> 类中，虽然我们不需要用类似 <code>hard code</code> 的方式，在类内部通过 <code>new</code> 来创建 <code>MessageSender</code> 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">MessageSender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>(); <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>(sender);<span class="comment">//依赖注入</span></span><br><span class="line">    notification.sendMessage(<span class="string">&quot;13918942177&quot;</span>, <span class="string">&quot;短信验证码：2346&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成“依赖注入框架”来自动完成。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p>
<p>现成的依赖注入框架有很多，比如 <code>Google Guice</code>、<code>Java Spring</code>、<code>Pico Container</code>、<code>Butterfly Container</code> 等。</p>
<h4 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（<code>DIP</code>）</h4><p>依赖反转原则的英文翻译是 <code>Dependency Inversion Principle</code>，缩写为 <code>DIP</code>，中文翻译有时候也叫依赖倒置原则。大概意思就是：高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p>
<p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。</p>
<p>我们拿 <code>Tomcat</code> 这个 <code>Servlet</code> 容器作为例子来解释一下。<code>Tomcat</code> 是运行 <code>Java Web</code> 应用程序的容器。我们编写的 <code>Web</code> 应用程序代码只需要部署在 <code>Tomcat</code> 容器下，便可以被 <code>Tomcat</code> 容器调用执行。按照之前的划分原则，<code>Tomcat</code> 就是高层模块，我们编写的 <code>Web</code> 应用程序代码就是低层模块。<code>Tomcat</code> 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 <code>Servlet</code> 规范。<code>Servlet</code> 规范不依赖具体的 <code>Tomcat</code> 容器和应用程序的实现细节，而 <code>Tomcat</code> 容器和应用程序依赖 <code>Servlet</code> 规范。</p>
]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>SOLID</tag>
      </tags>
  </entry>
  <entry>
    <title>基于业务驱动设计方法</title>
    <url>/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="业务建模-business-modeling"><a href="#业务建模-business-modeling" class="headerlink" title="业务建模(business modeling)"></a>业务建模(business modeling)</h4><p>业务建模首先是定义问题的方法，其次才是解决问题的方法。而我们通过定义问题，甚至可以把解决方案的复杂度降低几个数量级。</p>
<span id="more"></span>

<p>分析模型关联需求，设计模型关联实现：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/model.png" class="">
<p>模型与软件实现关联；统一语言与模型关联；提炼知识的循环:</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/ddd.png" class="">
<p>知识消化是一种迭代改进试错法，它并不追求模型的好坏，而是通过迭代反馈的方式逐渐提高模型的有效性。这个过程的前提是将模型与软件实现关联在一起。</p>
<h4 id="统一语言"><a href="#统一语言" class="headerlink" title="统一语言"></a>统一语言</h4><p>为什么会有统一语言？</p>
<ul>
<li>首先业务方大多习惯从业务维度（Business Perspective），比如流程、交互、功能、规则、价值等出发去描述软件系统，这是业务方感知软件系统的主要途径。而模型则偏重于数据角度，描述了在不同业务维度下，数据将会如何改变，以及如何支撑对应的计算与统计。那么，业务的维度就被模型的抽象隐藏了，业务方是无法从模型中直接感知到业务维度的。</li>
<li>其次，模型是从已知需求中总结提炼的知识，这就意味着模型无法表达未知需求中尚未提炼的知识。但是，单纯使用模型一定会有无法表述的需求，因而我们需要一个相对允许歧义与未知的隔离层，来帮助我们发现和反馈模型的不足。</li>
<li>因此，我们需要一种能与模型关联的共同语言，它既能让模型在核心位置扮演关键角色，又能弥合视角差异，并提供足够的缓冲。<br>修改代码就是修改模型，改变模型就是改变统一语言，修改代码等于改变统一语言：</li>
</ul>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/unified_language.png" class="">

<p>当且仅当，统一语言与领域模型关联，且多方认可并承认对统一语言的集体所有权时，统一语言的提案才能成为真正的统一语言。统一语言包含如下内容：</p>
<ul>
<li>源自领域模型的概念与逻辑</li>
<li>界限上下文（Bounded Context）</li>
<li>系统隐喻</li>
<li>职责的分层</li>
<li>模式（patterns）与惯用法</li>
</ul>
<p>除了源自领域逻辑的核心概念之外，界限上下文、系统隐喻等其他几项都可以看作对业务维度的补充与展开。将它们引入通过统一语言后，可以帮助业务方更直观地理解模型。</p>
<p>系统隐喻：<br>系统隐喻就是在价值与业务模式维度上的补充与扩展</p>
<p>责任分层：<br>责任分层关注“稳定性”，哪些是稳定而哪些是易变的</p>
<p>模式与惯用法:<br>模式与惯用法是业务规则、流程与实现模式</p>
<p>界限上下文：<br>总的来说，界限上下文是万能的，应用之妙存乎一心，关键在于你会不会用<br>通过定义与解释，我们使这些词语在其所使用的上下文中没有歧义。再通过这些基础词汇，去描述业务的行为或者规则，慢慢就可以将其确立为跨业务与技术的统一语言了。要始终记得，统一语言是在使用中被确立的。重点是，在所有可能的地方使用这个语言。只有当所有工种角色都接受它，使用它去描述业务和系统的时候，它才会真正成为统一语言</p>
<h5 id="什么是统一语言"><a href="#什么是统一语言" class="headerlink" title="什么是统一语言?"></a>什么是统一语言?</h5><p>统一语言特指根据领域模型构造的业务方与技术方都使用的共同语言。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/unified_language_desc.png" class="">

<h5 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h5><p>顾名思义，就是将对象间的关联关系直接建模出来，然后再通过接口与抽象的隔离，把具体技术实现细节封装到接口的实现中。这样可保证概念上的统一。又能避免技术实现上的限制</p>
<h5 id="使用关联对象实现聚合关系："><a href="#使用关联对象实现聚合关系：" class="headerlink" title="使用关联对象实现聚合关系："></a>使用关联对象实现聚合关系：</h5><p>首先我们需要定义关联对象，因为我们需要表达的是 User 与 Subscription 间的一对多的关系，那么最简单的命名方法是将两个对象名字组合，从而得到关联对象的名字 UserSubscriptions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserSubscriptions</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span> &#123; </span><br><span class="line">    List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>; <span class="comment">//分页 double getTotalSubscriptionFee(); //获取总共花费 </span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>; <span class="comment">//获取总订阅数 </span></span><br><span class="line">    Iterable <span class="title function_">sort</span><span class="params">(...)</span>; </span><br><span class="line">    .... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们最好是从业务上下文出发，寻找更具有业务含义的名字，毕竟我们是要形成统一语言的，源自业务的名字总是更容易被非技术角色所理解。<br>比如这里我们要表达的是用户已经订阅的专栏，或者是用户已经购买的专栏，所以选择了<strong>MySubscriptions</strong>,于是 User 对象就变成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MySubscriptions</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span> &#123; </span><br><span class="line">    List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>; <span class="comment">//分页 double getTotalSubscriptionFee(); //获取总共花费 </span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>; <span class="comment">//获取总订阅数 </span></span><br><span class="line">    Iterable <span class="title function_">sort</span><span class="params">(...)</span>; </span><br><span class="line">    .... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySubscriptions mySubscriptions; </span><br><span class="line">    <span class="keyword">public</span> MySubscriptions <span class="title function_">getMySubscriptions</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> mySubscriptions </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，我们没有逻辑泄露，User 是 Subscription 的聚合根，那么与之相关的逻辑也仍然被封装在 User 的上下文中，当然是进一步被封装在关联对象中。<br>那么我们怎么解决持久化的问题呢？怎么从领域对象中，移除掉对技术实现的依赖呢？秘诀就在于接口与实现分离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubscriptionsDB</span> <span class="keyword">implements</span> <span class="title class_">MySubscriptions</span> &#123;</span><br><span class="line">     ... </span><br><span class="line">     <span class="keyword">private</span> DataSource db;</span><br><span class="line">     <span class="keyword">private</span> User user; </span><br><span class="line">     <span class="keyword">public</span> List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> db.executeQuery(...); </span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在这里，我们将与数据库访问相关的逻辑毫不避讳地封装到 MySubscriptionsDB 中。不过，作为领域对象的 User 类，并不会知道它使用了数据库，因为它仅仅通过 MySubscriptions 接口，访问它所需要的功能。此时我们可以通过简单的分包的策略：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/package.png" class="">
<p>从上图中包的架构上看，模型的包中有 MySubscriptions、User、UserRepository。与数据库相关的代码的包里有 MySubscriptionsDB 和 UserRepositoryDB。于是，我们成功地将核心的领域逻辑与实现细节分开了。<br>当然最后还有一个问题：如何将 MySubscriptionsDB 与 User 结合在一起？最直接的做法就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserRepositoryDB <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123; </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findBy</span><span class="params">(<span class="type">long</span> id)</span> &#123; </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> .....; </span><br><span class="line">        <span class="keyword">return</span> setMySubscription(user); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">findBy</span><span class="params">(....)</span> &#123; </span><br><span class="line">        <span class="type">List</span> <span class="variable">user</span> <span class="operator">=</span> .....; </span><br><span class="line">        <span class="keyword">return</span> user.map(user -&gt; setMySubscription(user)); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">setMySubscription</span><span class="params">(User user)</span> &#123; </span><br><span class="line">        user.setMySubscriptions(<span class="keyword">new</span> <span class="title class_">MySubscriptionDB</span>(db, user)); </span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 User 是聚合根，从数据库中读取的 User 对象都需要从 UserRepository 中获取。那么，在 UserRepository 的具体实现中为 User 对象设置 MySubscription 对象，是再自然不过的选择了。<br>当然更简洁漂亮的做法，是通过 Java CDI API 或是框架提供的生命周期实践监听器，来完成关联对象的设置。</p>
<h5 id="隔离技术实现细节与领域逻辑"><a href="#隔离技术实现细节与领域逻辑" class="headerlink" title="隔离技术实现细节与领域逻辑"></a>隔离技术实现细节与领域逻辑</h5><p>如果这时候 Subscription 信息并不是存在数据库中，而是通过 RESTful API 从另一个系统中获取的。那么，我们只需提供另一个 MySubscriptions 的实现就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubscriptionsAPI</span> <span class="keyword">implements</span> <span class="title class_">MySubscriptions</span> &#123; </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">private</span> User user; </span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> client.findSubscriptions(....); </span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这种改变并不会传递到领域逻辑层，对于分页和计算的调用仍然不变，RESTful API 的性能瓶颈和需要调整的地方与数据库不同，这种变化都被关联对象的接口封装隔离了。<br>从面向对象编程的角度来说，我们很容易理解为什么关联对象可以带来如此多的好处。在诸多面向对象的最佳实践中，有一条是说要尽可能避免使用原始类型（primitive type）。因为原始类型没有对概念进行提取，也缺乏封装，所以我们应该尽可能地使用自定义的类去替换它们。<br>不过如果我们把语言内提供的集合类型（List 等）也当作原始类型的话，关联对象就是对这一条建议自然的扩展：使用自定义关联对象，而不是集合类型来表示对象间的关联。<br>关联对象除了可以帮助聚拢逻辑、隔离实现细节之外，还能从概念上帮助我们获得更好的领域模型，因为关联对象是对集体逻辑的直接建模。<br>所谓集体逻辑，是指个体不具备，而成为一个集体之后才具备的能力。哪怕是同一群个体，组成了不同的集体，就会具有不同的逻辑。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/model2.png" class="">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> List subscriptions; </span><br><span class="line">    .... </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Column</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> List subscriptions; </span><br><span class="line">    .... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，User 中的 List 表示用户已订阅的所有专栏，而 Column 中的 List，则表示所有订阅了专栏的用户。虽然同为 Subscription 的集合，但是当它们组成集体时，在不同的上下文中则具有不同的含义。<br>那么如果显式地表达为关联对象，可以进一步澄清我们的意图，得到揭示意图的接口（Intention Revealing Interface）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">MySubscriptions</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> MySubscriptions mySubscriptions; </span><br><span class="line">    ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Column</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">MyReaders</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> MyReaders myReaders； </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们通过引入关联对象，可以将这两个不同的集体变更为 User.MySubscriptions 和 Column.MyReaders，然后在各自的上下文去定义不同的集体逻辑。<br>比如我订阅的专栏可以计算我一共付了多少钱，而在我的读者中，可以计算订阅者对专栏的平均打分情况，示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">MySubscriptions</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span> &#123; </span><br><span class="line">    <span class="type">double</span> <span class="title function_">getTotalFee</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">MyReaders</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span> &#123; </span><br><span class="line">    <span class="type">double</span> <span class="title function_">getAverageRating</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="上下文过载（Context-Overloading）"><a href="#上下文过载（Context-Overloading）" class="headerlink" title="上下文过载（Context Overloading）"></a>上下文过载（Context Overloading）</h5><p>就是指领域模型中的某个对象在多个上下文中发挥重要作用，甚至是聚合根。<br>上下文过载存在的问题：</p>
<ul>
<li>一这个对象本身会变的很复杂，造成模型僵化</li>
<li>二可能带来潜在的性能问题</li>
</ul>
<p>对过载的上下文进行有效的分离，成为了要面对的问题。解决方式是利用角色对象和上下文对象。</p>
<h5 id="角色对象"><a href="#角色对象" class="headerlink" title="角色对象"></a>角色对象</h5><img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_1.png" class="">
<p>在这个扩展了的模型中，包含了三个不同的上下文:</p>
<ul>
<li>订阅：用户阅读订阅内容的上下文，根据订阅关系判断某些内容是否对用户可见；</li>
<li>社交：用户维护朋友关系的上下文，通过朋友关系分享动态与信息；</li>
<li>订单：用户购买订阅专栏的上下文，通过订单与支付，完成对专栏的订阅。<br>按照这个模型，我们很容易得到与之对应的“富含知识的模型”：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id; </span><br><span class="line">    <span class="comment">// 社交上下文 </span></span><br><span class="line">    <span class="keyword">private</span> List friends; <span class="keyword">private</span> List moments; </span><br><span class="line">    <span class="comment">// 订阅上下文 </span></span><br><span class="line">    <span class="keyword">private</span> List subscriptions; </span><br><span class="line">    <span class="comment">// 订单上下文 </span></span><br><span class="line">    <span class="keyword">private</span> List orders; <span class="keyword">private</span> List payments; </span><br><span class="line">    <span class="comment">// 社交上下文 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">(Friendship friend)</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">break</span><span class="params">(Friendship friend)</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 订单上下文 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Column column)</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 订阅上下文 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canView</span><span class="params">(Content content)</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
估计已经发现问题所在了：一个对象中包含了不同的上下文，而这恰好是坏味道过大类（Large Class）的定义。<br>那么过大类会带来什么问题呢？首当其冲是模型僵硬。想要理解这个类的行为，就必须理解所有的上下文。而只有理解了所有的上下文，才能判断其中的代码和行为是否合理。于是，上下文的过载就变成了认知的过载（Cognitive Overloading），而认知过载就会造成维护的困难。<br>但是我们不要忘了，这是与模型关联的代码啊！改不动的代码就是改不动的模型！改不动的僵硬的模型，要怎么参与提炼知识的循环呢？</li>
</ul>
<p>上下文过载的根本问题：<br>逻辑是需要汇聚于实体（User）还是上下文（订阅、社交与订单）<br>DCI 范型（Data-Context-Interaction，数据 - 上下文 - 交互）要求汇聚于显式建模的上下文对象（Context Object），或者上下文中的角色对象（Role Object）上，我们可以如下图这样建立模型：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_2.png" class="">
<p>在不同的上下文中，用户是以不同的角色与其他对象发生交互的，而一旦离开了对应的上下文，相关的交互也就不会发生了。也就是说，在订阅上下文中的读者（Reader），不会以读者的身份与订单上下文中的支付信息发生交互。而买家（Buyer），也不会以买家的身份去社交上下文中去建立朋友关系。</p>
<p>从 DCI 的角度看待聚合与聚合根关系，我们可以发现，并不是 User 聚合了 Subscription，而是订阅上下文中的 Reader 聚合了它。同时，并不是 User 聚合了 Friendship 与 Moments，而是社交上下文中的 Contact 聚合了它们。可以说，User 只是恰好在不同的上下文中扮演了这些角色而已。</p>
<p>我们也就发现了上下文过载的根源：实体在不同的上下文中扮演的多个角色，再借由聚合关系，将不同上下文中的逻辑富集于实体之中，就造成了上下文过载。<br>针对不同上下文中的角色建模，将对应的逻辑富集到角色对象中，再让实体对象去扮演不同的角色，就能解决上下文过载的问题了。<br>在实践中却没有这么简单，主要是如何在代码中实现这种实体与角色间的扮演关系?<br>通过装饰器（Decorator），我们可以构造一系列角色对象（Role Object）作为 User 的装饰器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Subscription&gt; subscriptions;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reader</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅上下文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canView</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buyer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Payment&gt; payments;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Buyer</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订单上下文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Column column)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Friendship&gt; friends;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Moments&gt; moments;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Contact</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 社交上下文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">(Friendship friend)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">break</span><span class="params">(Friendship friend)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们很容易地将不同上下文中的行为与逻辑富集到对应的角色对象中，并且与领域模型中的概念完全对应起来。然而这里还有最后一个问题，就是如何构造这些装饰器对象。</p>
<h5 id="通过上下文对象分离不同上下文中的逻辑"><a href="#通过上下文对象分离不同上下文中的逻辑" class="headerlink" title="通过上下文对象分离不同上下文中的逻辑"></a>通过上下文对象分离不同上下文中的逻辑</h5><p>如同我们之前在关联对象中讲到的，获取关联集合的方式可能是异构的，也就是不止从数据库中读取这一种方法。如果社交上下文中的朋友关系，是通过服务接口调用，从其他社交平台获取的呢？这个时候，我们将 asContact 方法置于 UserRepositoryDB 之内，就显得不那么合适了。<br>我们来换个思路。我们可以遵循关联对象的思路，将上下文直接建模出来，并通过接口隔离具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SubscriptionContext</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">canView</span><span class="params">(Content content)</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Reader <span class="title function_">asReader</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SocialContext</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">make</span><span class="params">(Friendship friend)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">break</span><span class="params">(Friendship friend)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contact <span class="title function_">asContact</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrderContext</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Buyer</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Column column)</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Buyer <span class="title function_">asBuyer</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，我们就可以将上下文对象的获取放置在 UserRepository 上，对它进行改写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    SubscriptionContext <span class="title function_">inSubscriptionContext</span><span class="params">()</span>;</span><br><span class="line">    SocialContext <span class="title function_">inSocialContext</span><span class="params">()</span>;</span><br><span class="line">    OrderContext <span class="title function_">inOrderContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepositoryDB</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="comment">//通过依赖注入获取不同的上下文对象</span></span><br><span class="line">    <span class="meta">@Inject</span> <span class="keyword">private</span> SubscriptionContext subscriptionContext;     </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span> <span class="keyword">private</span> SocialContext socialContext;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span> <span class="keyword">private</span> OrderContext orderContext;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最后的使用方式就成了：</span><br><span class="line"></span><br><span class="line"><span class="type">UserRepository</span> <span class="variable">users</span> <span class="operator">=</span> ....;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.findUserById(...);</span><br><span class="line"></span><br><span class="line"><span class="type">Buyer</span> <span class="variable">buyer</span> <span class="operator">=</span> users.inOrderContext().asBuyer(user);</span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> users.inSubscriptionContext().asReader(user);</span><br><span class="line"><span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> users.inSocialContext().asContact(user);</span><br></pre></td></tr></table></figure>
<p>通过增加上下文对象，我们获得了诸多好处:<br>第一：借由上下文对象的封装，不同上下文中的技术可以是完全异构的。也就是在不同的上下文中，我们可以使用不同的技术方案。而这些技术的细节，不会暴露给外在的使用者。<br>第二：软件实现、模型与统一语言更加紧密地关联在了一起。我们知道界限上下文的名字是统一语言的一部分。在模型中虽然不以实体的形式出现，但总归还是有它的标识（虚线的上下文边界）。如果没有上下文对象，那么它不会是软件实现的一部分，总是觉得不够理想。而有了上下文对象，统一语言、领域模型和软件实现就彻底一致了。<br>第三：我们更加清楚地揭示了领域知识的意图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    SubscriptionContext <span class="title function_">inSubscriptionContext</span><span class="params">()</span>;</span><br><span class="line">    SocialContext <span class="title function_">inSocialContext</span><span class="params">()</span>;</span><br><span class="line">    OrderContext <span class="title function_">inOrderContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个定义，我们清晰地知道，User 在三个不同的上下文中扮演不同的角色。而没有上下文对象的时候，这些信息则没有被披露，会增加理解的成本和负担。</p>
<h5 id="上下文间的依赖关系"><a href="#上下文间的依赖关系" class="headerlink" title="上下文间的依赖关系"></a>上下文间的依赖关系</h5><p>不过这里还有一个问题，上下文对象在处理复杂问题的时候，还能继续保持简洁和优雅吗？让我们再来看一个略微复杂的问题。比如我们要做个新业务，将我所订阅的专栏赠送给我的朋友。<br>直觉告诉我们，这需要跨越两个不同的上下文，才能构建这个业务。也就是说，在这个业务中，处在订阅上下文中的 Reader，也是处在社交上下文中的 Contact。单纯从实现它来说，问题也不难解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.findUserById(...);</span><br><span class="line"><span class="type">User</span> <span class="variable">friend</span> <span class="operator">=</span> users.findUserById(...);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> users.inSocialContext().asContact(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> users.inSubscriptionContext().asReader(user);</span><br><span class="line"><span class="type">Subscription</span> <span class="variable">subscription</span> <span class="operator">=</span> reader.getSubscriptions(...);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（contact.isFriend(friend) &#123;</span><br><span class="line">    reader.transfer(subscription, friend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题是，“只有朋友间才能赠送”属于领域逻辑。我们希望它被富集到模型中，而不是在模型外，那么我们要怎么处理呢？答案出乎意料得简单，在上下文对象中加入依赖就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionContextDB</span> <span class="keyword">implements</span> <span class="title class_">SubscriptionContext</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span> SocialContext SocialContext; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Reader <span class="title function_">asReader</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">//在这里将依赖的上下文传到角色对象中去就好了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而实现这个业务代码就成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.findUserById(...);</span><br><span class="line"><span class="type">User</span> <span class="variable">friend</span> <span class="operator">=</span> users.findUserById(...);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> users.inSubscriptionContext().asReader(user);</span><br><span class="line"><span class="type">Subscription</span> <span class="variable">subscription</span> <span class="operator">=</span> reader.getSubscriptions(...);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reader.transfer(subscription, friend)</span><br></pre></td></tr></table></figure>
<p>通过显式建模上下文对象，我们不光将业务逻辑富集到领域模型中，而且在跨域多个上下文实现某个业务时，上下文之间的依赖关系还成了实现细节，被封装于上下文对象中了。</p>
<p>而上下文过载会导致模型僵化，也就是“看不懂改不动”的代码变成了“看不懂改不动”的模型，这样提炼知识的循环就无法展开了。因而我们需要将上下文从领域对象上剥离，解决办法就是角色对象和上下文对象。<br>需要强调的是，虽然仅仅使用角色对象也能解决问题，但是配合上下文对象一起，它们能在揭示意图的同时，使模型、统一语言与软件实现更紧密地关联在了一起，是非常有用的模式。</p>
<h5 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h5><p>我们学会了</p>
<ul>
<li>通过关联对象解决聚合&#x2F;关联关系；</li>
<li>利用角色对象分离不同上下文中的交互；</li>
<li>并使用上下文对象完成实体对象到角色对象的扮演。</li>
</ul>
<p>这些模式通过结构上的优化，更好地组织了对核心数据的访问逻辑，使得我们可以在兼顾架构约束的同时，将领域概念与逻辑有效地转化为领域模型。<br>然而当我们把眼光从构造领域模型，扩展到利用领域模型构建整个应用或系统时，就会遇到新的问题：如何组织领域逻辑与非领域逻辑，才能避免非领域逻辑对模型的污染？<br>通常我们会使用分层架构（Layered Architecture）区分不同的逻辑以解决这个问题。然而由于领域层被人为赋予了最稳定的特性，破坏了分层架构间的依赖关系。所以我们需要修正分层，才能有效地围绕领域模型来构造软件架构。</p>
<p>分层架构是运用最为广泛的架构模式，它将不同关注点的逻辑封装到不同的层中，以便扩展维护，同时也能有效地控制变化的传播。<br>在使用领域驱动设计时，我们通常会将系统分成四层：</p>
<ul>
<li>展现层（Representation Layer）：负责给最终用户展现信息，并接受用户的输入作为功能的触发点。如果不是人机交互系统，用户也可以是其他软件系统。 </li>
<li>应用层（Application Layer）：负责支撑具体的业务或者交互流程，将业务逻辑组织为软件的功能。 </li>
<li>领域层（Domain Layer）：核心的领域概念、信息与规则。它不随应用层的流程、展现层的界面以及基础设施层的能力改变而改变。 </li>
<li>基础设施层（Infrastructure Layer）：通用的技术能力，比如数据库、消息总线等等。</li>
</ul>
<p>领域驱动设计使用分层架构，主要是因为各层的需求变化速率（Pace of Changing）不同。分层架构对变化传播的控制，是通过层与层之间的依赖关系实现的，因为下层的修改会波及到上层。我们希望通过层来控制变化的传播，只要所有层都单向依赖比自己更稳定的层，更易变依赖不易改变的，那么变化就不会扩散了。</p>
<p>那么我们只能承认基础设施不是层，需要从不同的角度构建一种架构模式，使得领域模型既可以隐含地使用基础设施，又不暴露对它的依赖。</p>
<h5 id="能力供应商模式"><a href="#能力供应商模式" class="headerlink" title="能力供应商模式"></a>能力供应商模式</h5><p>如何才能取消基础设施层，但仍然不影响领域模型的实现呢？我会推荐使用能力供应商（Capability Provider）模式。能力供应商模式是面向对象基础原则 SOLID 的综合应用。<br>让我们通过一个案例，看一下如何构造能力供应商。还是极客时间的例子，这次我们来看订单部分。假设目前需要通过网银来支付订单，并通过邮件将订单状态更新并发送给客户。模型如下：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_3.png" class="">
<p>那么在忽略具体实现细节之后，代码可能是这个样子的：首先调用银行网关，然后根据银行网关返回的结果，生成支付记录并通知客户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BankResponse</span> <span class="variable">response</span> <span class="operator">=</span> bank.pay(....);</span><br><span class="line">        <span class="keyword">if</span> （response.isOk()) &#123;</span><br><span class="line">            payments.add(<span class="keyword">new</span> <span class="title class_">Payment</span>(response...));</span><br><span class="line">            status = ....;</span><br><span class="line">            email.send(....);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            email.send(....);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为领域层被认为定义为绝对稳定，它不能依赖任何非领域逻辑（除了基础库）。而我们又要使用网银客户端和邮件通知客户端来完成功能，那该怎么办呢？我们只好将网银客户端和邮件通知客户端移动到领域层内。<br>但是我们不能直接移动，毕竟领域层中只能是领域概念与逻辑，与具体业务无关的概念是不能进入领域层的。于是我们需要将对基础设施层的依赖，看作一种未被发现的领域概念进行提取，这样其实就发挥了我们定义业务的权利，从业务上去思考技术组件的含义。<br>一种有效的方法是将技术组件进行拟人化处理。比如网银转账这个行为，如果在业务中有一个人去做这个操作，那么会是谁呢？通知用户订单状态发生转变了，这个人又会是谁呢？通过拟人化，我们就能很清楚地看到技术组件到底帮助我们完成了什么业务操作。<br>在我们这个例子里，转账的是出纳（Cashier），通知用户的是客服（Customer Service）。于是我们的模型就能转化为：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_4.png" class="">

<p>可以看到，我们将具有业务含义的能力抽象成接口纳入领域层，而使用基础设施层的技术能力去实现领域层的接口。也就是说，基础设施层成为了能力供应商。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//领域层内</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cashier</span> &#123;</span><br><span class="line">    Payment <span class="title function_">collect</span><span class="params">(...)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">(User owner)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(Cashier cashier, CustomerService staff)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> cashier.collect(...);</span><br><span class="line">            payments.add(payment);</span><br><span class="line">            staff.tell(owner, ..);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(....) &#123;</span><br><span class="line">            staff.tell(owner, ..);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//领域层外</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankPaymentCahsier</span> <span class="keyword">extends</span> <span class="title class_">BankPaymentClient</span> <span class="keyword">implements</span> <span class="title class_">Cashier</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailCustomerService</span> <span class="keyword">extends</span> <span class="title class_">EmailNotificationClient</span> <span class="keyword">implements</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从具体实现方法中寻找到一个抽象接口，然后将从对具体实现的依赖，转化为对接口的依赖（SOLID 中的里氏替换原则）。<br>也就是说，领域概念可以不是领域方提取的。只要我们从技术组件中提取的词汇具有业务含义，且被业务方认可，那么它就是领域概念。因此我们并不是改了个名，而是提取了领域概念。<br>总结来说，通过从技术组件抽象具有业务含义的能力，我们就能将基础设施转变为具有这种能力的供应商。于是，我们就能帮助领域层实现了它希望的那种“不正当关系”，既使用了基础设施，又对它没有依赖：我们依赖的是领域层内的能力接口（SOLID 中的接口隔离原则），而不是基础设计的实现（SOLID 中的倒置依赖原则）。</p>
<h5 id="使用能力供应商的多层架构"><a href="#使用能力供应商的多层架构" class="headerlink" title="使用能力供应商的多层架构"></a>使用能力供应商的多层架构</h5><p>我们可以将基础设施，看作对不同的层的扩展或贡献（SOLID 的开闭原则）。它虽被接口隔离，但却是展示层、应用层和领域层的有机组成部分。在每一层中留有能力接口，基础设施则作为这些能力接口的供应商，参与层内、层间的交互。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_5.png" class="">
<p>那么这样的架构，无论从变化的频率还是使用实现关系上就形成了统一。除此之外，通过能力供应商，我们还解决了分层架构里的另一个难题：层与层之间是单向依赖关系，那么如果需要上一层参与下一层的交互与逻辑，层与层之间就会形成双向依赖关系。<br>不过，通过能力与能力供应商，层与层之间出现了另一种交互的可能：上一层作为下一层的能力供应商，参与到下一层的业务与流程中去。而这种参与，并不会带来额外的依赖。<br>比如在前面支付的例子里，除了邮件通知以外，我们还希望触发一个流程去为用户做一下支付失败原因的回访。这属于应用层逻辑的一部分。那么我们只需要在应用层中实现对应的逻辑，并成为领域层的能力供应商就可以了。示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowUpWorkflow</span> <span class="keyword">implements</span> <span class="title class_">CustomerSerivce</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WorkflowEngine engine;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">(.....)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine.startFlow(....);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能力供应商模式就是它就是关联对象、角色对象和上下文对象的元模式（Meta Pattern）。通过这个元模式，我们还可以衍生出很多有用的模式，比如全局数据对象（Global Data Object）模型，用类似 Users 这样的领域概念表示系统全局范围内所有的用户对象。</p>
<p>分层模式并不能很好地帮助我们构建以领域模型为核心的系统架构，主要问题就在于如何处理领域层与基础设施层的关系上。而我们对领域模型的执念，使得我们无法承认基础设施层更稳定（本身也有突变风险）。所以我们应该重新思考分层架构是否正确，以及怎么分才更合理。</p>
<p>我个人建议分成三层：展示层、应用层与领域层。不仅要将基础设施作为能力供应商配合其他层来使用，同时通过能力供应商模式，来实现层与层之间的双向交互，这样就不用担心会带来额外的依赖了。</p>
<p>最后，能力供应商模式是一个元模式，关联对象、角色对象和上下文对象可以看作它的具体应用。熟练掌握这个模式，你就可以根据需要发明自己的领域驱动实现模式了。</p>
<h5 id="角色-目标-实体法"><a href="#角色-目标-实体法" class="headerlink" title="角色 - 目标 - 实体法"></a>角色 - 目标 - 实体法</h5><p>角色 - 目标 - 实体法除了能够得到一个更“纯净”（也就是不包含无法与实现关联的模型）的领域模型之外，还提供了一种收集需求，结构化进行领域建模与构建统一语言的流程：</p>
<ul>
<li>首先与业务方沟通，明确参与系统的所有角色。 </li>
<li>围绕着这些角色，澄清他们希望通过系统达成的目标。 </li>
<li>将目标中提及的“实体”（名词、概念）提取出来，问清楚含义与内涵。 </li>
<li>围绕这些实体建立领域模型，并与业务方阐述这些模型是如何用以实现目标的。 </li>
<li>当业务方理解了模型之后，模型就成为了统一语言。<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_6.png" class=""></li>
</ul>
<p>这个流程有个额外的好处：可以提高业务方对领域模型的认同感。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_7.png" class="">
<p>不同于催化剂方法，角色 - 目标 - 实体法更像一种共创方法，它由研发人员建立领域模型，然后再解释给业务方。双方通过协作共同梳理系统中的用户与其目标，共同澄清领域概念。然后技术人员再根据澄清的实体，建立领域模型。这样得到的领域模型，可以更自然地成为统一语言。</p>
<h5 id="弹性边界（Elasticity-Boundary）"><a href="#弹性边界（Elasticity-Boundary）" class="headerlink" title="弹性边界（Elasticity Boundary）"></a>弹性边界（Elasticity Boundary）</h5><p>它指把弹性作为最优先的考虑要素而划定的系统边界。如下图所示，产品目录和支付，被分别放入了不同的组网：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_8.png" class="">
<p>于是，我们通过弹性负载均衡控制了不同的组网环境，也就控制了不同逻辑功能在弹性变化上的边界。这就是弹性边界。换个角度来看，我们把弹性作为主要指标，对系统进行划分，将不同弹性变化的组件放入了不同的弹性边界中。<br>可以说，通过弹性边界，我们实际上是以更细致的粒度，控制了系统运营的成本。也只有这样，才能真正发挥云平台的能力。所以当我们想要利用云平台架构软件时，<strong>寻找合理的弹性边界</strong>便是最重要的事情。</p>
<h5 id="拆分微服务，弹性优先还是业务优先？"><a href="#拆分微服务，弹性优先还是业务优先？" class="headerlink" title="拆分微服务，弹性优先还是业务优先？"></a>拆分微服务，弹性优先还是业务优先？</h5><p><strong>事实上，我们可以将微服务架构看作一种以业务上下文为弹性边界的云原生架构模式</strong>。也就是说，微服务是云原生架构的一个子集，或者是一种特化（specilization）的形态。如图所示，我们可以把极客时间模型中不同的上下文放入不同的弹性边界中，就能获得一个微服务架构：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_9.png" class="">
<p>这里要说明的是，虽然微服务并不一定需要以云原生架构作为基础，而且你也可以在具有固定弹性的数据中心，去部署微服务。但是实践经验告诉我们，比起将微服务部署到云平台上，在固定弹性的平台上使用微服务架构，有极高的实施成本。<br>如果将微服务架构风格看作一种云原生架构风格，那我们可以从弹性边界出发，重新去审视它。这样我们就能获得另外一种视角：从云平台利用度去理解微服务架构风格，并将它与其他架构风格做出比较。<br>于是从弹性边界的角度出发来看待不同的架构模式，就为我们带来了另一个评价是否需要拆分微服务的思路：是否值得将某个业务上下文放入独立的弹性边界内。<br>答案是“弹性优先”。也就是说在云平台上，弹性永远是第一优先级。如果两个上下文明显具有不同的弹性诉求，那就应该拆分。而如果具有一致的弹性诉求，就可以不拆。<br>因为弹性优先原则用在微服务拆分上，就是在询问这样一个问题：将拆分出的服务放置于独立的弹性边界中，是否能够利用云的弹性，更容易地控制运营成本？如果不能，那么就不要拆。如果能，那么就可以拆。这种基于效益的考量，就是“功利主义架构思路”。<br><strong>微服务的划分要以弹性边界为主，以业务上下文为辅。</strong><br>微服务到底要多微？<br>答案是，微到能够更好地利用弹性控制成本的大小。</p>
<p>最后需要说明的是，弹性优先原则不仅仅适用于微服务架构，而是适用于所有云原生架构。无论是今天的微服务，或是无服务器架构（Serverless Architecture），还是未来可能出现的宏服务（Marco Service，已经有些许苗头了）。这些都是希望通过利用弹性进而更高效地利用云平台的架构模式。因而，这些架构模式都可以通过弹性优先原则去思考和比较。</p>
<h5 id="弹性边界间的依赖与耦合"><a href="#弹性边界间的依赖与耦合" class="headerlink" title="弹性边界间的依赖与耦合"></a>弹性边界间的依赖与耦合</h5><p>而弹性边界间的依赖（也就是服务间调用关系，或是数据交换关系），会造成流量的传递。如果上游弹性边界突然需要处理大量的流量，那么这些流量自然也会传递到下游弹性边界中。<br>我将这种不同弹性边界间流量的传递称作弹性依赖（Elasticity Dependency）。弹性依赖可以帮助我们理解不同弹性边界内容量变化的根源，并制定相应的扩容策略，然后作出最佳应对。<br>在云原生架构下，只要组件之间存在交互，弹性依赖就不可避免。只不过，云平台更擅长处理依赖于吞吐量（Thoughput）的弹性依赖，但对依赖于响应时间（Response Time）的弹性依赖，就没有什么好办法了。<br>水平扩展并不能保证改进响应时间，而只能提高吞吐量。也就是说，云平台的弹性并不总能改进响应时间，但一定可以提高吞吐量。这就意味着对于吞吐量的诉求，可以通过弹性来解决。但对于响应时间的诉求，弹性可能无法处理。<br>弹性扩容实际上就是对吞吐量的扩容，因而更大的吞吐量诉求对于云平台来说，就是小事一桩。同时我们也可以观察到，弹性扩容对响应速度没什么影响。如果从始至终，只有一个请求访问该服务，那么无论弹性负载均衡复制多少新的虚拟机，都无法缩短响应时间。<br>正因为云平台不擅长处理依赖于响应时间的弹性依赖，我将这类弹性依赖称为弹性耦合（Elasticity Coupling），以表示与依赖于吞吐量的弹性依赖的区别。因为两个弹性边界间存在弹性耦合，通常意味着，将这两个弹性边界分离后，对于云平台利用效率的提高，不足以弥补为了分离它们所付出的成本。</p>
<h5 id="如何避免弹性耦合？"><a href="#如何避免弹性耦合？" class="headerlink" title="如何避免弹性耦合？"></a>如何避免弹性耦合？</h5><p>最简单的方式，是将组件间的同步调用模式改为异步。这是因为，服务与组件间的同步调用，会带来响应时间的依赖；而异步调用，则能将其改变为吞吐量的依赖。</p>
<p>假设我们有一个电子商务网站，已经完全部署到了云平台之上。而且我们按照弹性边界，将这个系统分解成了“订单”“支付”“邮寄”“通知”等组件，并将它们放置到不同的弹性负载均衡控制之下。 那么对于“下单”这个业务功能，我们会：</p>
<ul>
<li>通过订单组件，先去调用支付组件，完成订单支付。 </li>
<li>然后呢，再通知邮寄组件，生成快递单，将用户购买的产品发出。 </li>
<li>最后通过通知组件，告知用户订单状态。</li>
</ul>
<p>如下图所示，展示了不同弹性边界内业务功能间的相互调用：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_10.png" class="">
<p>如果订单组件是同步调用支付组件，那么作为调用方的订单组件，也会消耗资源，等待支付组件的返回。<br>这里要注意，无论这个等待的时间是 500 毫秒、15 秒或是 5 分钟，可以确定的是，在下游响应之后，调用方才能释放自己的资源。而且，调用方付出了资源等待，那么这个时间就不仅仅是消耗了下游的资源，调用方自己的资源其实也在消耗。<br>此时，支付组件的响应时间，也就包含在了订单组件的响应时间里面，因而订单组件的响应时间依赖于支付组件的响应时间。这就意味着订单与支付这两个弹性边界间存在着耦合关系。<br>而异步调用的关键，就在于无需消耗资源等待下游返回，就可以将对下游响应时间的要求，改为对于吞吐量的诉求。<br>这个规定时间，无论是 500 毫秒、15 秒或是 5 分钟，其实并不是响应时间，而是吞吐量的另一种表现形式。所以 500 毫秒，其实是每分钟 120 次的吞吐量（60 秒 x1000 毫秒 &#x2F; 500），15 秒就是每分钟 5 次的吞吐量，5 分钟也就是 1 小时 12 次的吞吐量。<br>以此来看，当订单侧流量增大时，我们只需要利用云平台对支付进行扩容，保证同样的吞吐量即可。那么这里的关键就在于，异步调用是怎么做到将响应时间变为吞吐量的呢？<br>我们可以将异步调用想象成在所需调用的组件前，存在一个请求的缓冲。所有的请求都会先进入缓冲之中，而且这个缓冲有个总容量，在到达这个容量之前，总处理时间不会超过某个给定的限定值。<br>那么因为组件间的直接调用被缓冲隔离了，上下游组件间从直接耦合，就变成了通过缓冲的间接耦合。<br>而同步调用中对响应速度的要求，就被分解成了处理时间、等待返回时间和请求缓冲的轮转时间。其中请求缓冲的轮转时间，就是吞吐量的另一种表现形式。在我们前面例子里，这三个时间分别对应订单的处理速度、订单的结果返回速度以及支付的吞吐量。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_11.png" class="">
<p>由此可以看出，通过将同步调用改变为异步调用，我们就把对于下游响应时间的依赖，改变成对于下游吞吐量的依赖。然后将弹性耦合变成了弹性依赖，使得整个系统可以更好地利用云平台的能力。而行业中也有大量的佐证，表明在云时代，异步调用、事件驱动架构风格会逐渐成为主流的选择。<br>我相信这些尝试仅仅是个开始，随着我们对于云平台、弹性以及弹性边界认识的深入，过往的最佳实践都会被打破。而围绕着云与弹性，我们会重新认识什么才是架构软件的最佳方式。<br>#####默认异步对业务建模的挑战<br>为了消除弹性耦合，我们需要放弃默认同步调用的方式。那么当我们延续领域驱动设计的思路，以一种模型驱动的视角来看待这个问题的话，就会面临两个挑战：</p>
<ul>
<li>如何将异步调用与模型结合起来？</li>
<li>如何处理异步调用对聚合关系一致性的影响？<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_12.png" class=""></li>
</ul>
<p>可以看到这个模型中，有两个对象，User和Subscription，以及关联关系User-Subscription，我们可以创建 User 对象、Subscription 对象，或者将 User 对象与 Subscription 对象关联在一起。但是从模型中，并没有任何结构支撑我们以异步的方式构造 User、Subscription 对象，或是将 User 与 Subscription 关联起来。</p>
<p><strong>要知道异步方式意味着，由模型产生的数据可能存在中间状态</strong>，比如，我们通过异步方式为 User 增加了新的 Subscription，那么可能处于“请求已发送，但是还没有得到明确反馈的中间态”。<br>此外，异步的中间态还会影响聚合根对关联关系一致性的控制。正如我们前面所说，在同步模型中，要么 Subscription 已经与 User 关联，要么未与 User 关联。Subscription 关联的一致性由聚合根 User 控制。<br>然而一旦进入异步模式，会出现尚未确认的关联。这个问题其实不大，<strong>不过需要额外注意的是，那些在规定时间内没有得到确认的关联</strong>。<br>那么这种因为异步带来的一致性改变，对业务会产生什么影响呢？这是我们需要考虑的第二个问题。</p>
<p>所以归根到底，为了解决弹性耦合的问题，我们需要将原味面向对象风格中默认的同步模型改为异步。但是我们也知道，在领域驱动设计“两关联一循环”的大框架下，对于模型的改动，最终会反映到我们如何理解业务上。因此我们需要一种方式，将异步模型对应到业务上下文中。</p>
<p>总结来看，在云原生时代，我们需要将弹性作为首要考虑因素，纳入建模的考量，那么弹性边界就划分我们系统的重要依据，而且我们还需要考虑弹性边界间的依赖关系，尽量避免弹性耦合。<br>对于业务建模来说，为了配合云时代的架构约束，我们需要做到以下几点？</p>
<ul>
<li>确定一种模型结构以反应弹性边界</li>
</ul>
<h5 id="业务系统与领域系统的区别？"><a href="#业务系统与领域系统的区别？" class="headerlink" title="业务系统与领域系统的区别？"></a>业务系统与领域系统的区别？</h5><p>进入云时代，处于更有效的利用云平台的目的，我们引入了新的架构约束：<strong>弹性优先原则</strong>。也就是说，<strong>在云时代架构系统中，弹性是需要最优先考虑的因素</strong>。<br><strong>业务模型会不会受到技术泛型的影响</strong>？<br>会，但不经常发生。那什么时候会发生呢？就是在技术泛型改变可以带来成本答复下降，或者带来收入巨幅增加的时候。<strong>所以实际上，并不是新的技术泛型直接改变了模型，而是新的技术泛型带来成本、收入上的优势，业务方则为了利用这些优势，便根据新的技术泛型，改变了业务的运营方式，引起了背后模型的改变</strong>。<br>可以说，好的模型可以在软件的生命周期内保持稳定。帮助我们在特定的架构风格下高效的应对变化。但是，魔性不能帮助我们渡劫，如果架构风格彻底变了，那么模型就必须重建。</p>
<h5 id="四种业务运营模式"><a href="#四种业务运营模式" class="headerlink" title="四种业务运营模式"></a>四种业务运营模式</h5><img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_13.png" class="">
<p><strong>流程标准化</strong>：看做强制同样的的业务流程<br><strong>流程整合度</strong>：看做是否使用同一个数据源</p>
<ul>
<li>统一模式：强制使用同样的业务流程，也需要同样的数据源，业务上是强流程管控模式。对应的软件上元婴模式也是单例模式。</li>
<li>复制模式：强制使用同样的流程，但可以使用不同数据源，业务上以同样的业务模式独立运营的业务单元，对应的软件运营模式是多租户模式，也就是我们所说的SaaS模式。</li>
<li>协作模式：不强制使用同样的流程，但需要使用同样的数据源。业务上是仅仅在财务流程和关键数据上互通的，更具有独立性的业务单元或子公司模式。对应在软件上，可以看做通过开放 API 提供对于共享数据的访问。</li>
<li>差异化模式：不强制使用相同的业务流程，也不使用同样的数据源，基本上就是不同的业务实体。对应到软件上，可以将其看作开放生态模式。<br>而从这个角度来看，<strong>我们行业内存在的很多问题，就源自业务组织能力与 IT 能力的不匹配</strong>。</li>
</ul>
<h5 id="什么是模型中最明显的弹性边界？"><a href="#什么是模型中最明显的弹性边界？" class="headerlink" title="什么是模型中最明显的弹性边界？"></a>什么是模型中最明显的弹性边界？</h5><p>我们知道云是通过降低成本改变运营模式，从而给业务带来影响的。那么是否存在着某些业务功能更容易受到运营模式的影响，而另一些业务功能，则不容易受到运营模式的影响呢？<br>如果是这样，这就意味着<strong>两种不同的功能存在不同的弹性边界。那么按照弹性优先的原则，我们就需要将这两类需求进行分离</strong>，总而在最宏观层面，贯彻弹性优先的原则。<br>比如说，极客时间专栏提供了企业版，也就是对企业收取特定的费用（每年或者一次性），这样企业内的员工就能无限或者按照规定的量来自由阅读专栏。<br>可以发现，与发布、阅读、评论相关的功能点，无论是公开版本，还是企业版本，都没有什么区别。而定价、返现、提成等功能，则会发生较大的改变。也就是说，这些功能点更容易受运营模式改变的影响。<br>如果按照变化隔离的原则，从架构上将这两类功能分割开的话，我们就有了一个不同的看待极客时间系统架构的角度。我们将它分成两部分：一个是与运营无关的内容管理系统（Content Management System，CMS）；一个是极客时间的运营系统。<br>那么，企业版不过就是在内容管理系统上，提供了另一套运营系统而已。如下图所示：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_14.png" class="">
<p>由此我们发现了一个常用的架构模式，<strong>可以把系统分为两部分：与运营无关的部分，提供运营能力的部分</strong></p>
<ul>
<li>与运营无关的部分，模型似乎不需要业务方输入</li>
<li>提供运营能力的部分，需要业务方输入及验证<br>在进行建模时，针对与运营无关的部分和与运营有关的部分，我们需要处理的核心复杂度并不相同。而且，“两关联一循环”对于这两部分的功用也不尽相同。<br><strong>“领域”表示与运营无关的问题域，“业务”表示与运营相关的问题域</strong>。<br>从我的经验来看，通过“两关联一循环”对业务逻辑建模的效果，要远远好于对领域逻辑的建模的效果。<strong>因而业务逻辑一般具有运营特定和领域中立性。与之相对的，就是领域逻辑具有运营中立性和领域特定性</strong>。<br>事实上，对于能通过面向对象模型表示核心复杂度的领域逻辑，知识消化法是能够发挥作用的。因为我们讲到现在，隐含的前提就是通过对象模型建模问题。但是，并不是所有的领域逻辑都适合使用对象模型表达。比如推荐引擎，通过特征建模（Feature Modeling）并使用相似度算法，可能是更好的方法。当然，也可以是决策树（Decision Tree），甚至是神经网络（Neural Network）。这时候，知识消化并不能帮助我们得到这些模型。所以知识消化实际是一种“业务建模”方法，而不是“领域建模”方法。<br>总结来说：将领域和业务分开，可以让我们更好的理解什么是业务系统，<strong>支撑业务运营，利用领域系统赚钱&#x2F;省钱的系统，就做业务系统</strong>。所以我们建模的目的，就是寻找恰当的业务模型，更好的支撑业务系统的构建和演进。</li>
<li>业务逻辑是源自业务运营的逻辑，是领域中立且运营特定的，其复杂度来自于业务流程，关注的是如何通过某个领域逻辑实现获利。因而它的关注点，就集中在盈利和成本结构上。或者说，业务逻辑对外体现为利润或现金，对内体现为成本和绩效承诺。</li>
<li>领域逻辑源自问题域自身的逻辑，是运营中立而领域特定的，其复杂度来自于问题本身，关注点通常是算法、计划、统计、优化等等。</li>
</ul>
<p>所以关注业务逻辑的组件与关注领域逻辑的组件，通常具有不同的弹性边界。以极客时间专栏为例，在缓存策略恰当的前提下，如果读者猛增，那么对内容管理部分的弹性需求，会远远小于对业务运营部分的弹性需求。而对于搜索引擎业务来说，当搜索用户猛增时，对广告投放这部分的弹性需求，要远远小于对索引部分的弹性需求。</p>
<p>因而从弹性优先的角度出发，我们应该将关注业务逻辑的组件与关注领域逻辑的组件分离。这样构建出来的模型，更能适应云时代的架构约束，也能让我们分别使用不同的建模方法，获得对应的领域模型与业务模型。</p>
<p>如何通过模型发现业务系统的变化点？<br>领域逻辑与运营无关，源自某个特定的问题域；而业务逻辑与运营相关，大量的业务逻辑来资源运营中实践经验的总结。由此发现业务逻辑不如领域逻辑稳定。毕竟业务关注的是如何盈利，而不是准确的描述某个问题域。这似乎跟我们长久地想法相违背，我们希望通过精确建模某个问题域，从而实现某个问题域的复用。<strong>在商业社会里，复用某个领域，就是围绕这个领域构建能够盈利的运营模式</strong>。<strong>业务知识的重建与复用，才是领域复用的关键</strong>。</p>
<h5 id="理解业务逻辑，我们有什么好的办法吗？"><a href="#理解业务逻辑，我们有什么好的办法吗？" class="headerlink" title="理解业务逻辑，我们有什么好的办法吗？"></a>理解业务逻辑，我们有什么好的办法吗？</h5><ul>
<li>以凭证追溯从财务角度理解企业经营</li>
<li>以合同履约理解企业业务</li>
</ul>
<p>我们发现，在所有的业务逻辑中，权责履约是最小的业务交互，合同是最小的业务上下文。那么我们就可以使用权责和合同上下文来做业务建模了。<br>对于权责履约，我们可以使用履约请求（表示一个时间段）和履约确认（时间点）这样的结构来表示。并将相应的凭证与履约请求关联，以表示发起履约的依据。同样，履约确认也会与相应的凭证关联，以表示履约的证明。<br>凭证在权责履约的范围内，可以按照四色建模的方式寻找。也就是说，针对每一个权责履约，实际是在业务上定义了一小段时间线，从履约请求开始，到履约确认为止。这是利用了事件建模中的多时间线法。而我们可以在这条时间线上追溯履约中的关键凭证。<br>除了履约时间线上的凭证之外，履约请求还可以引用合同上下文中的其他凭证。特别是，履约请求和履约确认本身也是凭证，可以供其他请求与确认引用。比如，卖家未在约定时间内发货，那么违约取消合同的时候，就可以引用之前的支付履约请求或者支付履约确认，证明卖家没有发货。<br>明确了履约的结构之后，合同可以作为上下文对象，用以涵盖对应的所有履约项。而且由于合同只存在于双方之间（多方合同是多份双方合同），因而任何合同上下文中都存在两个角色对象。比如采购订单合同中的买家和卖家，快递合同中的邮寄方和承运方等。<br>在整个合同上下文中，权责也是围绕着两个角色展开的。所以，我们可以将合同上下文看做两个角色间业务交互的证据的聚合。这是一种业务上存在的聚合关系，是一种比对象聚合更具有业务含义的包含关系。<br>合同的参与方以及凭证中的标的物，可能来自领域系统。比如说，我们网购的采购合同中的支付凭证，牵扯到的标的物就是商品。那么我们可以将商品看做领域系统产品目录中的概念，然后通过凭证引用领域系统中的概念，让领域系统中的概念参与到业务逻辑中来。<br>元模型（Meta Model）图，表示了上面我们所讲的核心概念，以及它们之间的关联：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_15.png" class="">

<p>建模流程：</p>
<ul>
<li>寻找合同上下文</li>
<li>寻找合同中的主要履约项，按四色建模寻找凭证；</li>
<li>对于主要的履约项，寻找违约的情况，设立新的履约项，按四色建模寻找凭证;</li>
<li>重复步骤三，知道不得不打官司为止；</li>
<li>将参与方和标的物划分入领域边界</li>
</ul>
<p>下面就通过例子来看一下这个过程，还是我们的老朋友，极客时间专栏。首先来看一下读者侧，合同是非常明确的，即专栏订阅合同。参与方就是读者和极客时间。然后，我们来看看主要履约项：</p>
<ul>
<li>支付订阅费用，权利方是极客时间，义务方是读者。</li>
<li>访问付费内容，权利方是读者，义务方是极客时间。</li>
</ul>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_16.png" class="">

<p>接下来我们就需要寻找违约情况了，对应上面讲的两个权责，那么分别存在如下两种违约情况：</p>
<ul>
<li>未在规定时间内完成支付，那么合同自动作废，读者并不承担额外责任。权利方是极客时间，义务方是读者。 </li>
<li>如果专栏出现断更，没能按说明提供内容，专栏下架，极客时间退钱，并且在下次同专栏上架时，不再向原读者收取任何费用。权利方是读者，义务方是极客时间。</li>
</ul>
<p>所以我们可以继续添加模型到上面的模型图中，并将标的物划入不同的上下文，以表示领域边界，如下图所示。这里我也说明一下，由于图片大小关系，我省略了一些凭证，还简化了权责方与请求和确认的关联。不过这并不影响对模型的整体理解，你可以着重看一下权责履约项：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_17.png" class="">

<p>首先，通过 Request-Confirmation 表示的履约结构是一种异步结构：在规定时限内，未得到确认之前，履约处在未知状态。这种异步并不是技术上的刻意选择，而是业务的真实状态。<br>让我们回想一下真实世界中的业务操作，其实都是这样的异步状态：权利方主张，义务方履约。而我们在软件世界中习惯的是同步状态，是在很短时间内完成的主张 - 履约。但无论这个完成的时间有多短，在概念上，主张、履约仍是异步结构。<br><strong>所以严格意义来说，我们过往通过同步方式建模都是错的，都是从实现方式去理解问题，而不是从问题本身出发。其次，如果履约出现错误，也就是不能履约的情况，那么对于这种异常状态的修正，就需要触发新的履约过程。</strong><br>想想看，在现实世界中的业务，从来不存在可以自动修正的情况。因为任何履约失败，都存在破坏合同条款，最终引起法律纠纷的可能。所以不可能在合同双方不知情，也没有提前协商的情况下，对未完成的履约项进行修正（而且严格意义来讲，这么做也是违法的）。<br>因而，<strong>从业务角度出发，履约中的异常会触发新的履约项，从而在合同的上下文中维持业务的一致性。</strong><br>也就是说，如果我们完全从业务出发，不受对象模型搅合的话，就会自然地得到异步为主的模型以表示业务逻辑。那么接下来，就让我们看看合同上下文。</p>
<h5 id="凭证角色化建立合同间的关联"><a href="#凭证角色化建立合同间的关联" class="headerlink" title="凭证角色化建立合同间的关联"></a>凭证角色化建立合同间的关联</h5><p>如果再仔细看前面的模型，你可能会发现，我们将支付部分归属于专栏订阅合同了。这表明什么呢？表明这是一个线下的现金交易模型。也就是读者和极客时间面对面完成了现金交易，然后极客时间开具发票。<br>因为在专栏订阅的合同上下文中，参与的双方是读者和极客时间，既没有微信，也没有其他的参与方。因而说明，这是个现金交易模式。不过，这显然不适合现在的数字化时代。那么如果我们需要支持移动支付，模型会有什么改变呢？<br>首当其冲的改变就是引入了第三个角色：移动支付供应商。我们知道合同只能在两者之间签署，那么我们势必需要引入另一个合同上下文，去表示移动支付供应商和读者之间的关系。也就是说，在读者和移动支付供应商之间，存在一个合同，用以支撑支付行为。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_18.png" class="">

<p>通过这个模型很明显的发现，<strong>业务模式改变了，从面对面现金交易变成了借由第三方支付服务完成交易。</strong><br>因为在专栏订阅合同上下文的履约确认中，我们关联了另一个合同，也就是移动支付协议上下文中产生的凭证，而这个凭证是由合同上下文中的义务方移动支付供应商提供的。<br><strong>那么这种跨合同上下文的凭证引用，实际上就表示了不同合同履约项中权利方与义务方间的协作</strong>。专栏付款确认引用了移动支付确认作为凭证，也就是说，专栏订阅合同上下文中，专栏付款履约项的权利方极客时间，和移动支付协议上下文中，移动支付履约项的义务方移动支付供应商，共同协作，为用户（移动支付协议合同上下文）完成了支付，以帮助读者（专栏订阅合同上下文）完成了订阅。<br>我们通过跨合同上下文间的凭证引用，建模了不同服务之间的协作。但是对其他上下文中凭证的引用，实际上表示了不同上下文间的依赖关系。<br>专栏订阅合同是依赖于移动支付协议的。那么如果我们引入另一种支付模式，比如说预充值抵扣，那么我们可能就会引入另外一个合同上下文：预付费合同。而专栏订阅合同也会依赖于它。如下所示：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_19.png" class="">

<p>这里明显会出现一个坏味道，随着新支付方式和手段的引入，专栏订阅合同上下文会不断地去依赖新的合同上下文。且不说由于依赖关系引起的变化传播，单从业务上讲，专栏订阅合同是极客时间的核心业务逻辑，也是核心差异化所在。而不同的支付合同，更像是为了支撑这个核心业务逻辑而存在的。那么对于这种依赖关系，我们就需要小心了，因为让核心逻辑依赖于支撑逻辑，总是一种坏味道。</p>
<h5 id="业务系统中的变化点"><a href="#业务系统中的变化点" class="headerlink" title="业务系统中的变化点"></a>业务系统中的变化点</h5><p>不过解决的办法也很简单，<strong>那就是反转依赖，我们可以让履约确认角色化，让其他合同中的凭证来扮演这个履约确认</strong>。能力供应商模式，它是面向对象技术中反转依赖的一个小应用。如下图所示:</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_20.png" class="">

<p>通过将专栏付款确认角色化，我们就在专栏订阅合同中引入了一个变化点。就意味着这个履约项，可由多种不同凭证来确定，也就是存在跟其他不同合同上下文交互的可能性。<strong>而这种对业务变化的判断，并不是源自技术方案，而是从业务本身的结构出发，寻找可能存在的变化点。</strong></p>
<p><strong>我们不停地通过各种建模手段，希望可以预判业务改变的方向，尽早做出隔离，从而更好地响应业务的改变。同样的，业务逻辑变化的可能性天然也就存在于业务中，而且具有明显的结构特征</strong>。</p>
<p>云计算给建模带来的挑战时，总共讲了四条：</p>
<ul>
<li>确立一种模型结构以反映弹性边界； </li>
<li>在弹性边界切分业务上下文时，维护业务一致性； </li>
<li>从异步模型的视角，解读业务逻辑； </li>
<li>在异步调用产生中间态异常时，维护业务一致性。</li>
</ul>
<p>我们来看看怎么应对这四个挑战。前两条与弹性边界有关。我们知道合同上下文表示了服务边界，其中合同的乙方就是服务提供者，甲方就是消费者。那么是不是合同上下文就是弹性边界呢？<br><strong>所以合同上下文并不是弹性边界，履约上下文才是弹性边界</strong>。此外，由于我们分离了领域逻辑和业务逻辑，那么<strong>领域逻辑也是弹性边界</strong>。<br>在领域逻辑中，数据一致性为主导；而在业务逻辑中，是合同上下文中对业务逻辑的聚合为主导。合同上下文中的业务一致性，也就是履约与违约构成的一致性，因而业务逻辑的弹性改变并不会影响领域逻辑。<br><strong>通过切分领域与业务边界，分别以领域逻辑边界和合同上下文中的履约上下文作为弹性边界，就能解决在弹性边界切分业务上下文时的一致性维护问题。</strong></p>
<p>后两条与异步模式有关。这里有意思的是，如果我们完全从业务角度出发，遵循主张 - 履约的方式建模（比如用 8X Flow 建模），这根本不是问题：因为业务本身就应该通过异步解读；异常状态作为违约，触发其他履约项或诉诸法律。</p>
<p>然而在概念上，我们仍留有通过集合封装内存中的对象与数据库中的数据的习惯。这使得我们在使用领域驱动设计的时候，特别是使用聚合关系的时候，变得左右为难：要么放弃性能，获得更好的模型；要么泄露逻辑，以得到可接受的性能。 但是关联对象，则可以让我们在更加明确揭示意图的同时，去解决性能与逻辑封装的问题。</p>
<p>当我们严格遵照“富含知识的模型”的原则，将聚合关系有关的逻辑富集到领域模型上时，很容易产生上下文过载的问题，其根源在于实体在不同的上下文中扮演了多个角色。<br>而上下文过载会导致模型僵化，也就是“看不懂改不动”的代码变成了“看不懂改不动”的模型，这样提炼知识的循环就无法展开了。因而我们需要将上下文从领域对象上剥离，解决办法就是角色对象和上下文对象。</p>
<p>分层模式并不能很好地帮助我们构建以领域模型为核心的系统架构，主要问题就在于如何处理领域层与基础设施层的关系上。而我们对领域模型的执念，使得我们无法承认基础设施层更稳定（本身也有突变风险）。所以我们应该重新思考分层架构是否正确，以及怎么分才更合理。<br>我个人建议分成三层：展示层、应用层与领域层。不仅要将基础设施作为能力供应商配合其他层来使用，同时通过能力供应商模式，来实现层与层之间的双向交互，这样就不用担心会带来额外的依赖了。</p>
<ul>
<li>第一，合同之前的上下文和合同上下文应该具有不同的弹性边界。<br>从实际业务上讲，二者的弹性诉求通常也差距巨大。以网上购物为例，浏览啊、查找啊、比价啊、砍价啊、拼单啊、拼团啊，都是合同之前的业务。而下单之后的采购合同签订了，然后才会进入到合同履约的环节，弹性诉求自然不同。</li>
<li>第二，合同前的上下文是系统另一个重要变化点。</li>
<li>第三，虽然投标邀请和投标并不是履约项，但是它们也具有 Request-Confirmation 的结构，所以实际上也是异步的业务行为。</li>
</ul>
<h5 id="如果我做的系统并不包含对外的合同，那么要怎么办？"><a href="#如果我做的系统并不包含对外的合同，那么要怎么办？" class="headerlink" title="如果我做的系统并不包含对外的合同，那么要怎么办？"></a>如果我做的系统并不包含对外的合同，那么要怎么办？</h5><ul>
<li>第一，你做的系统的目标是管理内部绩效。比如说客户关系管理系统（CRM，Customer Relationship Management），目标管理系统（Objective Management），销售管理系统（Sales Management），等等。<br>虽然这些系统并不牵扯对外的权责履约，但是我们仍然可以使用权责履约对这类系统进行建模。因为从业务上讲，这类系统是存在履约项的，而履约项，其实就是干系人的工作产出、KPI、OKR 等等。<br>那么从合同上下文和履约的角度来看，管理者和电话销售就绩效目标达成一致，实际上是一种口头的绩效合同，或者叫绩效协议。那么周会、月会，实际上就是进度履约的检查和确认。</li>
<li>第二种情况，你做的是领域系统，并不在合同上下文之内。<br>我们仍然以上面这个 CRM 电话销售为例。假设你所做的是为电话销售提供客户信息（标的物），那么你做的系统就处在合同上下文之外了，当然不会具有合同上下文了。这时候你就需要按领域系统建模。</li>
<li>第三种情况，你做的是工具。仍然是 CRM 电话销售的例子。你做的系统是帮助电话销售，直接从电脑上控制座机电话拨号。同样的，不是业务系统，不需要业务建模，可能需要领域建模，也可能不需要（如果就是简单集成的话，就是胶水代码）。</li>
<li>或者，最可悲的，你做的系统完全不重要，跟业务没有任何关系。比如在任何的内外合同 &#x2F; 协议上下文中，都不留下任何痕迹，也不会被人当作工具使用。这个时候，你需要反思的不仅仅是这个系统了，可能还有你的职业生涯。</li>
</ul>
<p>其中至少存在两个合同上下文：极客时间和作者之间的创作协议；极客时间和编辑之间的绩效约定。</p>
<h5 id="极客时间和作者之间的创作合同上下文建模："><a href="#极客时间和作者之间的创作合同上下文建模：" class="headerlink" title="极客时间和作者之间的创作合同上下文建模："></a>极客时间和作者之间的创作合同上下文建模：</h5><img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_21.png" class="">

<h5 id="极客时间和编辑之间的绩效协议上下文建模："><a href="#极客时间和编辑之间的绩效协议上下文建模：" class="headerlink" title="极客时间和编辑之间的绩效协议上下文建模："></a>极客时间和编辑之间的绩效协议上下文建模：</h5><img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_22.png" class="">

<p>那么如果我们将这三个合同上下文放在一起，就可以看到凭证是如何在不同的合同上下文间，完成了业务的串联与整合。如下图所示：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_23.png" class="">
<p>在这个全视图中，我们可以看到：</p>
<ul>
<li>编辑是如何帮助作者从选题、打磨内容，到签订合同，最后再到催稿上线的； </li>
<li>读者是如何通过订阅专栏，为作者带来分成的； </li>
<li>创作合同是如何保证作者一定会按时更新文章，以保证读者能阅读到课程内容的； </li>
<li>以及三方是如何围绕领域系统 CMS（也就是由专栏、文章组成的领域上下文）展开协同的。</li>
</ul>
<p>我们首先区分了什么是业务逻辑，什么是领域逻辑。从宏观上将两者分离，以保证业务系统与领域系统具有不同的知识边界和弹性边界。<br>然后，我们从合同履约入手，通过履约项和合同上下文建立业务模型。<br>我们又介绍了合同之前的上下文，也就是渠道上下文。并解释了为何公司内的绩效管理也可以通过协议与履约的方式进行建模。<br><strong>归根结底，也就是不要从技术解决方案上去定义业务问题，要回到业务本身，去理解业务问题</strong>。<br>所以，<strong>架构也要以应对业务的变化点为根本出发点，将合同上下文、履约上下文和领域上下文作为系统天然的边界。从业务上下文中寻找变化点（角色化的履约确认、不同的渠道上下文等），并通过软件架构降低支持这些变化的成本</strong>。</p>
<p>总之，我们不要老是抱怨业务逻辑不易理解、变来变去的。事实上，业务逻辑是最简单，也是最理性的逻辑：多赚钱少花钱，规避法律风险，提供合规审计。要知道这套逻辑，业务方不光要跟你讲，也会跟投资人、股东讲，还会跟审计、法务讲，所以绝对是经过了千锤百炼，可以放心使用。</p>
<h5 id="什么是中台？"><a href="#什么是中台？" class="headerlink" title="什么是中台？"></a>什么是中台？</h5><p>应对未来商业社会的一种可能的更具竞争力的模式，是通过小而灵活的前台团队，频繁而低成本地试错。而支撑这种团队结构的软件平台，就是中台。那么它可能更接近一个产生 SaaS 的 SaaS，而不是直接服务于租户的 SaaS。<br>宏流程促进了从业务层面上模式的复用，也给创新带来了不同的思考。那就是如何复用已经存在并成功的业务模式，是一种更有效的创新方法。</p>
<p>说到底，不停地将企业成功的核心模式灌注到新的市场，让企业在扩展业务版图的同时，也能不断强化核心竞争力。这是绝大多数企业长久以来期盼的发展创新的模式。注意，不是重复，而是在不同的竞争领域复现。这是宏流程带来的思考方式的转变，也是承载宏流程的软件平台——中台让我们着迷的地方。</p>
<p>理论上讲，每个不同履约项都可能具有不同的弹性边界，而以履约项为单位拆分成细小的服务，仍然可以表示业务能力。然而我会建议你，从合同上下文开始，先将不同的合同上下文作为服务边界，然后再看看是否需要将履约项拆分成独立的服务。<br>需要再次强调，你并不需要把每一个履约项拆分成独立的服务，这样不一定有什么好处。只有在履约项真的需要独立的弹性边界时，才需要这么做。至于其他两种业务上下文，比照合同上下文处理即可。<br>另外，对于每个领域上下文，我建议做成一个服务就行了。毕竟在面向对象设计中，弹性边界不是很容易切分。但是只要使用 RESTful API，无论服务如何拆分，接口都是稳定的。</p>
<p><strong>学习是一种状态（being），而不是一种行为（doing）</strong></p>
<p>如何避免循环调用？<br>可以通过间接的方式避免(回调函数)</p>
<p>领域指的是问题，在业务场景边界不清，所以改用业务来代替，所以叫做业务建模。</p>
<h5 id="业务逻辑："><a href="#业务逻辑：" class="headerlink" title="业务逻辑："></a>业务逻辑：</h5><p>源自于业务运营的逻辑，是领域中立且运营特定的，其复杂度来自于流程本身，关注的如何盈利和成本结构(或者可以理解为对外体现利润和现金，对内体现成本和绩效承诺)。常见于：合同、法务、会计和审计等。业务逻辑是支撑了业务运营流程。</p>
<h5 id="领域逻辑"><a href="#领域逻辑" class="headerlink" title="领域逻辑"></a>领域逻辑</h5><p>源自于问题域的逻辑，是领域特定而运营中立的。其复杂度来自于问题本身，关注的是如何解决问题(通常这些问题的解决办法源于专家经验，研究成果或参考已有的解决方案)。常见于：算法、分布式计算与存储、统计、优化等。而领域逻辑实现了盈利的能力。</p>
<h5 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h5><p>从复用方式上来说，业务逻辑的复用往往通过复制运营团队来实现，而领域逻辑的复用往往通过包装并被业务集成来实现。</p>
<p>因为业务逻辑和领域逻辑天然具有不同的变化原因和复用方式，而隔离变化是架构设计的核心。所以，业务逻辑和领域逻辑要被明确区分。</p>
<h5 id="什么是业务系统？"><a href="#什么是业务系统？" class="headerlink" title="什么是业务系统？"></a>什么是业务系统？</h5><p>以业务逻辑支撑业务运营，利用领域逻辑实现盈利的系统，就叫过业务系统。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_24.png" class="">

<h5 id="面向业务设计"><a href="#面向业务设计" class="headerlink" title="面向业务设计"></a>面向业务设计</h5><p>面向业务设计所聚焦的是在业务架构明确后，理解并抽取业务模式，分离业务与领域的上下文。以应用架构作为系统架构的牵引，联系业务业务架构与组织架构，促进同构性。换句话说业务设计不直接影响业务架构，也不直接影响系统实现。</p>
<h5 id="业务建模"><a href="#业务建模" class="headerlink" title="业务建模"></a>业务建模</h5><p>是对业务流程的可视化抽象和分析过程。在面向业务设计中，用于对业务输入进行分析和抽象从而识别并分离业务上下文和领域上下文。侧重于理解业务、划分边界、分析业务模式。</p>
<h5 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h5><p>是对领域问题的可视化抽象和分析过程。在面向业务的设计中，用于在划分业务上下文和领域上下文后，对领域上下文进一步探索，或指导对象模型设计。侧重于理解领域，补充领域问题解决方案、指导实现。</p>
<h5 id="履约建模法"><a href="#履约建模法" class="headerlink" title="履约建模法"></a>履约建模法</h5><p>是一种以业务履约为视角，通过提取业务模式并引入变化点构建可复用业务模型的、云原生时代的业务建模方法。</p>
<p>如果没有软件系统，一个公对公的商品交易是靠双方的活动过程和纸质单据来完成的。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_25.png" class="">

<p>形成决定的过程往往都是复杂的领域问题，是产生纸质凭证的关键输入。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_26.png" class="">

<p>当交易结束后，交易过程将会遗忘，当事双方通过留存的纸质凭证进行过程追溯。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_27.png" class="">

<p>业务流程的本质即业务凭证的追溯过程</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_28.png" class="">

<p><strong>业务凭证具有不可变性和不可抛弃型</strong>，换句话说：<strong>作为业务凭证，只存在创建，不存在修改和删除</strong>。<br>注意：从架构实现视角来看，如果我们给业务逻辑实现了CRUD的API，那么显然做错了，基于可追溯理论，业务系统的对外API只能有CR，没有UD。</p>
<p>业务凭证追溯所体现的是当事双方的权责与履约关系</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_29.png" class="">

<p>权责履约关系被现实生活中的合约所描述。合约的关键信息：</p>
<ul>
<li>当事人：即常说的甲乙方</li>
<li>条款</li>
<li>违约</li>
</ul>
<p><strong>合约通常分为协议和合同两种形式。其中合同是可以被法院强制执行的协议。为了方便沟通，我们统一称为合约，统一称呼具有相同约束效力的业务凭证</strong>。</p>
<p>基于合约进行分析能够快速了解业务上下文，<strong>用合约来描述业务的做法天然存在，并且是职业经理人、法务、会计等专业人士一直以来快速理解和审视业务的合理性的依据</strong>。<br>合约可以被视为一种能够反映业务流程的有效业务模式（规律性）</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_30.png" class="">

<p>合约上下文有不同阶段的业务凭证所体现，通常一个完整的业务由5个关键阶段，以及每个阶段的业务凭证。其中履约有履约请求和履约确认两种凭证所组成，履约请求代表的是一个“时段”，履约确认代表的是一个时刻。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_31.png" class="">

<p>合约上下文能够充分的分离业务和领域：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_32.png" class="">

<p>因为合同签订和业务履约过程天然是“异步”的，所以为云原生的弹性边界的识别提供了关键依据。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_33.png" class="">

<p><strong>由于业务凭证是履约过程的结果(事件)，所以履约建模法的本质其实是一种以合约视角为核心的事件建模法</strong>。</p>
<p><strong>归纳推理法：是由经验、经历、对事实的观察，对个别案例或具体的特殊示例归类，概括得出一个一般性的结论，或者暂时认为是普遍适用的结论</strong>。</p>
<p><strong>演绎推理法：是基于“前提”的已知事实(通常是归纳得出)，“必然地”得出推理结果，如果前提为真，则结论必然为真</strong>。</p>
<ul>
<li>归纳法：超出归纳范围，结论则不成立，无法用逻辑来证伪</li>
<li>演绎法：大前提不成立，结论则不成立，可以用逻辑来证伪</li>
</ul>
<p><strong>归纳是演绎的前提和出发点，演绎又是归纳的补充和验证，两者辩证统一</strong>。</p>
<h5 id="履约建模法有三大图例分类："><a href="#履约建模法有三大图例分类：" class="headerlink" title="履约建模法有三大图例分类："></a>履约建模法有三大图例分类：</h5><ul>
<li>凭证(Evidence)：粉色</li>
<li>参与元素(Participant)：绿色</li>
<li>角色(Role)：黄色<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_34.png" class=""></li>
</ul>
<h5 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h5><p>以一个公对公的商品采购流程为例：<br>该业务由采购方发起询价，由商品提供方给予报价，当双方认可后签订商品采购协议。其中部分业务凭证追溯关系如下：<br>商品询价单、商品报价单、商品采购协议&#x2F;合同、支付申请单、支付确认单、支付凭证、发票开具申请单、发票开具确认单、发票、发货申请单、发货确认单、发货单。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_35.png" class="">
<p>由于业务凭证往往都是“单据”，可以省略单这个字，将单据的概念融入颜色中，用粉色来表示凭证：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_36.png" class="">
<p>凭证具有不同的上下文。其中商品询价和报价的业务凭证属于合约前的上下文，商品采购协议及其履约相关的业务凭证属于合约上下文。可以用实线表示上下文内的业务凭证追溯关联关系</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_37.png" class="">

<p>凭证的标准建模图，当使用标准化图例补充凭证的类型、数量关系和关键属性之后，可以清晰的看出模型元素之间的关系。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_38.png" class="">

<p>不同的凭证代表了时间关系上的时段和时刻</p>


<p>时段和时刻在合约条款上的体现，当甲乙双方签订商品采购协议后，甲方需在7个工作日内完成商品采购款支付，并提供支付凭证。</p>


<p>凭证标准建模图例，履约建模法使用六种标准图例代表不同类型的凭证：</p>

<p>合约前上下文的常见场景：一次RFP对应一次Proposal, 一次方案索取可能只会对应一次提案，并且在业务上只需要对方案索取和提案的唯一凭证进行留存和追溯。</p>

<p>合约前上下文的常见场景：一次RFP对应多次Proposal, 一次方案索取可能会对应多次提案，并且业务上需要对多次提案的凭证进行留存和追溯。</p>

<p>合约前上下文的常见场景：没有RFP，可能会没有方案索取的过程，或业务上无需对方案索取的凭证留存和追溯。</p>

<p>合约前上下文的常见场景：没有RFP和Proposal，可能会没有方案索取和提案的过程，或业务上无需对方案索取和提案的凭证进行留存和追溯。</p>

<p>合约前上下文的常见场景：一个合约可能存在多种合约前的上下文。合约的签订，可能会通过多种不同的方式的合约前的上下文所达成。</p>


<p>合约上下文的常见场景，一个履约请求时间段内由单次履约确认，并且业务上只需要对某个唯一的履约确认凭证进行记录和追溯</p>

<p>合约上下文的常见场景: 多个履约请求关联共同的履约确认来进行履约，在这种情况下用于履约确认的凭证的权责关系是等价的</p>


<p><strong>注意：在建模时，有履约请求(时段)，就至少有一次履约确认(时刻)。在追溯时，如果履约请求(时段)缺少了对应的履约确认(时刻)凭证，则可被认为是除了履约确认超时外的另一种违约形式。</strong></p>


<h5 id="参与元素"><a href="#参与元素" class="headerlink" title="参与元素"></a>参与元素</h5><p>当事人(party)。履约过程中所涉及到的具体人员(或其在系统内对应存在)，对凭证所承载的权责直接负责(也可以理解为凭证需要谁签字盖章)。可由绿色的当事人来表示。</p>


<p>标的物(Thing)。在履约的过程中，会涉及到凭证相关的非凭证物品(往往是交易或履约的具体对象)，此时我们可以使用同为绿色的标的物来表达。</p>


<p>参与元素的标准建模图</p>


<p>参与元素的标准建模图例：履约建模法使用两种标准图例代表不同类型的参与元素：</p>


<p><strong>参与元素的主要作用是丰富上下文相关的知识，所以在实际过程中，需要结合实际需要按需使用，不必追求完全穷尽</strong></p>
<h5 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h5><p>当事人角色化，从合约的视角来看，合约的当事双方都是法人，而具体的当事人实际上是在业务流程中代表法人进行履约活动，所以我们可以使用黄色的角色来抽象合约双方法人的概念。</p>


<p>抽象的目的是为了提供变化点，将当事人角色化之后，具体的当事人就可以扮演法人的角色，这样就为系统实现提供了基于角色的变化点。</p>


<p>领域逻辑角色化与第三方系统角色化，凭证还会与一些领域逻辑或第三方系统发生关联关系，此时我们可以用抽象来代表这两种特殊的概念。已体现业务的领域中立性，换句话说领域逻辑和第三方系统也可成为业务逻辑的变化点。</p>


<p>其他合约上下文角色化。对于当前合约上下文相关联的其他合约上下文，<strong>在我们不关心其业务内部逻辑时，也可以使用角色化来代替</strong>。</p>


<p>凭证角色化。已支付为例，有时候我们可能出现多种支付方式，而支付凭证往往是另外一个合约上下文的凭证，所以可以<strong>使用凭证角色化来表达另一个合约上下文中的凭证，对当前合约上文所依赖凭证的扮演关系。</strong></p>
<p>角色的标准建模图</p>


<p><strong>注意：由于时段类凭证不能代表业务上确定的结果，所以只有时刻类凭证能够成为凭证角色化的扮演者。</strong><br>角色的标准建模图例</p>


<p><strong>角色的主要作用是通过抽象提供业务变化点，所以在实际过程中需要结合对变化点进行抽象，不必追求完全抽象。</strong></p>
<h5 id="上下文-Conetxt"><a href="#上下文-Conetxt" class="headerlink" title="上下文(Conetxt)"></a>上下文(Conetxt)</h5><p>拥有角色扮演关系的角色元素提供了最为明显的上下文边界提示。</p>

<p>按照被扮演的角色可以清晰的分离不同的上下文，而这些角色被其分隔开两个上下文共用。</p>

<p>未标明扮演关系的参与元素、领域逻辑、第三方系统和其它合约上下文均处于独立的上下文中。</p>

<p>参与元素、领域逻辑、业务逻辑，通常是专门的领域问题，业务逻辑和领域逻辑的边界清晰分离。</p>


<p>常见的跨合约上下文关联方式：通过具体凭证直接关联。在无需通过抽象提供变化点的情况下，可能与另一个合约上下文中的时刻类凭证进行跨上下文的直接关联。</p>


<p>常见的跨合约上下文关联方式：通过凭证角色化扮演关系直接关联。在通过抽象提供变化点的情况下，通过凭证角色化元素和时刻类凭证扮演关系进行跨上下文的直接关联</p>


<p>常见的跨合约上下文关联方式：通过参与元素直接关联，两个合约上下文，可能通过对于某个共同使用的参与元素及所属的领域上下文产生间接关联。</p>


<p><strong>注意：在实际的法律追责中，三方合约被视作双方合约的组合。所以在建模时，需要根据当事双方的不同将三方合约建模成多个合约上下文。</strong></p>
<p>履约建模法简化建模图例</p>




<h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><p>腾讯会员VIP视频服务：从合约分析结果可以了解到腾讯视频VIP会员服务的核心业务逻辑。</p>

<p>腾讯视频VIP会员服务协议的关键合约内容</p>

<p>其它合约的关键内容</p>

<p>会员账号管理及使用</p>

<p>会员服务特别约定的关键内容</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_74.png" class="">
<p>会员个人信息收集、使用及保护的关键内容</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_75.png" class="">
<p>自动续费服务规则(补充协议)的关键内容</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_76.png" class="">
<p>与业务相关的部分(复杂度来自于业务流程本身，关注的是如何盈利和成本结构)</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_77.png" class="">
<p>与领域相关的部分(复杂度来自于问题本身，关注的是如何解决问题)</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_78.png" class="">
<p>与当前系统设计相关度不高的部分(通常是非系统承载的法务事项)</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_79.png" class="">

<p><strong>通过分析合约，能够快速了解合约所承载的业务全景</strong></p>
<p>按合约权责相关性可初步划分出上下文</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_80.png" class="">

<p>腾讯视频VIP会员服务协议上下文分析：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_81.png" class="">

<p>腾讯视频VIP会员服务协议上下文业务建模</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_82.png" class="">

<p>自动续费服务规则(补充协议)上下文分析</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_83.png" class="">
<p>自动续费服务规则(补充协议)上下文业务建模</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_84.png" class="">
<p><strong>所有的业务凭证，都是可以借助纸质单据来演练业务追溯过程的</strong></p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_85.png" class="">

<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_86.png" class="">


<h5 id="业务宏流程与核心业务模式"><a href="#业务宏流程与核心业务模式" class="headerlink" title="业务宏流程与核心业务模式"></a>业务宏流程与核心业务模式</h5><p>其它的腾讯会员服务与腾讯视频VIP会员服务有何业务上的区别？</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_87.png" class="">
<p>腾讯影视超级VIP会员服务的差异</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_88.png" class="">
<p>腾讯体育系列VIP会员服务差异</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_89.png" class="">

<p>腾讯视频付费会员服务的业务宏流程</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_90.png" class="">

<h5 id="业务宏流程与核心业务模式-1"><a href="#业务宏流程与核心业务模式-1" class="headerlink" title="业务宏流程与核心业务模式"></a>业务宏流程与核心业务模式</h5><p>识别核心业务模式(包括业务与领域)，便于未来拓展腾讯视频付费会员服务额新业务能力。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_91.png" class="">

<p><strong>由于履约建模法是一种以业务凭证追溯为核心的业务建模方法，而业务凭证是业务活动的结果，具有含义明确和不可变更的特性，所以履约建模法的本质是一种事件建模的方法</strong>。</p>
<ul>
<li>基于合约内容，理解业务</li>
<li>依据合约内容，提取权责和履约关系</li>
<li>按照合约上下文结构进行凭证分析和追溯</li>
<li>补充凭证相关的关键参与元素，丰富上下文</li>
<li>使用角色进行合理抽象，确定业务变化点</li>
<li>识别并划分业务和领域上下文</li>
<li>分析并提取业务宏流程，识别出核心业务模式</li>
</ul>
<p>在缺少合约作为参考或输入的情况下，如何实施履约建模？</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_92.png" class="">

<p>在软件工程最佳实践的基础上，我们所期望的好的设计原则：</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_93.png" class="">

<h5 id="面向业务设计-Business-Oriented-Design-简称BOD"><a href="#面向业务设计-Business-Oriented-Design-简称BOD" class="headerlink" title="面向业务设计(Business Oriented Design 简称BOD)"></a>面向业务设计(Business Oriented Design 简称BOD)</h5><p><strong>是一种以业务为核心，通过促进业务架构、系统架构、组织架构三者的同构性，从而解决业务系统设计和开发复杂性问题的软件系统架构设计思想</strong>。</p>
<h5 id="履约建模法-FulFillment-Modeling-简称：FM"><a href="#履约建模法-FulFillment-Modeling-简称：FM" class="headerlink" title="履约建模法(FulFillment Modeling 简称：FM)"></a>履约建模法(FulFillment Modeling 简称：FM)</h5><p>是一种业务履约关系为视角，通过提取业务模式并引入变化点构建可复用业务模型的云原生时代的业务建模方法。</p>
<h5 id="分层架构-Layered-Architecture"><a href="#分层架构-Layered-Architecture" class="headerlink" title="分层架构(Layered Architecture)"></a>分层架构(Layered Architecture)</h5><p>是依据隔离变化原则，将软件组件(广义)依据纵向结构进行分层组织的架构方式，其中上层能够依赖或调用下层，下层对上层一无所知，每一层都对自己的上层隐藏下层的细节。</p>
<h4 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h4><h5 id="从业务建模到微服务架构设计"><a href="#从业务建模到微服务架构设计" class="headerlink" title="从业务建模到微服务架构设计"></a>从业务建模到微服务架构设计</h5><ul>
<li>代码化(Infrastructure as code)<ul>
<li>镜像(Image)：将基础设施和应用以代码化的形式进行定义并构建出的静态制品，可被存储、传输和复制。</li>
<li>实例(Instance)：由镜像通过实例化所产生的运行时概念，工作在单一进程中。</li>
<li>复制(Replication)：通过镜像并实例化的方式复制机器(应用+基础设施)，已实现弹性和水平伸缩。</li>
</ul>
</li>
<li>不可变(Immutable)：镜像和实例一经创建不可修改</li>
<li>可抛弃(Disposable)：实例只能创建和销毁，也仅能通过这两种方式实现替换(新的创建、老的销毁)</li>
</ul>
<h5 id="微服务与云原生"><a href="#微服务与云原生" class="headerlink" title="微服务与云原生"></a>微服务与云原生</h5><img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_94.png" class="">

<h5 id="弹性边界的含义"><a href="#弹性边界的含义" class="headerlink" title="弹性边界的含义"></a>弹性边界的含义</h5><ul>
<li>具有不同弹性扩缩容需求的架构元素之间的边界，即弹性边界。</li>
<li>微服务架构风格可以被看作是一种以业务上下文为弹性边界的云原生架构模式。</li>
</ul>
<h5 id="微服务拆分的依据？"><a href="#微服务拆分的依据？" class="headerlink" title="微服务拆分的依据？"></a>微服务拆分的依据？</h5><p>以弹性边界为主，业务上下文为辅。</p>
<p><strong>注意：云平台更擅长处理依赖于吞吐量的弹性依赖，而不擅长处理对依赖于响应时间的弹性依赖。</strong></p>
<h5 id="业务天然的异步性，是弹性边界的天然设别点。"><a href="#业务天然的异步性，是弹性边界的天然设别点。" class="headerlink" title="业务天然的异步性，是弹性边界的天然设别点。"></a>业务天然的异步性，是弹性边界的天然设别点。</h5><h5 id="依据业务建模的业务与领域划分，可以指导相应的API能力设计。"><a href="#依据业务建模的业务与领域划分，可以指导相应的API能力设计。" class="headerlink" title="依据业务建模的业务与领域划分，可以指导相应的API能力设计。"></a>依据业务建模的业务与领域划分，可以指导相应的API能力设计。</h5><img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_95.png" class="">

<p>从服用方式来说，业务逻辑的复用往往通过复制运营团队来实现，而领域逻辑的复用往往通过包装并被业务集成来实现。</p>
<h5 id="从复用模式看业务中台与组织划分"><a href="#从复用模式看业务中台与组织划分" class="headerlink" title="从复用模式看业务中台与组织划分"></a>从复用模式看业务中台与组织划分</h5><p>按照变化频率实施分层</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_96.png" class="">
<p>从云原生的视角来看，不同的业务可以看做不同的云分区</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_97.png" class="">
<p>业务核心模式是业务中台的核心</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_91.png" class="">
<p>不同差异化业务和领域可以运行在不同的云分区</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_98.png" class="">
<p>用云原生的视角来看实现方式</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_99.png" class="">

<p><strong>业务中台即企业核心业务模式的复用平台</strong></p>
<h4 id="组织架构"><a href="#组织架构" class="headerlink" title="组织架构"></a>组织架构</h4><p>团队拓扑学与面向业务设计的惊人契合</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_100.png" class="">

<h4 id="基于合约视角的SaaS化策略"><a href="#基于合约视角的SaaS化策略" class="headerlink" title="基于合约视角的SaaS化策略"></a>基于合约视角的SaaS化策略</h4><p>SaaS化的两种功能策略</p>
<ul>
<li>按功能实施</li>
<li>按业务运营策略实施<ul>
<li>一种特殊的合约视角：SLA：服务级别协议</li>
</ul>
</li>
</ul>
<p>按功能实施的SaaS服务</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_101.png" class="">
<p>案业务运营策略实施SaaS化策略:灵感来源于篮球投篮的魔球理论：三分价值高，上篮把握性大；中距离很尴尬，所以要尽可能将出手转化为上篮或三分球，避免中距离</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_102.png" class="">

<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_103.png" class="">

<h5 id="什么时候切入面向业务设计？"><a href="#什么时候切入面向业务设计？" class="headerlink" title="什么时候切入面向业务设计？"></a>什么时候切入面向业务设计？</h5><p>服务蓝图(Service Blueprint)：是一个实用流程图，它从客户角度展示了服务交付过程。服务蓝图已经是管理服务运营、服务设计和服务定位最广泛使用的工具之一。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_104.png" class="">

<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_107.png" class="">

<p>在服务蓝图上拥有大量能够支撑下一步实施业务建模的直接参考信息。</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_105.png" class="">
<p>另外：在应用DDD的时候也可以基于服务蓝图的变种基于事件风暴的领域建模</p>
<img data-src="/2023/08/30/Design-Patterns/%E4%B8%9A%E5%8A%A1%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/example_106.png" class="">]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>business driven design</tag>
      </tags>
  </entry>
  <entry>
    <title>【HTTPS】技术详解</title>
    <url>/2023/04/01/HTTPS/%E3%80%90HTTPS%E3%80%91%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><code>HTTPS</code> 实现原理：</p>
<span id="more"></span>

<img data-src="/2023/04/01/HTTPS/%E3%80%90HTTPS%E3%80%91%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HTTPS.png" class="">]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>技术详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机&amp;垃圾回收</title>
    <url>/2023/07/12/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾收集是通过销毁未使用的对象，回收运行时未使用的内存的过程。垃圾收集器利用垃圾收集根(<code>GCRoots</code>)的概念来识别活动对象和死亡对象。</p>
<ul>
<li>有系统类加载器加载的类（不是自定义类加载器）</li>
<li>实时线程</li>
<li>当前执行方法的局部变量和参数</li>
<li><code>JNI</code>方法的局部变量和参数</li>
<li>全局的<code>JNI</code>参考</li>
<li>用作同步监视器的对象</li>
<li><code>JVM</code>出于其目的而从垃圾回收中保留的对象</li>
</ul>
<span id="more"></span>

<h4 id="Java垃圾收集的各个阶段"><a href="#Java垃圾收集的各个阶段" class="headerlink" title="Java垃圾收集的各个阶段"></a><code>Java</code>垃圾收集的各个阶段</h4><ul>
<li><p>将对象标记为活动状态。 当 GC 访问一个对象时，它会将其标记为可访问并因此处于活动状态。垃圾收集器访问的每个对象都被标记为活动对象。所有无法从 GC Root 到达的对象都是垃圾，并被视为垃圾收集的候选对象。</p>
</li>
<li><p>扫描死亡对象。 标记阶段之后，我们就有了由活（已访问）对象和死（未访问）对象占用的内存空间。清除阶段释放包含这些死对象的内存碎片。</p>
</li>
<li><p>压缩内存剩余的对象。 在扫描阶段移除的死对象不一定彼此相邻。因此，您最终可能会拥有碎片化的内存空间。垃圾收集器删除死对象后可以压缩内存，以便剩余对象位于堆开头的连续块中。压缩过程使按顺序为新对象分配内存变得更容易。</p>
</li>
</ul>
<h4 id="Java分代垃圾收集"><a href="#Java分代垃圾收集" class="headerlink" title="Java分代垃圾收集"></a><code>Java</code>分代垃圾收集</h4><p>JVM中的堆内存区域分为三部分：</p>


<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>当幸存的对象在幸存者空间中移动达到一定阈值时，它们就会被移动到老年代。您可以使用该-<code>Xmn</code>标志来设置年轻代的大小。</p>
<p>为对象的任期定义了一个阈值，该阈值决定了在将其移至老一代之前可以存活多少个垃圾收集周期。当对象从老年代被垃圾回收时，它是一个主要的垃圾回收事件。您可以使用-<code>Xms</code>和-<code>Xmx</code>标志来设置堆内存的初始大小和最大大小。</p>
<p>总结一下：当一个对象被创建时，它首先被放入年轻代的Eden空间 中。一旦发生较小的垃圾回收，来自Eden 的活动对象就会被提升到FromSpace。当下一次次要垃圾回收发生时，Eden和FromSpace中的活动对象都会移动到ToSpace中。这个循环持续特定的次数。如果该对象在此之后仍然被使用，则下一个垃圾收集周期会将其移动到老年代空间。</p>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>类和方法等元数据存储在永久代中。它由 JVM 在运行时根据应用程序使用的类进行填充。您可以使用-<code>XX:PermGen</code>和-<code>XX:MaxPermGen</code>标志来设置永久代的初始大小和最大大小。</p>
<h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>从 Java 8 开始，<code>MetaSpace</code>内存空间取代了<code>PermGen</code>空间。该实现与 &#96;PermGen 不同，元空间的堆大小也会自动调整。</p>
<h4 id="垃圾收集器的类型"><a href="#垃圾收集器的类型" class="headerlink" title="垃圾收集器的类型"></a>垃圾收集器的类型</h4><ul>
<li><p>串行垃圾收集器的jvm参数是：-<code>XX:+UseSerialGC</code>。整个应用程序暂停。由于整个应用程序在垃圾收集期间被冻结，因此在需要低延迟的现实场景中不建议这样做。</p>
</li>
<li><p>并行垃圾收集器的JVM 参数是-<code>XX:+UseParallelGC</code>。由于它更适合多线程环境，因此可以在需要完成大量工作并且可以接受长时间暂停的情况下使用它，例如运行批处理作业。</p>
</li>
<li><p><code>CMS</code>(并发标记清除) <code>GC</code> 这也称为并发低暂停收集器的JVM 参数是-<code>XX:+UseConcMarkSweepGC</code>。多个线程用于次要垃圾回收，使用与并行相同的算法。主要垃圾收集是多线程的，就像并行旧 <code>GC</code> 一样，但 &#96;CMS&#96;&#96; 与应用程序进程同时运行，以最大限度地减少停止事件。因此，CMS 收集器比其他 GC 使用更多的 CPU。如果您可以分配更多的CPU以获得更好的性能，那么CMS垃圾收集器是比并行收集器更好的选择。CMS GC 中不执行压缩。</p>
</li>
<li><p><code>G1</code>(垃圾优先) G1 垃圾收集器的<code>JVM</code>参数是-<code>XX:+UseG1GC</code>。GC 专为具有较大可用堆大小（超过 4GB）的多线程应用程序而设计。它像 CMS 一样是并行和并发的，但与旧的垃圾收集器相比，它的工作原理完全不同。虽然G1也是分代的，但是它没有单独的年轻代和老年代的区域。相反，每一代都是一组区域，这允许以灵活的方式调整年轻代的大小。由于G1GC会识别出垃圾最多的区域，并首先对该区域进行垃圾收集，因此称为垃圾优先。</p>
</li>
<li><p><code>Epsilon</code> 垃圾收集器的 JVM 参数是-<code>XX:+UnlockExperimentalVMOptions</code> -<code>XX:+UseEpsilonGC</code> Epsilon 是一个不执行任何操作（no-op）的垃圾收集器，作为 JDK 11 的一部分发布。它处理内存分配，但不实现任何实际的内存回收机制。一旦可用的 Java 堆耗尽，JVM 将关闭。</p>
</li>
<li><p><code>Shenandoah</code> 垃圾收集器的 JVM 参数是-<code>XX:+UnlockExperimentalVMOptions</code> -<code>XX:+UseShenandoahGC</code> 它与应用程序线程同时执行更多垃圾收集周期工作。G1 仅在应用程序暂停时才能清空其堆区域，而 Shenandoah 可以与应用程序同时重新定位对象。Shenandoah 可以在检测到可用内存后立即压缩活动对象、清理垃圾并将 RAM 释放回操作系统。由于所有这些都是在应用程序运行时同时发生的，Shenandoah 的 CPU 密集度更高。</p>
</li>
<li><p>ZGC 是另一种 GC垃圾收集器的 <code>JVM</code> 参数是-<code>XX:+UnlockExperimentalVMOptions</code> -<code>XX:+UseZGC</code>，作为 <code>JDK 11</code> 的一部分发布，并在 <code>JDK 12</code> 中进行了改进。它适用于需要低延迟（少于 10 毫秒暂停）和&#x2F;或使用非常大的堆（数 TB）的应用程序。<code>ZGC</code> 的主要目标是低延迟、可扩展性和易用性。为了实现这一点，<code>ZGC</code> 允许 Java 应用程序在执行所有垃圾收集操作时继续运行。默认情况下，<code>ZGC</code>取消提交未使用的内存并将其返回给操作系统。因此，<code>ZGC</code> 通过提供极低的暂停时间（通常在 2 毫秒内），比其他传统 GC 带来了显着改进。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Unified Modeling Langusge 2.5.1</title>
    <url>/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/</url>
    <content><![CDATA[<h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><h3 id="需求陈述的关键词"><a href="#需求陈述的关键词" class="headerlink" title="需求陈述的关键词"></a>需求陈述的关键词</h3><p>本规范中的词语<code>SHALL</code>、<code>SHALL NOT</code>、<code>SHOULD</code>、<code>SHOULD NOT</code>、<code>MAY</code>、<code>NEED NOT</code>、<code>CAN和CANNOT</code>应根据 <code>ISO</code> 附录 <code>H</code> 进行解释。</p>
<h3 id="示例图注释"><a href="#示例图注释" class="headerlink" title="示例图注释"></a>示例图注释</h3><p>本规范中的一些图表示例包含解释性注释，不应将其与成为正式 <code>UML</code> 图形符号的一部分。在这些情况下，解释性文本源自 <code>UML</code> 图边界之外，并且有一个箭头指向由注释解释的图表的特征。 该规格的色彩再现显示了这些注释为红色。</p>
<h2 id="公共结构"><a href="#公共结构" class="headerlink" title="公共结构"></a>公共结构</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>本节规定了 UML 中所有结构建模的基本建模概念。 许多元类这里定义的类是抽象的，为后续子句中定义的专门的、具体的类提供基础。 然而，为了提供如何在 <code>UML</code> 中应用这些基本概念的示例，有必要使用这些具体的建模构造，即使它们在后面的条款中指定。 提供了适当的前向参考：必要的。</p>
<span id="more"></span>

<h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><h4 id="概括-1"><a href="#概括-1" class="headerlink" title="概括"></a>概括</h4><p>元素和关系的根概念为 <code>UML</code> 中所有其他建模概念提供了基础。</p>
<h4 id="抽象语法"><a href="#抽象语法" class="headerlink" title="抽象语法"></a>抽象语法</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_1.png" class="" title="Unified Modeling Language 2.5.1">

<h4 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h4><h5 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h5><p>元素是模型的组成部分。 元素的后代提供适合它们的概念的语义代表。每个元素都具有拥有其他元素的固有能力。 当一个元素从模型中删除时，它的所有元素<code>ownedElements</code> 也必须从模型中删除。 每种元素的抽象语法指定它可能拥有哪些其他类型的元素。 模型中的每个元素必须完全属于该模型中的另一个元素模型，该模式的顶级包除外。</p>
<h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>每种元素都可以拥有注释。 元素的<code>ownedComments</code> 不添加任何语义，但可以表示对模型读者有用的信息。</p>
<h5 id="Relationships"><a href="#Relationships" class="headerlink" title="Relationships"></a>Relationships</h5><p>关系是指定其他元素之间某种关系的元素。 <code>DirectedRelationship</code> 表示源模型元素集合与目标模型元素。 <code>DirectedRelationship</code> 被认为是从源元素指向到目标元素。</p>
<h5 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h5><p><code>relatedElements</code> 对于定向关系，线路通常以某种方式从源定向到目标。注释显示为右上角弯曲的矩形（也称为“注释符号”）。 这矩形包含评论的正文。 与每个 <code>annotatedElement</code> 的连接由单独的虚线显示线。 如果从注释符号可以清楚地看出，连接注释符号和注释元素的虚线可以被抑制上下文，或者在此图中不重要。</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><h4 id="概括-2"><a href="#概括-2" class="headerlink" title="概括"></a>概括</h4><p>模板是由其他模型元素参数化的模型元素。 本子条款规定了一般适用于各种模板的概念。</p>
<h4 id="抽象语法-1"><a href="#抽象语法-1" class="headerlink" title="抽象语法"></a>抽象语法</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_2.png" class="" title="Templates">


<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_3.png" class="" title="Template bindings">

<h4 id="语义-1"><a href="#语义-1" class="headerlink" title="语义"></a>语义</h4><h5 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h5><p><code>TemplateableElement</code> 是一种可以选择定义为模板并绑定到其他模板的元素。 <code>A template</code> 是使用 <code>TemplateSignature</code> 进行参数化的 <code>TemplateableElement</code>。 这样的模板可以用来使用 <code>TemplateBinding</code> 关系生成其他模型元素。</p>
<p>模板不能以与同类非模板元素相同的方式使用（例如，模板类不能用作 <code>TypedElement</code> 的类型）。 模板元素只能用于生成绑定元素或作为另一个模板规范的一部分（例如，一个模板类可以转化为另一个模板类）。</p>
<p>模板的 <code>TemplateSignature</code> 定义了一组可以绑定到实际模型元素的 <code>TemplateParameters</code> 在模板的绑定元素中。 绑定元素是具有一个或多个此类的 <code>TemplateableElement</code> 模板绑定。</p>
<p>完全绑定元素是其所有 <code>TemplateBindings</code> 都绑定了该元素的所有 <code>TemplateParameter</code> 的绑定元素。模板正在绑定。 完全绑定元素是普通元素，可以像使用完全绑定元素一样使用同类非绑定（和非模板）元素。 例如，类模板的完全绑定元素可以用作类型化元素的类型。</p>
<p>部分绑定元素是至少其中一个 <code>TemplateBindings</code> 不绑定所绑定模板的<code>TemplateParameter</code>。 部分绑定的元素仍被视为模板，由其 <code>TemplateBindings</code> 未绑定的剩余 <code>TemplateParameters</code> 进行参数化。</p>
<h5 id="Template-Signatures"><a href="#Template-Signatures" class="headerlink" title="Template Signatures"></a>Template Signatures</h5><p><code>TemplateSignature</code> 的 <code>TemplateParameters</code> 指定将被实际替换的形参绑定中的参数（或默认值）。 <code>TemplateParameter</code> 是根据包含的 <code>ParameterableElement</code>定义的在拥有 <code>TemplateSignature</code> 的模板内，<code>TemplateParameter</code> 是其中的一部分。 这样的元素被称为由 <code>TemplateParameter</code> 公开。</p>
<p>公开的 <code>ParameterableElement</code> 可以由模板直接或间接拥有，也可以由模板拥有<code>TemplateParameter</code> 本身，在元素不具有所有权关联的情况下模板模型。 无论哪种情况，<code>ParameterableElement</code> 仅在模板的上下文中才有意义 - 它将被绑定上下文中的实际元素有效替换。 因此，由 <code>ParameterableElement</code> 公开不能在其所属模板或有权访问该模板的其他模板之外引用 <code>TemplateParameter</code>原始模板的内部结构（例如，如果模板是专用的）。 <code>TemplateSignature</code>的子类还可以添加附加规则，限制在上下文中可将哪种类型的 <code>ParameterableElement</code> 用于 <code>TemplateParameter</code>一种特定类型的模板。</p>
<p><code>TemplateParameter</code> 还可以引用 <code>ParameterableElement</code> 作为任何形式参数的默认值<code>TemplateBinding</code> 不为参数提供显式 <code>TemplateParameterSubstitution</code>。 类似于公开的 <code>ParameterableElement</code>，默认的 <code>ParameterableElement</code> 可以直接由模板拥有，也可以由模板拥有模板参数本身。 即使在以下情况下，<code>TemplateParameter</code> 也可以拥有此默认 <code>ParameterableElement</code>：公开的 <code>ParameterableElement</code> 不属于 <code>TemplateParameter</code>。</p>
<h5 id="Template-Bindings"><a href="#Template-Bindings" class="headerlink" title="Template Bindings"></a>Template Bindings</h5><p><code>TemplateBinding</code> 是 <code>TemplateableElement</code> 和指定替换的模板之间的关系模板的正式 <code>TemplateParameters</code> 的实际 <code>ParameterableElements</code>。 模板参数替换指定要替换 <code>TemplateBinding</code> 上下文中的形式 <code>TemplateParameter</code> 的实际参数。如果在此绑定中没有为形式参数指定实际参数，则该参数的默认 <code>ParameterableElement</code>使用正式的 <code>TemplateParameter</code>（如果指定）。</p>
<p>一个绑定元素可以有多个绑定，可能绑定到同一个模板。 此外，绑定元素可以包含除绑定之外的元素。 多个绑定的扩展以及绑定元素拥有的任何其他元素如何组合在一起以完全指定绑定元素的详细信息特定于 <code>TemplateableElement</code> 的子类。 一般原则是，单独评估绑定以产生中间结果（每个绑定一个），然后将其合并以产生最终结果。 这就是融合的方式所做的工作是针对每种 <code>TemplateableElement</code> 的。</p>
<p><code>TemplateableElement</code> 可以包含 <code>TemplateSignature</code> 和 <code>TemplateBindings</code>。 因此是一个 <code>TemplateableElement</code>可以既是模板又是绑定元素。</p>
<p>一致的工具可能要求所有正式的 <code>TemplateParameters</code> 必须作为 <code>TemplateBinding</code> 的一部分进行绑定（完全绑定）或者可以仅允许绑定正式模板参数的子集（部分绑定）。 在里面完全绑定的情况下，绑定元素可能有自己的<code>TemplateSignature</code>，并且<code>TemplateParameters</code>来自这可以作为 <code>TemplateBinding</code> 的实际参数提供。 在部分绑定的情况下，未绑定的形式<code>TemplateParameters</code> 充当绑定元素的正式 <code>TemplateParameters</code>，因此它仍然是模板。</p>
<div class="note danger"><p><strong>注意</strong>：具有默认值的 <code>TemplateParameter</code> 永远无法取消绑定，因为它具有到默认值的隐式绑定，即使没有给出显式的 <code>TemplateParameterSubstitution</code>。</p>
</div>

<h5 id="Bound-Element-Semantics"><a href="#Bound-Element-Semantics" class="headerlink" title="Bound Element Semantics"></a>Bound Element Semantics</h5><p><code>TemplateBinding</code> 意味着绑定元素具有相同的格式良好的约束和语义，就像拥有目标 <code>TemplateSignature</code> 的模板的内容被复制到绑定元素中，替换任何<code>ParameterableElements</code> 通过指定的相应 <code>ParameterableElements</code> 公开为正式 <code>TemplateParameters</code>作为 <code>TemplateBinding</code> 中的实际模板参数。 但是，绑定元素并不显式包含模型通过扩展其绑定的模板而隐含的元素。 尽管如此，还是可以定义一个扩展的将绑定元素的 <code>TemplateParameterSubstitution</code> 实际应用到目标所产生的绑定元素模板。</p>
<p>如果一个绑定元素有多个<code>TemplateBinding</code>，那么可以根据模板定义一个特定的扩展绑定元素在每个 <code>TemplateBinding</code> 上。 然后通过合并所有扩展边界元素来构造整体扩展边界元素<br><code>TemplateBinding</code> 特定的扩展绑定元素与原始绑定元素包含的任何其他元素。如前所述，如何执行此合并取决于所绑定的 <code>TemplateableElement</code> 的类型。</p>
<p>在模型中包含绑定元素并不自动要求相应的扩展绑定元素是包含在模型中。 然而，如果按上面给出的方式构造的扩展绑定元素违反了任何格式良好的约束，则原始绑定元素也被认为是格式不正确的。</p>
<p>另一方面，如果绑定元素用于命名空间模板，则可能需要能够引用绑定元素的成员被视为命名空间本身。 例如，对于类模板的绑定元素，可能需要引用该类的操作，例如从 <code>CallOperationAction</code> 中。</p>
<div class="note danger"><p><strong>注意</strong>：从模板引用操作是不够的，因为模板类的每个绑定元素都是被认为拥有自己的有效模板操作副本。</p>
</div>

<p>为了适应这种情况，允许在模型中包含扩展的绑定元素除了绑定元素本身之外，还包括绑定元素。 在这种情况下，扩展的绑定元素必须有一个实现与其扩展的绑定元素的依赖关系。 扩展的绑定元素必须是根据上面给出的规则构建（由建模者手动或由工具自动）。 参考然后照常从其他模型元素到扩展绑定元素的可见成员被认为是在语义上等同于对原始绑定的相应隐式成员进行的有效引用元素。 直接与扩展绑定元素建立的任何关系在语义上等同于关系对绑定元素本身进行了修改。</p>
<h4 id="Notation（符号）"><a href="#Notation（符号）" class="headerlink" title="Notation（符号）"></a>Notation（符号）</h4><p>如果 <code>TemplateableElement</code> 具有 <code>TemplateParameters</code>，则会在符号上叠加一个小虚线矩形<code>TemplateableElement</code>，通常位于符号的右上角（如果可能）。 虚线矩形包含正式模板参数的列表。 参数列表不能为空，尽管它可能被抑制在演示中。 <code>TemplateableElement</code> 符号中的任何其他部分均正常显示。</p>
<p>正式的 <code>TemplateParameter</code> 列表可以显示为逗号分隔的列表，也可以是一个正式的 <code>TemplateParameter</code> 列表。每行模板参数。 <code>TemplateParameter</code> 的一般表示法是显示在模板的<code>Template</code>参数列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">template</span>-parameter&gt; ::= &lt;<span class="keyword">template</span>-param-name&gt; [‘:’ &lt;parameter-kind&gt; ] [‘=’ &lt;<span class="keyword">default</span>&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;parameter-kind&gt;</code> 是公开元素的元类名称。 &lt;模板参数名称&gt; 的语法和 <code>&lt;default&gt;</code> 取决于此 <code>TemplateParameter</code> 的 <code>ParameteredElement</code> 类型。</p>
<p>绑定元素与其他同类元素具有相同的图形符号。 <code>TemplateBinding</code> 显示为虚线箭头，尾部位于绑定元素上，箭头位于模板上，关键字<code>“bind”</code>。 这绑定信息可以显示为模板参数替换的逗号分隔列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">template</span>-param-substitution&gt; ::= &lt;<span class="keyword">template</span>-param-name&gt; ‘-&gt;’ &lt;actual-<span class="keyword">template</span>-parameter&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;template-param-name&gt;</code> 的语法是形参的<code>parameteredElement</code> 的名称或<code>qualifiedNameTemplateParameter</code> 和 <code>&lt;actual-template-parameter&gt;</code> 的类型取决于 <code>ParameteredElement</code> 的类型那个模板参数。</p>
<p>绑定元素的绑定的另一种表示方式是将绑定信息包含在绑定元素的符号。 绑定元素的名称被扩展为包含绑定表达式以下语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[&lt;element-name&gt; ‘:’] &lt;binding-expression&gt; [‘,’ &lt;binding-expression&gt;]*</span><br><span class="line">&lt;binding-expression&gt; ::= &lt;<span class="keyword">template</span>-element-name&gt; ‘&lt;‘ &lt;<span class="keyword">template</span>-param-substitution&gt; [‘,’&lt;<span class="keyword">template</span>-paramsubstitution]*‘&gt;’</span><br><span class="line"><span class="keyword">and</span> &lt;<span class="keyword">template</span>-param-substitution&gt; is defined as above.</span><br></pre></td></tr></table></figure>
<h3 id="NameSpaces"><a href="#NameSpaces" class="headerlink" title="NameSpaces"></a>NameSpaces</h3><h4 id="概括-3"><a href="#概括-3" class="headerlink" title="概括"></a>概括</h4><p>命名空间是模型中的一个元素，包含一组可以通过名称标识的命名元素。 包（参见第 12 条）是命名空间，其特定目的是包含其他命名元素以组织模型，但许多其他类型的模型元素也是命名空间，包括分类器（参见子条款 9.2），其中包含命名特征和嵌套分类器，以及行为特征（参见子条款 9.4），其中包含命名特征参数。</p>
<h4 id="抽象语法-2"><a href="#抽象语法-2" class="headerlink" title="抽象语法"></a>抽象语法</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_4.png" class="" title="Namespaces">

<h4 id="语义-2"><a href="#语义-2" class="headerlink" title="语义"></a>语义</h4><h5 id="NameSpaces-1"><a href="#NameSpaces-1" class="headerlink" title="NameSpaces"></a>NameSpaces</h5><p>命名空间为命名元素提供容器，称为其拥有的成员。 命名空间也可以从其他命名空间导入 <code>NamedElements</code>，在这种情况下，这些元素与<code>ownedMembers</code> 一起都是导入命名空间。 如果名称为 <code>N</code> 的命名空间的成员是名称为 <code>x</code> 的 <code>NamedElement</code>，则成员可以通过 <code>N::x</code> 形式的限定名称来引用。</p>
<p>当需要区分时，不符合命名空间名称的简单名称可以称为不合格的名字。 在命名空间内，非限定名称可用于引用该命名空间的成员，并且到未隐藏的外部名称。 外部名称是 <code>NamedElement</code> 的名称，可以使用直接封闭的命名空间中的非限定名称。 外部名称被隐藏，除非它可以与所有名称区分开来内部命名空间的成员。 （请参阅下面“命名元素”下关于可区分性的讨论。）</p>
<p>由于命名空间本身就是一个 <code>NamedElement</code>，因此 <code>NamedElement</code> 的完全限定名称可能包括多个命名空间名称，例如 N1::N2::x。</p>
<p>命名空间的<code>ownedRule</code>约束表示受约束元素的格式良好的规则（参见子第 <code>7.6</code> 条关于约束）。 在确定受约束元素是否格式良好时，将评估这些约束。</p>
<h5 id="Named-Elements"><a href="#Named-Elements" class="headerlink" title="Named Elements"></a>Named Elements</h5><p><code>NamedElement</code> 是模型中可能有名称的元素。 该名称可用于识别命名空间内的 <code>NamedElement</code> 可以访问其名称。</p>
<div class="note danger"><p><strong>注意</strong>：<code>NamedElement</code> 的名称是可选的，它提供了缺少名称的可能性（即与空名称不同）。</p>
</div>

<p><code>NamedElements</code> 可能会根据指定 <code>NamedElement</code> 的规则出现在命名空间中与另一个有区别。 默认规则是，如果两个成员具有不同的名称或者如果它们具有相同的名称，但它们的元类不同，并且都不是另一个的（直接或间接）子类。对于特定情况，例如通过签名区分的操作（请参阅子命令），此规则可能会被覆盖第 9.6 条）。</p>
<p><code>NamedElement</code> 的可见性提供了一种限制元素使用的方法，无论是在命名空间还是在访问元素。 它旨在与导入、泛化和访问机制结合使用。</p>
<p>除了具有显式名称之外，<code>NamedElement</code> 还可以与 <code>StringExpression</code> 关联（参见第 8.3 节）可用于指定 <code>NamedElement</code> 的计算名称。 在模板中（参见第 7.3 条），<code>NamedElement</code> 可能有一个关联的 <code>StringExpression</code>，其子表达式可能是 <code>ParameteredElements</code> 公开的通过模板参数。 绑定模板时，公开的子表达式将替换为实际值替换模板参数。 <code>StringExpression</code> 的值是连接后产生的字符串子表达式的值，然后提供 <code>NamedElement</code> 的名称。</p>
<p><code>NamedElement</code> 可以具有与其关联的名称和名称表达式。 在这种情况下，名称可以用作<code>NamedElement</code> 的别名，例如，可用于引用约束表达式中的元素。（这避免了在文本表面表示法中使用 <code>StringExpressions</code> 的需要，这通常很麻烦，尽管它确实不排除它。）</p>
<h5 id="Packageable-Elements-and-Imports"><a href="#Packageable-Elements-and-Imports" class="headerlink" title="Packageable Elements and Imports"></a>Packageable Elements and Imports</h5><p><code>PackageableElement</code> 是可以直接由包拥有的 <code>NamedElement</code>（请参阅有关包的第 12 条）。 任何这样的元素可以充当模板参数（参见有关模板的子条款 7.3）。</p>
<p><code>ElementImport</code> 是导入命名空间和 <code>PackageableElement</code> 之间的 <code>DirectedRelationship</code>。 它添加了<code>PackageableElement</code> 的名称到导入命名空间。 <code>ElementImport</code> 的可见性可以是与导入元素相同或更受限制。</p>
<p>如果名称与外部名称（在封闭的命名空间中定义的元素，可使用它在封闭的命名空间中的非限定名称）在导入命名空间中，外部名称被隐藏<code>ElementImport</code>，非限定名称指的是导入的元素。 外部名称可以使用其访问合格名称。</p>
<p><code>PackageImport</code> 是导入命名空间和 <code>Package</code> 之间的 <code>DirectedRelationship</code>，表明<code>importing Namespace</code> 会将 <code>Package</code> 的成员名称添加到其自己的命名空间中。 从概念上讲，一个包<code>import</code> 相当于对导入的命名空间的每个单独成员都有一个 <code>ElementImport</code>，除非有单独定义的 <code>ElementImport</code>。 如果某个元素有 <code>ElementImport</code>，那么它优先于通过 <code>PackageImport</code> 可能导入相同的元素。</p>
<p>如果无法区分的元素由于 <code>ElementImports</code> 或<code>PackageImports</code>，元素不会添加到导入命名空间中，并且这些元素的名称必须是符合资格才能在该命名空间中使用。 如果导入元素的名称与元素归导入命名空间所有，该元素未添加到导入命名空间且名称为该元素必须经过限定才能使用。</p>
<p>公开导入的元素是导入命名空间的公共成员。 这意味着，如果命名空间是一个包，另一个命名空间对它的 PackageImport 将导致进一步公开这些内容除了包的公共成员之外，还将成员导入到其他命名空间中。</p>
<div class="note danger"><p><strong>注意</strong>：命名空间不能导入自身，也不能导入任何它自己拥有的成员。 这意味着它不是<code>NamedElement</code> 可以在其所属的命名空间中获取别名。</p>
</div>

<h4 id="Notation-1"><a href="#Notation-1" class="headerlink" title="Notation"></a>Notation</h4><h5 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h5><p>命名空间没有通用的符号。 特定种类的命名空间有其自己特定的符号。符合标准的工具可以选择允许使用第 12.2.4 条中定义的“圆加号”符号来显示封装成员资格也可用于显示其他类型命名空间中的成员资格（例如，显示嵌套分类器和拥有的类的行为）。</p>
<h5 id="Name-Expressions"><a href="#Name-Expressions" class="headerlink" title="Name Expressions"></a>Name Expressions</h5><p>与 <code>NamedElement</code> 关联的 <code>nameExpression</code> 可以通过两种方式显示，具体取决于别名是否为是否需要。 两种表示法如图 7.6 所示.</p>
<ul>
<li>无别名：<code>StringExpression</code> 显示为模型元素的名称。</li>
<li>使用别名：无论名称出现在何处，都会显示 <code>StringExpression</code> 和别名。 别名下面给出 <code>StringExpression</code>。</li>
</ul>
<p>在这两种情况下，<code>StringExpression</code> 都出现在<code>“$”</code>符号之间。 <code>UML</code> 中的表达式规范支持在抽象语法中使用替代字符串表达式语言——它们必须以 <code>String</code> 作为其类型，并且可以是带有操作数的运算符表达式的一些结构。在模板的上下文中，在 <code>a</code> 中参数化的 <code>StringExpression</code>（通常是 <code>LiteralStrings</code>）的子表达式模板显示在尖括号之间。</p>
<h5 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h5><p><code>PackageImport</code> 或 <code>ElementImport</code> 使用虚线箭头显示，带有来自导入的空心箭头导入的包或元素的命名空间。 如果可见性，则关键字 <code>«import»</code> 将显示在虚线箭头附近是公开的； 否则，将显示关键字<code>“access”</code>以指示私有可见性。 别名可能显示在之后或下方关键字“导入”。 如果 <code>ElementImport</code> 的导入元素是 <code>Package</code>，则关键字可以选择为前面是<code>“element”，即“element import”</code>。</p>
<p>作为虚线箭头的替代方案，可以通过以下文本来显示 <code>PackageImport</code> 或 <code>ElementImport</code>：在大括号内唯一标识导入的包或元素，位于名称下方或之后命名空间。 <code>PackageImport</code> 的文本语法是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">‘&#123;<span class="keyword">import</span> ’ &lt;qualified-name&gt; ‘&#125;’ | ‘&#123;access ’ &lt;qualified-name&gt; ‘&#125;’</span><br><span class="line">The textual syntax <span class="keyword">for</span> an ElementImport is:</span><br><span class="line"> ‘&#123;element <span class="keyword">import</span>’ &lt;qualified-name&gt; ‘&#125;’ | ‘&#123;element access ’ &lt;qualified-name&gt; ‘&#125;’</span><br></pre></td></tr></table></figure>
<p> 或者，也可以显示别名（如果有）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">‘&#123;element <span class="keyword">import</span> ’ &lt;qualified-name&gt; ‘ as ’ &lt;alias&gt; ‘&#125;’ | ‘&#123;element access ’ &lt;qualified-name&gt; ‘as’ &lt;alias&gt; ‘&#125;’</span><br></pre></td></tr></table></figure>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><h5 id="Name-Expressions-1"><a href="#Name-Expressions-1" class="headerlink" title="Name Expressions"></a>Name Expressions</h5><p>下图显示了一个资源分配包模板，其中前两个正式模板参数是字符串表达式参数。 这些正式的模板参数在包模板中使用来命名一些<code>Classes</code> 和 <code>Association</code>结束。 该图还显示了一个绑定包（名为 <code>TrainingAdmin</code>），它有两个绑定到此 <code>ResourceAllocation</code> 模板。 第一个绑定用字符串<code>“Instructor”</code>替换资源，<code>ResourceKind</code> 的字符串<code>“Qualification”</code>，<code>System</code> 的 <code>Class TrainingAdminSystem</code>。 第二个绑定将字符串<code>“Facility”</code>替换为 <code>Resource</code>，将字符串<code>“FacilitySpecification”</code>替换为 <code>ResourceKind</code>，将 <code>Class</code> 替换为<code>TrainingAdminSystem</code> 再次替换为 <code>System</code>。</p>
<p>绑定的结果包括 <code>Classes Instructor、Qualification、InstructorAllocation</code> 以及 <code>Classes Facility</code>，设施规格和设施分配。 这些关联也被类似地复制。</p>
<div class="note danger"><p><strong>注意</strong>：请求将具有从单个<code>“the&lt;ResourceKind&gt;”</code>属性派生的两个属性（此处通过箭头），即规格和设施规格。</p>
</div>

<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_5.png" class="" title="Template package with string parameters">

<h5 id="Imports-1"><a href="#Imports-1" class="headerlink" title="Imports"></a>Imports</h5><p>下图中，所示的 <code>ElementImport</code> 允许包程序中的元素通过名称引用 <code>DataType</code>时间类型无限定。 然而，他们仍然需要显式引用 <code>Types::Integer</code>，因为这个 <code>Element</code> 不是进口的。 数据类型字符串被导入到程序包中，但它作为以下成员不公开可见程序在该包之外，并且不能通过其他命名空间进一步从该程序包导入。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_6.png" class="" title="Example of element import">

<p>在下图中，<code>ElementImport</code> 与别名相结合，这意味着将引用 <code>DataType Types::Real</code>在 <code>Shapes</code> 包中名为 <code>Double</code>。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_7.png" class="" title="Example of element import with aliasing">

<p>在下图中，显示了许多 <code>PackageImport</code>。 <code>Types</code> 的公共成员被导入到 <code>ShoppingCart</code> 中然后进一步导入到<code>WebShop</code>。 不过，辅助队的成员只是由私人引进的。<code>ShoppingCart</code> 不能使用 <code>WebShop</code> 中的不合格名称进行引用。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_8.png" class="" title="Examples of public and private package imports">

<h3 id="Types-and-Multiplicity"><a href="#Types-and-Multiplicity" class="headerlink" title="Types and Multiplicity"></a>Types and Multiplicity</h3><h4 id="概括-4"><a href="#概括-4" class="headerlink" title="概括"></a>概括</h4><p>类型和多重性在包含值的元素的声明中使用，以约束类型和可能包含的值的数量。</p>
<h4 id="抽象语法-3"><a href="#抽象语法-3" class="headerlink" title="抽象语法"></a>抽象语法</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_9.png" class="" title="Abstract syntax of types and multiplicity elements">

<h4 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h4><h5 id="Types-and-Typed-Elements"><a href="#Types-and-Typed-Elements" class="headerlink" title="Types and Typed Elements"></a>Types and Typed Elements</h5><p>类型指定一组允许的值，称为类型的实例。 根据类型、实例的种类随着时间的推移，该类型可能会被创建或销毁。 然而，类型实例的构成规则由该类型的定义保持固定。 <code>UML</code> 中的所有类型都是分类器。</p>
<p><code>TypedElement</code> 是 <code>NamedElement</code>，它以某种方式表示特定值。 取决于种类<code>TypedElement</code>，它所代表的实际值可能会随着时间的推移而改变。 <code>TypedElement</code> 种类的示例包括<br><code>ValueSpecification</code>，它直接指定值的集合，以及 <code>StructuralFeature</code>，它表示作为拥有它的分类器实例的结构的一部分而保存的值。</p>
<p>如果 <code>TypedElement</code> 有关联的 <code>Type</code>，则 <code>TypedElement</code> 表示的任何值（在任何时间点）都应是给定类型的实例。 没有关联 <code>Type</code> 的 <code>TypeElement</code> 可以表示任何值。</p>
<h5 id="Multiplicities"><a href="#Multiplicities" class="headerlink" title="Multiplicities"></a>Multiplicities</h5><p><code>MultiplicityElement</code> 是可以以某种方式实例化以表示值集合的元素。根据 <code>MultiplicityElement</code> 的类型，集合中的值可能会随时间而变化。 种类的例子<code>MultiplicityElement</code> 包括 <code>StructuralFeature</code>，它在拥有的 <code>Classifier</code> 实例的上下文中具有它和变量，它在活动执行的上下文中有值。</p>
<p>集合的基数是该集合中包含的值的数量。 <code>MultiplicityElement</code> 指定它所代表的集合的有效基数。 多重性是对基数，不得小于为指定的下界且不大于指定的上限（除非多重性是无限的，在这种情况下，上限没有限制）。</p>
<p><code>MultiplicityElement</code> 的重数的下限和上限由 <code>ValueSpecifications</code> 指定，<code>lowerBound</code> 必须为 <code>Integer</code> 值，<code>upperBound</code> 必须为 <code>UnlimitedNatural</code> 值。 如果<code>MultiplicityElement</code> 的 <code>upperBound</code> 有无限自然值（“*”）。 如果 <code>MultiplicityElement</code> 的 <code>upperBound</code>大于 1，则它是多值的（包括无界）。 非多值的 <code>MultiplicityElement</code> 最多只能表示一个值。</p>
<p><code>MultiplicityElement</code> 可以定义其边界均为零的重数。 这将允许的基数限制为为 <code>0</code>； 也就是说，它要求该元素的实例化不包含任何值。 这在以下情况下很有用概括以约束更一般分类器的基数。 它适用于（但不仅限于）重新定义更通用的分类器中存在的属性。如果 <code>MultiplicityElement</code> 被指定为有序（即 <code>isOrdered</code> 为 <code>true</code>），则实例化中的值集合该元素的值是有序的。 这种排序意味着存在从正整数到元素的映射值的集合。 如果 <code>MultiplicityElement</code> 不是多值，则 <code>isOrdered</code> 的值没有语义效果。如果 <code>MultiplicityElement</code> 被指定为无序（即 <code>isOrdered</code> 为 <code>false</code>），则不能对该元素的实例化中的值排序。</p>
<p>如果 <code>MultiplicityElement</code> 被指定为唯一（即 <code>isUnique</code> 为 <code>true</code>），则实例化中的值集合该元素必须是唯一的。 也就是说，集合中没有两个值可以相等，其中对象（实例）相等类）基于对象标识，而数据值（数据类型的实例）和信号实例的相等性是基于值。 如果一个<code>MultiplicityElement</code> 不是多值的，因此 <code>isUnique</code> 的值没有语义效果。总而言之，<code>isOrdered</code> 和 <code>isUnique</code> 属性可用于指定<code>MultiplicityElement</code> 的实例化属于四种类型之一。 </p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_10.png" class="" title="Collection types for MultiplicityElements">

<h4 id="Notation-2"><a href="#Notation-2" class="headerlink" title="Notation"></a>Notation</h4><h5 id="Multiplicity-Element"><a href="#Multiplicity-Element" class="headerlink" title="Multiplicity Element"></a>Multiplicity Element</h5><p><code>MultiplicityElement</code> 的特定符号是为每种具体类型的 <code>MultiplicityElement</code> 定义的。 一般来说，符号将包括多重性规范，它显示为包含边界的文本字符串多重性和用于显示可选排序和唯一性规范的符号。</p>
<p>多重界限可以用以下格式显示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;lower-bound&gt; ‘..’ &lt;upper-bound&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;lower-bound&gt;</code> 是 <code>Integer</code> 类型的 <code>ValueSpecification</code>，<code>&lt;upper-bound&gt;</code> 是UnlimitedNatural类型的 <code>ValueSpecification</code>。 星号 <code>(*)</code> 用作多重性规范的一部分，表示无限的上限边界。如果多重性与表示法是文本字符串（例如属性）的 <code>MultiplicityElement</code> 关联，则多重字符串作为该文本字符串的一部分放置在方括号 <code>([ ])</code>内。如果多重性与显示为符号（例如关联端）的多重性元素相关联，则多重性字符串显示时不带方括号，并且可以放置在元素符号附近。</p>
<p>如果下限等于上限，则另一种表示法是使用仅包含上限的字符串边界。 例如，“1”在语义上等同于“1..1”多重性。 以零为下界的重数未指定的上限可以使用包含单星“*”而不是“0..*”的替代符号多重性。排序和唯一性规范的具体符号可能会根据具体类型而有所不同多重性元素。 一般的表示法是使用包含“有序”或“无序”的文本注释来定义排序，以及“唯一”或“非唯一”来定义唯一性。</p>
<p>下面的<code>BNF</code>定义了多重性字符串的一般语法，包括支持顺序和唯一性指示符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;multiplicity&gt; ::= &lt;multiplicity-range&gt; [ [ ‘&#123;‘ &lt;order-designator&gt; [‘,’ &lt;uniqueness-designator&gt; ] ‘&#125;’ ] |</span><br><span class="line">[ ‘&#123;‘ &lt;uniqueness-designator&gt; [‘,’ &lt;order-designator&gt; ] ‘&#125;’ ] ]</span><br><span class="line">&lt;multiplicity-range&gt; ::= [ &lt;lower&gt; ‘..’ ] &lt;upper&gt;</span><br><span class="line">&lt;lower&gt; ::= &lt;value-specification&gt;</span><br><span class="line">&lt;upper&gt; ::= &lt;value-specification&gt;</span><br><span class="line">&lt;order-designator&gt; ::= ‘ordered’ | ‘unordered’</span><br><span class="line">&lt;uniqueness-designator&gt; ::= ‘unique’ | ‘nonunique’</span><br></pre></td></tr></table></figure>

<h4 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h4><p>下图中，显示两个多重字符串作为类符号中属性规范的一部分。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_11.png" class="" title="Multiplicity within a textual specification">

<p>下图中，显示两个多重字符串作为两个关联端规范的一部分。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_12.png" class="" title="Multiplicity as an adornment to a symbol">

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>约束是一个断言，指示模型的任何有效实现都必须满足的限制包含约束。 <code>Constraint</code> 附加到一组 <code>constrainedElements</code>，它表示附加语义有关这些元素的信息。</p>
<h4 id="Abstract-Syntax"><a href="#Abstract-Syntax" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_13.png" class="" title="Abstract Syntax of Constraints">

<h4 id="Semantics-1"><a href="#Semantics-1" class="headerlink" title="Semantics"></a>Semantics</h4><p>约束的规范由布尔类型的 <code>ValueSpecification</code>给出。 计算规范可以引用约束的 <code>constrainedElements</code> 以及约束的上下文。一般来说，约束有多种可能的上下文。 约束的上下文决定了何时评估约束规范。 例如，作为操作前提条件的约束在操作调用开始时，而作为后置条件的约束在操作结束时评估调用。通过评估其规范来评估约束。 如果规范评估为真，则约束为当时就满足了。 如果规范评估为 <code>false</code>，则不满足 <code>Constraint</code>，并且实现进行评估的模型无效。</p>
<h4 id="Notation-3"><a href="#Notation-3" class="headerlink" title="Notation"></a>Notation</h4><p>某些类型的约束是在 <code>UML</code> 中预定义的，其他类型的约束可以是用户定义的。 用户定义的规范约束通常表示为某种语言中的文本字符串，其语法和解释如下所定义语言。 在某些情况下，形式语言（例如 <code>OCL</code>）或编程语言（例如 <code>Java</code>）可能是适当的，在其他情况下可以使用自然语言。 这样的规范可以表示为具有适当语言和正文的 <code>OpaqueExpression</code>。 可以将约束标记为根据以下 <code>BNF</code>，文本在大括号 <code>(&#123;&#125;)</code> 内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;constraint&gt; ::= ‘&#123;‘ [ &lt;name&gt; ‘:’ ] &lt;boolean-expression&gt; ‘ &#125;’</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;name&gt;</code> 是约束的名称，<code>&lt;boolean-expression&gt;</code> 是约束的适当文本表示法约束规范。最常见的是，约束字符串放置在注释符号中，并附加到每个符号<code>constrainedElements</code>由虚线表示。对于应用于单个 <code>constrainedElement</code>（例如单个类或关联）的约束，约束字符串可以直接放置在 <code>constrainedElement</code> 的符号附近，最好靠近名称（如果有）。 一个工具就能做到可以确定<code>constrainedElement</code>。对于表示法是文本字符串（例如属性等）的 <code>Element</code>，约束字符串可以跟在 <code>Element</code> 后面文本字符串。 这样注释的元素就是约束的单个 <code>constrainedElement</code>。</p>
<p>对于适用于两个元素（例如两个类或两个关联）的约束，可以显示约束作为约束字符串标记的元素之间的虚线。如果约束显示为两个元素之间的虚线，则可以在一端放置一个箭头。 这箭头方向是约束内的相关信息。 箭头尾部的 Element 映射到 constrainedElement 中的第一个位置，箭头头部的元素映射到 constrainedElement 中的第二个位置。对于三个或更多相同类型的路径（例如泛化路径或关联路径），约束字符串可以附加到穿过所有路径的虚线。</p>
<h4 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_14.png" class="" title="Constraint in a note symbol">

<p>下图中，显示附加到属性的约束字符串。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_15.png" class="" title="Constraint attached to an attribute">

<p>下图中，显示两个关联之间的 {xor} 约束</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_16.png" class="" title="{xor} constraint">

<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><h4 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h4><p>依赖关系表示模型元素之间的供应商&#x2F;客户关系，其中供应商的修改可能影响客户端模型元素。</p>
<h4 id="Abstract-Syntax-1"><a href="#Abstract-Syntax-1" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_17.png" class="" title="Abstract syntax of dependencies">

<h4 id="Semantics-2"><a href="#Semantics-2" class="headerlink" title="Semantics"></a>Semantics</h4><h5 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h5><p>依赖关系意味着如果没有供应商，客户端的语义就不完整。 模型中的依赖关系没有任何运行时语义含义。 语义全部给出参与关系的 <code>NamedElements</code> 的术语，而不是它们的实例。</p>
<h5 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h5><p><code>Usage</code>是一种依赖关系，其中一个 <code>NamedElement</code> 需要另一个 <code>NamedElement</code>（或一组 <code>NamedElement</code>）其全面实施或运作。 使用并未指定客户如何使用供应商，除了以下事实：供应商由客户的定义或实现使用。</p>
<h5 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h5><p>抽象是一种依赖关系，它关联两个 <code>NamedElements</code> 或代表相同内容的 <code>NamedElements</code> 集不同抽象层次或不同观点的概念。 该关系可以被定义为映射供应商和客户之间。 根据抽象的具体构造型，映射可以是形式的或非正式的，可以是单向的，也可以是双向的。 抽象具有预定义的构造型（例如<code>“Derive”，“Refine”和“Trace”</code>）在标准配置文件中定义。 如果一个抽象有多个客户，供应商作为一个组映射到客户集合中。 例如，一个分析级类可能会被分成几个设计级类。 如果有多个供应商，情况也类似。</p>
<h5 id="Realization"><a href="#Realization" class="headerlink" title="Realization"></a>Realization</h5><p><code>Realization</code>是两组 <code>NamedElement</code> 之间的特殊抽象依赖关系，一组代表一个规范（供应商）和另一个代表该规范的实现（客户）。 实现可以用于建模逐步细化、优化、转换、模板、模型合成、框架实现表示客户端集合是供应商集合的实现，供应商集合充当规范。 <code>“Realization”</code>的含义并没有严格定义，而是暗示了更细化或关于特定建模环境的复杂形式。 可以指定规范和之间的映射实现元素，尽管这不一定是可计算的。</p>
<h4 id="Notation-4"><a href="#Notation-4" class="headerlink" title="Notation"></a>Notation</h4><p>依赖关系显示为两个模型元素之间的虚线箭头。 箭头尾部的模型元素（客户）箭头处的模型元素（供应商）。 箭头可以标有可选的关键字或构造型以及可选名称。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_18.png" class="" title="Notation for a Dependency between two elements">

<p>可以为客户或供应商提供一组元素。 在这种情况下，一个或多个箭头的尾部位于客户与一个或多个箭头的尾部相连，其头指向供应商。 可以在上面放置一个小点如果需要的话。 应在连接点附上有关依赖关系的注释。用法显示为依赖项，并附加有<code>“use”</code>关键字。抽象显示为带有“抽象”关键字或附加的特定预定义构造型的依赖项到它。实现显示为一条虚线，末端有一个三角形箭头，对应于已实现的元素。</p>
<h4 id="Examples-3"><a href="#Examples-3" class="headerlink" title="Examples"></a>Examples</h4><p>下图中，<code>CarFactory</code> 类依赖于 <code>Car</code> 类。 在这种情况下，依赖关系是一个用法应用了标准构造型<code>“Instantiate”</code>，表明 <code>CarFactory</code> 类的实例创建了汽车类。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_19.png" class="" title="An example of an «Instantiate» Dependency">

<p>下图中，<code>Order</code>类需要<code>Line Item</code>类才能完整实现。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_20.png" class="" title="An example of a «use» Dependency">

<p>下图中，举例说明了 <code>Business</code> 类由 <code>Owner</code> 和 <code>Employee</code> 组合实现的示例类。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_21.png" class="" title="An example of a realization Dependency">

<h3 id="Classifier-Descriptions"><a href="#Classifier-Descriptions" class="headerlink" title="Classifier Descriptions"></a>Classifier Descriptions</h3><h4 id="Abstraction-Class"><a href="#Abstraction-Class" class="headerlink" title="Abstraction [Class]"></a>Abstraction [Class]</h4><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>抽象是一种关系，它将表示同一概念的两个元素或元素集联系起来。不同的抽象层次或不同的<code>viewpoints</code>。</p>
<h4 id="Comment-Class"><a href="#Comment-Class" class="headerlink" title="Comment [Class]"></a>Comment [Class]</h4><h5 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h5><p>注释是可以附加到一组元素的文本注释。</p>
<h4 id="Constraint-Class"><a href="#Constraint-Class" class="headerlink" title="Constraint [Class]"></a>Constraint [Class]</h4><h5 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h5><p>约束是用自然语言文本或机器可读语言表达的条件或限制声明一个元素或一组元素的一些语义的目的。</p>
<h4 id="Dependency-Class"><a href="#Dependency-Class" class="headerlink" title="Dependency [Class]"></a>Dependency [Class]</h4><h5 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h5><p>依赖关系是一种关系，表示单个模型元素或一组模型元素需要其他元素其规范或实现的模型元素。 这意味着客户端的完整语义元素在语义上或结构上取决于供应商元素的定义。</p>
<h4 id="DirectedRelationship-Abstract-Class"><a href="#DirectedRelationship-Abstract-Class" class="headerlink" title="DirectedRelationship [Abstract Class]"></a>DirectedRelationship [Abstract Class]</h4><h5 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h5><p><code>DirectedRelationship</code> 表示源模型元素集合和目标模型元素。</p>
<h4 id="Element-Abstract-Class"><a href="#Element-Abstract-Class" class="headerlink" title="Element [Abstract Class]"></a>Element [Abstract Class]</h4><h5 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h5><p>元素是模型的组成部分。 因此，它有能力拥有其他元素。</p>
<h4 id="ElementImport-Class"><a href="#ElementImport-Class" class="headerlink" title="ElementImport [Class]"></a>ElementImport [Class]</h4><h5 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h5><p><code>ElementImport</code> 标识命名空间中的 <code>NamedElement</code>，而不是拥有该 <code>NamedElement</code> 的命名空间，并且允许在拥有 <code>ElementImport</code> 的命名空间中使用非限定名称来引用 <code>NamedElement</code>。</p>
<h4 id="MultiplicityElement-Abstract-Class"><a href="#MultiplicityElement-Abstract-Class" class="headerlink" title="MultiplicityElement [Abstract Class]"></a>MultiplicityElement [Abstract Class]</h4><h5 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h5><p>重数是非负整数的包含区间的定义，从下限开始到结束具有（可能是无限的）上限。 <code>MultiplicityElement</code> 嵌入此信息来指定允许的元素实例化的基数。</p>
<h4 id="NamedElement-Abstract-Class"><a href="#NamedElement-Abstract-Class" class="headerlink" title="NamedElement [Abstract Class]"></a>NamedElement [Abstract Class]</h4><h5 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h5><p><code>NamedElement</code> 是模型中可能有名称的元素。 该名称可以直接给出和&#x2F;或通过使用一个字符串表达式。</p>
<h4 id="Namespace-Abstract-Class"><a href="#Namespace-Abstract-Class" class="headerlink" title="Namespace [Abstract Class]"></a>Namespace [Abstract Class]</h4><h5 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h5><p>命名空间是模型中的一个元素，它拥有和&#x2F;或导入一组可以通过以下方式识别的命名元素姓名。</p>
<h2 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h2><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><p>一般来说，<code>ValueSpecification</code> 是一个模型元素，被认为是在语义上产生零个或多个值。 值的类型和数量应适合于上下文使用 <code>ValueSpecification</code>（由该上下文中给出的约束确定）。以下子条款描述了 <code>UML</code> 中可用的各种 <code>ValueSpecification</code>。</p>
<h3 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a>Literals</h3><h4 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h4><p><code>LiteralSpecification</code> 是指定文字值的 <code>ValueSpecification</code>。 有一种不同的 <code>UML</code> 标准 <code>PrimitiveTypes</code> 的 <code>LiteralSpecification</code>，带有相应的文字符号，加上<code>“null”</code>字面意思是“缺少值”。</p>
<h4 id="Abstract-Syntax-2"><a href="#Abstract-Syntax-2" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_22.png" class="" title="Literals">

<h4 id="Semantics-3"><a href="#Semantics-3" class="headerlink" title="Semantics"></a>Semantics</h4><p><code>LiteralSpecification</code> 有六种：</p>
<ol>
<li><code>LiteralNull</code> 旨在用于显式建模缺少值的情况。 在一个背景下<code>MultiplicityElement</code> 的重数下界为 <code>0</code>，这对应于空集（即，一组没有值）。 这相当于没有为 <code>Element</code> 指定任何值。</li>
<li><code>LiteralString</code> 指定 <code>PrimitiveType String</code> 的常量值。 虽然 <code>String</code> 被指定为字符序列，字符串值在 <code>UML</code> 中被认为是原始的，因此它们的内部结构不是指定为 <code>UML</code> 语义的一部分。</li>
<li><code>LiteralInteger</code> 指定 <code>PrimitiveType Integer</code> 的常量值。</li>
<li><code>LiteralBoolean</code> 指定 <code>PrimitiveType Boolean</code> 的常量值。</li>
<li><code>LiteralUnlimitedNatural</code> 指定 <code>PrimitiveType UnlimitedNatural</code> 的常量值。</li>
<li><code>LiteralReal</code> 指定 <code>PrimitiveType Real</code> 的常量值。</li>
</ol>
<h4 id="Notation-5"><a href="#Notation-5" class="headerlink" title="Notation"></a>Notation</h4><p><code>LiteralSpecifications</code> 以文本方式标注。</p>
<p><code>LiteralNull</code> 的表示法根据其使用位置的不同而有所不同。 它通常显示为<code>“null”一词</code>。 其他地方描述了符号的具体用途。</p>
<ul>
<li><code>LiteralString</code> 显示为双引号内的字符序列。 String 值是以下序列字符，不包括引号。 使用的字符集未指定。</li>
<li><code>LiteralInteger</code> 显示为表示 <code>Integer</code> 值的十进制数字的数字序列。</li>
<li><code>LiteralBoolean</code> 显示为单词<code>“true”</code>或单词<code>“false”</code>，与其值相对应。</li>
<li><code>LiteralUnlimitedNatural</code> 显示为数字序列或星号 <code>(*)</code>，其中星号表示无限制。 请注意，“无限制”表示对某些元素的值没有限制（例如多重性上限），而不是“无穷大”值。</li>
<li><code>LiteralReal</code> 以十进制记数法或科学记数法显示。 十进制表示法由可选符号组成字符 <code>(+/-)</code> 后跟零个或多个数字，可选地后跟一个点 <code>(.)</code>，后跟一个或多个数字。科学记数法由十进制记数法后跟字母<code>“e”</code>或<code>“E”</code>和指数组成由可选的符号字符后跟一个或多个数字组成。 科学记数法表达的是实数等于指数前面的小数表示的数字乘以 <code>10</code> 的幂指数。<br>该表示法由以下 EBNF 规则指定：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;natural-literal&gt; ::= (<span class="string">&#x27;0&#x27;</span>.<span class="number">.&#x27;9&#x27;</span>)+</span><br><span class="line">&lt;decimal-literal&gt; ::= [<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> ] &lt;natural-literal&gt; | [<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> ] [&lt;natural-literal&gt;] <span class="string">&#x27;.&#x27;</span> &lt;natural-literal&gt;</span><br><span class="line">&lt;real-literal&gt; ::= &lt;decimal-literal&gt; [ (<span class="string">&#x27;e&#x27;</span> | <span class="string">&#x27;E&#x27;</span>) [<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> ] &lt;natural-literal&gt; ]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h3><h4 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h4><p>表达式是指定计算结果值的 <code>ValueSpecifications</code>。</p>
<h4 id="Abstract-Syntax-3"><a href="#Abstract-Syntax-3" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_23.png" class="" title="Expressions">

<h4 id="Semantics-4"><a href="#Semantics-4" class="headerlink" title="Semantics"></a>Semantics</h4><h5 id="Expressions-1"><a href="#Expressions-1" class="headerlink" title="Expressions"></a>Expressions</h5><p>表达式被指定为树结构。 该树结构中的每个节点都包含一个符号和一组可选的操作数。 如果没有操作数，则表达式表示终端节点。 如果有操作数，则表达式表示由应用于这些操作数的符号给出的运算符。表达式的计算方法是首先计算其每个操作数，然后执行由结果操作数值的表达式符号。 然而，该符号的实际解释取决于表达式的使用上下文和本规范不提供任何标准符号定义。 一个合格的工具可以定义一组特定的符号并为其提供解释，也可以简单地将所有表达式视为未解释的。</p>
<h5 id="String-Expressions"><a href="#String-Expressions" class="headerlink" title="String Expressions"></a>String Expressions</h5><p><code>StringExpression</code> 是一个表达式，它指定通过连接子字符串列表而派生的字符串值。子字符串以 <code>LiteralString</code> 操作数列表或 <code>StringExpression</code> 子表达式列表的形式给出（但它是不允许将两者混合）。 <code>StringExpression</code> 的 <code>String</code> 值是通过按顺序连接 <code>String</code> 获得的操作数或子表达式的值，具体取决于给定的值。<code>StringExpressions</code> 旨在用于在模板上下文中指定 <code>NamedElements</code> 的名称。 任何一个整个 <code>StringExpression</code> 或其一个或多个子表达式可以用作 <code>ParameterableElements TemplateParameters</code>，允许在模板中参数化 <code>NamedElement</code> 的名称。</p>
<h5 id="Opaque-Expressions"><a href="#Opaque-Expressions" class="headerlink" title="Opaque Expressions"></a>Opaque Expressions</h5><p><code>OpaqueExpression</code> 指定根据 <code>UML</code> 行为或基于使用除 <code>UML</code> 之外的语言的文本语句。 <code>OpaqueExpression</code> 可能有一个由一系列文本字符串组成的主体，这些文本字符串表示替代方法计算 <code>OpaqueExpression</code> 的值。 相应的语言字符串序列可用于指定每个正文字符串要解释的语言。 语言按顺序与正文字符串匹配。<code>UML</code> 规范没有定义正文字符串相对于任何语言的解释方式，尽管其他语言规范可以定义特定的语言字符串，用于指示对这些语言的解释规范（例如，<code>“OCL”</code>表示根据 <code>OCL</code> 规范解释的表达式）。 另请注意，它不是需要指定语言。 如果未指定，则必须确定任何正文字符串的解释隐含地来自主体的形式或 <code>OpaqueExpression</code> 的使用上下文。</p>
<h4 id="Examples-4"><a href="#Examples-4" class="headerlink" title="Examples"></a>Examples</h4><h5 id="Expressions-2"><a href="#Expressions-2" class="headerlink" title="Expressions"></a>Expressions</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span>、<span class="keyword">else</span>、<span class="built_in">plus</span>(x,<span class="number">1</span>)、x+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="Opaque-Expressions-1"><a href="#Opaque-Expressions-1" class="headerlink" title="Opaque Expressions"></a>Opaque Expressions</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a &gt; <span class="number">0</span> &#123;OCL&#125; i &gt; j <span class="keyword">and</span> self.size &gt; i</span><br><span class="line">average hours worked per week</span><br></pre></td></tr></table></figure>

<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><h4 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h4><p>该子条款定义了基于简单时间模型生成值的时间表达式和持续时间。 这简单的时间模型旨在作为时间和时间的更复杂方面的情况的近似值可以安全地忽略测量。 例如，在许多分布式系统中，没有全局的时间概念，只有相对于系统的每个分布式元素的本地时间概念。 时间的相对性没有被考虑在内简单的时间模型，也不是由具有有限分辨率的不完美时钟、溢出、漂移、倾斜等造成的影响。假设与这些特征相关的应用程序将使用更复杂的时间模型由适当的配置文件提供。</p>
<h4 id="Abstract-Syntax-4"><a href="#Abstract-Syntax-4" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_24.png" class="" title="Time and Duration">

<h4 id="Semantics-5"><a href="#Semantics-5" class="headerlink" title="Semantics"></a>Semantics</h4><h5 id="Time-1"><a href="#Time-1" class="headerlink" title="Time"></a>Time</h5><p><code>UML</code> 的结构建模用于对特定时间的实体属性进行建模。 在相比之下，行为建模构造用于模拟这些属性如何随时间变化。 一个事件是一个当感兴趣的事情发生时，特定时间点可能发生的事情的规范<br>正在建模的属性和行为，例如属性值的变化或开始执行活动。在这个概念中，时间只是一个安排事件发生的坐标。 每个事件的发生都可以给出时间坐标值，基于此，可以说是在另一个事件之前、之后或同时发生。持续时间是两个事件发生之间的时间段，计算为时间坐标的差那些事件。 如果模型元素具有行为效果，则该效果可能会在一段时间内发生。 开始持续时间的事件称为进入元素，结束事件称为退出元素。</p>
<h5 id="Observations"><a href="#Observations" class="headerlink" title="Observations"></a>Observations</h5><p><code>Observation</code>表示对相对于模型的其他部分可能发生的事件的观察。 一个对模型内的 <code>NamedElement</code> 进行观察。 感兴趣的事件是当参考进入和退出<code>NamedElement</code>。 如果引用的 <code>NamedElement</code> 不是行为元素，则持续时间进入和退出 <code>NamedElement</code> 之间的值被认为为零，但本规范不另外规定定义在元素上观察到哪些特定事件。观察有两种，时间观察和持续时间观察。<code>TimeObservation</code> 观察进入或退出特定的 <code>NamedElement</code>。 如果<code>firstEvent为true</code>，则它是条目观察到进入的事件，否则观察到退出事件。 <code>TimeObservation</code> 的结果是观察到的事件发生。<code>DurationObservation</code> 观察相对于一个或两个 <code>NamedElement</code> 的持续时间。 如果单个元素是观察到，则观察到的持续时间是元素的进入和退出事件连续发生之间的时间。 如果观察到两个元素，则持续时间介于第一个元素的进入或退出事件与第二个元素的后续进入或退出事件。 在后一种情况下，两个相应的<code>firstEvent</code>值也必须是为 <code>DurationObservation</code> 给出，这样，如果观察到的元素的<code>firstEvent=true</code>，那么它就是入口事件观察到，否则观察到的是退出事件。</p>
<h5 id="TimeExpression"><a href="#TimeExpression" class="headerlink" title="TimeExpression"></a>TimeExpression</h5><p><code>TimeExpression</code> 是一个 <code>ValueSpecification</code>，它计算出某个时刻的时间坐标，可能是相对的对于某些给定的观察集。如果 <code>TimeExpression</code> 有 <code>expr</code>，则会对其求值以生成 <code>TimeExpression</code> 的结果。 表达式必须评估为单个值，但 <code>UML</code> 没有定义该值必须具有的任何特定类型或单位。 表达式可能引用与 <code>TimeExpression</code> 相关的观察结果，但没有为此类引用定义标准符号。 如果<code>TimeExpression</code> 有一个 <code>expr</code> 但没有观测值，那么 <code>expr</code> 的计算结果为时间常数。如果 <code>TimeExpression</code> 没有 <code>expr</code>，那么它必须有一个 <code>TimeObservation</code> 及其结果观察值是 <code>TimeExpression</code> 的值。</p>
<h5 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h5><p><code>Duration</code> 是一个 <code>ValueSpecification</code>，它评估某个持续时间，可能相对于某些给定的一组观察。如果 <code>Duration</code> 有一个 expr，则对其求值以生成 <code>DurationExpression</code> 的结果。 表达式必须评估为单个值，但 <code>UML</code> 没有定义该值必须具有的任何特定类型或单位。 表达式可能参考与持续时间相关的观察结果，但没有为此类参考定义标准符号。 如果<code>Duration</code> 有一个 <code>expr</code> 但没有观测值，然后 <code>expr</code> 计算结果为一个持续时间的常量。如果持续时间没有 <code>expr</code>，那么它必须有一个 <code>DurationObservation</code> 并且该观察的结果是持续时间的值。</p>
<h4 id="Notation-6"><a href="#Notation-6" class="headerlink" title="Notation"></a>Notation</h4><h5 id="Observations-1"><a href="#Observations-1" class="headerlink" title="Observations"></a>Observations</h5><p>观察可以用一条附加到它所引用的 <code>NamedElement</code> 的直线来表示。 给出了观察结果显示在该行未连接端附近的名称。 给出了关于观察的附加符号约定相对于通常使用它们的建模结构的其他地方。</p>
<h5 id="Time-Expressions-and-Durations"><a href="#Time-Expressions-and-Durations" class="headerlink" title="Time Expressions and Durations"></a>Time Expressions and Durations</h5><p>时间表达式或持续时间由其 <code>expr</code> 的文本形式表示（如果有的话）。该表示是用于计算时间或持续时间值的公式，其中可以包括相关的名称观察结果和常数。 如果 <code>TimeExpression</code>或 <code>Duration</code> 没有 <code>expr</code>，则它仅由其表示单一相关观察。持续时间是以特定于实现的文本格式给出的相对时间值。 通常，持续时间是一个非负整数表达式，表示在此持续时间内可能经过的“时间刻度”数。</p>
<h4 id="Examples-5"><a href="#Examples-5" class="headerlink" title="Examples"></a>Examples</h4><p>时间通常使用数字坐标表示，在这种情况下，<code>TimeExpression</code> 的 <code>expr</code> 应计算为数值，其单位可以按照模型中的惯例假定（例如，时间始终以秒为单位）。或者，数据类型可用于对具有特定单位（例如，秒、日等）的时间值和<code>expr</code>进行建模然后，<code>TimeExpression</code> 应该具有这些类型中适当的一种。持续时间是相对时间的值，因此通常表示为非负数，例如整数持续时间内参考时钟上经过的“时间滴答”数量的计数。 在这种情况下，<code>expr</code>的 <code>DurationExpression</code>计算结果应为非负数值。 <code>Duration</code> 值也可以用来表示自某个固定的时间“原点”以来，时间坐标值的持续时间。</p>
<h3 id="Intervals"><a href="#Intervals" class="headerlink" title="Intervals"></a>Intervals</h3><h4 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h4><p>间隔是两个值之间的范围，主要用于断言某些其他元素具有给定范围内的值。 可以为任何类型的值定义间隔，但它们对于时间特别有用持续时间值作为相应 <code>TimeConstraints</code> 和 <code>DurationConstraints</code> 的一部分。</p>
<h3 id="Abstract-Syntax-5"><a href="#Abstract-Syntax-5" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h3><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_25.png" class="" title="Intervals">

<h3 id="Semantics-6"><a href="#Semantics-6" class="headerlink" title="Semantics"></a>Semantics</h3><h4 id="Intervals-1"><a href="#Intervals-1" class="headerlink" title="Intervals"></a>Intervals</h4><p>间隔是使用其他两个 <code>ValueSpecification</code>（最小值和最大值）指定的 <code>ValueSpecification</code>。 间隔是通过首先评估其每个组成 <code>ValueSpecifications</code> ，每个<code>ValueSpecifications</code> 必须评估单个值。<code>Interval</code> 的值就是从最小值到最大值的范围，即所有大于或等于的值的集合等于最小值且小于或等于最大值（可能是空集）。 请注意，虽然从语法上讲，任何类型的 <code>ValueSpecifications</code> 都允许用于 <code>Interval</code> 的最小值和最大值，这是一种标准语义仅针对最小和最大 <code>ValueSpecifications</code> 具有相同类型和该类型的间隔给出解释其上定义了排序。<code>Interval</code> 有两种特殊形式可用于时间约束。 <code>TimeInterval</code> 指定两个时间之间的范围由 <code>TimeExpressions</code> 给出的时间值。 <code>DurationInterval</code> 指定两个持续时间值之间的范围：持续时间。</p>
<h4 id="IntervalConstraint"><a href="#IntervalConstraint" class="headerlink" title="IntervalConstraint"></a>IntervalConstraint</h4><p><code>IntervalConstraint</code> 定义了一个 <code>Constraint</code>，其规范 <code>Interval</code> 给出约束。 <code>IntervalConstraint</code> 的 <code>constrainedElements</code> 被断言为具有范围内的值由 <code>IntervalConstraint</code> 的间隔指定。 如果 <code>constrainedElement</code> 的值超出此范围，则违反了 <code>IntervalConstraint</code>。 如果任何 <code>constrainedElement</code> 无法被解释为值，或者其值不相同类型为 <code>IntervalConstraint</code> 给定的范围，则 <code>IntervalConstraint</code> 没有标准语义解释。<code>IntervalConstraint</code> 有两种专门化用于指定时序约束。 <code>TimeConstraint</code> 定义了单个 <code>constrainedElement</code> 上的 <code>IntervalConstraint</code>，其中约束 <code>Interval</code> 是 <code>TimeInterval</code>。 <code>DurationConstraint</code> 在一个或两个 <code>constrainedElement</code> 上定义<code>IntervalConstraint</code>。</p>
<h4 id="Notation-7"><a href="#Notation-7" class="headerlink" title="Notation"></a>Notation</h4><h5 id="Intervals-2"><a href="#Intervals-2" class="headerlink" title="Intervals"></a>Intervals</h5><p>间隔在文本上由两个用<code>“..”</code>分隔的 <code>ValueSpecifications</code> 的文本表示形式表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;interval&gt; ::= &lt;min-value&gt; ‘ ..’ &lt;max-value&gt;</span><br></pre></td></tr></table></figure>
<p><code>TimeInterval</code> 用 <code>Interval</code> 表示法显示，其中每个 <code>ValueSpecification</code> 元素都是一个 <code>TimeExpression</code>。 <code>DurationInterval</code> 使用 <code>Interval</code> 表示法显示，其中每个 <code>ValueSpecification</code> 元素都是一个 <code>Duration</code>。</p>
<h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><h3 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h3><p>分类是组织的一项重要技术。 本节规定了与分类相关的概念。 这核心概念是分类器，一个抽象元类，其具体子类用于对不同类型的值进行分类。本节中的其他元类表示分类器的组成部分，以及如何实例化分类器的模型使用 <code>InstanceSpecifications</code> 以及所有这些概念之间的各种关系。</p>
<h3 id="Classifiers"><a href="#Classifiers" class="headerlink" title="Classifiers"></a>Classifiers</h3><h4 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h4><p>分类器表示根据实例的特征对实例进行分类。 分类器按层次结构组织。 <code>RedefinableElements</code> 可以在泛化层次结构的上下文中重新定义。</p>
<h4 id="Abstract-Syntax-6"><a href="#Abstract-Syntax-6" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_26.png" class="" title="Classifiers">

<h4 id="Semantics-7"><a href="#Semantics-7" class="headerlink" title="Semantics"></a>Semantics</h4><h5 id="Classifiers-1"><a href="#Classifiers-1" class="headerlink" title="Classifiers"></a>Classifiers</h5><p>分类器具有一组特征，其中一些是属性，称为分类器的属性。 每个功能是分类器的成员。分类器分类的值称为分类器的实例, 可以重新定义分类器。</p>
<h5 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h5><p>泛化定义了分类器之间的泛化&#x2F;专业化关系。 每个概括都涉及一个特定的分类器到更通用的分类器。 给定一个分类器，其一般分类器的传递闭包通常是称为其泛化，其特定分类器的传递闭包称为其特化。 即时的泛化也称为分类器的父类，如果分类器是一个类，则称为它的超类。</p>
<div class="note danger"><p><strong>注意</strong>：父级（分类器之间的泛化关系）的概念与所有者（分类器之间的泛化关系）的概念无关。</p>
</div>

<p>分类器的实例也是其每个泛化的（间接）实例。 任何适用于的限制泛化的实例也适用于分类器的实例。当分类器被泛化时，其泛化的某些成员会被继承，也就是说，它们的行为就好像它们一样在继承的分类器本身中定义。 例如，作为属性的继承成员可能具有值或继承分类器的任何实例中的值的集合，并且作为操作的继承成员可以是在继承分类器的实例上调用。继承的成员集称为继承成员。 除非对特定种类有不同的规定分类器中，继承的成员是不具有私有可见性的成员。类型一致性意味着如果一个类型符合另一个类型，则第一个类型的任何实例都可以用作<code>TypedElement</code> 的值，其类型被声明为第二个<code>Type</code>。</p>
<p><code>Classifier</code> 的 <code>isAbstract</code> 属性为 <code>true</code> 时，指定该 <code>Classifier</code> 是抽象的，即没有直接实例：每个抽象分类器的实例应是其专业化之一的实例。如果一个分类器（父级）概括另一个分类器（子级），则子级的实例不一定是这样的在任何可能的情况下都可以替代父实例。 例如，<code>Circle</code> 可以定义为<code>Ellipse</code> 的专业化，并且它的实例在涉及访问的每种情况下都是可替换的椭圆的性质。 但是，如果 <code>Ellipse</code> 要定义修改其长轴长度的拉伸行为只有这样，<code>Circle</code> 对象将无法实现这样的行为。 <code>isSubstitutable</code> 属性可用于指示特定分类器是否可以在可以使用通用分类器的所有情况下使用。</p>
<h5 id="Redefinition"><a href="#Redefinition" class="headerlink" title="Redefinition"></a>Redefinition</h5><p>专业分类器的泛化的任何成员（即一种 <code>RedefinableElement</code>）都可以重新定义而不是被继承。 重新定义是为了增加、约束或覆盖重新定义的成员专业分类器实例的上下文。 当这种情况发生时，重新定义成员将有助于代替重新定义的成员的专门分类器的结构或行为； 具体来说，任何对在专业分类器实例的上下文中重新定义的成员应解析为重新定义的成员（注意为了避免循环，这里的“任何引用”不包括<code>redefineElement</code>引用本身）。可以重新定义成员的分类器称为 <code>redefinitionContext</code>。 虽然在元模型中<code>redefinitionContext</code> 具有多重性“<em>”，<code>UML</code> 规范中没有出现多个“</em>”的情况重新定义<code>Context</code>。 <code>redefinitionContext</code>是为每种<code>RedefinableElement</code>定义的。重定义元素应与其重定义的 <code>RedefinableElement</code> 一致，但可以添加特定约束或专业化 <code>redefinitionContext</code> 实例特有的其他细节。可以重定义多个 <code>RedefinableElements</code>。 此外，<code>RedefinableElement</code> 可以是多次重新定义，只要明确哪个定义适用于哪个特定实例即可。</p>
<p>当 <code>isLeaf</code> 属性对于特定 <code>RedefinableElement</code> 为 <code>true</code> 时，指定它不应被重新定义。重定义的详细语义因 <code>RedefinableElement</code> 的每个专业化而异。 有各种各样的重定义元素与其重定义元素之间的兼容性，例如名称兼容性（重定义元素与重新定义的元素具有相同的名称），结构兼容性（客户端可见属性重定义元素也是重定义元素的属性），或行为兼容性（重定义元素是可替换重新定义的元素）。 任何类型的兼容性都涉及对重新定义的约束。分类器本身就是一个 <code>RedefinableElement</code>。 当分类器嵌套在类或接口中时，这可以发挥作用，这成为重新定义上下文。 在专门的类或接口的上下文中重新定义分类器具有从专门的类或接口解析的实例对重新定义的分类器进行任何引用。</p>
<h5 id="Substitution"><a href="#Substitution" class="headerlink" title="Substitution"></a>Substitution</h5><p>替换是两个分类器之间的关系，表示替换分类器符合合约分类器指定的合约。 这意味着 <code>substitutingClassifier</code> 的实例是运行时的情况下,在需要合同分类器实例时可以替换。 替换依赖表示运行时不基于专业化的可替代性。 与专业化不同，替代并不意味着有继承结构，但仅遵守公开可用的合同。 它要求：</p>
<ul>
<li>由合约分类器实现的接口, 也由 <code>substitutingClassifier</code> 实现，或者由<code>substitutingClassifier</code> 实现了更专业的接口类型。</li>
<li>合约分类器拥有的任何端口，都有一个替代分类器所拥有的匹配端口。</li>
</ul>
<h4 id="Notation-8"><a href="#Notation-8" class="headerlink" title="Notation"></a>Notation</h4><h5 id="Classifiers-2"><a href="#Classifiers-2" class="headerlink" title="Classifiers"></a>Classifiers</h5><p>分类器是一个抽象元类。 尽管如此，在一个地方定义一个可用的默认符号还是很方便的。 分类器的一些专业化有其自己独特的符号。分类器的默认表示法是一个包含分类器名称的实线矩形，并带有隔间名称下方用水平线分隔。 分类器的名称应以粗体居中。 对于那些区分大小写字符的语言，分类器名称应以大写字母。如果分类器使用默认符号，则应显示与分类器元类相对应的关键字在名称上方的 <code>guillemets</code>中。 每个元类的关键字在附录 <code>C</code> 中列出并在符号中指定对于分类器的每个子类。 不需要关键字来表明元类是 <code>Class</code>。任何关键字（包括构造型名称）也应在分类器上方的 <code>guillemets</code> 内以普通面居中姓名。 如果多个关键字和&#x2F;或构造型名称适用于同一模型元素，则每个关键字和&#x2F;或构造型名称都可以包含在单独的一对 <code>guillemets</code> 并一个接一个地列出。 或者，它们可能全部出现在同一对之间<code>guillemets</code>，用逗号分隔。在使用的字体允许的情况下，抽象分类器的名称以斜体显示。 替代或附加，抽象分类器可以使用其名称之后或下方的文本注释 <code>&#123;abstract&#125;</code> 来显示。分类器形状中的一些隔间是强制性的，并且应得到显示具体语法的工具的支持一致性。 其他是可选的，因为一致性工具可能不支持此类隔间。任何隔室都可以被抑制。 不为抑制隔室绘制分隔线。 如果一个隔间是如果被抑制，则无法推断其中是否存在元素。名为<code>“attributes”</code>的部分包含通过 <code>attribute</code> 属性访问的属性的符号。 这属性隔间是强制性的，并且如果不被抑制，则始终显示在其他隔间上方。</p>
<p>名为“操作”的部分包含操作的符号。 操作舱是强制性的，并且如果未限制，则始终显示在属性隔间下方。 操作室用于拥有操作的分类器，包括类、数据类型和接口。名为“接待”的隔间包含接待的符号。 接待室是强制性的，并且如果未限制，则始终出现在操作室下方。 接待室用于拥有接待的分类器，包括类。任何包含特征符号的隔间都可以显示那些分组在公共文字下的特征，私有和受保护，代表他们的可见性。 可见性文字在隔间中左对齐特征的符号在其下方缩进显示。 这些组可以按任何顺序出现。 可见性分组是可选：一致性工具不需要支持它。一致性工具可以提供选项来抑制包含符号的隔间中的各个特征。一致性工具可以选择支持隔间命名。 可能会显示隔间的名称以删除含糊不清，或者可能被隐藏。 分区名称应居中并以小写字母开头。 隔间名称可以包含空格，并且不应包含标点符号（包括 <code>guillemets</code>）。如果分类器拥有属于分类器的成员（包括行为），则符合标准的工具可以提供显示拥有的分类器以及它们之间的关系的选项，以图表方式嵌套在单独的分类器中所属分类器矩形的隔间。 除非另有规定，该隔室的名称应为从相应的元模型属性派生，如果该属性的重数大于 1，则为复数。因此，对于例如，显示类的属性<code>nestedClassifier</code>的内容的隔间应被调用“嵌套分类器；” 显示<code>BehavioredClassifier</code> 的属性<code>ownedBehavior</code> 的内容的隔间应被称为“拥有的行为”。如果分类器拥有约束，一致工具可以实现一个隔间来显示列出的拥有的约束在所属分类器矩形的单独隔间内。 该可选隔间的名称是<code>“constraints”</code>。</p>
<h5 id="Other-elements"><a href="#Other-elements" class="headerlink" title="Other elements"></a>Other elements</h5><p>泛化显示为一条线，在表示概括的符号之间有一个空心三角形作为箭头。涉及分类器。 箭头指向代表通用分类器的符号。引用相同通用分类器的多个泛化关系可以显示为单独的行单独的箭头。 这种表示法称为“单独目标样式”。 或者，它们可以连接到“共享目标样式”中的相同箭头。<code>RedefinableElement</code> 没有通用符号。 有关特定符号，请参阅 <code>RedefinableElement</code> 的子类。替换显示为依赖项，并附有关键字<code>“substitute”</code>。由分类器继承的成员可以通过在前面添加<code>“^”</code>符号来显示在该分类器的图表上，如果该成员不是继承的，则将显示文本表示形式。 因此继承的符号属性定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;inherited-property&gt; ::= ’^’ &lt;property&gt;</span><br><span class="line">where &lt;property&gt; </span><br><span class="line"></span><br><span class="line">&lt;inherited-connector&gt; ::= ’^’ &lt;connector&gt;</span><br><span class="line">where &lt;connector&gt;</span><br></pre></td></tr></table></figure>
<p>类似的符号可以用于所有继承了分类器成员的命名元素，以表明它们是继承的。继承的成员也可以显示为较浅的颜色，以帮助将它们与非继承的成员区分开。</p>
<h5 id="Examples-6"><a href="#Examples-6" class="headerlink" title="Examples"></a>Examples</h5><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_27.png" class="" title="Generalization notation showing different target styles">

<p>在特定环境中，通用 Window 类可以由 Resizing Window 类替代。</p>
<img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_28.png" class="" title="Example of Substitution notation">

<h3 id="Classifier-Templates"><a href="#Classifier-Templates" class="headerlink" title="Classifier Templates"></a>Classifier Templates</h3><h4 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h4><p>分类器是一种<code>TemplateableElement</code>，表示分类器可以参数化。 这也是（通过<code>PackageableElement</code>）一种 <code>ParameterableElement</code>，因此分类器可以是正式的 <code>TemplateParameter</code> 并且可以被指定为模板绑定中的实际参数。</p>
<h4 id="Abstract-Syntax-7"><a href="#Abstract-Syntax-7" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h4><img data-src="/2024/01/03/Design-Patterns/unified_modeling_language_2.5.1/uml_29.png" class="" title="Classifier Templates">

]]></content>
      <categories>
        <category>系统建模</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2023/02/26/Nginx/Nginx/</url>
    <content><![CDATA[

<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>以下使用 <code>docker</code> 准备学习环境。</p>
<ol>
<li>先拉取<code>centos</code>的最新镜像：<code>docker image pull centos</code></li>
<li>创建一个数据卷用于存放容器中产生的文件：<code>docker volume create centos</code></li>
<li>启动我们的容器：<code>docker run -d -it -v centos:/workdir --name centos  centos /bin/bash</code></li>
<li>进入我们的容器：<code>docker exec -it centos /bin/bash</code></li>
</ol>
<h3 id="Nginx-的主要应用场景"><a href="#Nginx-的主要应用场景" class="headerlink" title="Nginx 的主要应用场景"></a>Nginx 的主要应用场景</h3><ol>
<li>静态资源服务，即通过本地文件系统提供服务；</li>
<li>反向代理服务，提供缓存，负载均衡功能；</li>
<li><code>API</code>服务，通过<code>Openresty</code>直接访问数据库；</li>
</ol>


<span id="more"></span>

<h3 id="Nginx-的组成部分"><a href="#Nginx-的组成部分" class="headerlink" title="Nginx 的组成部分"></a>Nginx 的组成部分</h3><ol>
<li><code>Nginx</code> 二进制可执行文件；</li>
<li><code>Nginx.conf</code> <code>Nginx</code> 配置文件，控制<code>Nginx</code>的行文；</li>
<li><code>access.log</code> 访问日志，记录一条 <code>http</code> 请求信息；</li>
<li><code>error.log</code> 错误日志；</li>
</ol>
<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>为了便于演示，在编译<code>Nginx</code>的时候添加<a href="https://github.com/openresty/echo-nginx-module"><code>echo-nginx-module</code></a>模块，记录一次编译（我所有的操作都是在目录 <code>/workdir</code>下）：</p>
<ol>
<li><p>源代码下载页面：<a href="http://nginx.org/en/download.html"><code>http://nginx.org/en/download.html</code></a> 先下载 <code>1.14.1</code> 版本，然后升级到 <code>1.15.6</code> 最新版；</p>
</li>
<li><p>下载源代码并且解压，<code>wget http://nginx.org/download/nginx-1.14.1.tar.gz</code>，然后 <code>tar -xzvf nginx-1.14.1.tar.gz</code></p>
</li>
<li><p>下载 <a href="https://github.com/openresty/echo-nginx-module"><code>nginx-echo-module</code></a>，<code>wget https://github.com/openresty/echo-nginx-module/archive/master.zip -O nginx-echo-module.zip</code>，并且解压：<code>unzip nginx-echo-module.zip</code></p>
</li>
<li><p>我们开始编译，<code>./configure --prefix=/workdir/nginx --add-module=/workdir/echo-nginx-module-master</code></p>
</li>
<li><p>结束之后，我们执行：<code>make</code>，这时候nginx已经编译好，在 <code>objs</code> 目录下，例如：</p>
 
</li>
<li><p>首次编译，我们执行 <code>make install</code> 安装我们执行的目录：<code>/workdir/nginx</code></p>
</li>
<li><p>至此将看到如下的目录结构：</p>
 
</li>
<li><p>修改Nginx的配置文件让其输出版本号，便于以后升级比较，<code>vim nginx/cong/nginx.conf</code>：</p>
 
<p> 利用我们添加的<code>echo</code>模块中包含的 <code>echo</code> 指令输出 Nginx的版本号。</p>
</li>
<li><p>启动 Nginx （执行命令 <code>./nginx/sbin/nginx</code>）之后，我们访问: <code>http://localhost/version</code>，将会看到：</p>
 
</li>
<li><p>我们下载 <code>1.15.6</code> 版本，并且编译好，编译的时候依然带上<code>echo</code> 模块，但不要执行 <code>make install</code>，将会看到如下结构：</p>
 
</li>
<li><p>由于热更新只是替换二进制文件，但是我们在操作之前先备份旧的二进制文件：<code>cp ./nginx/sbin/nginx ./nginx/sbin/nginx.old</code></p>
</li>
<li><p>使用新版的<code>Nginx</code>二进制文件替换掉当前正在使用中的：<code>cp -f  nginx-1.15.6/objs/nginx ./nginx/sbin/nginx</code></p>
</li>
<li><p>发送信号至正在运行的Nginx，告诉它我们要进行热部署，升级Nginx，<code>kill -USR2 MasterPID</code></p>


<p>这个时候会使用新的二进制文件新起一个<code>master</code>进程，并且将新的请求转到新的<code>worker</code>进程中处理，旧的<code>master</code>和<code>worker</code>虽然仍然存活，但已经不再监听相应的端口并且接受请求了，这个时候我们在查看版本号，就是升级之后的版本了：</p>
<pre><code>[root@5b4bb2c41637 sbin]# curl http://localhost/version
1.15.6
</code></pre>
</li>
<li><p>关闭老的 <code>worker</code> 进程，发送信号给旧的 <code>MasterPID</code>，<code>kill -WINCH MasterPID</code>：</p>


<p>可以看到老的<code>worker</code>进程已经关闭了，但是此时老的<code>master</code>进程依然存在，是因为如果升级有问题，我们还可回退。回滚的时候，向老的 <code>master</code> 进程发送 <code>HUP</code>信号，向新的 <code>master</code> 发送 <code>QUIT</code> 信号。</p>
</li>
<li><p>如果正常升级之后，应该给老的 <code>master</code> 进程发送 <code>QUIT</code> 信号，使其优雅退出。</p>
</li>
</ol>
<h3 id="nginx-命令行"><a href="#nginx-命令行" class="headerlink" title="nginx 命令行"></a>nginx 命令行</h3><ol>
<li><code>nginx -s quit</code> 优雅退出进程</li>
<li><code>nginx -s stop</code> 立即退出进程</li>
</ol>
<h3 id="nginx-常用配置学习"><a href="#nginx-常用配置学习" class="headerlink" title="nginx 常用配置学习"></a>nginx 常用配置学习</h3><h4 id="配置静态资源访问服务器"><a href="#配置静态资源访问服务器" class="headerlink" title="配置静态资源访问服务器"></a>配置静态资源访问服务器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /workdir/libc;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="记录-access-日志"><a href="#记录-access-日志" class="headerlink" title="记录 access 日志"></a>记录 <code>access</code> 日志</h4><p>使用 <a href="http://nginx.org/en/docs/http/ngx_http_log_module.html"><code>ngx_http_log_module</code></a> 模块我们来配置记录访问日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 设置日志格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        # 开启访问日志</span><br><span class="line">        access_log  logs/access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /version &#123;</span><br><span class="line">	        echo $nginx_version;</span><br><span class="line">	    &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    include vhost/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开启-gzip-压缩"><a href="#开启-gzip-压缩" class="headerlink" title="开启 gzip 压缩"></a>开启 <code>gzip</code> 压缩</h4><p>使用 <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html"><code>ngx_http_gzip_module</code></a> 提供的功能，对静态文件进行压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ....</span><br><span class="line">    gzip on;</span><br><span class="line">    # 小于1k不压缩</span><br><span class="line">    gzip_min_length  1k;</span><br><span class="line">    gzip_buffers     4 16k;</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    # 设置压缩级别</span><br><span class="line">    gzip_comp_level 2;</span><br><span class="line">    gzip_types  text/plain application/javascript application/x-javascript text/javascript text/css application/xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_proxied   expired no-cache no-store private auth;</span><br><span class="line">    # IE6 一下禁用</span><br><span class="line">    gzip_disable   &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开启防盗链"><a href="#开启防盗链" class="headerlink" title="开启防盗链"></a>开启防盗链</h4><p>使用 <a href="http://nginx.org/en/docs/http/ngx_http_referer_module.html"><code>ngx_http_referer_module</code></a> 提供的功能实现防盗链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referers blocked server_names *.fudenglong.site;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">    expires      30d;</span><br><span class="line">    access_log off; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>使用 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream"><code>ngx_http_upstream_module</code></a> 模块提供的 <code>upstream</code> 来配置上游服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream local &#123;</span><br><span class="line">    server 127.0.0.1:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定某些路径配置反向代理，使用<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html"><code>ngx_http_proxy_module</code></a>提供的指令：</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path"><code>proxy_cache_path</code></a> 配置缓存存储路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_headet X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    proxy_cache my_cache;</span><br><span class="line">    proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">    proxy_cache_valid 200 304 302 1d;</span><br><span class="line">    proxy_pass http://local;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h3><h4 id="location"><a href="#location" class="headerlink" title="location"></a><code>location</code></h4><p><code>location</code> 配置指令是由 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location">ngx_http_core_module</a> 模块提供，它的配置是下面这个样组的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:  location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">       location @name &#123; ... &#125;</span><br><span class="line">默认:   —</span><br><span class="line">上下文: server, location</span><br></pre></td></tr></table></figure>

<p>它主要是用于根据请求 <code>URL</code> 设置配置，在解码以 <code>％XX</code> 形式编码的文本，解析对相对路径组件 <code>.</code>和<code>..</code>的引用，并将两个或多个相邻斜杠<code>/</code>的可能<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#merge_slashes">压缩</a>为单个斜杠之后，对规范化的URI执行匹配。</p>
<p>一个<code>location</code> 可以被一个前缀字符串定义或者一个正则表达式，正则表达式通过 <code>~*</code>(大小写不敏感) 或者 <code>~</code>(大小写敏感) 指定。为了找到与给定请求匹配的 <code>location</code> ，<code>nginx</code> 首先检查使用前缀字符串定义的 <code>location</code>，其中有最长匹配前缀的将被使用，然后按照他们在配置文件中出现的顺序检查正则表达式，正则表达式的搜索在第一个匹配时终止，并使用相应的配置。如果未找到与正则表达式的匹配，则使用先前记住的前缀位置的配置。</p>
<p><code>location</code> 块是可以嵌套的，但是除了下面提到的。</p>
<p>对于不区分大小写的操作系统（如<code>macOS</code>和<code>Cygwi</code>n），与前缀字符串匹配会忽略大小写（<code>0.7.7</code>）。</p>
<p>正则表达式可以包含捕获组，用于后续的其他指令。</p>
<p>如果最长匹配前缀位置具有“^〜”修饰符，则不检查正则表达式。</p>
<p>此外，使用<code>=</code>修饰符可以定义<code>URI</code>和位置的精确匹配。如果找到完全匹配，则搜索终止。例如，如果频繁发生<code>/</code>请求，则定义<code>location = /</code>将加速这些请求的处理，因为搜索在第一次比较之后立即终止。这样的 <code>location</code> 显然不能包含嵌套 <code>location</code>。</p>
<p>我们来通过一个例子说明情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">    [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">    [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">    [ configuration E ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/</code> 请求将会匹配 <code>A</code>，<code>/index.html</code> 将会匹配 <code>B</code>，<code>/documents/document.html</code> 将会匹配 <code>C</code>，<code>/images/1.gif</code> 将会匹配 <code>D</code>，<code>/documents/1.jpg</code> 将会匹配 <code>E</code>。</p>
<p><code>@</code> 用于定义一个命名 <code>location</code>，这样的 <code>location</code> 不用于常规请求处理，而是用于请求重定向。它们不能嵌套，也不能包含嵌套 <code>location</code>。</p>
<p>匹配顺序是：先精确匹配，然后前缀匹配取最长匹配，然后是正则表达式；但是如果前缀匹配到 <code>^~</code> 则不会进行正则表达式匹配，如果匹配到的最长前缀前面没有 <code>^~</code> 则会继续按声明顺序进行正则表达式匹配，取匹配到的第一个正则表达式，否则匹配前缀匹配。</p>
<h4 id="路由重写"><a href="#路由重写" class="headerlink" title="路由重写"></a>路由重写</h4><p><code>NGINX</code> 通过 <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#internals"><code>ngx_http_rewrite_module</code></a> 模块支持<code>URL</code>重写，支持 if 条件判断，但不支持 else。</p>
<p><code>NGINX rewrite</code> 指令执行顺序：</p>
<ol>
<li>执行 <code>server</code> 快的 <code>rewrite</code> 指令；</li>
<li>执行 <code>location</code> 匹配；</li>
<li>执行选定的 <code>location</code> 中的 <code>rewrite</code> 指令；</li>
</ol>
<p>如果其中某一步 <code>URI</code> 被重写，则重新执行循环 <code>1-3</code>，直到找到真实存在的文件，如果循环超过<code>10</code>次，则返回 <code>500</code> 错误。</p>
<h5 id="break-指令"><a href="#break-指令" class="headerlink" title="break 指令"></a><code>break</code> 指令</h5><p><code>break</code> 的作用域为 <code>server, location, if</code>，用于停止当前虚拟主机的后续 <code>rewrite</code> 指令集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a><code>if</code> 指令</h5><p>语法：<code>if(condition) &#123;...&#125;</code><br>默认值：无<br>作用域：<code>server, location</code></p>
<p>对给定的条件 <code>condition</code> 进行判断。如果为真，大括号内的 <code>rewrite</code> 指令将被执行。<code>if</code>条件( <code>condition</code> )可以是如下任何内容：</p>
<ul>
<li>一个变量名；<code>false</code>如果这个变量是空字符串或者以<code>0</code>开始的字符串；</li>
<li>使用<code>= ,!= </code>比较的一个变量和字符串</li>
<li>是用<code>~， ~*</code>与正则表达式匹配的变量，如果这个正则表达式中包含}，;则整个表达式需要用” 或’ 包围</li>
<li>使用<code>-f ，!-f</code> 检查一个文件是否存在</li>
<li>使用<code>-d, !-d</code> 检查一个目录是否存在</li>
<li>使用<code>-e ，!-e</code> 检查一个文件、目录、符号链接是否存在</li>
<li>使用<code>-x ， !-x</code> 检查一个文件是否可执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="return-指令"><a href="#return-指令" class="headerlink" title="return 指令"></a><code>return</code> 指令</h5><p>语法：<code>return code [text];</code><br>     <code>return code URL;</code><br>     <code>return URL;</code></p>
<p>默认值：无<br>作用域：<code>server</code>，<code>location</code>，<code>if</code></p>
<p>停止处理并返回指定状态码(code)给客户端。非标准状态码 <code>444</code> 表示关闭连接且不给客户端发响应头。</p>
<p>从0.8.42版本起，return 支持响应URL重定向(对于301，302，303，307），或者文本响应。对于文本或者URL重定向可以包含变量。作为特殊情况，可以将重定向 URL 指定为此服务器的本地URI，在这种情况下，根据请求方案（<code>$scheme</code>）以及 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a> 和 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#port_in_redirect">port_in_redirect</a> 指令形成完整重定向URL。</p>
<h5 id="rewrite-指令"><a href="#rewrite-指令" class="headerlink" title="rewrite 指令"></a><code>rewrite</code> 指令</h5><p>语法：<code>	rewrite regex replacement [flag];</code><br>作用域：<code>server, location, if</code></p>
<p>如果指定的正则表达式匹配请求的<code>URL</code>，<code>URL</code> 将被改变为 <code>replacement</code> 中声明的字符串。<code>rewrite</code> 按照他们在配置文件出现的顺序执行，并且可以使用 <code>[flag]</code> 终止进一步处理。如果 <code>replacement</code> 是以 <code>http://</code>, <code>https://</code>, 或者 <code>$scheme</code> 开始，将不再继续处理，这个重定向将返回给客户端。</p>
<p><code>flag</code> 参数可以是下列值之一：</p>
<p><code>last</code>     : 停止处理后续 rewrite 指令集，然后对当前重写的新URI在 rewrite 指令集上重新查找；<br><code>break</code>    : 停止处理后续rewrite指令集，并不在重新查找，但是当前 <code>location</code> 内剩余非 <code>rewrite</code> 语句和 <code>location</code> 外的的非 <code>rewrite</code> 语句可以执行；<br><code>redirect</code> : 如果 <code>replacement</code> 不是以 <code>http://</code> 或 <code>https://</code> 开始，返回<code>302</code>临时重定向；<br><code>permanent</code>: 返回 <code>301</code> 永久重定向。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     ...</span><br><span class="line">     rewrite ^(/download/.*)/media/(.*)..*$ $1/mp3/$2.mp3 last;</span><br><span class="line">     rewrite ^(/download/.*)/audio/(.*)..*$ $1/mp3/$2.ra last;</span><br><span class="line">     return 403;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这些 <code>rewrite</code> 放到 <code>/download/ location</code>，如下所示, 那么应使用 <code>break</code> 而不是 <code>last</code>, 使用 <code>last</code> 将循环<code>10</code>次匹配，然后返回 500错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">    rewrite ^(/download/.*)/media/(.*)..*$ $1/mp3/$2.mp3 break;</span><br><span class="line">    rewrite ^(/download/.*)/audio/(.*)..*$ $1/mp3/$2.ra break;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于重写后的<code>URL</code>（<code>replacement</code>）包含原请求的请求参数，原URL的?后的内容。如果不想带原请求的参数 ，可以在<code>replacement</code>后加一个问号。如下，我们加了一个自定义的参数<code>user=$1</code>,然后在结尾处放了一个问号?,把原请的参数去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rewrite ^/users/(.*)$ /show?user=$1? last;</span><br></pre></td></tr></table></figure>

<h5 id="rewrite-log-指令"><a href="#rewrite-log-指令" class="headerlink" title="rewrite_log 指令"></a><code>rewrite_log</code> 指令</h5><p>语法：<code>rewrite_log on | off;</code><br>作用域：<code>http, server, location, if</code></p>
<p>开启或关闭以 <code>notice</code> 级别打印 <code>rewrite</code> 处理日志到 <code>error_log</code> 文件。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rewrite_log on;</span><br><span class="line">error_log logs/xxx.error.log notice;</span><br></pre></td></tr></table></figure>

<h5 id="set-指令"><a href="#set-指令" class="headerlink" title="set 指令"></a><code>set</code> 指令</h5><p>语法：<code>set $variable value;</code><br>作用域：<code>server, location, if</code></p>
<p>定义一个变量并赋值，值可以是文本，变量或者文本变量混合体。</p>
<h5 id="uninitialized-variable-warn-指令"><a href="#uninitialized-variable-warn-指令" class="headerlink" title="uninitialized_variable_warn 指令"></a><code>uninitialized_variable_warn</code> 指令</h5><p>语法：<code>uninitialized_variable_warn on | off;</code><br>作用域：<code>http, server, location, if</code></p>
<p>控制是否输出为初始化的变量到日志。</p>
<h3 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h3><ol>
<li><a href="http://www.nginx.cn/nginxchscommandline">nginx 平滑升级</a></li>
<li><a href="http://www.nginx.cn/216.html">nginx rewrite指令</a></li>
<li>[ngx_http_rewrite_module 官方模块](<a href="http://nginx.org/en/docs/htt">http://nginx.org/en/docs/htt</a></li>
</ol>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Systems Modeling Language™ v2 Overview</title>
    <url>/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/</url>
    <content><![CDATA[<h3 id="基于模型系统工程-MBSE-的未来"><a href="#基于模型系统工程-MBSE-的未来" class="headerlink" title="基于模型系统工程(MBSE) 的未来"></a>基于模型系统工程(MBSE) 的未来</h3><ul>
<li>作为数字化转型的一部分。</li>
<li>从SoS到组件级的完整生命周期。</li>
<li>自动化的工作流程和数字线程的配置基于敏捷的系统开发方法。</li>
<li>建模模式和重用。</li>
</ul>
<p>实现的目标：</p>
<ul>
<li>管理复杂性和风险。</li>
<li>更快地对变化作出反应。</li>
<li>重用和设计演进。</li>
<li>推理和分析系统。</li>
<li>利益相关者共享认知。</li>
<li>自动化的文档 &amp; 报告。</li>
</ul>
<span id="more"></span>

<h3 id="SysML-v2-的目标"><a href="#SysML-v2-的目标" class="headerlink" title="SysML v2 的目标"></a>SysML v2 的目标</h3><ul>
<li>语言的精确性和广泛性。</li>
<li>语言概念之间的一致性和统一性。</li>
<li>与其他工程模型和工具的互操作性。</li>
<li>模型开发人员和客户的可用性。</li>
<li>支持特定领域应用程序的可扩展性。</li>
<li><code>SysML v1</code>用户和实现者的迁移路径。</li>
</ul>
<h3 id="SysML-v2-的关键成员"><a href="#SysML-v2-的关键成员" class="headerlink" title="SysML v2 的关键成员"></a>SysML v2 的关键成员</h3><ul>
<li>不受<code>UML</code>约束的新元模型，保留了大部分<code>UML</code>建模功能，重点放在系统建模上, 基于形式语义学构建。</li>
<li>基于灵活的视图和视角的鲁棒可视化，图形、表格、文本。</li>
<li>标准化的<code>API</code>来访问模型。</li>
</ul>
<h3 id="示例车辆模型SysML-v2-文本和图形语法"><a href="#示例车辆模型SysML-v2-文本和图形语法" class="headerlink" title="示例车辆模型SysML v2 文本和图形语法"></a>示例车辆模型SysML v2 文本和图形语法</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_1.png" class="">

<h3 id="SysML-v2-vs-SysML-v1的定义和用法"><a href="#SysML-v2-vs-SysML-v1的定义和用法" class="headerlink" title="SysML v2 vs SysML v1的定义和用法"></a>SysML v2 vs SysML v1的定义和用法</h3><ul>
<li>重用概念, 个元素只定义一次，然后在不同的上下文中使用它。</li>
<li><code>SysML v1</code>非正式地介绍了定义和使用的概念。</li>
<li>定义和使用元素是<code>SysML v2</code>的正式组成部分。支持一致的分解和特殊化。</li>
<li>优点：实现了有效的重用、有助于学习和使用语言、能够自动化。</li>
</ul>
<img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_2.png" class="">

<h3 id="SysML-v1-and-SysML-v2-vehicle-block-vs-part-分解"><a href="#SysML-v1-and-SysML-v2-vehicle-block-vs-part-分解" class="headerlink" title="SysML v1 and SysML v2 vehicle block vs part 分解"></a>SysML v1 and SysML v2 vehicle block vs part 分解</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_3.png" class="">

<h3 id="SysML-v2-的需求"><a href="#SysML-v2-的需求" class="headerlink" title="SysML v2 的需求"></a>SysML v2 的需求</h3><ul>
<li><code>SysML v1</code>的需求是基于属性的概念上构建的。</li>
<li>有效的设计方案必须满足的约束定义:<ul>
<li>标识符</li>
<li>可以计算为真或假的约束表达式</li>
<li>约束表达式的属性</li>
<li>约束表达式必须为<code>true</code>，才能满足需求</li>
</ul>
</li>
</ul>
<h3 id="SysML-v1实例-vs-SysML-v2个体和快照"><a href="#SysML-v1实例-vs-SysML-v2个体和快照" class="headerlink" title="SysML v1实例 vs SysML v2个体和快照"></a>SysML v1实例 vs SysML v2个体和快照</h3><p><code>SysML v2</code> 将个体的概念与个体在其生命周期中的某个时刻的快照区分开来。</p>
<img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_4.png" class="">

<h3 id="SysML-v2-别名和短名"><a href="#SysML-v2-别名和短名" class="headerlink" title="SysML v2 别名和短名"></a>SysML v2 别名和短名</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_5.png" class="">

<h3 id="语言扩展-SysML-v2-vs-SysML-v1"><a href="#语言扩展-SysML-v2-vs-SysML-v1" class="headerlink" title="语言扩展 SysML v2 vs SysML v1"></a>语言扩展 SysML v2 vs SysML v1</h3><p><code>SysML v2</code>中的库扩展机制可以自动地将专门化功能与构造型结合起来。</p>
<img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_6.png" class="">

<h3 id="示例车辆的模型（SysML-v2）"><a href="#示例车辆的模型（SysML-v2）" class="headerlink" title="示例车辆的模型（SysML v2）"></a>示例车辆的模型（SysML v2）</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_7.png" class="">

<h3 id="通过标准API连接SysML-v2"><a href="#通过标准API连接SysML-v2" class="headerlink" title="通过标准API连接SysML v2"></a>通过标准API连接SysML v2</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_8.png" class="">

<h3 id="SysML-v2-vs-SysML-v1-比较"><a href="#SysML-v2-vs-SysML-v1-比较" class="headerlink" title="SysML v2 vs SysML v1 比较"></a>SysML v2 vs SysML v1 比较</h3><ul>
<li>更容易学习和使用<ul>
<li>设计成元模型的系统工程概念</li>
<li>定义和用法模式的一致应用</li>
<li>更一致的术语</li>
<li>使用包过滤器更灵活地组织模型</li>
</ul>
</li>
<li>更精确<ul>
<li>文本语法和表达语言</li>
<li>形式语义分类</li>
<li>作为约束的需求</li>
</ul>
</li>
<li>更多表达<ul>
<li>不同的建模</li>
<li>分析用例</li>
<li>权衡分析</li>
<li>个体、快照、时间片</li>
<li>更稳健的定量性质</li>
<li>简单的几何</li>
<li>查询&#x2F;筛选器表达式</li>
<li>元数据</li>
</ul>
</li>
<li>更具可扩展性<ul>
<li>更简单的语言扩展能力(基于模型库)</li>
</ul>
</li>
<li>更多可互操作性<ul>
<li>标准的<code>API</code></li>
</ul>
</li>
</ul>
<h3 id="SysML-v1-转换为-SysML-v2"><a href="#SysML-v1-转换为-SysML-v2" class="headerlink" title="SysML v1 转换为 SysML v2"></a>SysML v1 转换为 SysML v2</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_9.png" class="">

<h3 id="概念统一"><a href="#概念统一" class="headerlink" title="概念统一"></a>概念统一</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_10.png" class="">

<h3 id="在上下文中的专业化"><a href="#在上下文中的专业化" class="headerlink" title="在上下文中的专业化"></a>在上下文中的专业化</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_11.png" class="">
<img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_12.png" class="">

<h3 id="具体关系"><a href="#具体关系" class="headerlink" title="具体关系"></a>具体关系</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_13.png" class="">

<h3 id="紧凑的符号"><a href="#紧凑的符号" class="headerlink" title="紧凑的符号"></a>紧凑的符号</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_14.png" class="">

<h3 id="语义库模型"><a href="#语义库模型" class="headerlink" title="语义库模型"></a>语义库模型</h3><img data-src="/2024/01/08/Other/Systems_Modeling_Language_v2_Overview/sysml_15.png" class="">]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>SysML</tag>
      </tags>
  </entry>
  <entry>
    <title>MBSE-SysML与CAD集成</title>
    <url>/2023/12/27/Other/SysML_CAD_integration/</url>
    <content><![CDATA[<h2 id="系统建模语言（SysML）"><a href="#系统建模语言（SysML）" class="headerlink" title="系统建模语言（SysML）"></a>系统建模语言（SysML）</h2><h3 id="什么是系统建模语言？"><a href="#什么是系统建模语言？" class="headerlink" title="什么是系统建模语言？"></a>什么是系统建模语言？</h3><p><code>SysML</code> 是一种用于系统工程应用程序的通用架构建模语言。</p>
<ul>
<li><code>SysML</code> 支持各种系统和系统之间的规范、分析、设计、验证和确认。这些系统可能包括硬件、软件、信息、流程、人员和设施。</li>
<li><code>SysML</code> 是 <code>UML 2.x</code> 的方言，并被定义为 <code>UML 2 Profile</code>。（<code>UML</code> 配置文件是一种 <code>UML</code> 方言，它通过三种机制自定义语言：构造型、标记值和约束。）</li>
<li><code>SysML</code> 是基于模型的系统工程 <code>(MBSE)</code>的一项支持技术。</li>
</ul>
<p><code>SysML</code>图分类：</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_3.png" class="">

<span id="more"></span>

<h3 id="什么是-SysML-需求图-Requirement-Diagram-？"><a href="#什么是-SysML-需求图-Requirement-Diagram-？" class="headerlink" title="什么是 SysML 需求图(Requirement Diagram)？"></a>什么是 SysML 需求图(Requirement Diagram)？</h3><p>需求：需求（符号：带有“需求”关键字的矩形）是系统必须（“应”）满足的能力或条件。功能需求（&lt;&lt;功能需求&gt;&gt;关键字）指定系统必须执行的功能，而非功能需求（<code>NFR</code>）指定可用于测试系统功能有效性的质量标准。<code>SysML</code> 预定义了 <code>NFR</code> 的以下构造型特性：</p>
<ul>
<li><code>«performanceRequirement»</code></li>
<li><code>«interfaceRequirement»</code></li>
<li><code>«designConstraint»</code></li>
<li><code>«physicalRequirement»</code></li>
</ul>
<p>需求图（<code>req</code>）：<code>SysML</code>需求图是一个静态结构图，显示需求（“需求”）构造、满足（“满足”依赖性）它们的模型元素以及验证（“验证”依赖性）的测试用例之间的关系）。需求图的目的是指定模型中的功能和非功能需求，以便可以将它们追溯到满足它们的其他模型元素和验证它们的测试用例。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_6.png" class="" title="SysML 需求图：顶级需求">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_7.png" class="" title="SysML 需求图：需求集群模式">

<h3 id="什么是-SysML-用例图-Use-Case-Diagram-？"><a href="#什么是-SysML-用例图-Use-Case-Diagram-？" class="headerlink" title="什么是 SysML 用例图(Use Case Diagram)？"></a>什么是 SysML 用例图(Use Case Diagram)？</h3><p>用例：用例（符号：椭圆形）表示与外部系统用户的系统事务，称为参与者。用例有时被视为高级功能需求。用例图 <code>(uc)</code>：用例图显示系统边界（主题；符号：矩形）上下文中系统事务（用例）和外部用户（参与者）之间的通信。参与者可以代表湿件（人、组织、设施）、软件系统或硬件系统。定义系统主体和系统参与者之间的关系是定义系统范围的有效非正式方法。用例图的目的是提供主题系统的高级视图，并以非技术术语向所有利益相关者（包括客户和项目经理以及架构师和工程师）传达顶级系统需求。需要额外的更严格的 <code>SysML</code> 图来指定可扩展和可模拟的系统架构模型 (<code>SAM</code>)。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_4.png" class="" title="SysML 用例图：顶级用例">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_5.png" class="" title="SysML 用例图：用例分解">

<h3 id="什么是-SysML-活动图（Activity-Diagram）"><a href="#什么是-SysML-活动图（Activity-Diagram）" class="headerlink" title="什么是 SysML 活动图（Activity Diagram）?"></a>什么是 SysML 活动图（Activity Diagram）?</h3><p>活动：活动（符号：圆角矩形或“圆角”）表示功能行为流，可能包括可选的对象（数据）流。根据条件，控制和对象流可以是顺序的（默认）或并行的（由分叉和连接节点指示）。</p>
<ul>
<li><code>Action</code> &#x3D;  原子<code>Activity</code>, 这是一个原生的可执行动作.</li>
<li><code>Control Flow</code> &#x3D; 功能行为流</li>
<li><code>Object Flow</code>&#x3D; 活动或操作的对象输入&#x2F;输出的数据流.</li>
</ul>
<p>活动图（<code>act</code>）：活动图使用组合的控制流和对象（数据）流模型显示系统动态行为。活动（以及间接活动图）可以通过在活动定义和调用行为操作用法之间交替进行递归分解（“嵌套”）活动和动作可以被分配（通过代表控制块的分区（即代表系统、子系统、子子系统……原子结构的块）；数据块（即表示持久数据存储的块）和包含数据块的信号可以分配给活动参数和操作引脚；比较和对比：<code>SA/SD DFD、FFBD、EFFFD、IDEF0；BPMN BPD</code>。活动图的目的是使用控制流和对象（数据）流来指定满足系统功能需求的动态系统行为。如果应用得当，活动图可以递归地扩展和模拟。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_8.png" class="" title="SysML 活动图：顶级函数">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_9.png" class="" title="SysML 活动图：功能分解">

<h3 id="什么是-SysML-时序图-Squence-Diagram-？"><a href="#什么是-SysML-时序图-Squence-Diagram-？" class="headerlink" title="什么是 SysML 时序图(Squence Diagram)？"></a>什么是 SysML 时序图(Squence Diagram)？</h3><p>消息：消息（符号：箭头）表示从一个对象到另一个对象的通信，期望随之而来的是有用的行为。消息可以是同步的（表示法：空心箭头）或异步的（表示法：黑色三角形箭头）。时序图<code>(sd)</code>：序列图是一种动态行为图，它通过交换的消息序列以及相应的（可选）事件显示分布式对象或服务之间的交互（协作）。</p>
<ul>
<li>协作对象或服务是被描述为生命线的部件（表示法：下面带有垂直虚线的矩形）</li>
<li>组合片段运算符支持递归嵌套和图灵完备语义（替代<code>[alt]</code>、可选<code>[opt]</code>、并行<code>[par]</code>、循环<code>[loop]</code> 等）</li>
<li>比较和对比：消息时序图 (<code>MSC</code>)。</li>
</ul>
<p>时序图的目的是将动态系统行为指定为原型块（部件）之间的消息传递协作。如果应用得当，活动图可以递归地扩展和模拟。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_10.png" class="" title="SysML 时序图：顶级时序">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_11.png" class="" title="SysML 时序图：参考分解">

<h3 id="什么是-SysML-状态机图-State-Machine-Diagram-？"><a href="#什么是-SysML-状态机图-State-Machine-Diagram-？" class="headerlink" title="什么是 SysML 状态机图(State Machine Diagram)？"></a>什么是 SysML 状态机图(State Machine Diagram)？</h3><p>状态：状态（符号：圆角矩形又名“圆角”）表示对象生命周期中的条件或情况，在此期间它满足某些条件、执行某些活动或等待某些事件。状态机图 (<code>smd</code>)：状态机图是一种动态行为图，显示对象或交互在其生命周期内响应事件（也称为“触发器”）所经历的状态序列。状态机图的目的是指定时间关键、任务关键、安全关键或财务关键对象的动态系统行为。如果应用得当,状态机图可以递归扩展和模拟。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_12.png" class="" title="SysML 状态机图：顶级状态机">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_13.png" class="" title="SysML 状态机图：子状态机">

<h3 id="什么是-SysML-块定义图-Bolock-Definiation-Diagram-？"><a href="#什么是-SysML-块定义图-Bolock-Definiation-Diagram-？" class="headerlink" title="什么是 SysML 块定义图(Bolock Definiation Diagram)？"></a>什么是 SysML 块定义图(Bolock Definiation Diagram)？</h3><p>块：块（表示法：带有关键字&#x3D;<code>“block”</code>的矩形）表示一个系统组件，一个封装其内容（属性，行为，约束）并支持（即可以在其中绘制和直接操作的模块化结构单元）模型存储库）接口。块封装的行为包括：操作、信号和状态机。用于附加和连接（<code>“connection”</code>）块接口的独特交互点称为端口。</p>
<ul>
<li>块可以指定软件、硬件、机械和<code>facilities</code>（人员、组织、设施）组件。</li>
<li>块支持信息和物理流的提供（实现或实现）和必需（使用）接口。</li>
<li>块可以递归地分解为部分，其中每个部分也必须由块定义。</li>
</ul>
<p>块定义图（<code>bdd</code>）：块定义图是一个静态结构图，显示系统组件、它们的内容（属性、行为、约束）、接口和关系。</p>
<ul>
<li>通过在块定义图 (<code>BDD</code>)定义和内部框图 (<code>IBD</code>) 用法之间交替，可以将块递归分解（“嵌套”）为多个部分（请参阅下面的使用说明。）</li>
<li>行为可以由块（例如，操作、信号和状态机）封装，也可以直接或间接（通过接口）分配（通过“分配”依赖性）到块（例如活动&#x2F;动作）。</li>
<li>可以通过约束块对块进行数学约束，以生成数学上可模拟的参数图。</li>
</ul>
<p>块定义图的目的是指定用于控制对象、数据对象和接口对象的系统静态结构。如果应用得当，块定义图可以递归扩展并在数学上（参数）可模拟。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_14.png" class="" title="SysML 块定义图：系统块剖析">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_15.png" class="" title="SysML 块定义图：系统上下文">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_16.png" class="" title="SysML 块定义图：系统接口">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_17.png" class="" title="SysML 块定义图：系统组件">

<h3 id="什么是-SysML-内部块图？"><a href="#什么是-SysML-内部块图？" class="headerlink" title="什么是 SysML 内部块图？"></a>什么是 SysML 内部块图？</h3><p>块：块（表示法：带有关键字&#x3D;<code>“block”</code>的矩形）表示一个系统组件，一个封装其内容（属性，行为，约束）并支持一流（即可以在其中绘制和直接操作的模块化结构单元）模型存储库）接口。块封装的行为包括：操作、信号和状态机。用于附加和连接（“接线”）块接口的独特交互点称为端口。</p>
<ul>
<li>块可以指定软件、硬件、机械和湿件（人员、组织、设施）组件。</li>
<li>块支持信息和物理流的提供（实现或实现）和必需（使用）接口。</li>
<li>块可以递归地分解为部分，其中每个部分也必须由块定义。</li>
</ul>
<p>内部块图（<code>ibd</code>）：内部框图是特定块拥有的静态结构图，显示其封装的结构内容：部件、属性、连接器、端口和接口。换句话说，<code>IBD</code> 是封装（“黑盒”）块的“白盒”视角。</p>
<ul>
<li>通过在块定义图 (<code>BDD</code>)定义和内部块图 (&#96;IBD&#96;&#96;) 用法之间交替，可以将块递归分解（“嵌套”）为多个部分。</li>
<li>行为可以由块（例如，操作、信号和状态机）封装，也可以直接或间接（通过接口）分配（通过“分配”依赖性）到块（例如活动&#x2F;动作）。</li>
<li>可以通过约束块对块进行数学约束，以生成数学上可模拟的参数图。</li>
</ul>
<p>内部块图（<code>IBD</code>）的目的是显示块的封装结构内容（部件、属性、连接器、端口、接口），以便可以使用基于接口的设计技术递归地分解和“<code>connection</code>”它们。如果正确使用，<code>BDD + IBD</code> 可以递归扩展并且可以在数学上（参数）模拟。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_14.png" class="" title="SysML 内部块图：零件定义">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_18.png" class="" title="SysML 内部块图：零件使用">

<h3 id="什么是-SysML-参数图-Parametric-Diagram-？"><a href="#什么是-SysML-参数图-Parametric-Diagram-？" class="headerlink" title="什么是 SysML 参数图(Parametric Diagram)？"></a>什么是 SysML 参数图(Parametric Diagram)？</h3><p>约束块：约束块（表示法：带有关键字 &#x3D; <code>«constraint»</code> 的矩形）定义数学规则 ( <code>Constraint</code> ) 和规则参数，其中后者绑定到块值属性，以便对一个块值属性的更改将传播到其他块值属性以符合数学规则的方式块值属性。</p>
<p>参数图 (<code>par</code>)：参数图是内部块图 (&#96;IBD&#96;&#96;) 的特例化，它在受约束块参数约束的内部零件值属性上强制执行由约束块定义的数学规则（约束） 。</p>
<ul>
<li>约束块参数和内部零件值属性之间的绑定连接器（关键字 &#x3D; <code>«equal»</code>）会影响约束满足（传播）</li>
</ul>
<p>参数图 (<code>PAR</code>) 的目的是在块值属性中强制执行数学规则。如果正确使用，<code>BDD + IBD + PAR</code> 可以递归扩展并且可以进行数学模拟。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_19.png" class="" title="SysML 参数图：约束块定义">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_20.png" class="" title="SysML 参数图：约束块使用">

<h3 id="什么是-SysML-包图-Package-Diagram-？"><a href="#什么是-SysML-包图-Package-Diagram-？" class="headerlink" title="什么是 SysML 包图(Package Diagram)？"></a>什么是 SysML 包图(Package Diagram)？</h3><p>包：包（符号：“文件夹”图标）是一种将模型元素和图表组织成组的通用机制。包为在其范围内定义的模型元素定义了唯一的名称空间。</p>
<ul>
<li>命名空间&#x3D;一个声明性区域，为其中包含的标识符提供范围。</li>
</ul>
<p>包图（<code>pkg</code>）：包图是一个静态结构图，显示包及其内容之间的关系。包可以被构造型（定制）用于将模型元素组织成模型、视图、模型库和框架。</p>
<p>包图的目的是支持大型、复杂的系统架构模型（<code>SAM</code>）的组织和管理。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_21.png" class="" title="SysML 包图：视图&amp;视角">
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_22.png" class="" title="SysML 包图：系统设计视图">

<h3 id="什么是-SysML-分配表-Allocation-Table-？"><a href="#什么是-SysML-分配表-Allocation-Table-？" class="headerlink" title="什么是 SysML 分配表(Allocation Table)？"></a>什么是 SysML 分配表(Allocation Table)？</h3><p>分配：分配依赖性箭头（带有开放箭头表示法的虚线和关键字 &#x3D; <code>«allocate»</code>）关联或映射不同类型或不同层次结构中的模型元素。分配依赖模式通常对于提高模型架构完整性（也称为格式良好）和一致性很有用。<code>SysML</code> 预定义了以下分配依赖项：</p>
<ul>
<li>需求依赖性的分配</li>
<li>活动到分区的分配（泳道）</li>
</ul>
<p>分配表：分配表是分配关系的表格（矩阵）表示法，但 <code>SysML</code> 标准没有规定这些格式的特定格式，因此它们往往是特定于供应商的。</p>
<p>分配表的目的是定义图表类型内部和之间的关系矩阵，以提高模型架构的完整性和一致性。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_23.png" class="" title="SysML 分配表：示例">

<h2 id="MBSE"><a href="#MBSE" class="headerlink" title="MBSE"></a>MBSE</h2><h3 id="什么是基于模型的系统工程-MBSE-以及如何使用它？"><a href="#什么是基于模型的系统工程-MBSE-以及如何使用它？" class="headerlink" title="什么是基于模型的系统工程 (MBSE) 以及如何使用它？"></a>什么是基于模型的系统工程 (MBSE) 以及如何使用它？</h3><p>基于模型的系统工程 (<code>MBSE</code>)，又名基于模型的系统开发 (<code>MBSD</code>)，是一种系统工程过程范例，强调在整个系统开发生命周期 (<code>SDLC</code>) 的系统工程活动中应用严格的架构建模原则和最佳实践。这些系统工程活动包括但不限于需求分析、系统（功能）分析、性能分析（权衡研究）、系统设计、系统架构规范以及系统验证和确认（<code>V&amp;V</code>）。</p>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_24.png" class="" title="MBSE 系统体系架构">

<h3 id="SysML-应如何应用于-MBSE-项目？"><a href="#SysML-应如何应用于-MBSE-项目？" class="headerlink" title="SysML 应如何应用于 MBSE 项目？"></a>SysML 应如何应用于 MBSE 项目？</h3><p>随着 <code>SysML</code> 成为基于模型的系统工程 (<code>MBSE</code>) 方法的事实上的标准，几种渐进严格的 <code>SysML</code> 使用模式如下：</p>
<ul>
<li><p>最不严格且最常见的使用模式— <code>SysML-as-Pretty-Pictures</code>：这是最不正式且最不严格的 <code>SysML</code> 使用模式。不幸的是，这也是 <code>SysML</code> 被滥用的最常见方式。在<code>SysML-as-Pretty-Pictures</code> 使用模式中，使用<code>SysML</code> 表示法代替临时建模表示法（例如<code>Visio</code> 或<code>PowerPoint</code> 绘图），但对<code>SysML</code> 格式良好性及其底层可模拟和可执行语义的关注相对较少。因此，在 <code>SysML-as-Pretty-Pictures</code> 模式下生成的 <code>SysML</code> 模型很少能够驱动动态模拟或精确指定系统架构蓝图。</p>
</li>
<li><p><code>SysML-as-Model-Simulation</code>：这种<code>SysML</code>使用模式是对<code>SysML-as-Pretty-Pictures</code>模式的重大改进，因为它强调系统动态行为和系统参数约束的模拟。在 <code>SysML-as-System-Simulation</code> 模式中，至少一些 <code>SysML</code> 行为图（活动、序列、状态机图）由行为模拟引擎执行。此外，一些参数图约束也可以由约束传播引擎（<code>MATLAB/Simulink、OpenModelica、SysML</code> 工具专有插件等）执行。对于那些寻求摆脱 <code>SysML-as-Pretty-Pictures</code> 语言滥用的人来说，这是一种中间 <code>SysML</code> 使用模式。</p>
</li>
<li><p><code>SysML-as-System-Architecture-Blueprint</code>：此 <code>SysML</code> 使用模式是对 <code>SysML-as-Model-Simulation</code> 模式的实质性改进，因为它扩展了后者以包含系统架构模型 (<code>SAM</code>) 的精确且完整的规范。<code>SAM</code> 的目的是足够精确和完整，作为系统项目中涉及的所有工程流程的“系统架构真相”，包括系统工程师 (<code>SE</code>)、软件工程师 (<code>SWE</code>)、电气工程师 (<code>EE</code>)、机械工程师 (<code>ME</code>) 等。为了使 <code>SAM</code> 成为系统工程项目的系统架构真理，<code>SAM</code> 必须满足系统架构质量的所有 5 个 <code>C</code>（正确、完整、清晰、简洁和一致）。这是一种比较先进的<code>SysML</code>使用模式，通常是 - <code>SysML-as-System-Simulation</code>模式的自然演进。</p>
</li>
<li><p>最严格的 <code>SYSML</code> 使用模式— <code>SysML-as-Executable-System-Architecture</code>：此 <code>SysML`` 使用模式是对 </code>SysML-as-System-Architecture-Blueprint<code>模式的重大改进，因为它扩展了后一种模式以实现</code>SAM<code> 的大部分行为和参数规范可模拟，并且可执行。</code>MBSE&#96;上下文中的可执行文件通常指的是系统接口、系统测试用例的部分或完全自动生成。</p>
</li>
</ul>
<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_25.png" class="" title="MBSE + SysML System Architecture Framework Pattern Example">

<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration.png" class="">

<img data-src="/2023/12/27/Other/SysML_CAD_integration/SysML_CAD_integration_2.png" class="">

]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>MBSE</tag>
      </tags>
  </entry>
  <entry>
    <title>认证、授权、凭证</title>
    <url>/2023/08/30/Other/authentication/</url>
    <content><![CDATA[<h5 id="认证（Authentication）、授权（Authorization）、凭证（credentials）"><a href="#认证（Authentication）、授权（Authorization）、凭证（credentials）" class="headerlink" title="认证（Authentication）、授权（Authorization）、凭证（credentials）"></a>认证（Authentication）、授权（Authorization）、凭证（credentials）</h5><p><strong>认证</strong>是指以当前用户的身份登录过后，系统便能追踪到他的身份，并做出符合相应业务逻辑的操作。即使用户没有登录，大多数系统也会追踪他的身份，只是当做来宾或匿名用户来处理，认证技术解决的是**我是谁?**的问题。</p>
<p><strong>授权</strong>是指什么样的身份被允许访问某些资源，在获取用户身份后继续检查用的权限。单一的系统授权往往是伴随认证来完成的，但是开放API的多系统结构之下，授权可以有不同的系统来完成。例如<code>OAuth</code>。授权是解决<strong>我能做什么？</strong>的问题。</p>
<p><strong>凭证</strong>，实现认证和授权的基础是需要一种媒介（<code>credentials</code>）来标记访问者的身份或权利，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，<strong>这就是认证的凭证</strong>。在互联网世界中，服务器为每一个访问者颁发 <code>session ID</code>存放到<code>cookie</code>，这就是一种凭证技术。数字凭证还表现在方方面面，<code>SSH</code>登录的秘钥、<code>JWT</code>令牌、一次性密码等。用户账户也不一定存放在数据库中的一张表，在一些企业的IT系统中，对账户管理的权限有了更多的要求。所以账户技术（accounting）可以帮助我们使用不同的方式管理用户账户，同时具有不同系统之间共享账户的能力。</p>
<span id="more"></span>

<p><strong>访问控制策略（AC）</strong>，如果我们需要把资源的权限划分到一个很细的粒度，就不得不考虑用户以何种身份来访问受限的资源，选择基于<strong>访问控制列表（ACL）</strong>，还是基于<strong>用户角色的访问控制（RBAC）</strong>，或者其他的访问控制策略</p>
<h6 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h6><p>这种方式实现起来非常简单，在大量场景下被采用。当然缺点也很明显，<code>Base64</code> 只能称为编码，而不是加密 (实际上无需配置密匙的客户端并没有任何可靠地加密方式，我们都依赖 <code>TSL</code>协议)。这种方式的致命弱点是编码后的密码如果明文传输则容易在网络传输中泄露，在密码不会过期的情况下，密码一旦泄露，只能通过修改密码的方式。</p>
<h6 id="HMAC（AK-SK）认证"><a href="#HMAC（AK-SK）认证" class="headerlink" title="HMAC（AK&#x2F;SK）认证"></a>HMAC（AK&#x2F;SK）认证</h6><p>在我对接一些PaaS平台和支付平台时会要求我们提前生成一个<code>Access Key(AK) and Secure Key(SK)</code>, 然后通过签名的方式完成认证请求，这种方式可以避免传输<code>secure key</code>, 且大多数情况下签名只允许一次，避免了重放攻击。这种<code>AK/SK</code>的认证方式主要是利用了散列的消息认证码 (<code>Hash-based MessageAuthentication Code</code>) 来实现的。为了让每一次请求的签名变得独一无二，从而实现重放攻击，我们需要在签名时放入一些干扰信息。在业界标准中有两种典型的做法，质疑&#x2F;应答算法（<code>OCRA: OATH Challenge-Response Algorithm</code>）、基于时间的一次性密码算法（<code>TOTP：Time-based One-time Password Algorithm</code>）。</p>
<p>质疑&#x2F;应答算法需要客户端先请求一次服务器，获得一个 401 未认证的返回，并得到一个随机字符串（<code>nonce</code>）。将 nonce 附加到按照上面说到的方法进行 <code>HMAC</code> 签名，服务器使用预先分配的 <code>nonce</code> 同样进行签名校验，这个 nonce 在服务器只会被使用一次，因此可以提供唯一的摘要。</p>
<img data-src="/2023/08/30/Other/authentication/aac1.png" class="">
<p>基于时间的一次性密码认证，为了避免额外的请求来获取 <code>nonce</code>，还有一种算法是使用时间戳，并且通过同步时间的方式协商到一致，在一定的时间窗口内有效（1分钟左右）。</p>
<img data-src="/2023/08/30/Other/authentication/aac2.png" class="">
<p>这里的只是利用时间戳作为验证的时间窗口，并不能严格的算作基于时间的一次性密码算法。标准的基于时间的一次性密码算法在两步验证中被大量使用，例如 <code>Google</code> 身份验证器不需要网络通信也能实现验证（但依赖准确的授时服务）。原理是客户端服务器共享密钥然后根据时间窗口能通过 <code>HMAC</code> 算法计算出一个相同的验证码。</p>
<h6 id="OAuth2-和-Open-ID"><a href="#OAuth2-和-Open-ID" class="headerlink" title="OAuth2 和 Open ID"></a>OAuth2 和 Open ID</h6><p><code>OAuth</code>（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。<code>OAuth</code> 是一个授权标准，而不是认证标准。提供资源的服务器不需要知道确切的用户身份（<code>session</code>），只需要验证授权服务器授予的权限（<code>token</code>）即可。</p>
<img data-src="/2023/08/30/Other/authentication/aac3.png" class="">
<p>上图只是 <code>OAuth</code> 的一个简化流程，<code>OAuth</code> 的基本思路就是通过授权服务器获取 <code>access token</code> 和 <code>refresh token</code>（<code>refresh token</code> 用于重新刷新<code>access token</code>），然后通过 <code>access token</code> 从资源服务器获取数据 。如果需要获取用户的认证信息，<code>OAuth</code> 本身没有定义这部分内容，如果需要识别用户信息，则需要借助另外的认证层，例如 <code>OpenID Connect</code>。<code>OAuth</code> 负责解决分布式系统之间的授权问题，即使有时候客户端和资源服务器或者认证服务器存在同一台机器上。<code>OAuth</code>没有解决认证的问题，但提供了良好的设计利于和现有的认证系统对接。<code>Open ID </code>解决的问题是分布式系统之间身份认证问题，使用<code>Open ID token</code> 能在多个系统之间验证用户，以及返回用户信息，可以独立使用，与 <code>OAuth</code> 没有关联。<code>OpenID Connect</code> 解决的是在 <code>OAuth</code> 这套体系下的用户认证问题，实现的基本原理是将用户的认证信息（<code>ID token</code>）当做资源处理。在 <code>OAuth</code> 框架下完成授权后，再通过 <code>access token</code>获取用户的身份。这三个概念之间的关系有点难以理解，用现实场景来说，如果系统中需要一套独立的认证系统，并不需要多系统之间的授权可以直接采用 <code>Open ID</code>。如果使用了 <code>OAuth</code> 作为授权标准，可以再通过 <code>OpenID Connect</code> 来完成用户的认证。</p>
<h6 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h6><p>在 <code>OAuth</code> 等分布式的认证、授权体系下，对凭证技术有了更多的要求，比如包含用户 <code>ID</code>、过期等信息，不需要与外部存储关联。因此业界对 <code>token</code> 做了进一步优化，设计了一种自包含令牌，令牌签发后无需从服务器存储中检查是否合法，通过解析令牌就能获取令牌的过期、有效等信息，这就是<code>JWT （JSON Web Token）</code>。<code>JWT</code> 是一种包含令牌（<code>self-contained token</code>），或者叫值令牌 （<code>value token</code>），我们以前使用关联到 <code>session</code> 上的 hash 值被叫做引用令牌（<code>reference token</code>）。</p>
<img data-src="/2023/08/30/Other/authentication/aac4.png" class="">
<p>简而言之，一个基本的JWT令牌为一段点分3段式结构。生成JWT 令牌的流程为</p>
<img data-src="/2023/08/30/Other/authentication/aac5.png" class="">
<ol>
<li>header json 的 base64 编码为令牌第一部分</li>
<li>payload json 的 base64 编码为令牌第二部分</li>
<li>拼装第一、第二部分编码后的 <code>json</code> 以及 <code>secret</code> 进行签名的令牌的第三部分<br>因此只需要签名的 <code>secret key</code>就能校验 <code>JWT</code> 令牌，如果在消息体中加入用户 <code>ID</code>、过期信息就可以实现验证令牌是否有效、过期了，无需从数据库&#x2F;缓存中读取信息。因为使用了加密算法，所以第一、二部分即使被修改（包括过期信息）也无法通过验证。<code>JWT</code> 优点是不仅可以作为 <code>token</code> 使用，同时也可以承载一些必要信息，省去多次查询。<code>JWT token</code>在微服务的系统中优势特别突出。多层调用的 API 中可以直接传递 <code>JWT token</code>，利用自包含的能力，可以减少用户信息查询次数；更重要的是，使用非对称的加密方式可以通过在系统中分发密匙的方式验证 <code>JWT token</code>。</li>
</ol>
<h6 id="选择合适的认证方式"><a href="#选择合适的认证方式" class="headerlink" title="选择合适的认证方式"></a>选择合适的认证方式</h6><p>客户端到服务器之间认证和服务器到服务器之间认证是不同的。我们把终端用户（<code>Human</code>）参与的通信，叫做 <code>Human-to-machine (H2M)</code>，服务器与服务器之间的通信叫做 <code>Machine-to-machine (M2M)</code>。<code>H2M</code>的通信需要更高的安全性，<code>M2M</code> 的通信天然比 <code>H2M</code> 安全，因此更多的强调性能，在不同的场合下选择合适的认证技术就显得特别重要。例如 <code>HTTP Basic Authentication</code> 用来作为 <code>H2M</code> 认证显得有些落后，但是在 <code>M2M</code> 中被大量使用。另外值得一提的是，<code>H2M</code> 这种通信方式下，客户端不受控制，由于无法自主分发密匙，认证通信的安全高度依赖 <code>HTTPS</code>。从一个宏观的角度看待他们的关系，对我们技术选型非常有帮助。</p>
<img data-src="/2023/08/30/Other/authentication/aac6.png" class="">
]]></content>
      <categories>
        <category>Network Security</category>
      </categories>
      <tags>
        <tag>network security</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 解决分支冲突</title>
    <url>/2023/07/27/Other/git-reconcile_divergent_branches/</url>
    <content><![CDATA[<p>昨天我在处理项目时我尝试使用 <code>git pull</code> 命令从远程分支中拉取更改的内容，但最终报错：<code>&quot;fatal: Need to specify how to reconcile divergent branches&quot;</code>, 这阻碍了我的工作。我决定写一篇关于这个问题的文章，以便它也能帮助你们。</p>
<h4 id="解决了“reconcile-divergent-branches”"><a href="#解决了“reconcile-divergent-branches”" class="headerlink" title="解决了“reconcile divergent branches”"></a>解决了“reconcile divergent branches”</h4><p>如果您使用 <code>Git</code>，那么在尝试从远程存储库执行 git pull 时出现此错误并不罕见。虽然大多数时候您会看到<code>&quot;fatal: Need to specify how to reconcile divergent branches&quot;</code>警告，但有时您会看到它是致命错误。如果错误显示为警告，那么您仍然可以从存储库中提取更改，但如果它显示为致命错误，那么您将无法继续进行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin main</span><br><span class="line">*branch dev -&gt; FETCH_HEAD</span><br><span class="line">提示：您有不同的分支，需要指定如何协调它们。</span><br><span class="line">提示：您可以通过在提示之前运行以下命令之一来完成此操作</span><br><span class="line">：您的下一个拉取：</span><br><span class="line">提示：</span><br><span class="line">提示：git config pull.rebase false＃合并</span><br><span class="line">提示：git config pull.rebase true＃rebase</span><br><span class="line">提示：git config pull.ff only # 仅快进</span><br><span class="line">提示：</span><br><span class="line">提示：您可以将“git config”替换为“git config --global”以设置默认</span><br><span class="line">提示：所有存储库的首选项。您还可以传递 --rebase, --no-rebase,</span><br><span class="line">在命令行上提示：或 --ff-only 以覆盖每个</span><br><span class="line">提示：调用配置的默认值。fatal：需要指定如何协调不同的分支。</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>要解决这个错误，您可以有以下两种解决方案并应用适合您的解决方案。但在此之前，请使用<code>git --version</code>命令检查当前的 git 版本。发现以下解决方案运行良好<code>Git 2.27.0</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git --version </span><br><span class="line">git 版本 2.35.1</span><br></pre></td></tr></table></figure>

<p><strong>解决方案1：切换到合并策略</strong></p>
<p>当存在不在本地分支上的远程更改时，需要解决它们。默认的 Git 行为是合并，这将在本地分支上创建一个新的提交来解决这些更改。您可以使用<code>git config pull.rebase false</code>命令切换回默认合并策略，而不是使用变基策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config pull.rebase false</span><br></pre></td></tr></table></figure>
<p>切换回默认策略后，您可以再次尝试运行<code>git pull origin main</code>命令以从分支中提取所有更改main。这次您可以看到所有更改现在都已由<code>&#39;ort&#39;</code>策略合并。查看此处以了解有关 <code>ort</code> 策略的更多信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin main</span><br><span class="line"></span><br><span class="line">*branch dev -&gt; FETCH_HEAD</span><br><span class="line">由“ort”策略进行合并。</span><br><span class="line">application.yaml | 13 ++++++++++++ </span><br><span class="line">config.yaml | 160 ++++++++++++++++++++++++++++++++++++++++++++++ </span><br><span class="line">+++++++ +++++++++++++++++++++++++++++++++++++ </span><br><span class="line">2 个文件已更改，173 个插入(+)</span><br><span class="line">创建模式 100644 application.yaml</span><br><span class="line">创建模式100644 config.yaml</span><br></pre></td></tr></table></figure>

<p><strong>解决方案2：切换到快进策略</strong></p>
<p>有时您的默认策略只是 <code>FF</code>。因此，要切换回此策略，您需要运行<code>git config --global pull.ff only</code>如下所示的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global pull.ff only</span><br></pre></td></tr></table></figure>
<p>这会将以下行添加到<code>$HOME/.gitconfig</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[pull] </span><br><span class="line">      ff = only</span><br></pre></td></tr></table></figure>
<p>但这里还需要注意的是，只有在不创建新提交的情况下可以“快进”时，Git 才会更新您的分支。如果这无法完成，意味着本地和远程存在分歧，则<code>git config --global pull.ff only</code>只需中止并显示错误消息。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【multipass】一个好用的跨平台虚拟机</title>
    <url>/2023/07/09/Other/multipass/</url>
    <content><![CDATA[<p><a href="https://multipass.run/"><code>multipass</code></a> 是一个很好用的虚拟机软件，基于它能够快速创建出需要的虚拟机环境。</p>
<img data-src="/2023/07/09/Other/multipass/multipass.png" class="">

<span id="more"></span>

<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>下载安装之后，本地会有一个 <code>multipass</code> 命令，后续所有的操作都是基于此命令，例如，查看本地帮助：</p>
<img data-src="/2023/07/09/Other/multipass/multipass-help.png" class="">

<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>使用 <code>multipass find</code> 我们可以查看有哪些可供选择的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 19:12:15</span><br><span class="line">$ multipass find</span><br><span class="line">Image                       Aliases           Version          Description</span><br><span class="line">18.04                       bionic            20221014         Ubuntu 18.04 LTS</span><br><span class="line">20.04                       focal             20221018         Ubuntu 20.04 LTS</span><br><span class="line">22.04                       jammy,lts         20221101.1       Ubuntu 22.04 LTS</span><br><span class="line">anbox-cloud-appliance                         latest           Anbox Cloud Appliance</span><br><span class="line">charm-dev                                     latest           A development and testing environment for charmers</span><br><span class="line">docker                                        latest           A Docker environment with Portainer and related tools</span><br><span class="line">jellyfin                                      latest           Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media.</span><br><span class="line">minikube                                      latest           minikube is local Kubernetes</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>使用 <code>multipass launch</code> 命令能快速启动一个 <code>Ubuntu</code> 虚拟机，如果我们没有指定镜像，会选择 <code>ubuntu</code> 最新的 <code>LTS</code> 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 19:12:37</span><br><span class="line">$ multipass launch --name ubuntu2204 -d 20G</span><br><span class="line">Launched: ubuntu2204</span><br></pre></td></tr></table></figure>

<h3 id="本地虚拟机"><a href="#本地虚拟机" class="headerlink" title="本地虚拟机"></a>本地虚拟机</h3><p>使用 <code>multipass list</code> 查看本地正在运行的虚拟机，这里的 <code>primary</code> 是默认的，<code>ubuntu2204</code> 是新创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 19:16:23</span><br><span class="line">$ multipass list</span><br><span class="line">Name                    State             IPv4             Image</span><br><span class="line">primary                 Running           192.168.64.16    Ubuntu 20.04 LTS</span><br><span class="line">ubuntu2204              Running           192.168.64.17    Ubuntu 22.04 LTS</span><br></pre></td></tr></table></figure>

<h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>使用 <code>multipass mount</code> 命令，可以挂在目录，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 19:42:59</span><br><span class="line">$ multipass mount /Users/fudenglong/WORKDIR  ubuntu2204</span><br></pre></td></tr></table></figure>

<h3 id="登录虚拟机"><a href="#登录虚拟机" class="headerlink" title="登录虚拟机"></a>登录虚拟机</h3><p>使用 <code>multipass shell</code> 进入虚拟机之后，查看我们挂在的目录，如果要切 <code>root</code>，直接使用 <code>sudo su</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 19:44:28</span><br><span class="line">$ multipass shell ubuntu2204</span><br><span class="line">Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-52-generic aarch64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Sun Nov 13 19:45:42 CST 2022</span><br><span class="line"></span><br><span class="line">  System load:             0.0</span><br><span class="line">  Usage of /:              7.2% of 19.21GB</span><br><span class="line">  Memory usage:            19%</span><br><span class="line">  Swap usage:              0%</span><br><span class="line">  Processes:               93</span><br><span class="line">  Users logged in:         0</span><br><span class="line">  IPv4 address for enp0s1: 192.168.64.17</span><br><span class="line">  IPv6 address for enp0s1: fd88:7848:a9f4:53b8:5054:ff:fe74:a03b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The list of available updates is more than a week old.</span><br><span class="line">To check for new updates run: sudo apt update</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu2204:~$ ll /Users/fudenglong/WORKDIR/</span><br><span class="line">total 76</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   480 Oct 26 23:05 ./</span><br><span class="line">drwxr-xr-x 3 ubuntu ubuntu  4096 Nov 13 19:44 ../</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 10244 Nov  3 10:19 .DS_Store</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu  9483 Apr  5  2022 cluster-configuration.yaml</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   800 Jan 20  2022 delve/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   544 Nov  3 10:39 gamelife1314.github.io/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   128 Oct 26 23:07 gitee/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   480 Jun 24 23:35 gostudy/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   480 Nov  3 10:34 hexo-generator-searchdb/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   128 Jun 13 00:26 java-study/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   224 Dec  5  2021 k8s/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   576 Jan 20  2022 manim/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   672 May 21 22:29 pyquery/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu   384 Jun 20 00:21 rust/</span><br><span class="line">drwxr-xr-x 1 ubuntu ubuntu    96 Apr  8  2022 temp/</span><br><span class="line">ubuntu@ubuntu2204:~$ sudo su</span><br><span class="line">root@ubuntu2204:/home/ubuntu#</span><br><span class="line">root@ubuntu2204:/home/ubuntu#</span><br><span class="line">root@ubuntu2204:/home/ubuntu# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h3 id="停止、删除"><a href="#停止、删除" class="headerlink" title="停止、删除"></a>停止、删除</h3><p>使用 <code>multipass stop ubuntu2204</code>，<code>multipass delete ubuntu2204</code> 以及 <code>multipass purge</code> 可以彻底删除我们创建的虚拟机。</p>
<p>我们可以在创建虚拟机的时候，可以指定更多的参数，例如，指定 <code>CPU</code>，内存，磁盘，目录挂在以及网路模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 20:01:44</span><br><span class="line">$ multipass launch -c 4 -d 20G -m 2G -n vm-ubuntu --bridged --mount /Users/fudenglong/WORKDIR:/Workdir</span><br><span class="line">Launched: vm-ubuntu</span><br><span class="line">Mounted &#x27;/Users/fudenglong/WORKDIR&#x27; into &#x27;vm-ubuntu:/Workdir&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="可用网络"><a href="#可用网络" class="headerlink" title="可用网络"></a>可用网络</h3><p>可以使用 <code>multipass network</code> 查看我们可以使用的网络类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 20:08:09</span><br><span class="line">$ multipass networks</span><br><span class="line">Name     Type         Description</span><br><span class="line">bridge0  bridge       Network bridge with en1, en2, en3</span><br><span class="line">en0      wifi         Wi-Fi</span><br><span class="line">en1      thunderbolt  Thunderbolt 1</span><br><span class="line">en2      thunderbolt  Thunderbolt 2</span><br><span class="line">en3      thunderbolt  Thunderbolt 3</span><br><span class="line">en4      ethernet     Ethernet Adapter (en4)</span><br><span class="line">en5      ethernet     Ethernet Adapter (en5)</span><br><span class="line">en6      ethernet     Ethernet Adapter (en6)</span><br></pre></td></tr></table></figure>

<h3 id="虚拟机信息"><a href="#虚拟机信息" class="headerlink" title="虚拟机信息"></a>虚拟机信息</h3><p>可以使用 <code>multipass info</code> 查看虚拟机的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ⌚ 20:11:45</span><br><span class="line">$ multipass info vm-ubuntu</span><br><span class="line">Name:           vm-ubuntu</span><br><span class="line">State:          Running</span><br><span class="line">IPv4:           192.168.64.18</span><br><span class="line">Release:        Ubuntu 22.04.1 LTS</span><br><span class="line">Image hash:     c363ebe92173 (Ubuntu 22.04 LTS)</span><br><span class="line">Load:           0.00 0.02 0.00</span><br><span class="line">Disk usage:     1.4G out of 19.2G</span><br><span class="line">Memory usage:   166.1M out of 1.9G</span><br><span class="line">Mounts:         /Users/fudenglong/WORKDIR =&gt; /Workdir</span><br><span class="line">                    UID map: 501:default</span><br><span class="line">                    GID map: 20:default</span><br></pre></td></tr></table></figure>

<h3 id="扩容虚拟机"><a href="#扩容虚拟机" class="headerlink" title="扩容虚拟机"></a>扩容虚拟机</h3><p>虚拟机的磁盘大小在创建的时候就固定了，目前 <code>multipass</code> 没有提供扩容虚拟机磁盘的直接命令，但是总有大神会给出方案，例如这里的：<a href="https://github.com/canonical/multipass/issues/62#issuecomment-1093179387">https://github.com/canonical/multipass/issues/62#issuecomment-1093179387</a>。</p>
<p>但是参考这个方案之前，要查看自己本地的驱动是什么：</p>
<blockquote>
<p>multipass get local.driver</p>
</blockquote>
<p>然后安装 <code>qemu</code>：</p>
<blockquote>
<p>brew install  qemu</p>
</blockquote>
<p>安装之后，使用下面的命令进行 <code>resize</code>：</p>
<img data-src="/2023/07/09/Other/multipass/resize.png" class="">

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://mp.weixin.qq.com/s/HuTISol9ucqo7EQAVS8h6g"><code>Rust Aya</code> 开发 <code>eBPF</code> 程序</a></li>
</ol>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>multipass</tag>
      </tags>
  </entry>
  <entry>
    <title>S3 架构原理</title>
    <url>/2023/12/22/Other/s3-design/</url>
    <content><![CDATA[<p>当你上传一个文件到<code>S3</code>服务器会发生什么？ 让我们来看一下<code>S3</code>对象存储系统是如何工作的？</p>
<img data-src="/2023/12/22/Other/s3-design/s3-design1.png" class="">

<span id="more"></span>

<p><strong>桶</strong>：对象的逻辑容器，桶的名称是全局唯一的。要将数据上传到<code>S3</code>, 首先必须创建一个桶。<br><strong>对象</strong>： 对象是我们存储在桶中的单个数据，它包含对象数据（也称为有效载荷）和元数据，对象数据可以是我们想要存储的任何字节序列，元数据是一组描述对象的键-值对。</p>
<p>一个<code>S3</code>对象包括：</p>
<ul>
<li><strong>元数据</strong>：它是可变的，包括<code>ID</code>、桶名称、对象名称等属性。</li>
<li><strong>对象数据</strong>：它是不可变的，包含实际数据。</li>
</ul>
<p>在<code>S3</code>中，对象驻留在桶中，桶只有元数据；而对象有元数据和实际数据。图二中阐述了文件上传的工作原理，在本例中，我们首先创建一个名称为<code>bucket-to-share</code>的桶，然后将一个名为<code>script.txt</code>上传到存储桶中。</p>
<ol>
<li>客户端发送一个<code>HTTP PUT</code>请求去创建一个名为<code>bucket-to-share</code>的桶，请求被转发到<code>API</code>服务。</li>
<li><code>API</code>服务调用<code>IAM</code>系统(身份和访问管理系统)，以确保用户获得授权并具有<code>WRITE</code>权限。</li>
<li><code>API</code>服务调用元数据存储，在元数据的数据库中创建一条包含桶信息的条目。创建条目后，将向客户端返回成功的消息。</li>
<li>创建桶后，客户端发送<code>HTTP PUT</code>请求，创建一个名为<code>script.txt</code>的对象。</li>
<li><code>API</code>服务验证用户的身份，并确保用户在存储桶上拥有写入权限。</li>
<li>一旦验证成功，<code>API</code>服务将<code>HTTP PUT</code>有效载荷中的对象数据发送到存储节点，存储节点将有效载荷保存为对象，并返回对象的<code>UUID</code>。</li>
<li>API服务调用元数据存储，在元数据的数据库中创建一个新条目，它包含重要的元数据信息，如<code>object_id(UUID)</code>、 <code>bucket_id</code>（对象属于那个桶）、<code>object_name</code>等。</li>
</ol>
<img data-src="/2023/12/22/Other/s3-design/s3-design2.png" class="">]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>S3</tag>
      </tags>
  </entry>
  <entry>
    <title>【Regex】正则表达式</title>
    <url>/2022/03/01/Other/regex-expression/</url>
    <content><![CDATA[<p>一直以来，从 <code>JavaScript</code>，<code>PHP</code>，<code>Python</code>到<code>Golang</code>，然后还有<code>linux</code>系统中，无处不见正则表达式的身影，可是一致困扰在<code>POSIX</code>和<code>PCRE</code>的概念中，分不清这两个是个啥，今天就来翻翻正则表达式的老底，了解了解正则表达式的前世今生。</p>
<p><code>Regular Expression</code>的<code>Regular</code>一般被译为正则、正规、常规。此处的<code>Regular</code>即是规则的意思，<code>Regular Expression</code>即描述某种规则的表达式之意。  </p>
<p>正则表达式（英语：<code>Regular Expression</code>，在代码中常简写为<code>regex</code>、<code>regexp</code>或<code>RE</code>），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p>
<p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在<code>Perl</code>中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由<code>Unix</code>中的工具软件（例如<code>sed</code>和<code>grep</code>）普及开的。正则表达式通常缩写成<code>regex</code>，单数有<code>regexp</code>、<code>regex</code>，复数有<code>regexps</code>、<code>regexes</code>、<code>regexen</code>。</p>
<span id="more"></span>

<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>正则表示式这一概念最早可以追溯到20世纪40年代的两个神经物理学家<code>Warren McCulloch</code>与<code>Walter Pitts</code>，他们将神经系统中的神经元描述成小而简单的自动控制元。 </p>
<p>紧接着，在<code>50</code>年代，数学家<code>1950</code>年代，数学家<code>Stephen Kleene</code>利用称之为<code>正则集合</code>的数学符号来描述此模型，并且建议使用一个简单的概念来表示，于是<code>regular expressions</code>就正式登上历史舞台了。</p>
<p><code>1968</code>年，<code>Ken Thompson</code>发表了<a href="http://www.fing.edu.uy/inco/cursos/intropln/material/p419-thompson.pdf">Regular Expression Search Algorithm</a>, 紧接着大神<code>Thompson</code>根据这个论文实现了<code>Unix</code>上编辑器<code>ed</code>的前身<a href="http://en.wikipedia.org/wiki/QED_%28text_editor%29"><code>qed</code></a>。<code>ed</code>所支持的正则表示式并不比<code>qed</code>的高级，但是<code>ed</code>是第一个在非技术圈广泛传播的工具，<code>ed</code>有一个命令可以展示文本中符合给定正则表达式的行，这个命令是<code>g/Regular Expression/p</code>，在英文中读作**<code>Global Regular Expression Print</code>**，由于这个命令非常实用，所以后来有了<code>grep</code>、<code>egrep</code>这两个命令。</p>
<p>相比<code>egrep</code>，<code>grep</code>只支持很少的元符号，<code>＊</code>是支持的（但不能用于分组中），但是<code>+</code>、<code>|</code>与<code>?</code>是不支持的；而且，分组时需要加上反斜线转义，像<code>\( ...\)</code>这样才行，由于<code>grep</code>的缺陷性日渐明显，<code>AT&amp;T</code>的<code>Alfred Aho</code>实在受不了了，于是<code>egrep</code>诞生了，这里的<code>e</code>表示<code>extended</code>，加强版的意思，支持了<code>+</code>、<code>|</code>与<code>?</code>这三个元符号，并且可以在分组中使用<code>*</code>，分组可以直接写成<code>(...)</code>，同时用<code>\1,\2...</code>来引用分组。</p>
<p>在<code>grep</code>、<code>egrep</code>发展的同时，<code>awk</code>、<code>lex</code>、<code>sed</code>等程序也开始发展起来，而且每个程序所支持的正则表达式都或多或少的和其他的不一样，这应该算是正则表达式发展的混乱期，因为这些程序在不断的发展过程中，有时新增加的功能因为<code>bug</code>原因，在后期的版本中取消了该功能，例如，如果让<code>grep</code>支持元符号<code>+</code>的话，那么<code>grep</code>就不能表示字符<code>+</code>了，而且<code>grep</code>的老用户会对这很反感。</p>
<p>这种门派自居的时代混乱不堪，总得有人来统一吧。到了<code>1986</code>年，这个人终于来了，他就是**<code>POSIX(Portable Operating System Interface)</code>标准**，<code>POSIX</code>制定了不同操作系统之间都需要遵守的一套规则。当然了，正则表达式也包括其中，终于来个管事的，<code>POSIX</code>规范分为基本正则表达式<code>BRE(Basic Regular Expressions)</code>和扩展正则表达式<code>ERE(Extended Regular Express，ERE)</code>两个流派，所有的<code>POSIX</code>程序可以选择支持其中的一种，具体规范详见下表：</p>
<img data-src="/2022/03/01/Other/regex-expression/1.png" class="" title="posix-regexp-favor">

<p>从上图可以看出，有三个空白栏，那么是不是就意味这无法使用该功能了呢？答案是否定的，因为我们现在使用的<code>linux</code>发行版，都是集成<code>GNU</code>套件的，<code>GNU</code>是<code>Gnu’s Not Unix</code>的缩写，<code>GNU</code>在实现了<code>POSIX</code>标准的同时，做了一定的扩展，所以上面空白栏中的功能也能使用。下面一一讲解：</p>
<ul>
<li><code>BRE</code>如何使用<code>+</code>、<code>?</code>呢？需要用<code>\+</code>、<code>\?</code>；</li>
<li><code>BRE</code>如何使用<code>|</code>呢？需要用<code>\|</code>；</li>
<li><code>ERE</code>如何使用<code>\1、\2…\9</code>这样的反引用？和<code>BRE</code>一样，就是<code>\1、\2…\9</code>；</li>
</ul>
<p>通过上面总结，可以发现：<code>GNU</code>中的<code>ERE</code>与<code>BRE</code>的功能相同，只是语法不同（<code>BRE</code>需要用<code>\</code>进行转义，才能表示特殊含义）。例如<code>a&#123;1,2&#125;</code>，在<code>ERE</code>表示的是<code>a</code>或<code>aa</code>，在<code>BRE</code>中表示的是<code>a&#123;1,2&#125;</code>这个字符串。为了能够在Linux下熟练使用文本处理工具，我们必须知道这些命令支持那种正则表达式。现对常见的命令总结如下：</p>
<ul>
<li>使用<code>BRE</code>语法的命令有：<code>grep、ed、sed、vim</code></li>
<li>使用<code>ERE</code>语法的命令有：<code>egrep、awk、emacs</code></li>
</ul>
<p>当然，这也不是绝对的，比如 <code>sed</code> 通过<code>-r</code>选项就可以使用<code>ERE</code>了，大家到时自己<code>man</code>一下就可以了。还值得一提的是<code>POSIX</code>还定义了一些<code>shorthand</code>，具体如下：</p>
<ul>
<li><code>[:alnum:]</code></li>
<li><code>[:alpha:]</code></li>
<li><code>[:cntrl:]</code></li>
<li><code>[:digit:]</code></li>
<li><code>[:graph:]</code></li>
<li><code>[:lower:]</code></li>
<li><code>[:print:]</code></li>
<li><code>[:punct:]</code></li>
<li><code>[:space:]</code></li>
<li><code>[:upper:]</code></li>
<li><code>[:xdigit:]</code></li>
</ul>
<p>在使用这些<code>shorthand</code>时有一个约束：<strong>必须在<code>[]</code>中使用</strong>，也就是说如果像匹配<code>0-9</code>的数字，需要这么写<code>[[:alnum:]]</code>，取反就是<code>[^[:alnum:]]</code>。<code>shorhand</code> 在<code>BRE</code>与<code>EBE</code>中的用法相同。</p>
<p>如果你对<code>sed</code>、<code>awk</code>比较熟悉，你会发现我们平常在变成语言中用的<code>\d</code>、<code>\w</code>在这些命令中不能用，原因很简单，因为<code>POSIX</code>规范根本没有定义这些<code>shorthand</code>，这些是由下面将要说的<code>PCRE</code>中定义的。</p>
<p>除了<code>POSIX</code>标准外，还有一个<code>Perl</code>分支，也就是我们现在熟知的<code>PCRE（Perl兼容正则表达式，Perl Compatible Regular Expressions)</code>，源自于<code>Henry Spencer</code>于<code>1986</code>年<code>1</code>月<code>19</code>日发布的<code>regex</code>，随着<code>Perl</code>语言的发展<code>，Perl</code>语言中的正则表达式功能越来越强悍，为了把<code>Perl</code>语言中正则的功能移植到其他语言中，<code>PCRE</code>就诞生了。<strong>现在的编程语言中的正则表达式，大部分都属于PCRE这个分支</strong>。</p>
<p><code>Perl</code>语言第一版是由<code>Larry Wall</code>发布于<code>1987</code>年<code>12</code>月，<code>Perl</code>在发布之初，就因其强大的功能而一票走红，<code>Perl</code>的定位目标就是天天要使用的工具。</p>
<p><code>Perl</code>比较显诸特征之一是与<code>sed</code>与<code>awk</code>兼容，这造就了<code>Perl</code>成为第一个通用性脚本语言。</p>
<p>随着<code>Perl</code>的不断发展，其支持的正则表达式的功能也越来越强大。其中影响较大的是于<code>1994</code>年<code>10</code>月发布的<code>Perl 5</code>，其增加了很多特性，比如<code>non-capturing parentheses</code>、<code>lazy quantifiers</code>、<code>look-ahead</code>、元符号<code>\G</code>等等。</p>
<p>正好这时也是 <code>WWW</code> 兴起的时候，而<code>Perl</code>就是为了文本处理而发明的，所以<code>Perl</code>基本上成了<code>web</code>开发的首选语言。<code>Perl</code>语言应用是如此广泛，以至于其他语言开始移植 <code>Perl</code>，最终<code>Perl compatible</code>（兼容）的<code>PCRE</code>诞生了，这其中包括了<code>Tcl</code>, <code>Python</code>, <code>Microsoft’s .NET</code>，<code>Ruby</code>，<code>PHP</code>，<code>C/C++</code>， <code>Java</code>等等。</p>
<p>前面说了<code>shorthand</code>在<code>POSIX</code>与<code>PCRE</code>是不同的，<code>PCRE</code>中我们常用的有如下这些：</p>
<ul>
<li><code>\w</code> 表示<code>[a-zA-Z]</code></li>
<li><code>\W</code> 表示<code>[^a-zA-Z]</code></li>
<li><code>\s</code> 表示<code>[ \t\r\n\f]</code></li>
<li><code>\S</code> 表示<code>[^ \t\r\n\f]</code></li>
<li><code>\d</code> 表示<code>[1-9]</code></li>
<li><code>\D</code> 表示<code>[^1-9]</code></li>
<li><code>\&lt;</code> 表示一个单词的起始</li>
<li><code>\&gt;</code> 表示一个单词的结尾</li>
</ul>
<h3 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a><code>PCRE</code></h3><img data-src="/2022/03/01/Other/regex-expression/pcre.png" class="" title="pcre">

<ol>
<li><p><code>\</code>, 将下一个字符标记为一个<code>特殊字符(File Format Escape)</code>、或一个<code>原义字符（Identity Escape，有^$()*+?.[\&#123;|共计12个)</code>、或一个向<code>后引用(backreferences)</code>、或一个<code>八进制转义符</code>。例如，<code>n</code>匹配字符<code>n</code>。<code>\n</code>匹配一个换行符。序列<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code>。</p>
</li>
<li><p><code>^</code>, 匹配输入字符串的开始位置。如果设置了<code>RegExp</code>对象的<code>Multiline</code>属性，<code>^</code>也匹配<code>\n</code>或<code>\r</code>之后的位置。</p>
</li>
<li><p><code>$</code>, 匹配输入字符串的结束位置。如果设置了<code>RegExp</code>对象的<code>Multiline</code>属性，<code>$</code>也匹配<code>\n</code>或<code>\r</code>之前的位置。</p>
</li>
<li><p><code>*</code>, 匹配前面的子表达式零次或多次。例如，<code>zo*</code>能匹配<code>z</code>、<code>zo</code>以及<code>zoo</code>。<code>*</code>等价于<code>&#123;0,&#125;</code>。</p>
</li>
<li><p><code>+</code>, 匹配前面的子表达式一次或多次。例如，<code>zo+</code>能匹配<code>zo</code>以及<code>zoo</code>，但不能匹配<code>z</code>。<code>+</code>等价于<code>&#123;1,&#125;</code>。</p>
</li>
<li><p><code>?</code>, 匹配前面的子表达式零次或一次。例如，<code>do(es)?</code>可以匹配<code>do</code>或<code>does</code>中的<code>do</code>。<code>?</code>等价于<code>&#123;0,1&#125;</code>。</p>
</li>
<li><p><code>&#123;n&#125;</code>, <code>n</code>是一个非负整数。匹配确定的<code>n</code>次。例如，<code>o&#123;2&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code>。</p>
</li>
<li><p><code>&#123;n,&#125;</code>, n是一个非负整数。至少匹配n次。例如，<code>o&#123;2,&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但能匹配<code>foooood</code>中的所有<code>o</code>。<code>o&#123;1,&#125;</code>等价于<code>o+</code>。<code>o&#123;0,&#125;</code>则等价于<code>o*</code>。</p>
</li>
<li><p><code>&#123;m,n&#125;</code>, <code>m</code>和<code>n</code>均为非负整数，其中<code>n&lt;=m</code>。最少匹配<code>n</code>次且最多匹配<code>m</code>次。例如，<code>o&#123;1,3&#125;</code>将匹配<code>fooooood</code>中的前三个<code>o</code>。<code>o&#123;0,1&#125;</code>等价于<code>o?</code>。<strong>请注意在逗号和两个数之间不能有空格</strong>。</p>
</li>
<li><p><code>?</code>, <strong>非贪心量化（<code>Non-greedy quantifiers</code>）</strong>：当该字符紧跟在任何一个其他重复修饰符（<code>*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串<code>oooo</code>，<code>o+?</code>将匹配单个<code>o</code>，而<code>o+</code>将匹配所有<code>o</code>。</p>
</li>
<li><p><code>.</code>, 匹配除<code>\r</code> <code>\n</code>之外的任何单个字符。要匹配包括<code>\r</code> <code>\n</code>在内的任何字符，请使用像<code>(.|\r|\n)</code>的模式。</p>
</li>
<li><p><code>(pattern)</code>, 匹配<code>pattern</code>并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的<code>Matches</code>集合得到，在<code>VBScript</code>中使用<code>SubMatches</code>集合，在<code>JScript</code>中则使用<code>$0…$9</code>属性，要匹配圆括号字符，请使用<code>\(</code>或<code>\)</code>。</p>
</li>
<li><p><code>(?:pattern)</code>, 匹配<code>pattern</code>但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符<code>(|)</code>来组合一个模式的各个部分是很有用。例如<code>industr(?:y|ies)</code>就是一个比<code>industry|industries</code>更简略的表达式。</p>
</li>
<li><p><code>(?=pattern)</code>, 正向肯定预查（<code>look ahead positive assert</code>），在任何匹配<code>pattern</code>的字符串开始处匹配查找字符串。<strong>这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</strong>。例如，<code>Windows(?=95|98|NT|2000)</code>能匹配<code>Windows2000</code>中的<code>Windows</code>，但不能匹配<code>Windows3.1</code>中的<code>Windows</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>
</li>
<li><p><code>(?!pattern)</code>, 正向否定预查(<code>negative assert</code>)，在任何不匹配<code>pattern</code>的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如<code>Windows(?!95|98|NT|2000)</code>能匹配<code>Windows3.1</code>中的<code>Windows</code>，但不能匹配<code>Windows2000</code>中的<code>Windows</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>
</li>
<li><p><code>(?&lt;=pattern)</code>, 反向(<code>look behind</code>)肯定预查，与正向肯定预查类似，只是方向相反。例如，<code>(?&lt;=95|98|NT|2000)Windows</code>能匹配<code>2000Windows</code>中的<code>Windows</code>，但不能匹配<code>3.1Windows</code>中的<code>Windows</code>。</p>
</li>
<li><p><code>(?&lt;!pattern)</code>, 反向否定预查，与正向否定预查类似，只是方向相反。例如<code>(?&lt;!95|98|NT|2000)Windows</code>能匹配<code>3.1Windows</code>中的<code>Windows</code>，但不能匹配<code>2000Windows</code>中的<code>Windows</code>。</p>
</li>
<li><p><code>x|y</code>, 匹配<code>x</code>或<code>y</code>。例如，<code>z|food</code>能匹配<code>z</code>或<code>food</code>。<code>(?:z|f)ood</code>则匹配<code>zood</code>或<code>food</code>。</p>
</li>
<li><p><code>[xyz]</code>, 字符集合（<code>character class</code>）。匹配所包含的任意一个字符。例如，<code>[abc]</code>可以匹配<code>plain</code>中的<code>a</code>。特殊字符仅有反斜线<code>\</code>保持特殊含义，用于转义字符。其它特殊字符如<code>*</code>、<code>+</code>、各种括号等均作为普通字符。<code>^</code>如果出现在首位则表示不在字符集合；如果出现在字符串中间就仅作为普通字符。连字符 <code>-</code> 如果出现在字符串中间表示字符范围描述；如果如果出现在首位（或末尾）则仅作为普通字符。右方括号应转义出现，也可以作为首位字符出现。</p>
</li>
<li><p><code>[^xyz]</code>, 排除型字符集合（<code>negated character classes</code>）。匹配未列出的任意字符。例如，<code>[^abc]</code>可以匹配<code>plain</code>中的<code>plin</code>。</p>
</li>
<li><p><code>[a-z]</code>, 字符范围。匹配指定范围内的任意字符。例如，<code>[a-z]</code>可以匹配<code>a</code>到<code>z</code>范围内的任意小写字母字符。</p>
</li>
<li><p><code>[^a-z]</code>, 排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，<code>[^a-z]</code>可以匹配任何不在<code>a</code>到<code>z</code>范围内的任意字符。</p>
</li>
<li><p><code>\b</code>, 匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>er\b</code>可以匹配<code>never</code>中的<code>er</code>，但不能匹配<code>verb</code>中的<code>er</code>。</p>
</li>
<li><p><code>\B</code>, 匹配非单词边界。<code>er\B</code>能匹配<code>verb</code>中的<code>er</code>，但不能匹配<code>never</code>中的<code>er</code>。</p>
</li>
<li><p><code>\cx</code>, 匹配由x指明的控制字符。例如，<code>\cM</code>匹配一个<code>Control-M</code>或回车符。<code>x</code>的值必须为<code>A-Z</code>或<code>a-z</code>之一。否则，将<code>c</code>视为一个原义的<code>c</code>字符。</p>
</li>
<li><p><code>\d</code>, 匹配一个数字字符。等价于<code>[0-9]</code>。注意<code>Unicode</code>正则表达式会匹配全角数字字符。</p>
</li>
<li><p><code>\D</code>, 匹配一个非数字字符。等价于<code>[^0-9]</code>。</p>
</li>
<li><p><code>\f</code>, 匹配一个换页符。等价于<code>\x0c</code>和<code>\cL</code>。</p>
</li>
<li><p><code>\n</code>, 匹配一个换行符。等价于<code>\x0a</code>和<code>\cJ</code>。</p>
</li>
<li><p><code>\r</code>, 匹配一个回车符。等价于<code>\x0d</code>和<code>\cM</code>。</p>
</li>
<li><p><code>\s</code>, 匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[ \f\n\r\t\v]</code>。注意<code>Unicode</code>正则表达式会匹配全角空格符。</p>
</li>
<li><p><code>\S</code>, 匹配任何非空白字符。等价于<code>[^ \f\n\r\t\v]</code>。</p>
</li>
<li><p><code>\t</code>, 匹配一个制表符。等价于<code>\x09</code>和<code>\cI</code>。</p>
</li>
<li><p><code>\v</code>, 匹配一个垂直制表符。等价于<code>\x0b</code>和<code>\cK</code>。</p>
</li>
<li><p><code>\w</code>, 匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code>。注意<code>Unicode</code>正则表达式会匹配中文字符。</p>
</li>
<li><p><code>\W</code>, 匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code>。</p>
</li>
<li><p><code>\ck</code>, 匹配控制转义字符。<code>k</code>代表一个字符。等价于<code>Ctrl-k</code>。用于<code>ECMA</code>语法。</p>
</li>
<li><p><code>\xnn</code>, 十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，<code>\x41</code>匹配<code>A</code>。<code>\x041</code>则等价于<code>\x04&amp;1</code>。正则表达式中可以使用<code>ASCII</code>编码。</p>
</li>
<li><p><code>\num</code>, 向后引用（<code>back-reference</code>）一个子字符串（<code>substring</code>），该子字符串与正则表达式的第<code>num</code>个用括号围起来的捕捉群（<code>capture group</code>）子表达式（<code>subexpression</code>）匹配。其中<code>num</code>是从<code>1</code>开始的十进制正整数，其上限可能是<code>9</code>、<code>31</code>、<code>99</code>甚至无限。例如：<code>(.)\1</code>匹配两个连续的相同字符。</p>
</li>
<li><p><code>\n</code>, 标识一个八进制转义值或一个向后引用。如果<code>\n</code>之前至少<code>n</code>个获取的子表达式，则<code>n</code>为向后引用。否则，如果<code>n</code>为八进制数字<code>（0-7）</code>，则<code>n</code>为一个八进制转义值。</p>
</li>
<li><p><code>\nm</code>, <code>3</code>位八进制数字，标识一个八进制转义值或一个向后引用。如果<code>\nm</code>之前至少有<code>nm</code>个获得子表达式，则<code>nm</code>为向后引用。如果<code>\nm</code>之前至少有<code>n</code>个获取，则<code>n</code>为一个后跟文字<code>m</code>的向后引用。如果前面的条件都不满足，若<code>n</code>和<code>m</code>均为八进制数字（<code>0-7</code>），则<code>\nm</code>将匹配八进制转义值<code>nm</code>。</p>
</li>
<li><p><code>\nml</code>, 如果<code>n</code>为八进制数字（<code>0-3</code>），且<code>m</code>和<code>l</code>均为八进制数字（<code>0-7</code>），则匹配八进制转义值<code>nml</code>。</p>
</li>
<li><p><code>\un</code>, <code>Unicode</code>转义字符序列。其中<code>n</code>是一个用四个十六进制数字表示的<code>Unicode</code>字符。例如，<code>\u00A9</code>匹配版权符号（<code>©</code>）。</p>
</li>
</ol>
<h3 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a><code>POSIX</code></h3><img data-src="/2022/03/01/Other/regex-expression/posix.png" class="" title="posix">

<h3 id="优先权"><a href="#优先权" class="headerlink" title="优先权"></a>优先权</h3><table>
<thead>
<tr>
<th align="center">优先权</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最高</td>
<td align="center"><code>\</code></td>
</tr>
<tr>
<td align="center">高</td>
<td align="center"><code>( )、(?: )、(?= )、[ ]</code></td>
</tr>
<tr>
<td align="center">中</td>
<td align="center"><code>*、+、?、&#123;n&#125;、&#123;n,&#125;、&#123;m,n&#125;</code></td>
</tr>
<tr>
<td align="center">低</td>
<td align="center">^、$、中介字符</td>
</tr>
<tr>
<td align="center">次最低</td>
<td align="center">串接，即相邻字符连接在一起</td>
</tr>
<tr>
<td align="center">最低</td>
<td align="center">&#124;</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><p>匹配至少同时包含大小写字母，数字以及符号中其中两个的密码字符串：<code>^(?![A-Z]+$)(?![a-z]+$)(?!\d+$)(?!\W+$)\S&#123;8,16&#125;$</code></p>
<p> 123131sdadad<br> #%sdad@#$dsd</p>
</li>
</ul>
<h3 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
<li><a href="http://en.wikipedia.org/wiki/Regular_expression">Regular_expression</a></li>
<li><a href="http://regularexp.wordpress.com/">正则表达式应用示例</a></li>
<li><a href="http://liujiacai.net/blog/2014/12/07/regexp-favors/">正则表达式“派别”简述</a></li>
<li><a href="http://www.regular-expressions.info/posixbrackets.html">POSIX Bracket Expressions</a></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.100).aspx">MSDN正则表达式语法介绍</a></li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></li>
<li><a href="http://www.regular-expressions.info/gnu.html"><code>GNU Regular Expression Extensions</code></a></li>
<li><a href="https://regexr.com/"><code>RegExr: Learn, Build, &amp; Test RegEx</code></a></li>
<li><a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux&#x2F;Unix工具与正则表达式的POSIX规范</a></li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=Comparison_of_regular_expression_engines&action=edit&redlink=1"><code>Comparison of regular expression engines</code></a></li>
<li><a href="http://www.greenend.org.uk/rjk/2002/06/regexp.html">各种语言或工具软件的不同风格的正则表达式文法规定</a></li>
<li><a href="https://www.gnu.org/software/gnulib/manual/html_node/Regular-expression-syntaxes.html"><code>Different types of regular expressions Gnulib supports</code></a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/05/01/Design-Patterns/design-patterns/</url>
    <content><![CDATA[<p>设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。</p>
<p>设计模式与方法或库的使用方式不同，很难直接在自己的程序中套用某个设计模式。模式并不是一段特定的代码，而是解决特定问题的一般性概念。可以根据模式来实现符合自己程序实际所需的解决方案。</p>
<p>人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。但算法总是明确定义达成特定目标所需的一系列步骤，而模式则是对解决方案的更高层次描述，同一模式在两个不同程序中的实现代码可能会不一样。</p>
<p>算法更像是菜谱：提供达成目标的明确步骤。而模式更像是蓝图：可以看到最终的结果和模式的功能，但需要自己确定实现步骤。</p>
<p>设计模式从分类上来讲，可以分为创建型、结构型和行为型。</p>
<span id="more"></span>

<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例设计模式（<code>Singleton Design Pattern</code>）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<p>下面举两个例子来说明单例模式能解决的问题。</p>
<div class="tabs" id="单例模式场景"><ul class="nav-tabs"><li class="tab active"><a href="#单例模式场景-1">处理资源冲突</a></li><li class="tab"><a href="#单例模式场景-2">表示全局唯一类</a></li></ul><div class="tab-content"><div class="tab-pane active" id="单例模式场景-1"><p>打印日志是应用程序基本的需求，为了将日志信息打印到文件中，我们可能会写出下面这样的代码：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    writer.write(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    logger.log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    logger.log(<span class="string">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码看起来貌似没什么问题，但是在多线程环境中会出现日志覆盖的情况。那如何解决呢，资源抢占访问的最直接的解决方案就是加锁，所以我们可能给出下面这样的解决方案，对象级别的锁或者类级别的锁：</p>
<div class="tabs" id="单例模式解决方案一两种处理方式"><ul class="nav-tabs"><li class="tab active"><a href="#单例模式解决方案一两种处理方式-1">对象级别的锁</a></li><li class="tab"><a href="#单例模式解决方案一两种处理方式-2">类级别的锁</a></li></ul><div class="tab-content"><div class="tab-pane active" id="单例模式解决方案一两种处理方式-1"><div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
对象级别的锁明显解决不了问题，两个线程两个对象，毫不相干。</div><div class="tab-pane" id="单例模式解决方案一两种处理方式-2"><div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Logger.class) &#123; <span class="comment">// 类级别的锁</span></span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>类级别的锁可以解决问题，让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 <code>log()</code> 函数，而导致的日志覆盖问题。</p></div></div></div>

<p>对比这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 <code>Logger</code> 对象，一方面节省内存空间，另一方面节省系统文件句柄。</p>
<p>按照这个思路，我们可以设计出下面这样的单例模式解决方案，既然加锁能解决，全局创建一个对象也可以解决咯：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(<span class="string">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="单例模式场景-2"><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。再比如，唯一递增 <code>ID</code> 号码生成器，如果程序中有两个对象，那就会存在生成重复 <code>ID</code> 的情况，所以，我们应该将 <code>ID</code> 生成器类设计为单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  <span class="comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class="line">  <span class="comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class="line">  <span class="comment">// 比如下面会用到的incrementAndGet().</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure></div></div></div>

<p>讲到这里，如何实现单例模式呢，通用的解决方案有两个步骤：</p>
<ol>
<li>将默认构造函数设为私有，防止其他对象使用单例类的 <code>new</code> 运算符创建新的对象，也就是禁止创建新对象；</li>
<li>新建一个静态构建方法作为构造函数。该函数会 “偷偷” 调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象；</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。</p>
<h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>一个专门负责创建对象的类，职责单一，代码清楚，我们将这种类称之为简单工厂类，结合一个例子来解释，根据配置文件的后缀（<code>json</code>、<code>xml</code>、<code>yaml</code>、<code>properties</code>），选择不同的解析器（<code>JsonRuleConfigParser</code>、<code>XmlRuleConfigParser</code>……），将存储在文件中的配置解析成内存对象 <code>RuleConfig</code>。</p>
<div class="tabs" id="简单工厂"><ul class="nav-tabs"><li class="tab"><a href="#简单工厂-1">简单模式</a></li><li class="tab"><a href="#简单工厂-2">稍作优化</a></li><li class="tab active"><a href="#简单工厂-3">简单工厂</a></li></ul><div class="tab-content"><div class="tab-pane" id="简单工厂-1"><div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">             <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这一块代码中，创建解析器这部分的代码功能比较独立，为了让代码逻辑比较清晰，可读性更好，我们将这部分代码独立封装成函数。</p></div><div class="tab-pane" id="简单工厂-2"><p>将代码中涉及 <code>parser</code> 创建的部分逻辑剥离出来，抽象成 <code>createParser()</code> 函数。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">              <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane active" id="简单工厂-3"><p>为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 <code>createParser()</code> 函数剥离到一个独立的类中，让这个类只负责对象的创建，而这个类就是我们现在要讲的简单工厂模式类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">              <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>大部分工厂类都是以<code>Factory</code>这个单词结尾的，但也不是必须的，比如 <code>Java</code> 中的 <code>DateFormat</code>、<code>Calender</code>。除此之外，工厂类中创建对象的方法一般都是 <code>create</code> 开头，比如代码中的 <code>createParser()</code>。</p>
<p>上面的代码实现中，我们每次调用 <code>RuleConfigParserFactory</code> 的 <code>createParser()</code> 的时候，都要创建一个新的 <code>parser</code>。实际上，如果 <code>parser</code> 可以复用，为了节省内存和对象创建的时间，我们可以将 <code>parser</code> 事先创建好缓存起来。当调用 <code>createParser()</code> 函数的时候，我们从缓存中取出 <code>parser</code> 对象直接使用，这有点类似单例模式和简单工厂模式的结合，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 <code>parser</code>，那势必要改动到 <code>RuleConfigParserFactory</code> 的代码，虽然违反开闭原则，但如果不是需要频繁地添加新的 <code>parser</code>，只是偶尔修改一下 <code>RuleConfigParserFactory</code> 代码，稍微不符合开闭原则，也是完全可以接受的。</p>
<p>总结一下，尽管简单工厂模式的代码实现中，有多处 <code>if</code> 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 <code>parser</code>，也没有太多的 <code>parser</code>）是没有问题的。</p>
<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>在前面的简单工厂中，还存在了很多 <code>if</code> 分支，我们现在利用多态的思路将这里的 <code>if</code> 分支去掉，对上面的代码重构之后如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 <code>parser</code> 的时候，只需要新增一个实现了 <code>IRuleConfigParserFactory</code> 接口的 <code>Factory</code> 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p>
<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 <code>RuleConfigSource</code> 的 <code>load()</code> 函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 <code>load()</code> 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。为了解决这个问题，我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，<code>RuleConfigParserFactoryMap</code> 类是创建工厂对象的工厂类，<code>getParserFactory()</code> 返回的是缓存好的单例工厂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parserFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactoryMap</span> &#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParserFactory</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title function_">getParserFactory</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 <code>parser</code> 类和 <code>parser factory</code> 类，并且在 <code>RuleConfigParserFactoryMap</code> 类中，将新的 <code>parser factory</code> 对象添加到 <code>cachedFactories</code> 中即可。代码的改动非常少，基本上符合开闭原则。</p>
<p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 <code>Factory</code> 类，也会增加代码的复杂性，而且，每个 <code>Factory</code> 类只是做简单的 <code>new</code> 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</p>
<p>当对象的创建逻辑比较复杂，不只是简单的 <code>new</code> 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（<code>Json</code>、<code>Xml</code>、<code>Yaml</code>……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（<code>Rule</code> 规则配置还是 <code>System</code> 系统配置）来分类，那就会对应下面这 <code>8</code> 个 <code>parser</code> 类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>

<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 <code>parser</code> 都编写一个工厂类，也就是要编写 <code>8</code> 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 <code>IBizConfigParser</code>），那就要再对应地增加 <code>4</code> 个工厂类。</p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（<code>IRuleConfigParser</code>、<code>ISystemConfigParser</code> 等），而不是只创建一种 <code>parser</code> 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">  IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span>;</span><br><span class="line">  ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonSystemConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlSystemConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>

<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。在平时的开发中，创建一个对象最常用的方式是，使用 <code>new</code> 关键字调用类的构造函数来完成。</p>
<p>但是假设有这样一个场景，我们需要定义一个资源池配置类 <code>ResourcePoolConfig</code>。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/builder-pattern-exmaple.webp" class="">

<div class="tabs" id="建造者模式示例"><ul class="nav-tabs"><li class="tab active"><a href="#建造者模式示例-1">最初想法</a></li><li class="tab"><a href="#建造者模式示例-2">初步优化</a></li><li class="tab"><a href="#建造者模式示例-3">建造者模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="建造者模式示例-1"><p>实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 不是必填变量，所以在创建 <code>ResourcePoolConfig</code> 对象的时候，我们通过往构造函数中，给这几个参数传递 <code>null</code> 值，来表示使用默认值。</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotal != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxIdle != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minIdle != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现在，<code>ResourcePoolConfig</code> 只有 <code>4</code> 个可配置项，对应到构造函数中，也只有 <code>4</code> 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 <code>8</code> 个、<code>10</code> 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 <code>bug</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class="line"><span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="string">&quot;dbconnectionpool&quot;</span>, <span class="number">16</span>, <span class="literal">null</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="literal">false</span> , <span class="literal">true</span>, <span class="number">10</span>, <span class="number">20</span>，<span class="literal">false</span>， <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="建造者模式示例-2"><p>解决这个问题的办法你应该也已经想到了，那就是用 <code>set()</code> 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 <code>name</code> 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 都不是必填的，所以我们通过 <code>set()</code> 函数来设置，让使用者自主选择填写或者不填写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxTotal</span><span class="params">(<span class="type">int</span> maxTotal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxIdle</span><span class="params">(<span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinIdle</span><span class="params">(<span class="type">int</span> minIdle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看新的 <code>ResourcePoolConfig</code> 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ResourcePoolConfig使用举例</span></span><br><span class="line"><span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="string">&quot;dbconnectionpool&quot;</span>);</span><br><span class="line">config.setMaxTotal(<span class="number">16</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 <code>set()</code> 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>
<ol>
<li>我们刚刚讲到，<code>name</code> 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 <code>set()</code> 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了；</li>
<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，<code>maxIdle</code> 和 <code>minIdle</code> 要小于等于 <code>maxTotal</code>。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了；</li>
<li>如果我们希望 <code>ResourcePoolConfig</code> 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 <code>ResourcePoolConfig</code> 类中暴露 <code>set()</code> 方法；</li>
</ol></div><div class="tab-pane" id="建造者模式示例-3"><p>我们可以把校验逻辑放置到 <code>Builder</code> 类中，先创建建造者，并且通过 <code>set()</code> 方法设置建造者的变量值，然后在使用 <code>build()</code> 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 <code>ResourcePoolConfig</code> 的构造函数改为 <code>private</code> 私有权限。这样我们就只能通过建造者来创建 <code>ResourcePoolConfig</code> 类对象。并且，<code>ResourcePoolConfig</code> 没有提供任何 <code>set()</code> 方法，这样我们创建出来的对象就是不可变对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = builder.name;</span><br><span class="line">    <span class="built_in">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">    <span class="built_in">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">    <span class="built_in">this</span>.minIdle = builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">  <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResourcePoolConfig <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setMaxTotal</span><span class="params">(<span class="type">int</span> maxTotal)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setMaxIdle</span><span class="params">(<span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setMinIdle</span><span class="params">(<span class="type">int</span> minIdle)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line"><span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>.Builder()</span><br><span class="line">        .setName(<span class="string">&quot;dbconnectionpool&quot;</span>)</span><br><span class="line">        .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">        .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">        .setMinIdle(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></div></div></div>

<h5 id="和工厂模式有何区别？"><a href="#和工厂模式有何区别？" class="headerlink" title="和工厂模式有何区别？"></a>和工厂模式有何区别？</h5><p>建造者模式是让建造者类来负责对象的创建工作。工厂模式，是由工厂类来负责对象创建的工作。</p>
<p>实际上，<strong>工厂模式是用来创建不同但是相关类型的对象</strong>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<strong>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</strong></p>
<p>网上有一个经典的例子很好地解释了两者的区别。顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p>
<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p>
<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 <code>RPC</code>、网络、数据库、文件系统等非常慢速的 <code>IO</code> 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p>
<p>举个例子，假设数据库中存储了大约 <code>10</code> 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 <code>A</code> 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</p>
<p>如果是 <code>Java</code> 语言，可以直接使用语言中提供的 <code>HashMap</code> 容器来实现。其中，<code>HashMap</code> 的 <code>key</code> 为搜索关键词，<code>value</code> 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 <code>HashMap</code> 就可以了。</p>
<p>不过，我们还有另外一个系统 <code>B</code>，专门用来分析搜索日志，定期（比如间隔 <code>10</code> 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 <code>v2</code> 版本的数据进行更新，得到 <code>v3</code> 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/prototype-pattern.webp" class="">

<div class="tabs" id="原型模式"><ul class="nav-tabs"><li class="tab active"><a href="#原型模式-1">初始需求</a></li><li class="tab"><a href="#原型模式-2">进一步要求</a></li><li class="tab"><a href="#原型模式-3">原型模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="原型模式-1"><p>为了保证系统 <code>A</code> 中数据的实时性，系统 <code>A</code> 需要定期根据数据库中的数据，更新内存中的索引和数据。实现这个需求，我们只需要在系统 <code>A</code> 中，记录当前数据的版本 <code>Va </code>对应的更新时间 <code>Ta</code>，从数据库中捞出更新时间大于 <code>Ta</code> 的所有搜索关键词，也就是找出 <code>Va</code> 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</p>
<p>按照这个思路，我们可以写出下面这样的代码：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="原型模式-2"><p>不过，现在，我们有一个特殊的要求：任何时刻，系统 <code>A</code> 中的所有数据都必须是同一个版本的，要么都是版本 <code>a</code>，要么都是版本 <code>b</code>，不能有的是版本 <code>a</code>，有的是版本 <code>b</code>。那刚刚的更新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统 <code>A</code> 不能处于不可用状态，也就是不能停机更新数据。</p>
<p>按照这个思路，我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 <code>a</code> 数据）上更新，而是重新创建另一个版本数据（假设是版本 <code>b</code> 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 <code>a</code> 切换到版本 <code>b</code>。这样既保证了数据一直可用，又避免了中间状态的存在。</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过，在上面的代码实现中，<code>newKeywords</code> 构建的成本比较高。我们需要将这 <code>10</code> 万条数据从数据库中读出，然后计算哈希值，构建 <code>newKeywords</code>。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</p></div><div class="tab-pane" id="原型模式-3"><p>我们拷贝 <code>currentKeywords</code> 数据到 <code>newKeywords</code> 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 <code>newKeywords</code> 中。而相对于 <code>10</code> 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        <span class="type">SearchWord</span> <span class="variable">oldSearchWord</span> <span class="operator">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里利用了 <code>Java</code> 中的 <code>clone()</code> 语法来复制一个对象。如果熟悉的语言没有这个语法，那把数据从 <code>currentKeywords</code> 中一个个取出来，然后再重新计算哈希值，放入到 <code>newKeywords</code> 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 <code>IO</code> 操作来说，内存操作和 <code>CPU</code> 计算的耗时都是可以忽略的。</p></div></div></div>

<p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个<code>clone</code>方法。</p>
<p>所有的类对 <code>clone</code> 方法的实现都非常相似。该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p>
<p>支持克隆的对象即为原型。</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p>
<p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。除非像前面的那个例子，需要从数据库中加载 <code>10</code> 万条数据并构建散列表索引，操作非常耗时，这种情况下比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p>
<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
<p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式（<code>Proxy Design Pattern</code>）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<p>假设我们正在开发 <code>MetricsCollector</code> 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。</p>
<div class="tabs" id="代理模式"><ul class="nav-tabs"><li class="tab active"><a href="#代理模式-1">初始设计</a></li><li class="tab"><a href="#代理模式-2">代理模式</a></li><li class="tab"><a href="#代理模式-3">动态代理</a></li></ul><div class="tab-content"><div class="tab-pane active" id="代理模式-1"><p>一开始，我们会采用如下的方式来使用 <code>MetricsCollector</code> 类：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略login逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略register逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</p></div><div class="tab-pane" id="代理模式-2"><p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 <code>UserControllerProxy</code> 和原始类 <code>UserController</code> 实现相同的接口 <code>IUserController</code>。<code>UserController</code> 类只负责业务功能。代理类 <code>UserControllerProxy</code> 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">  UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略login逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略register逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">(UserController userController)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userController = userController;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托</span></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>
</div>

<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。</p>
<p>如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>();</span><br></pre></td></tr></table></figure>
</div></div><div class="tab-pane" id="代理模式-3"><p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</p>
<p>如果有 <code>50</code> 个要添加附加功能的原始类，那我们就要创建 <code>50</code> 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。</p>
<p>我们可以使用动态代理来解决这个问题。所谓动态代理（<code>Dynamic Proxy</code>），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p><code>Java</code> 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 <code>Java</code> 的反射语法）。</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCollectorProxy</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MetricsCollectorProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    <span class="type">DynamicProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">      <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line"><span class="type">MetricsCollectorProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetricsCollectorProxy</span>();</span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> (IUserController) proxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>
</div>

<p>实际上，<code>Spring AOP</code> 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。<code>Spring</code> 为这些类创建动态代理对象，并在 <code>JVM</code> 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p></div></div></div>

<p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。</p>
<p>实际上，<code>RPC</code> 框架也可以看作一种代理模式，<code>GoF</code> 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，<code>RPC</code> 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>
<p>另外，假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。</p>
<p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p>
<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 <code>Spring</code> 框架来开发的话，那就可以在 <code>AOP</code> 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 <code>AOP</code> 切面中拦截请求，如果请求中带有支持缓存的字段（比如 <code>http://…?..&amp;cached=true</code>），我们便从缓存（内存缓存或者 <code>Redis</code> 缓存等）中获取数据直接返回。</p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>桥接模式，也叫作桥梁模式，英文是 <strong>Bridge Design Pattern</strong>。关于桥接模式有两种理解：</p>
<ol>
<li>将抽象和实现解耦，让它们可以独立变化；</li>
<li>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展；</li>
</ol>
<p>看个例子，<code>JDBC</code> 驱动是桥接模式的经典应用。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//加载及注册JDBC驱动程序</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(url);</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()；</span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line">ResultSet rs=stmt.executeQuery(query);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">  rs.getString(<span class="number">1</span>);</span><br><span class="line">  rs.getInt(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要把 <code>MySQL</code> 数据库换成 <code>Oracle</code> 数据库，只需要把第一行代码中的 <code>com.mysql.jdbc.Driver</code> 换成 <code>oracle.jdbc.driver.OracleDriver</code> 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 <code>Driver</code> 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</p>
<p>为了弄清楚如何实现的这么优雅，来看看源码是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，当执行 <code>Class.forName(“com.mysql.jdbc.Driver”)</code> 这条语句的时候，实际上是做了两件事情。第一件事情是要求 <code>JVM</code> 查找并加载指定的 <code>Driver</code> 类，第二件事情是执行该类的静态代码，也就是将 <code>MySQL Driver</code> 注册到 <code>DriverManager</code> 类中。</p>
<p>当我们把具体的 <code>Driver</code> 实现类（比如，<code>com.mysql.jdbc.Driver</code>）注册到 <code>DriverManager</code> 之后，后续所有对 <code>JDBC</code> 接口的调用，都会委派到对具体的 <code>Driver</code> 实现类来执行。而 <code>Driver</code> 实现类都实现了相同的接口（<code>java.sql.Driver</code>），这也是可以灵活切换 <code>Driver</code> 的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">null</span>) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url, String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">      info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">      info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 <code>JDBC</code> 这个例子中，什么是<strong>抽象</strong>？什么是<strong>实现</strong>呢？</p>
<p>实际上，<code>JDBC</code> 本身就相当于<strong>抽象</strong>。注意，这里所说的<strong>抽象</strong>，指的并非<strong>抽象类</strong>或<strong>接口</strong>，而是跟具体的数据库无关的、被抽象出来的一套<strong>类库</strong>。具体的 <code>Driver</code>（比如，<code>com.mysql.jdbc.Driver</code>）就相当于<strong>实现</strong>。注意，这里所说的<strong>实现</strong>，也并非指<strong>接口的实现类</strong>，而是跟具体数据库相关的一套<strong>类库</strong>。<code>JDBC</code> 和 <code>Driver</code> 独立开发，通过对象之间的组合关系，组装在一起。<code>JDBC</code> 的所有逻辑操作，最终都委托给 <code>Driver</code> 来执行。它们之间的关系如下图所示：</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/bridge-pattern.webp" class="">

<p>在这里，<code>JDBC</code>(抽象) 和 <code>Driver</code>（接口） 都是可以独立演进的，<code>JDBC</code> 本身不完成任何具体的工作，它只是将工作委派给具体的实现层。</p>
<p>再举个例子，在实际的程序中， 抽象出来的图形用户界面（<code>GUI</code>）， 由底层操作系统代码（<code>API</code>）实现，<code>GUI</code> 层调用 <code>API</code> 层来对用户的各种操作做出响应。</p>
<p>一般来说， 你可以在两个独立方向上扩展这种应用：</p>
<ol>
<li>开发多个不同的 <code>GUI</code> （例如面向普通用户和管理员进行分别配置）；</li>
<li>支持多个不同的 <code>API</code> （例如， 能够在 <code>Windows</code>、 <code>Linux</code> 和 <code>macOS</code> 上运行该程序）；</li>
</ol>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<p>举个 <code>Java</code> 的例子，<code>Java IO</code> 类库非常庞大和复杂，有几十个类，负责 <code>IO</code> 数据的读取和写入。如果对 <code>Java IO</code> 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p>
<table>
<thead>
<tr>
<th align="center">输入输出</th>
<th align="center">字节留</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入流</td>
<td align="center"><code>InputStream</code></td>
<td align="center"><code>Reader</code></td>
</tr>
<tr>
<td align="center">输出流</td>
<td align="center"><code>OutputStream</code></td>
<td align="center"><code>Writer</code></td>
</tr>
</tbody></table>
<p>针对不同的读取和写入场景，<code>Java IO</code> 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/wrapper-patterns.webp" class="">

<p>这么多类在使用起来对于初学者造成了不少困惑，当我们需要以缓存的形式读取文件时，我们需要这么去写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能在想，还不如下面这种方式简洁明了：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedFileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="tabs" id="装饰器模式"><ul class="nav-tabs"><li class="tab active"><a href="#装饰器模式-1">基于继承</a></li><li class="tab"><a href="#装饰器模式-2">基于组合</a></li></ul><div class="tab-content"><div class="tab-pane active" id="装饰器模式-1"><p>然而如果 <code>InputStream</code> 只有一个子类 <code>FileInputStream</code> 的话，那我们在 <code>FileInputStream</code> 基础之上，再设计一个孙子类 <code>BufferedFileInputStream</code>，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 <code>InputStream</code> 的子类有很多。我们需要给每一个 <code>InputStream</code> 的子类，再继续派生支持缓存读取的子类。</p>
<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 <code>DataInputStream</code> 类，支持按照基本数据类型（<code>int</code>、<code>boolean</code>、<code>long</code> 等）来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(in);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> din.readInt();</span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 <code>DataFileInputStream</code>、<code>DataPipedInputStream</code> 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 <code>BufferedDataFileInputStream</code>、<code>BufferedDataPipedInputStream</code> 等 <code>n</code> 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们在第 10 节中讲的不推荐使用继承的原因。</p></div><div class="tab-pane" id="装饰器模式-2"><p>我们之前说过组合优于继承，可以解决因继承导致的类爆炸问题，上面提到的 <code>Java IO</code> 库就是使用了这种模式来解决这里的问题，大致的代码思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;mark/reset not supported&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...实现基于缓存的读数据接口...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">DataInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>通过这个例子，不能说装饰器就是简单的<strong>用组合代替继承</strong>，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>
<ol>
<li>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。比如，下面这样一段代码，我们对 <code>FileInputStream</code> 嵌套了两个装饰器类：<code>BufferedInputStream</code> 和 <code>DataInputStream</code>，让它既支持缓存读取，又支持按照基本数据类型来读取数据。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bin);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> din.readInt();</span><br></pre></td></tr></table></figure></li>
<li>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> impelements IA &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AProxy</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AProxy</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">    a.f();</span><br><span class="line">    <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADecorator</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ADecorator</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 功能增强代码</span></span><br><span class="line">    a.f();</span><br><span class="line">    <span class="comment">// 功能增强代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是在 <code>JDK</code> 的源码中，<code>BufferedInputStream</code>、<code>DataInputStream</code> 并非继承自 <code>InputStream</code>，而是另外一个叫 <code>FilterInputStream</code> 的类。是因为 <code>InputStream</code> 是一个抽象类而非接口，而且它的大部分函数（比如 <code>read()</code>、<code>available()</code>）都有默认实现，按理来说，我们只需要在 <code>BufferedInputStream</code> 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 <code>InputStream</code> 的默认实现。但实际上，这样做是行不通的。对于即便是不需要增加缓存功能的函数来说，<code>BufferedInputStream</code> 还是必须把它重新实现一遍，简单包裹对 <code>InputStream</code> 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 <code>BufferedInputStream</code> 类就无法将最终读取数据的任务，委托给传递进来的 <code>InputStream</code> 对象来完成。</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// f()函数不需要增强，只是重新调用一下InputStream in对象的f()</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    in.f();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上，<code>DataInputStream</code> 也存在跟 <code>BufferedInputStream</code> 同样的问题。为了避免代码重复，<code>Java IO</code> 抽象出了一个装饰器父类 <code>FilterInputStream</code>，代码实现如下所示。<code>InputStream</code> 的所有的装饰器类（<code>BufferedInputStream</code>、<code>DataInputStream</code>）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">FilterInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.read(b, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.skip(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.available();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span> &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> in.markSupported();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，<code>ITarget</code> 表示要转化成的接口定义。<code>Adaptee</code> 是一组不兼容 <code>ITarget</code> 接口定义的接口，<code>Adaptor</code> 将 <code>Adaptee</code> 转化成一组符合 <code>ITarget</code> 接口定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Adaptor</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fa(); <span class="comment">//委托给Adaptee</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对这两种实现方式，在实际的开发中，选择哪个使用，判断的标准主要有两个，一个是 <code>Adaptee</code> 接口的个数，另一个是 <code>Adaptee</code> 和 <code>ITarget</code> 的契合程度。</p>
<ol>
<li>如果 <code>Adaptee</code> 接口并不多，那两种实现方式都可以；</li>
<li>如果 <code>Adaptee</code> 接口很多，而且 <code>Adaptee</code> 和 <code>ITarget</code> 接口定义大部分都相同，那我们推荐使用类适配器，因为 <code>Adaptor</code> 复用父类 <code>Adaptee</code> 的接口，比起对象适配器的实现方式，<code>Adaptor</code> 的代码量要少一些；</li>
<li>如果 <code>Adaptee</code> 接口很多，而且 <code>Adaptee</code> 和 <code>ITarget</code> 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活；</li>
</ol>
<p>说完了原理和实现，讲讲适配器的应用场景。适配器模式的应用场景是接口不兼容，一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。以下是它的 <code>5</code> 中使用场景：</p>
<div class="tabs" id="适配器"><ul class="nav-tabs"><li class="tab active"><a href="#适配器-1">1. 封装有缺陷的接口设计</a></li><li class="tab"><a href="#适配器-2">2. 统一多个类的接口设计</a></li><li class="tab"><a href="#适配器-3">3. 替换依赖的外部系统</a></li><li class="tab"><a href="#适配器-4">4. 兼容老版本接口</a></li><li class="tab"><a href="#适配器-5">5. 适配不同格式的数据</a></li></ul><div class="tab-content"><div class="tab-pane active" id="适配器-1"><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> &#123; <span class="comment">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction1</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uglyNamingFunction2</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tooManyParamsFunction3</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB, ...)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowPerformanceFunction4</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fucntion3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDAdaptor</span> <span class="keyword">extends</span> <span class="title class_">CD</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...reimplement it...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="适配器-2"><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。</p>
<p>举个例子，假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilter</span> &#123; <span class="comment">// A敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSexyWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterPoliticalWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSensitiveWordsFilter</span>  &#123; <span class="comment">// B敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSensitiveWordsFilter</span> &#123; <span class="comment">// C敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text, String mask)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ASensitiveWordsFilter</span> <span class="variable">aFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BSensitiveWordsFilter</span> <span class="variable">bFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">CSensitiveWordsFilter</span> <span class="variable">cFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSensitiveWordsFilter</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText = bFilter.filter(maskedText);</span><br><span class="line">    maskedText = cFilter.filter(maskedText, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行改造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISensitiveWordsFilter</span> &#123; <span class="comment">// 统一接口定义</span></span><br><span class="line">  String <span class="title function_">filter</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilterAdaptor</span> <span class="keyword">implements</span> <span class="title class_">ISensitiveWordsFilter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ASensitiveWordsFilter aFilter;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class="line"><span class="comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSensitiveWordsFilter</span><span class="params">(ISensitiveWordsFilter filter)</span> &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> text;</span><br><span class="line">    <span class="keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText = filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="适配器-3"><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 外部系统A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在我们的项目中，外部系统A的使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部系统A替换成外部系统B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BAdaptor</span> implemnts IA &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BAdaptor</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class="line"><span class="comment">// 只需要将BAdaptor如下注入到Demo即可。</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">BAdaptor</span>(<span class="keyword">new</span> <span class="title class_">B</span>()));</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="适配器-4"><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 <code>deprecated</code>，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。</p>
<p><code>JDK1.0</code> 中包含一个遍历集合容器的类 <code>Enumeration</code>。<code>JDK2.0</code> 对这个类进行了重构，将它改名为 <code>Iterator</code> 类，并且对它的代码实现做了优化。但是考虑到如果将 <code>Enumeration</code> 直接从 <code>JDK2.0</code> 中删除，那使用 <code>JDK1.0</code> 的项目如果切换到 <code>JDK2.0</code>，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 <code>Enumeration</code> 的地方，都修改为使用 <code>Iterator</code> 才行。</p>
<p>为了做到兼容使用低版本 <code>JDK</code> 的老代码，我们可以暂时保留 <code>Enumeration</code> 类，并将其实现替换为直接调用 <code>Itertor</code>。代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Emueration <span class="title function_">emumeration</span><span class="params">(<span class="keyword">final</span> Collection c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Enumeration</span>() &#123;</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMoreElments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="适配器-5"><p>适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，<code>Java</code> 中的 <code>Arrays.asList()</code> 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Moe&quot;</span>, <span class="string">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>门面模式，也叫外观模式，原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。</p>
<p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 <code>n</code> 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。相反，如果接口粒度设计得太大，一个接口返回 <code>n</code> 多数据，要做 <code>n</code> 多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀，门面模式就是用来解决这种问题。</p>
<p>门面模式总结下来有几个应用场景：</p>
<div class="tabs" id="门面模式"><ul class="nav-tabs"><li class="tab active"><a href="#门面模式-1">1. 解决易用性问题</a></li><li class="tab"><a href="#门面模式-2">2. 解决性能问题</a></li><li class="tab"><a href="#门面模式-3">3. 解决分布式事务问题</a></li></ul><div class="tab-content"><div class="tab-pane active" id="门面模式-1"><p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，<code>Linux</code> 系统调用函数就可以看作一种“门面”。它是 <code>Linux</code> 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 <code>Linux</code> <code>内核调用。再比如，Linux</code> 的 <code>Shell</code> 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。我们前面也多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p></div><div class="tab-pane" id="门面模式-2"><p>此外利用门面模式还可以解决性能问题。假设有一个系统 <code>A</code>，提供了 <code>a、b、c、d</code> 四个接口。系统 <code>B</code> 完成某个业务功能，需要调用 <code>A</code> 系统的 <code>a、b、d</code> 接口。利用门面模式，我们提供一个包裹 <code>a、b、d</code> 接口调用的门面接口 <code>x</code>，给系统 <code>B</code> 直接使用。</p>
<p>但是让系统 <code>B</code> 直接调用 <code>a、b、d</code> 感觉也没有太大问题，为什么还要提供一个包裹 <code>a、b、d</code> 的接口 <code>x</code> 呢？关于这个问题，通过一个具体的例子来解释一下。</p>
<p>假设我们刚刚提到的系统 <code>A</code> 是一个后端服务器，系统 <code>B</code> 是 <code>App</code> 客户端。<code>App</code> 客户端通过后端服务器提供的接口来获取数据。我们知道，<code>App</code> 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 <code>App</code> 的响应速度，我们要尽量减少 <code>App</code> 与服务器之间的网络通信次数。</p>
<p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 <code>a、b、d</code> 三个接口，因自身业务的特点，不支持并发调用这三个接口。如果我们现在发现 <code>App</code> 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 <code>a、b、d</code> 三个接口调用的接口 <code>x</code>。<code>App</code> 客户端调用一次接口 <code>x</code>，来获取到所有想要的数据，将网络通信的次数从 <code>3</code> 次减少到 <code>1</code> 次，也就提高了 <code>App</code> 的响应速度。</p>
<p>上面是一个简单的应用场景，从代码实现的角度来看，该如何组织门面接口和非门面接口？如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</p></div><div class="tab-pane" id="门面模式-3"><p>同样举个例子，在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 <code>User</code> 表中），还会给用户创建一个钱包（在数据库的 <code>Wallet</code> 表中）。</p>
<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p>
<p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 <code>Java</code> 语言的话），在一个事务中，执行创建用户和创建钱包这两个 <code>SQL</code> 操作。这就要求两个 <code>SQL</code> 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 <code>SQL</code> 操作。</p></div></div></div>

<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>组合模式（<code>Composite Design Pattern</code>）跟之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的<strong>数据</strong>，可以简单理解为一组对象集合。</p>
<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>
<ol>
<li>动态地添加、删除某个目录下的子目录或文件；</li>
<li>统计指定目录下的文件个数；</li>
<li>统计指定目录下的文件总大小；</li>
</ol>
<div class="tabs" id="组合模式"><ul class="nav-tabs"><li class="tab active"><a href="#组合模式-1">基础实现</a></li><li class="tab"><a href="#组合模式-2">组合模式</a></li><li class="tab"><a href="#组合模式-3">示例</a></li></ul><div class="tab-content"><div class="tab-pane active" id="组合模式-1"><p>下面给出这个类的骨架代码，在下面的代码实现中，我们把文件和目录统一用 <code>FileSystemNode</code> 类来表示，并且通过 <code>isFile</code> 属性来区分。</p>
<details class="note warning"><summary><p>示例</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isFile;</span><br><span class="line">  <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileSystemNode</span><span class="params">(String path, <span class="type">boolean</span> isFile)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">    <span class="built_in">this</span>.isFile = isFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subNodes.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>想要补全其中的 <code>countNumOfFiles()</code> 和 <code>countSizeOfFiles()</code> 这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回 <code>1</code>）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p>
<details class="note warning"><summary><p>实现示例</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">numOfFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">    numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numOfFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> file.length();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">sizeofFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">    sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为 <code>File</code> 和 <code>Directory</code> 两个类。</p></div><div class="tab-pane" id="组合模式-2"><p>按照前面的设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileSystemNode</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    java.io.<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Directory</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sizeofFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subNodes.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div><div class="tab-pane" id="组合模式-3"><p>如何用上节的实现来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * /</span></span><br><span class="line"><span class="comment">     * /wz/</span></span><br><span class="line"><span class="comment">     * /wz/a.txt</span></span><br><span class="line"><span class="comment">     * /wz/b.txt</span></span><br><span class="line"><span class="comment">     * /wz/movies/</span></span><br><span class="line"><span class="comment">     * /wz/movies/c.avi</span></span><br><span class="line"><span class="comment">     * /xzg/</span></span><br><span class="line"><span class="comment">     * /xzg/docs/</span></span><br><span class="line"><span class="comment">     * /xzg/docs/d.txt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">fileSystemTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_wz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/wz/&quot;</span>);</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_xzg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/xzg/&quot;</span>);</span><br><span class="line">    fileSystemTree.addSubNode(node_wz);</span><br><span class="line">    fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">node_wz_a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/wz/a.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">node_wz_b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/wz/b.txt&quot;</span>);</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_wz_movies</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/wz/movies/&quot;</span>);</span><br><span class="line">    node_wz.addSubNode(node_wz_a);</span><br><span class="line">    node_wz.addSubNode(node_wz_b);</span><br><span class="line">    node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">node_wz_movies_c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/wz/movies/c.avi&quot;</span>);</span><br><span class="line">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_xzg_docs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/xzg/docs/&quot;</span>);</span><br><span class="line">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">node_xzg_docs_d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/xzg/docs/d.txt&quot;</span>);</span><br><span class="line">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());</span><br><span class="line">    System.out.println(<span class="string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p>
<p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p></div></div></div>

<p>另外举个例子，假设我们在开发一个 <code>OA</code> 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p>
<p>代码实现如下，<code>HumanResource</code> 是部门类（<code>Department</code>）和员工类（<code>Employee</code>）抽象出来的父类，为的是能统一薪资的处理逻辑。<code>Demo</code> 中的代码负责从数据库中读取数据并在内存中构建组织架构图。</p>
<details class="note success"><summary><p>点击查看实现</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HumanResource</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HumanResource</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calculateSalary</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">HumanResource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">long</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id);</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">HumanResource</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">totalSalary</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (HumanResource hr : subNodes) &#123;</span><br><span class="line">      totalSalary += hr.calculateSalary();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.salary = totalSalary;</span><br><span class="line">    <span class="keyword">return</span> totalSalary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(HumanResource hr)</span> &#123;</span><br><span class="line">    subNodes.add(hr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建组织架构的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORGANIZATION_ROOT_ID</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">  <span class="keyword">private</span> DepartmentRepo departmentRepo; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> EmployeeRepo employeeRepo; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildOrganization</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Department</span> <span class="variable">rootDepartment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(ORGANIZATION_ROOT_ID);</span><br><span class="line">    buildOrganization(rootDepartment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildOrganization</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());</span><br><span class="line">    <span class="keyword">for</span> (Long subDepartmentId : subDepartmentIds) &#123;</span><br><span class="line">      <span class="type">Department</span> <span class="variable">subDepartment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(subDepartmentId);</span><br><span class="line">      department.addSubNode(subDepartment);</span><br><span class="line">      buildOrganization(subDepartment);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());</span><br><span class="line">    <span class="keyword">for</span> (Long employeeId : employeeIds) &#123;</span><br><span class="line">      <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> employeeRepo.getEmployeeSalary(employeeId);</span><br><span class="line">      department.addSubNode(<span class="keyword">new</span> <span class="title class_">Employee</span>(employeeId, salary));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p>
<p>定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 <code>set()</code> 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p>
<p>举个例子，假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，<code>ChessPiece</code> 类表示棋子，<code>ChessBoard</code> 类表示一个棋局，里面保存了象棋中 <code>30</code> 个棋子的信息。</p>
<div class="tabs" id="享元模式"><ul class="nav-tabs"><li class="tab active"><a href="#享元模式-1">初步实现</a></li><li class="tab"><a href="#享元模式-2">享元模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="享元模式-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPiece</span> &#123;<span class="comment">//棋子</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionX;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPiece</span><span class="params">(<span class="type">int</span> id, String text, Color color, <span class="type">int</span> positionX, <span class="type">int</span> positionY)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="built_in">this</span>.positionX = positionX;</span><br><span class="line">    <span class="built_in">this</span>.positionY = positionX;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他属性和getter/setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;<span class="comment">//棋局</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    chessPieces.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(<span class="number">2</span>,<span class="string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> chessPieceId, <span class="type">int</span> toPositionX, <span class="type">int</span> toPositionY)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 <code>ChessBoard</code> 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。</p></div><div class="tab-pane" id="享元模式-2"><p>在使用享元模式之前，记录 <code>1</code> 万个棋局，我们要创建 <code>30</code> 万（<code>30*1</code> 万）个棋子的 <code>ChessPieceUnit</code> 对象。利用享元模式，我们只需要创建 <code>30</code> 个享元对象供所有棋局共享使用即可，将大大节省内存。</p>
<p>刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 <code>id</code>、<code>text</code>、<code>color</code> 都是相同的，唯独 <code>positionX</code>、<code>positionY</code> 不同。实际上，我们可以将棋子的 <code>id</code>、<code>text</code>、<code>color</code> 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPieceUnit</span><span class="params">(<span class="type">int</span> id, String text, Color color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他属性和getter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnitFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    pieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">2</span>,<span class="string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title function_">getChessPiece</span><span class="params">(<span class="type">int</span> chessPieceId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionX;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPiece</span><span class="params">(ChessPieceUnit unit, <span class="type">int</span> positionX, <span class="type">int</span> positionY)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chessPieceUnit = unit;</span><br><span class="line">    <span class="built_in">this</span>.positionX = positionX;</span><br><span class="line">    <span class="built_in">this</span>.positionY = positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">1</span>), <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">2</span>), <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> chessPieceId, <span class="type">int</span> toPositionX, <span class="type">int</span> toPositionY)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现中，我们利用工厂类来缓存 <code>ChessPieceUnit</code> 信息（也就是 <code>id</code>、<code>text</code>、<code>color</code>）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 <code>ChessBoard</code> 对象共享这 <code>30</code> 个 <code>ChessPieceUnit</code> 对象（因为象棋中只有 <code>30</code> 个棋子）。</p></div></div></div>

<p>另外一个示例应用场景，文本编辑器，可以把这里提到的文本编辑器想象成 <code>Office</code> 的 <code>Wor</code>d。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：</p>
<div class="tabs" id="享元模式2"><ul class="nav-tabs"><li class="tab active"><a href="#享元模式2-1">初步实现</a></li><li class="tab"><a href="#享元模式2-2">享元模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="享元模式2-1"><div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Character</span> &#123;<span class="comment">//文字</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Font font;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Character</span><span class="params">(<span class="type">char</span> c, Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.c = c;</span><br><span class="line">    <span class="built_in">this</span>.font = font;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">    <span class="built_in">this</span>.colorRGB = colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendCharacter</span><span class="params">(<span class="type">char</span> c, Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c, font, size, colorRGB);</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>在文本编辑器中，我们每敲一个文字，都会调用 <code>Editor</code> 类中的 a<code>ppendCharacter()</code> 方法，创建一个新的 <code>Character</code> 对象，保存到 <code>chars</code> 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 <code>Character</code> 对象。</p></div><div class="tab-pane" id="享元模式2-2"><p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterStyle</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Font font;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CharacterStyle</span><span class="params">(Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.font = font;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">    <span class="built_in">this</span>.colorRGB = colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">CharacterStyle</span> <span class="variable">otherStyle</span> <span class="operator">=</span> (CharacterStyle) o;</span><br><span class="line">    <span class="keyword">return</span> font.equals(otherStyle.font)</span><br><span class="line">            &amp;&amp; size == otherStyle.size</span><br><span class="line">            &amp;&amp; colorRGB == otherStyle.colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterStyleFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> CharacterStyle <span class="title function_">getStyle</span><span class="params">(Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="type">CharacterStyle</span> <span class="variable">newStyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterStyle</span>(font, size, colorRGB);</span><br><span class="line">    <span class="keyword">for</span> (CharacterStyle style : styles) &#123;</span><br><span class="line">      <span class="keyword">if</span> (style.equals(newStyle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    styles.add(newStyle);</span><br><span class="line">    <span class="keyword">return</span> newStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">private</span> CharacterStyle style;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Character</span><span class="params">(<span class="type">char</span> c, CharacterStyle style)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.c = c;</span><br><span class="line">    <span class="built_in">this</span>.style = style;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendCharacter</span><span class="params">(<span class="type">char</span> c, Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c, CharacterStyleFactory.getStyle(font, size, colorRGB));</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div></div></div>

<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p>行为型设计模式几乎占了 <code>23</code> 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>观察者模式（<code>Observer Design Pattern</code>）也被称为发布订阅模式（<code>Publish-Subscribe Design Pattern</code>），它的意思是在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p>一般情况下，被依赖的对象叫作被观察者（<code>Observable</code>），依赖的对象叫作观察者（<code>Observer</code>）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：<code>Subject-Observer</code>、<code>Publisher-Subscriber</code>、<code>Producer-Consumer</code>、<code>EventEmitter-EventListener</code>、<code>Dispatcher-Listener</code>。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>
<p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，现在，我们先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverOne</span>());</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverTwo</span>());</span><br><span class="line">    subject.notifyObservers(<span class="keyword">new</span> <span class="title class_">Message</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上，上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 <code>register</code> 函数还可以叫作 <code>attach</code>，<code>remove</code> 函数还可以叫作 <code>detach </code>等等。不过，万变不离其宗，设计思路都是差不多的。</p>
<p>举个实际的应用场景，假设我们在开发一个 <code>P2P</code> 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p>
<p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改 <code>register()</code> 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那 <code>register()</code> 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p>
<p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegNotificationObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, <span class="string">&quot;Welcome...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性设置好，之后也不可能动态的修改</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，<code>UserController</code> 类的 <code>register()</code> 函数完全不需要修改，只需要再添加一个实现了<code> RegObserver</code> 接口的类，并且通过 <code>setRegObservers()</code> 函数将它注册到 <code>UserController</code> 类中即可。</p>
<p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改 <code>RegPromotionObserver</code> 类中 <code>handleRegSuccess()</code> 函数的代码，这还是违反开闭原则呀？你说得没错，不过，相对于 <code>register()</code> 函数来说，<code>handleRegSuccess()</code> 函数的逻辑要简单很多，修改更不容易出错，引入 <code>bug</code> 的风险更低。</p>
<p>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>模板模式，全称是模板方法设计模式，英文是 <code>Template Method Design Pattern</code>，主要是用来解决复用和扩展两个问题，它的定义是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p>
<p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。<code>templateMethod()</code> 函数定义为 <code>final</code>，是为了避免子类重写它。<code>method1()</code> 和 <code>method2()</code> 定义为 <code>abstract</code>，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method1();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method2();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<p>下面分别来讲模板模式的量大作用：复用和扩展。</p>
<div class="tabs" id="模板模式"><ul class="nav-tabs"><li class="tab active"><a href="#模板模式-1">复用</a></li><li class="tab"><a href="#模板模式-2">扩展</a></li></ul><div class="tab-content"><div class="tab-pane active" id="模板模式-1"><p>模板模式第一的作用是流程复用，模板模式把一个算法中不变的流程抽象到父类的模板方法 <code>templateMethod()</code> 中，将可变的部分 <code>method1()</code>、<code>method2()</code> 留给子类 <code>ContreteClass1</code> 和 <code>ContreteClass2</code> 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体会一下。</p>
<p><code>Java IO</code> 类库中，有很多类的设计用到了模板模式，比如 <code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code>。我们拿 <code>InputStream</code> 来举例说明一下。我把 <code>InputStream</code> 部分相关代码贴在了下面。在代码中，<code>read()</code> 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 <code>read()</code>，只是参数跟模板方法不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> read();</span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] = (<span class="type">byte</span>)c;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">        c = read();</span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off + i] = (<span class="type">byte</span>)c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteArrayInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="模板模式-2"><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过 <code>Junit TestCase</code>、<code>Java Servlet</code> 两个例子来解释一下。</p>
<ol>
<li><p><code>Java Servlet</code><br> 对于 <code>Java Web </code>项目开发来说，常用的开发框架是 <code>SpringMVC</code>。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发 <code>Web</code> 项目，必然会用到 <code>Servlet</code>。实际上，使用比较底层的 <code>Servlet</code> 来开发 <code>Web</code> 项目也不难。我们只需要定义一个继承 <code>HttpServlet</code> 的类，并且重写其中的 <code>doGet()</code> 或 <code>doPost()</code> 方法，来分别处理 <code>get</code> 和 <code>post</code> 请求。具体的代码示例如下所示：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 除此之外，我们还需要在配置文件 <code>web.xml</code> 中做如下配置。<code>Tomcat</code>、<code>Jetty</code> 等 <code>Servlet</code> 容器在启动的时候，会自动加载这个配置文件中的 <code>URL</code> 和 <code>Servlet</code> 之间的映射关系。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 当我们在浏览器中输入网址（比如，<code>http://127.0.0.1:8080/hello</code> ）的时候，<code>Servlet</code> 容器会接收到相应的请求，并且根据 <code>URL</code> 和 <code>Servlet</code> 之间的映射关系，找到相应的 <code>Servlet（HelloServlet）</code>，然后执行它的 <code>service()</code> 方法。<code>service()</code> 方法定义在父类 <code>HttpServlet</code> 中，它会调用 <code>doGet()</code> 或 <code>doPost()</code> 方法，然后输出数据（<code>Hello world</code>）到网页。</p>
<p> 而<code>HttpServlet</code> 的 <code>service()</code> 方法就是一个模板方法，它实现了整个 <code>HTTP</code> 请求的执行流程，<code>doGet()</code>、<code>doPost()</code> 是模板中可以由子类来定制的部分。实际上，这就相当于 <code>Servlet</code> 框架提供了一个扩展点（<code>doGet()</code>、<code>doPost()</code> 方法），让框架用户在不用修改 <code>Servlet</code> 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>
<p> 接下来是它的实现，感兴趣的可以点开看：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">            res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JUnit TestCase</code><br> 跟 <code>Java Servlet</code> 类似，<code>JUnit</code> 框架也通过模板模式提供了一些功能扩展点（<code>setUp()</code>、t<code>earDown()</code> 等），让框架用户可以在这些扩展点上扩展功能。在使用 <code>JUnit</code> 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 <code>TestCase</code> 类。在 <code>TestCase</code> 类中，<code>runBare()</code> 函数是模板方法，它定义了执行测试用例的整体流程：先执行 <code>setUp()</code> 做些准备工作，然后执行 <code>runTest()</code> 运行真正的测试代码，最后执行 <code>tearDown()</code> 做扫尾工作。<code>TestCase</code> 类的具体代码如下所示。尽管 <code>setUp()</code>、<code>tearDown()</code> 并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模板模式的定义。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> <span class="keyword">extends</span> <span class="title class_">Assert</span> <span class="keyword">implements</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runBare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    setUp();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runTest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable running) &#123;</span><br><span class="line">      exception = running;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        tearDown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable tearingDown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>) exception = tearingDown;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets up the fixture, for example, open a network connection.</span></span><br><span class="line"><span class="comment">  * This method is called before a test is executed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Tears down the fixture, for example, close a network connection.</span></span><br><span class="line"><span class="comment">  * This method is called after a test is executed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></div></div></div>

<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式，英文全称是 <code>Strategy Design Pattern</code>，它是这样定义的：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p>
<div class="tabs" id="策略模式"><ul class="nav-tabs"><li class="tab active"><a href="#策略模式-1">策略定义</a></li><li class="tab"><a href="#策略模式-2">策略创建</a></li><li class="tab"><a href="#策略模式-3">策略使用</a></li></ul><div class="tab-content"><div class="tab-pane active" id="策略模式-1"><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//具体的算法...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//具体的算法...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="策略模式-2"><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（<code>type</code>）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 <code>type</code> 创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">    strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 <code>getStrategy()</code> 的时候，都创建一个新的策略对象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="策略模式-3"><p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。接下来，我们通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserCache</span><span class="params">(EvictionStrategy eviction)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eviction = eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LruEvictionStrategy</span>();</span><br><span class="line">    <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h5 id="使用策略模式避免分支判断"><a href="#使用策略模式避免分支判断" class="headerlink" title="使用策略模式避免分支判断"></a>使用策略模式避免分支判断</h5><p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p>
<p>我们先通过一个例子来看下，<code>if-else</code> 或 <code>switch-case</code> 分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">discount</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">calDiscount</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>());</span><br><span class="line">    strategies.put(OrderType.GROUPON, <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">    <span class="type">DiscountStrategy</span> <span class="variable">discountStrategy</span> <span class="operator">=</span> DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>重构之后的代码就没有了 <code>if-else</code> 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 <code>type</code> 直接从 <code>Map</code> 中获取对应的策略，从而避免 <code>if-else</code> 分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据 <code>type</code> 查表（代码中的 <code>strategies</code> 就是表）替代根据 <code>type</code> 分支判断。但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Type should not be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><p>职责链模式，英文翻译是 <code>Chain Of Responsibility Design Pattern</code>，它的定义式：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<p>详细点说就是，在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 <code>A</code> 处理器处理，然后再把请求传递给 <code>B</code> 处理器，<code>B</code> 处理器处理完后再传递给 <code>C</code> 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p>
<p>下面的示例中，<code>IHandler</code> 是 <code>Handler</code> 的通用接口，<code>HandlerChain</code> 使用数组保存了所有 <code>Handler</code>，并且需要在 <code>handle()</code> 函数中，依次调用每个处理器的 <code>handle()</code> 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">implements</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">implements</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(IHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> handler.handle();</span><br><span class="line">      <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>GoF</code> 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。</p>
<p>职责链模式通常应用于一系列过滤器出现的地方，例如，对于支持 <code>UGC</code>（<code>User Generated Content</code>，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。</p>
<p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 <code>***</code> 替换敏感词）之后再发布。第一种处理方式符合 <code>GoF</code> 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p>
<p>下面是第一种方案的实现，如果哪一个 <code>Handler</code> 返回不合法，就直接结束流程。而第二种方案，需要依次应用每个 <code>Handler</code>，不会出现中途终止的情况。</p>
<div class="note success"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">    <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">      <span class="comment">// 不发表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 发表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性，这里应用职责链模式也不例外。为了解决这个问题，下面的方案何尝不可，只是不号扩展：</p>
<details class="note warning"><summary><p>错误示例</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!filterSexyWord(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filterAdsWord(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filterPoliticalWord(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">filterSexyWord</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">filterAdsWord</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">filterPoliticalWord</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>对比来看，职责链模式将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 <code>SensitiveWordFilter</code> 类，让 <code>SensitiveWordFilter</code> 类的代码不会过多，过复杂。</p>
<p>其次，当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的代码实现方式，我们需要修改 <code>SensitiveWordFilter</code> 的代码，违反开闭原则。不过，这样的修改还算比较集中，也是可以接受的。而职责链模式的实现方式更加优雅，只需要新添加一个 <code>Filter</code> 类，并且通过 <code>addFilter()</code> 函数将它添加到 <code>FilterChain</code> 中即可，其他代码完全不需要修改。</p>
<p>职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。例如：<code>Servlet Filter</code>、<code>Spring Interceptor</code>。</p>
<div class="tabs" id="职责链模式"><ul class="nav-tabs"><li class="tab active"><a href="#职责链模式-1">Servlet Filter</a></li><li class="tab"><a href="#职责链模式-2">Spring Interceptor</a></li></ul><div class="tab-content"><div class="tab-pane active" id="职责链模式-1"><p><code>Servlet Filter</code> 是 <code>Java Servlet</code> 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 <code>HTTP</code> 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 <code>Servlet</code> 规范的一部分，所以，只要是支持 <code>Servlet</code> 的 <code>Web</code> 容器（比如，<code>Tomcat</code>、<code>Jetty</code> 等），都支持过滤器功能。工作原理图如下所示：</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/Chain-Of-Responsibility-Design-Pattern.webp" class="">

<p>在实际项目中，添加一个过滤器，我们只需要定义一个实现 <code>javax.servlet.Filter</code> 接口的过滤器类，并且将它配置在 <code>web.xml</code> 配置文件中。<code>Web</code> 容器启动的时候，会读取 <code>web.xml</code> 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 <code>Servlet</code> 来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">// 在创建Filter时自动调用，</span></span><br><span class="line">    <span class="comment">// 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截客户端发送来的请求.&quot;</span>);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截发送给客户端的响应.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在销毁Filter时自动调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在web.xml配置文件中如下配置：</span></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;logFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例代码中，我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现 <code>javax.servlet.Filter</code> 的类，再改改配置就搞定了，完全符合开闭原则。<code>Servlet Filter</code> 能做到这点，其实就是应用了职责链模式。</p>
<p>前面讲过，<code>Servlet</code> 只是一个规范，并不包含具体的实现，所以，<code>Servlet</code> 中的 <code>FilterChain</code> 只是一个接口定义。具体的实现类由遵从 <code>Servlet</code> 规范的 <code>Web</code> 容器来提供，比如，<code>ApplicationFilterChain</code> 类就是 <code>Tomcat</code> 提供的 <code>FilterChain</code> 的实现类，源码如下所示(为了让代码更易读懂，对代码进行了简化，只保留了跟设计思路相关的代码片段)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//当前执行到了哪个filter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n; <span class="comment">//filter的个数</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationFilterConfig[] filters;</span><br><span class="line">  <span class="keyword">private</span> Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">      <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">      <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationFilterConfig filter:filters)</span><br><span class="line">      <span class="keyword">if</span> (filter==filterConfig)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == filters.length) &#123;<span class="comment">//扩容</span></span><br><span class="line">      ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">      filters = newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] = filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="职责链模式-2"><p><code>Spring Interceptor</code>，翻译成中文就是拦截器，用来实现对 <code>HTTP</code> 请求进行拦截处理。它和 <code>Servlet Filter</code> 不同之处在于，<code>Servlet Filter</code> 是 <code>Servlet</code> 规范的一部分，实现依赖于 <code>Web</code> 容器。<code>Spring Interceptor</code> 是 <code>Spring MVC</code> 框架的一部分，由 <code>Spring MVC</code> 框架来提供实现。客户端发送的请求，会先经过 <code>Servlet Filter</code>，然后再经过 <code>Spring Interceptor</code>，最后到达具体的业务代码中，原理具体如下图所示：</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/spring-interceptor.webp" class="">

<p>下面的示例，简单说明 <code>Spring Interceptor</code> 如何使用，<code>LogInterceptor</code> 实现的功能跟刚才的 <code>LogFilter</code> 完全相同，只是实现方式上稍有区别。<code>LogFilter</code> 对请求和响应的拦截是在 <code>doFilter()</code> 一个函数中实现的，而 <code>LogInterceptor</code> 对请求的拦截在 <code>preHandle()</code> 中实现，对响应的拦截在<code> postHandle()</code> 中实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截客户端发送来的请求.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 继续后续的处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截发送给客户端的响应.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这里总是被执行.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Spring MVC配置文件中配置interceptors</span></span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path=<span class="string">&quot;/*&quot;</span>/&gt;</span><br><span class="line">       &lt;bean class=<span class="string">&quot;com.xzg.cd.LogInterceptor&quot;</span> /&gt;</span><br><span class="line">   &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<p><code>Spring Interceptor</code> 底层也是基于职责链模式实现的。其中，<code>HandlerExecutionChain</code> 类是职责链模式中的处理器链。它的实现相较于 <code>Tomcat</code> 中的 <code>ApplicationFilterChain</code> 来说，逻辑更加清晰，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。<code>HandlerExecutionChain</code> 的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"> <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">  initInterceptorList().add(interceptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">    <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">    <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">     triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">    interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span><br><span class="line">   <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">     logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p>
<p>开始之前，首先说明下什么是有限状态机，英文是 <code>Finite State Machine</code>，缩写为 <code>FSM</code>，简称为状态机。状态机有 <code>3</code> 个组成部分：状态（<code>State</code>）、事件（<code>Event</code>）、动作（<code>Action</code>）。其中，事件也称为转移条件（<code>Transition Condition</code>）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<p>在游戏<strong>超级马里奥</strong>中，马里奥可以变身为多种形态，比如小马里奥（<code>Small Mario</code>）、超级马里奥（<code>Super Mario</code>）、火焰马里奥（<code>Fire Mario</code>）、斗篷马里奥（<code>Cape Mario</code>）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 <code>100</code> 积分。</p>
<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 <code>100</code> 积分）。</p>
<p>为了方便接下来的讲解，对游戏背景做了简化，只保留了部分状态和事件。简化之后的状态转移如下图所示：</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/super-mario.webp" class="">

<p>下面是实现这种状态机的代码骨架：</p>
<details class="note success"><summary><p>点击展开</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  SMALL(<span class="number">0</span>),</span><br><span class="line">  SUPER(<span class="number">1</span>),</span><br><span class="line">  FIRE(<span class="number">2</span>),</span><br><span class="line">  CAPE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">State</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MarioStateMachine</span> <span class="variable">mario</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarioStateMachine</span>();</span><br><span class="line">    mario.obtainMushRoom();</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> mario.getScore();</span><br><span class="line">    <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> mario.getCurrentState();</span><br><span class="line">    System.out.println(<span class="string">&quot;mario score: &quot;</span> + score + <span class="string">&quot;; state: &quot;</span> + state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>实现状态机这里提供三种方式，分支逻辑法，查表法和状态模式。</p>
<div class="tabs" id="状态模式"><ul class="nav-tabs"><li class="tab"><a href="#状态模式-1">分支逻辑法</a></li><li class="tab"><a href="#状态模式-2">查表法</a></li><li class="tab active"><a href="#状态模式-3">状态模式</a></li></ul><div class="tab-content"><div class="tab-pane" id="状态模式-1"><p>其中，分支逻辑法最简单直接，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 <code>if-else</code> 或 <code>switch-case</code> 分支判断逻辑，甚至是嵌套的分支判断逻辑。</p>
<p>按照这个实现思路，补全下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SUPER;</span><br><span class="line">      <span class="built_in">this</span>.score += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.CAPE;</span><br><span class="line">      <span class="built_in">this</span>.score += <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.FIRE;</span><br><span class="line">      <span class="built_in">this</span>.score += <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="built_in">this</span>.score -= <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="built_in">this</span>.score -= <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="built_in">this</span>.score -= <span class="number">300</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 <code>if-else</code> 或者 <code>switch-case</code> 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 <code>bug</code>。</p></div><div class="tab-pane" id="状态模式-2"><p>前一种方法有点类似 <code>hard code</code>，对于复杂的状态机来说不适用，而状态机的第二种实现方式查表法，就更加合适了。接下来，我们就一块儿来看下，如何利用查表法来补全骨架代码。</p>
<p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/state-patttern-find-table.webp" class="">

<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 <code>transitionTable</code> 和 <code>actionTable</code> 两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  GOT_MUSHROOM(<span class="number">0</span>),</span><br><span class="line">  GOT_CAPE(<span class="number">1</span>),</span><br><span class="line">  GOT_FIRE(<span class="number">2</span>),</span><br><span class="line">  MET_MONSTER(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Event</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] actionTable = &#123;</span><br><span class="line">          &#123;+<span class="number">100</span>, +<span class="number">200</span>, +<span class="number">300</span>, +<span class="number">0</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">200</span>, +<span class="number">300</span>, -<span class="number">100</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">200</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">stateValue</span> <span class="operator">=</span> currentState.getValue();</span><br><span class="line">    <span class="type">int</span> <span class="variable">eventValue</span> <span class="operator">=</span> event.getValue();</span><br><span class="line">    <span class="built_in">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class="line">    <span class="built_in">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane active" id="状态模式-3"><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，用一个 <code>int</code> 类型的二维数组 <code>actionTable</code> 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p>
<p>虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们可以使用状态模式来解决。</p>
<p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。我们还是结合代码来理解这句话。</p>
<p>利用状态模式，我们来补全 <code>MarioStateMachine</code> 类，补全后的代码如下所示。其中，<code>IMario</code> 是状态的接口，定义了所有的事件。<code>SmallMario</code>、<code>SuperMario</code>、<code>CapeMario</code>、<code>FireMario</code> 是 <code>IMario</code> 接口的实现类，分别对应状态机中的 <code>4</code> 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 <code>MarioStateMachine</code> 类中，现在，这些代码逻辑被分散到了这 <code>4</code> 个状态类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMario</span> &#123; <span class="comment">//所有状态类的接口</span></span><br><span class="line">  State <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//以下是定义的事件</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SmallMario</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">SuperMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">CapeMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">FireMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SuperMario</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">CapeMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">FireMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">SmallMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略CapeMario、FireMario类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> IMario currentState; <span class="comment">// 不再使用枚举来表示状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = <span class="keyword">new</span> <span class="title class_">SmallMario</span>(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(IMario currentState)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState = currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现不难看懂，我只强调其中的一点，即 <code>MarioStateMachine</code> 和各个状态类之间是双向依赖关系。<code>MarioStateMachine</code> 依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖 <code>MarioStateMachine</code> 呢？这是因为，各个状态类需要更新 <code>MarioStateMachine</code> 中的两个变量，<code>score</code> 和 <code>currentState</code>。</p>
<p>实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递 <code>MarioStateMachine</code> 了，而状态类又要依赖 <code>MarioStateMachine</code>，那该如何解决这个问题呢？</p>
<p>在这里，我们可以通过函数参数将 <code>MarioStateMachine</code> 传递进状态类。根据这个设计思路，我们对上面的代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  State <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SmallMario</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmallMario</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SmallMario</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SmallMario <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(SuperMario.getInstance());</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(CapeMario.getInstance());</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(FireMario.getInstance());</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略SuperMario、CapeMario、FireMario类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> IMario currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = SmallMario.getInstance();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainMushRoom(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainCape(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainFireFlower(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.meetMonster(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(IMario currentState)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState = currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p></div></div></div>

<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>迭代器模式（<code>Iterator Design Pattern</code>），也叫作游标模式（<code>Cursor Design Pattern</code>）。它用来遍历集合对象。不过，很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开发，我们直接使用即可，很少会自己去实现一个迭代器。不过，知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类，所以，我觉得还是有必要学习一下这个模式。</p>
<p>大部分编程语言都提供了多种遍历集合的方式，比如 <code>for</code> 循环、<code>foreach</code> 循环、迭代器等。所以，本节除了讲解迭代器的原理和实现之外，还会重点讲一下，相对于其他遍历方式，利用迭代器来遍历集合的优势。</p>
<h5 id="迭代器原理和实现"><a href="#迭代器原理和实现" class="headerlink" title="迭代器原理和实现"></a>迭代器原理和实现</h5><p>迭代器用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>
<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。对于迭代器模式，画了一张简单的类图。</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/iterator-pattern-1.webp" class="">

<p>为了讲解迭代器的实现原理，从零开始开发一个迭代器。我们知道，线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应 <code>ArrayList</code> 和 <code>LinkedList</code> 两个类。除此之外，我们从两个类中抽象出公共的接口，定义为 <code>List</code> 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p>
<p>现在，我们针对 <code>ArrayList</code> 和 <code>LinkedList</code> 两个线性容器，设计实现对应的迭代器。按照之前给出的迭代器模式的类图，我们定义一个迭代器接口 <code>Iterator</code>，以及针对两种容器的具体的迭代器实现类 <code>ArrayIterator</code> 和 <code>ListIterator</code>。</p>
<p>先来看下 <code>Iterator</code> 接口的定义。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接口定义方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  E <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口定义方式二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Iterator</code> 接口有两种定义方式。在第一种定义中，<code>next()</code> 函数用来将游标后移一位元素，<code>currentItem()</code> 函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数 <code>next()</code> 中完成。第一种定义方式更加灵活一些，比如我们可以多次调用 <code>currentItem()</code> 查询当前元素，而不移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。现在，我们再来看下 <code>ArrayIterator</code> 的代码实现，具体如下所示。代码实现非常简单，不需要太多解释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != arrayList.size(); <span class="comment">//注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">currentItem</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cursor &gt;= arrayList.size()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator = <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>(names);</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 <code>iterator()</code> 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 <code>List</code> 接口中。具体的代码实现和使用示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  Iterator <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//...省略其他接口函数...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>LinkedIterator</code>，它的代码结构跟 <code>ArrayIterator</code> 完全相同，就不给出具体的代码实现了。结合刚刚的例子，我们来总结一下迭代器的设计思路。总结下来就三句话：迭代器中需要定义 <code>hasNext()</code>、<code>currentItem()</code>、<code>next()</code> 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过 <code>iterator()</code> 方法来创建迭代器。</p>
<p>画了一张类图，如下所示，实际上就是对上面那张类图的细化，你可以结合着一块看：</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/iterator-pattern-2.webp" class="">

<h5 id="在遍历的同时增删集合元素会咋样"><a href="#在遍历的同时增删集合元素会咋样" class="headerlink" title="在遍历的同时增删集合元素会咋样"></a>在遍历的同时增删集合元素会咋样</h5><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。</p>
<p>延续上一节课实现的 <code>ArrayList</code> 迭代器的例子，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayList</code> 底层对应的是数组这种数据结构，在执行完第 <code>55</code> 行代码的时候，数组中存储的是 <code>a、b、c、d</code> 四个元素，迭代器的游标 <code>cursor</code> 指向元素 <code>a</code>。当执行完第 <code>10</code> 行代码的时候，游标指向元素 <code>b</code>，到这里都没有问题。为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到第 <code>11</code> 行代码的时候，我们从数组中将元素 <code>a</code> 删除掉，<code>b、c、d</code> 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 <code>b</code>，现在变成了指向元素 <code>c</code>。原本在执行完第 <code>10</code> 行代码之后，我们还可以遍历到 <code>b、c、d</code> 三个元素，但在执行完第 <code>11</code> 行代码之后，我们只能遍历到 <code>c、d</code> 两个元素，<code>b</code> 遍历不到了。</p>
<p>不过，如果第 <code>11</code> 行代码删除的不是游标前面的元素（元素 <code>a</code>）以及游标所在位置的元素（元素 <code>b</code>），而是游标后面的元素（元素 <code>c</code> 和 <code>d</code>），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了。所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素 <code>c</code> 或 <code>d</code>），有时候就有问题（删除元素 <code>a</code> 或 <code>b</code>），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思。</p>
<p>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.add(<span class="number">0</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行完第 <code>10</code> 行代码之后，数组中包含 <code>a、b、c、d</code> 四个元素，游标指向 <code>b</code> 这个元素，已经跳过了元素 <code>a</code>。在执行完第 <code>11</code> 行代码之后，我们将 <code>x</code> 插入到下标为 <code>0</code> 的位置，<code>a、b、c、d</code> 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 <code>a</code>。元素 <code>a</code> 被游标重复指向两次，也就是说，元素 <code>a</code> 存在被重复遍历的情况。跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。</p>
<h6 id="如何应对遍历时改变集合导致的未决行为"><a href="#如何应对遍历时改变集合导致的未决行为" class="headerlink" title="如何应对遍历时改变集合导致的未决行为"></a>如何应对遍历时改变集合导致的未决行为</h6><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 <code>debug</code> 的 <code>bug</code> 就是这么产生的。有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p>
<p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？你可能会说，遍历到最后一个元素的时候就算结束呗。但是，在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。如下所示，我们找到一个值为 <code>b</code> 的元素就提前结束了遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> iterator.currentItem();</span><br><span class="line">      <span class="keyword">if</span> (name.equals(<span class="string">&quot;b&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们可以在迭代器类中定义一个新的接口 <code>finishIteration()</code>，主动告知容器迭代器使用完了，你可以增删元素了，示例代码如下所示。但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> iterator.currentItem();</span><br><span class="line">      <span class="keyword">if</span> (name.equals(<span class="string">&quot;b&quot;</span>)) &#123;</span><br><span class="line">        iterator.finishIteration();<span class="comment">//主动告知容器这个迭代器用完了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，第二种解决方法更加合理。<code>Java</code> 语言就是采用的这种解决方案，增删元素之后，让遍历报错。接下来，我们具体来看一下如何实现。</p>
<p>怎么确定在遍历时候，集合有没有增删元素呢？我们在 <code>ArrayList</code> 中定义一个成员变量 <code>modCount</code>，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 <code>modCount</code> 加 <code>1</code>。当通过调用集合上的 <code>iterator()</code> 函数来创建迭代器的时候，我们把 <code>modCount</code> 值传递给迭代器的 <code>expectedModCount</code> 成员变量，之后每次调用迭代器上的 <code>hasNext()</code>、<code>next()</code>、<code>currentItem()</code> 函数，我们都会检查集合上的 <code>modCount</code> 是否等于 <code>expectedModCount</code>，也就是看，在创建完迭代器之后，<code>modCount</code> 是否改变过。</p>
<p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择 <code>fail-fast</code> 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 <code>bug</code>。</p>
<details class="note success"><summary><p>点击展开示例</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList arrayList;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(ArrayList arrayList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">    <span class="built_in">this</span>.expectedModCount = arrayList.modCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; arrayList.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrayList.modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iterator.next();<span class="comment">//抛出ConcurrentModificationException异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h6 id="如何在遍历的同时安全地删除集合元素"><a href="#如何在遍历的同时安全地删除集合元素" class="headerlink" title="如何在遍历的同时安全地删除集合元素"></a>如何在遍历的同时安全地删除集合元素</h6><p>像 <code>Java</code> 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 <code>remove()</code> 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</p>
<p>个人觉得，<code>Java</code> 迭代器中提供的 <code>remove()</code> 方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个 <code>next()</code> 函数之后，只能跟着最多一个 <code>remove()</code> 操作，多次调用 <code>remove()</code> 操作会报错，还是通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    iterator.remove();</span><br><span class="line">    iterator.remove(); <span class="comment">//报错，抛出IllegalStateException异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们一块来看下，为什么通过迭代器就能安全的删除集合中的元素呢？源码之下无秘密。我们来看下 <code>remove()</code> 函数是如何实现的，代码如下所示。稍微提醒一下，在 <code>Java</code> 实现中，迭代器类是容器类的内部类，并且 <code>next()</code> 函数不仅将游标后移一位，还会返回当前的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，迭代器类新增了一个 <code>lastRet</code> 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 <code>lastRet</code> 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>
<h5 id="如何设计实现一个支持快照功能的迭代器"><a href="#如何设计实现一个支持快照功能的迭代器" class="headerlink" title="如何设计实现一个支持快照功能的迭代器"></a>如何设计实现一个支持快照功能的迭代器</h5><p>所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（<code>Snapshot</code>）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p>
<p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器 <code>list</code> 中初始存储了 <code>3、8、2</code> 三个元素。尽管在创建迭代器 <code>iter1</code> 之后，容器 <code>list</code> 删除了元素 <code>3</code>，只剩下 <code>8、2</code> 两个元素，但是，通过 <code>iter1</code> 遍历的对象是快照，而非容器 <code>list</code> 本身。所以，遍历的结果仍然是 <code>3、8、2</code>。同理，<code>iter2</code>、<code>iter3</code> 也是在各自的快照上遍历，输出的结果如代码中注释所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iter1 = list.iterator();<span class="comment">//snapshot: 3, 8, 2</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//list：3, 8</span></span><br><span class="line">Iterator&lt;Integer&gt; iter2 = list.iterator();<span class="comment">//snapshot: 3, 8</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));<span class="comment">//list：8</span></span><br><span class="line">Iterator&lt;Integer&gt; iter3 = list.iterator();<span class="comment">//snapshot: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：3 8 2</span></span><br><span class="line"><span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">  System.out.print(iter1.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：3 8</span></span><br><span class="line"><span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">  System.out.print(iter1.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：8</span></span><br><span class="line"><span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">  System.out.print(iter1.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<p>下面是针对这个功能需求的骨架代码，其中包含 <code>ArrayList</code>、<code>SnapshotArrayIterator</code> 两个类。对于这两个类，我只定义了必须的几个关键接口，完整的代码实现我并没有给出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SnapshotArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;<span class="comment">//返回当前元素，并且游标后移一位</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h6><p>先来看最简单的一种解决办法。在迭代器类中定义一个成员变量 <code>snapshot</code> 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.snapshot = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> snapshot.get(cursor);</span><br><span class="line">    cursor++;</span><br><span class="line">    <span class="keyword">return</span> currentItem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，<code>Java</code> 中的拷贝属于浅拷贝，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p>
<h6 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h6><p>可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 <code>addTimestamp</code>，一个是删除时间戳 <code>delTimestamp</code>。当元素被加入到集合中的时候，我们将 <code>addTimestamp</code> 设置为当前时间，将 <code>delTimestamp</code> 设置成最大长整型值（<code>Long.MAX_VALUE</code>）。当元素被删除时，我们将 <code>delTimestamp</code> 更新为当前时间，表示已经被删除。</p>
<p>注意，这里只是标记删除，而非真正将它从容器中删除。</p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 <code>snapshotTimestamp</code>，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 <code>addTimestamp &lt; snapshotTimestamp &lt; delTimestamp</code> 的元素，才是属于这个迭代器的快照。</p>
<p>如果元素的 <code>addTimestamp &gt; snapshotTimestamp</code>，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 <code>delTimestamp &lt; snapshotTimestamp</code>，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>
<p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，我们没有考虑 <code>ArrayList</code> 的扩容问题，感兴趣的话，你可以自己完善一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> actualSize; <span class="comment">//不包含标记删除元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> totalSize; <span class="comment">//包含标记删除元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span>[] addTimestamps;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span>[] delTimestamps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="built_in">this</span>.addTimestamps = <span class="keyword">new</span> <span class="title class_">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="built_in">this</span>.delTimestamps = <span class="keyword">new</span> <span class="title class_">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="built_in">this</span>.totalSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.actualSize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    elements[totalSize] = obj;</span><br><span class="line">    addTimestamps[totalSize] = System.currentTimeMillis();</span><br><span class="line">    delTimestamps[totalSize] = Long.MAX_VALUE;</span><br><span class="line">    totalSize++;</span><br><span class="line">    actualSize++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalSize; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elements[i].equals(obj)) &#123;</span><br><span class="line">        delTimestamps[i] = System.currentTimeMillis();</span><br><span class="line">        actualSize--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">actualSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.actualSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.totalSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (E)elements[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getAddTimestamp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addTimestamps[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelTimestamp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delTimestamps[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> snapshotTimestamp;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cursorInAll; <span class="comment">// 在整个容器中的下标，而非快照中的下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> leftCount; <span class="comment">// 快照中还有几个元素未被遍历</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.snapshotTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="built_in">this</span>.cursorInAll = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.leftCount = arrayList.actualSize();;</span><br><span class="line">    <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line"></span><br><span class="line">    justNext(); <span class="comment">// 先跳到这个迭代器快照的第一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.leftCount &gt;= <span class="number">0</span>; <span class="comment">// 注意是&gt;=, 而非&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> arrayList.get(cursorInAll);</span><br><span class="line">    justNext();</span><br><span class="line">    <span class="keyword">return</span> currentItem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">justNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (cursorInAll &lt; arrayList.totalSize()) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">addTimestamp</span> <span class="operator">=</span> arrayList.getAddTimestamp(cursorInAll);</span><br><span class="line">      <span class="type">long</span> <span class="variable">delTimestamp</span> <span class="operator">=</span> arrayList.getDelTimestamp(cursorInAll);</span><br><span class="line">      <span class="keyword">if</span> (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;</span><br><span class="line">        leftCount--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cursorInAll++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。<code>ArrayList</code> 底层依赖数组这种数据结构，原本可以支持快速的随机访问，在 <code>O(1)</code> 时间复杂度内获取下标为 i 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。</p>
<p>解决的方法也不难，我们可以在 <code>ArrayList</code> 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的，用来支持随机访问。</p>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>访问者模式，英文是：<code>Visitor Design Pattern</code>，定义时：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。它可以算是 <code>23</code> 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>
<p>通过一个例子，逐步来了解访问者模式，假设我们从网站上爬取了很多资源文件，它们的格式有三种：<code>PDF</code>、<code>PPT</code>、<code>Word</code>。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 <code>txt</code> 文件中。</p>
<div class="tabs" id="访问者模式"><ul class="nav-tabs"><li class="tab active"><a href="#访问者模式-1">初步实现</a></li><li class="tab"><a href="#访问者模式-2">需求增加</a></li><li class="tab"><a href="#访问者模式-3">访问者模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="访问者模式-1"><p>实现这个功能并不难，不同的人有不同的写法，下面是一种实现方式。其中，<code>ResourceFile</code> 是一个抽象类，包含一个抽象函数 <code>extract2txt()</code>。<code>PdfFile</code>、<code>PPTFile</code>、<code>WordFile</code> 都继承 <code>ResourceFile</code> 类，并且重写了 <code>extract2txt()</code> 函数。在 <code>ToolApplication</code> 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PPTFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PPTFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...省略一大坨从PPT中抽取文本的代码...</span></span><br><span class="line">    <span class="comment">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WordFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是：</span></span><br><span class="line"><span class="comment">// Extract PDF.</span></span><br><span class="line"><span class="comment">// Extract WORD.</span></span><br><span class="line"><span class="comment">// Extract PPT.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.extract2txt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="访问者模式-2"><p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：</p>
<ul>
<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>
<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>
<li>把所有比较上层的业务逻辑都耦合到 <code>PdfFile</code>、<code>PPTFile</code>、<code>WordFile</code> 类中，导致这些类的职责不够单一，变成了大杂烩；</li>
</ul>
<p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span> &#123;</span><br><span class="line">    extractor.extract2txt(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行第 <code>45</code> 行的时候，根据多态特性，程序会调用实际类型的 <code>accept</code> 函数，比如 <code>PdfFile</code> 的 <code>accept</code> 函数，也就是第 <code>16</code> 行代码。而 <code>16</code> 行代码中的 <code>this</code> 类型是 <code>PdfFile</code> 的，在编译的时候就确定了，所以会调用 <code>extractor</code> 的 <code>extract2txt(PdfFile pdfFile)</code> 这个重载函数。这里的实现很有技巧性，这是理解访问者模式的关键所在，也是我之前所说的访问者模式不好理解的原因。</p>
<p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 <code>Extractor</code> 类的新类 <code>Compressor</code> 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的 <code>accept</code> 重载函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Compressor compressor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span> &#123;</span><br><span class="line">    extractor.extract2txt(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Compressor compressor)</span> &#123;</span><br><span class="line">    compressor.compress(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class="line"><span class="comment">//...Extractor代码不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Compressor</span> <span class="variable">compressor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compressor</span>();</span><br><span class="line">    <span class="keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。</p></div><div class="tab-pane" id="访问者模式-3"><p>针对前面的问题，我们抽象出来一个 <code>Visitor</code> 接口，包含是三个命名非常通用的 <code>visit()</code> 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 <code>Visitor</code> 接口的具体的类来决定，比如 <code>Extractor</code> 负责抽取文本内容，<code>Compressor</code> 负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 <code>ToolApplication</code> 的代码就可以了。</p>
<p>按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor vistor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">    visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pdfFile)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile pdfFile)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extractor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compressor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Compress PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Compress PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Compress WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Compressor</span> <span class="variable">compressor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compressor</span>();</span><br><span class="line">    <span class="keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>访问者模式，定义比较简单，结合前面的例子不难理解。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。下面总结了一张图，可以对照着前面的例子代码一块儿来看一下。</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/visitor-pattern.webp" class="">

<p>最后，我们再来看下，访问者模式的应用场景。一般来说，访问者模式针对的是一组类型不同的对象（<code>PdfFile</code>、<code>PPTFile</code>、<code>WordFile</code>）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（<code>ResourceFile</code>）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（<code>PdfFile</code>、<code>PPTFile</code>、<code>WordFile</code>）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（<code>Extractor</code>、<code>Compressor</code>）中。</p>
<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p>备忘录模式，也叫快照（<code>Snapshot</code>）模式，英文是 <code>Memento Design Pattern</code>，定义是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式理解、掌握起来不难，代码实现比较灵活，应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。</p>
<p>假设有这样一个需求，希望编写一个小程序，可以接收命令行的输入。用户输入文本时，程序将其追加存储在内存文本中；用户输入<code>:list</code>，程序在命令行中输出内存文本的内容；用户输入<code>:undo</code>，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。我举了个小例子来解释一下这个需求，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;hello</span><br><span class="line">&gt;:list</span><br><span class="line">hello</span><br><span class="line">&gt;world</span><br><span class="line">&gt;:list</span><br><span class="line">helloworld</span><br><span class="line">&gt;:undo</span><br><span class="line">&gt;:list</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<div class="tabs" id="快照模式"><ul class="nav-tabs"><li class="tab active"><a href="#快照模式-1">基本实现</a></li><li class="tab"><a href="#快照模式-2">快照模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="快照模式-1"><p>下面是一个基本的实现：</p>
<div class="note warning"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> text.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    text.append(input);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;InputText&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> InputText <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(InputText inputText)</span> &#123;</span><br><span class="line">    <span class="type">InputText</span> <span class="variable">deepClonedInputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">    deepClonedInputText.setText(inputText.getText());</span><br><span class="line">    snapshots.push(deepClonedInputText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">    <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">      <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(inputText.getText());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">InputText</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">        inputText.setText(snapshot.getText());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        snapshotsHolder.pushSnapshot(inputText);</span><br><span class="line">        inputText.append(input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：</p>
<ul>
<li>第一，为了能用快照恢复 <code>InputText</code> 对象，我们在 <code>InputText</code> 类中定义了 <code>setText()</code> 函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则；</li>
<li>第二，快照本身是不可变的，理论上讲，不应该包含任何 <code>set()</code> 等修改内部状态的函数，但在上面的代码实现中，“快照“这个业务模型复用了 <code>InputText</code> 类的定义，而 <code>InputText</code> 类本身有一系列修改内部状态的函数，所以，用 <code>InputText</code> 类来表示快照违背了封装原则。</li>
</ul></div><div class="tab-pane" id="快照模式-2"><p>针对前面的问题，我们对代码做两点修改。其一，定义一个独立的类（<code>Snapshot</code> 类）来表示快照，而不是复用 <code>InputText</code> 类。这个类只暴露 <code>get()</code> 方法，没有 <code>set()</code> 等任何修改内部状态的方法。其二，在 <code>InputText</code> 类中，我们把 <code>setText()</code> 方法重命名为 <code>restoreSnapshot()</code> 方法，用意更加明确，只用来恢复对象。</p>
<p>重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> text.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    text.append(input);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Snapshot <span class="title function_">createSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(text.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), snapshot.getText());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Snapshot</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Snapshot <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">    snapshots.push(snapshot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">    <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">      <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(inputText.toString());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">        inputText.restoreSnapshot(snapshot);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class="line">        inputText.append(input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括 <code>GoF</code> 的《设计模式》）中给出的实现方法。</p></div></div></div>

<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>命令模式，英文 <code>Command Design Pattern</code>，定义是：命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p>
<p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。我们知道，<code>C</code> 语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。</p>
<p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>
<p>举个例子，假设我们正在开发一个类似《天天酷跑》或者《<code>QQ</code> 卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，后端逻辑相对于客户端来说，要简单很多。</p>
<p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如 <code>Protocol Buffer</code>、<code>JSON</code>、<code>XML</code>，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据是执行这个指令所需的数据。服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。</p>
<ol>
<li>一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理；</li>
<li>在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程 <code>Bug</code> 比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了；</li>
</ol>
<p>下面是第二种实现思路的代码示例，整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GotDiamondCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="comment">// 省略成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GotDiamondCommand</span><span class="params">(<span class="comment">/*数据*/</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行相应的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameApplication</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_HANDLED_REQ_COUNT_PER_LOOP</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Command&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mainloop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      List&lt;Request&gt; requests = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//省略从epoll或者select中获取数据，并封装成Request的逻辑，</span></span><br><span class="line">      <span class="comment">//注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (Request request : requests) &#123;</span><br><span class="line">        <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> request.getEvent();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (event.equals(Event.GOT_DIAMOND)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">GotDiamondCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.GOT_STAR)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">GotStartCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.HIT_OBSTACLE)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">HitObstacleCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.ARCHIVE)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">ArchiveCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="comment">// ...一堆else if...</span></span><br><span class="line"></span><br><span class="line">        queue.add(command);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">handledCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>策略模式和命令模式相比，在策略模式中，<strong>不同的策略具有相同的目的、不同的实现、互相之间可以替换</strong>。比如，<code>BubbleSort</code>、<code>SelectionSort</code> 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，<strong>不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换</strong>。</p>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>解释器模式，英文是 <code>Interpreter Design Pattern</code>，定义是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<p>解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。</p>
<p>定义很难理解，因为这里面有很多我们平时开发中很少接触的概念，比如语言，语法，解释器。实际上，这里的语言不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为语言，比如，古代的结绳记事、盲文、哑语、摩斯密码等。要想了解语言表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写句子，阅读者根据语法规则来阅读句子，这样才能做到信息的正确传递。而我们要讲的<strong>解释器模式，其实就是用来实现根据语法规则解读句子的解释器</strong>。</p>
<p>我们看一个更加接近实战的例子：实现一个自定义接口告警规则功能。</p>
<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过 <code>100</code>，监控系统就通过短信、微信、邮件等方式发送告警给开发者。</p>
<p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 <code>100</code> 或者每分钟 <code>API</code> 总调用数超过 <code>10000</code> 就触发告警。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000</span><br></pre></td></tr></table></figure>

<p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 <code>API</code> 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个 <code>Map</code> 中（数据的格式如下所示），发送给告警模块。接下来，我们只关注告警模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Long&gt; apiStat = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">apiStat.put(<span class="string">&quot;api_error_per_minute&quot;</span>, <span class="number">103</span>);</span><br><span class="line">apiStat.put(<span class="string">&quot;api_count_per_minute&quot;</span>, <span class="number">987</span>);</span><br></pre></td></tr></table></figure>

<p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含<code>||、&amp;&amp;、&gt;、&lt;、==</code>这五个运算符，其中，<code>&gt;、&lt;、==</code>运算符的优先级高于<code>||、&amp;&amp;</code>运算符，<code>&amp;&amp;</code>运算符优先级高于<code>||</code>。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 <code>key</code>，比如前面的 <code>api_error_per_minute、api_count_per_minute</code>。</p>
<p>下面的代码的骨架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlertRuleInterpreter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();</span></span><br><span class="line">  <span class="comment">//apiStat.put(&quot;key1&quot;, 103);</span></span><br><span class="line">  <span class="comment">//apiStat.put(&quot;key2&quot;, 987);</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="string">&quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&quot;</span>;</span><br><span class="line">    <span class="type">AlertRuleInterpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertRuleInterpreter</span>(rule);</span><br><span class="line">    Map&lt;String, Long&gt; stats = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stats.put(<span class="string">&quot;key1&quot;</span>, <span class="number">101l</span>);</span><br><span class="line">    stats.put(<span class="string">&quot;key3&quot;</span>, <span class="number">121l</span>);</span><br><span class="line">    stats.put(<span class="string">&quot;key4&quot;</span>, <span class="number">88l</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alert</span> <span class="operator">=</span> interpreter.interpret(stats);</span><br><span class="line">    System.out.println(alert);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreaterExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String key;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GreaterExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">    String[] elements = strExpression.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (elements.length != <span class="number">3</span> || !elements[<span class="number">1</span>].trim().equals(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Expression is invalid: &quot;</span> + strExpression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.key = elements[<span class="number">0</span>].trim();</span><br><span class="line">    <span class="built_in">this</span>.value = Long.parseLong(elements[<span class="number">2</span>].trim());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GreaterExpression</span><span class="params">(String key, <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stats.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">statValue</span> <span class="operator">=</span> stats.get(key);</span><br><span class="line">    <span class="keyword">return</span> statValue &gt; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(String strAndExpression)</span> &#123;</span><br><span class="line">    String[] strExpressions = strAndExpression.split(<span class="string">&quot;&amp;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String strExpr : strExpressions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strExpr.contains(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">        expressions.add(<span class="keyword">new</span> <span class="title class_">GreaterExpression</span>(strExpr));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strExpr.contains(<span class="string">&quot;&lt;&quot;</span>)) &#123;</span><br><span class="line">        expressions.add(<span class="keyword">new</span> <span class="title class_">LessExpression</span>(strExpr));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strExpr.contains(<span class="string">&quot;==&quot;</span>)) &#123;</span><br><span class="line">        expressions.add(<span class="keyword">new</span> <span class="title class_">EqualExpression</span>(strExpr));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Expression is invalid: &quot;</span> + strAndExpression);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.expressions.addAll(expressions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Expression expr : expressions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!expr.interpret(stats)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(String strOrExpression)</span> &#123;</span><br><span class="line">    String[] andExpressions = strOrExpression.split(<span class="string">&quot;\\|\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String andExpr : andExpressions) &#123;</span><br><span class="line">      expressions.add(<span class="keyword">new</span> <span class="title class_">AndExpression</span>(andExpr));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.expressions.addAll(expressions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Expression expr : expressions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr.interpret(stats)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlertRuleInterpreter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Expression expression;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.expression = <span class="keyword">new</span> <span class="title class_">OrExpression</span>(ruleExpression);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> expression.interpret(stats);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>解释器模式的代码实现比较灵活，没有固定的模板。应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><p>中介模式，英文是 <code>Mediator Design Pattern</code>，定义是：介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 <code>n</code> 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>下面是一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中我们可以很直观地看出，右边的交互关系更加清晰、简洁。</p>
<img data-src="/2022/05/01/Design-Patterns/design-patterns/Mediator-Design-Pattern.webp" class="">

<p>关于中介模式，有一个比较经典的例子不得不说，那就是航空管制。为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。</p>
<p>刚刚举的是生活中的例子，我们再举一个跟编程开发相关的例子。假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。</p>
<div class="tabs" id="中介模式"><ul class="nav-tabs"><li class="tab active"><a href="#中介模式-1">普通实现</a></li><li class="tab"><a href="#中介模式-2">中介模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="中介模式-1"><p>按照通常我们习惯的 <code>UI</code> 界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这个样子。在这种实现方式中，控件和控件之间互相操作、互相依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UIControl</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_BTN_ID</span> <span class="operator">=</span> <span class="string">&quot;login_btn&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REG_BTN_ID</span> <span class="operator">=</span> <span class="string">&quot;reg_btn&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;username_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;pswd_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;repeated_pswd_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HINT_TEXT_ID</span> <span class="operator">=</span> <span class="string">&quot;hint_text&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SELECTION_ID</span> <span class="operator">=</span> <span class="string">&quot;selection&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Button</span> <span class="variable">loginButton</span> <span class="operator">=</span> (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">regButton</span> <span class="operator">=</span> (Button)findViewById(REG_BTN_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">usernameInput</span> <span class="operator">=</span> (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">passwordInput</span> <span class="operator">=</span> (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">repeatedPswdInput</span> <span class="operator">=</span> (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="line">    <span class="type">Text</span> <span class="variable">hintText</span> <span class="operator">=</span> (Text)findViewById(HINT_TEXT_ID);</span><br><span class="line">    <span class="type">Selection</span> <span class="variable">selection</span> <span class="operator">=</span> (Selection)findViewById(SELECTION_ID);</span><br><span class="line"></span><br><span class="line">    loginButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameInput.text();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordInput.text();</span><br><span class="line">        <span class="comment">//校验数据...</span></span><br><span class="line">        <span class="comment">//做业务处理...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    regButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">      <span class="comment">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class="line">      <span class="comment">//校验数据...</span></span><br><span class="line">      <span class="comment">//做业务处理...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略selection下拉选择框相关代码....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="中介模式-2"><p>我们再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，各个控件只跟中介对象交互，中介对象负责所有业务逻辑的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(Component component, String event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandingPageDialog</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Button loginButton;</span><br><span class="line">  <span class="keyword">private</span> Button regButton;</span><br><span class="line">  <span class="keyword">private</span> Selection selection;</span><br><span class="line">  <span class="keyword">private</span> Input usernameInput;</span><br><span class="line">  <span class="keyword">private</span> Input passwordInput;</span><br><span class="line">  <span class="keyword">private</span> Input repeatedPswdInput;</span><br><span class="line">  <span class="keyword">private</span> Text hintText;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(Component component, String event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (component.equals(loginButton)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameInput.text();</span><br><span class="line">      <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordInput.text();</span><br><span class="line">      <span class="comment">//校验数据...</span></span><br><span class="line">      <span class="comment">//做业务处理...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(regButton)) &#123;</span><br><span class="line">      <span class="comment">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class="line">      <span class="comment">//校验数据...</span></span><br><span class="line">      <span class="comment">//做业务处理...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(selection)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">selectedItem</span> <span class="operator">=</span> selection.select();</span><br><span class="line">      <span class="keyword">if</span> (selectedItem.equals(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">        usernameInput.show();</span><br><span class="line">        passwordInput.show();</span><br><span class="line">        repeatedPswdInput.hide();</span><br><span class="line">        hintText.hide();</span><br><span class="line">        <span class="comment">//...省略其他代码</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectedItem.equals(<span class="string">&quot;register&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UIControl</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_BTN_ID</span> <span class="operator">=</span> <span class="string">&quot;login_btn&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REG_BTN_ID</span> <span class="operator">=</span> <span class="string">&quot;reg_btn&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;username_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;pswd_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;repeated_pswd_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HINT_TEXT_ID</span> <span class="operator">=</span> <span class="string">&quot;hint_text&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SELECTION_ID</span> <span class="operator">=</span> <span class="string">&quot;selection&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Button</span> <span class="variable">loginButton</span> <span class="operator">=</span> (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">regButton</span> <span class="operator">=</span> (Button)findViewById(REG_BTN_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">usernameInput</span> <span class="operator">=</span> (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">passwordInput</span> <span class="operator">=</span> (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">repeatedPswdInput</span> <span class="operator">=</span> (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="line">    <span class="type">Text</span> <span class="variable">hintText</span> <span class="operator">=</span> (Text)findViewById(HINT_TEXT_ID);</span><br><span class="line">    <span class="type">Selection</span> <span class="variable">selection</span> <span class="operator">=</span> (Selection)findViewById(SELECTION_ID);</span><br><span class="line"></span><br><span class="line">    <span class="type">Mediator</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LandingPageDialog</span>();</span><br><span class="line">    dialog.setLoginButton(loginButton);</span><br><span class="line">    dialog.setRegButton(regButton);</span><br><span class="line">    dialog.setUsernameInput(usernameInput);</span><br><span class="line">    dialog.setPasswordInput(passwordInput);</span><br><span class="line">    dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class="line">    dialog.setHintText(hintText);</span><br><span class="line">    dialog.setSelection(selection);</span><br><span class="line"></span><br><span class="line">    loginButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        dialog.handleEvent(loginButton, <span class="string">&quot;click&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    regButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        dialog.handleEvent(regButton, <span class="string">&quot;click&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的“上帝类”（<code>God Class</code>）。所以，在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p></div></div></div>



<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><h4 id="工厂模式和-DI-容器"><a href="#工厂模式和-DI-容器" class="headerlink" title="工厂模式和 DI 容器"></a>工厂模式和 <code>DI</code> 容器</h4><p>实际上，<code>DI</code> 容器底层最基本的设计思路就是基于工厂模式的。<code>DI</code> 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<p><code>DI</code> 容器相对于工厂模式的例子来说，它处理的是更大的对象创建工程。工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 <code>DI</code> 容器负责的是整个应用中所有类对象的创建。</p>
<p>除此之外，<code>DI</code> 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 <code>DI</code> 容器应该包含哪些核心功能。</p>
<p>一个简单的 <code>DI</code> 容器的核心功能一般有三个：<strong>配置解析、对象创建和对象生命周期管理</strong>。</p>
<h5 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h5><p>工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，<code>DI</code> 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 <code>DI</code> 容器要创建哪些对象，这种形式就是我们要讲的配置。</p>
<p>我们将需要由 <code>DI</code> 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p>
<p>下面是一个典型的 <code>Spring</code> 容器的配置文件。<code>Spring</code> 容器读取这个配置文件，解析出要创建的两个对象：<code>rateLimiter</code> 和 <code>redisCounter</code>，并且得到两者的依赖关系：<code>rateLimiter</code> 依赖 <code>redisCounter</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> RedisCounter redisCounter;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">RateLimiter</span><span class="params">(RedisCounter redisCounter)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.redisCounter = redisCounter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCounter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String ipAddress;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">RedisCounter</span><span class="params">(String ipAddress, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ipAddress = ipAddress;</span><br><span class="line">    <span class="built_in">this</span>.port = port;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件beans.xml：</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id=<span class="string">&quot;rateLimiter&quot;</span> class=<span class="string">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span><br><span class="line">      &lt;constructor-arg ref=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id=<span class="string">&quot;redisCounter&quot;</span> class=<span class="string">&quot;com.xzg.redisCounter&quot;</span>&gt;</span><br><span class="line">     &lt;constructor-arg type=<span class="string">&quot;String&quot;</span> value=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span><br><span class="line">     &lt;constructor-arg type=<span class="string">&quot;int&quot;</span> value=<span class="number">1234</span>&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h5 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h5><p>在 <code>DI</code> 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 <code>BeansFactory</code>。</p>
<p>通过“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，<code>BeansFactory</code> 工厂类代码都是一样的。</p>
<h5 id="对象生命周期管理"><a href="#对象生命周期管理" class="headerlink" title="对象生命周期管理"></a>对象生命周期管理</h5><p>简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 <code>Spring</code> 框架中，我们可以通过配置 <code>scope</code> 属性，来区分这两种不同类型的对象。<code>scope=prototype</code> 表示返回新创建的对象，<code>scope=singleton</code> 表示返回单例对象。</p>
<p>除此之外，我们还可以配置对象是否支持懒加载。如果 <code>lazy-init=true</code>，对象在真正被使用到的时候（比如：<code>BeansFactory.getBean(“userService”)</code>）才被被创建；如果 <code>lazy-init=false</code>，对象在应用启动的时候就事先创建好。</p>
<p>不仅如此，我们还可以配置对象的 <code>init-method</code> 和 <code>destroy-method</code> 方法，比如 <code>init-method=loadProperties()</code>，<code>destroy-method=updateConfigFile()</code>。<code>DI</code> 容器在创建好对象之后，会主动调用 <code>init-method</code> 属性指定的方法来初始化对象。在对象被最终销毁之前，<code>DI</code> 容器会主动调用 <code>destroy-method</code> 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</p>
<h4 id="如何实现简单的-DI-容器"><a href="#如何实现简单的-DI-容器" class="headerlink" title="如何实现简单的 DI 容器"></a>如何实现简单的 <code>DI</code> 容器</h4><p>用 <code>Java</code> 语言来实现一个简单的 <code>DI</code> 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p>
<h5 id="最小原型设计"><a href="#最小原型设计" class="headerlink" title="最小原型设计"></a>最小原型设计</h5><p>像 <code>Spring</code> 框架这样的 <code>DI</code> 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>
<figure class="highlight xml"><figcaption><span>beans.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rateLimiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisCounter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.redisCounter&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">1234</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure>

<p>最小原型的使用方式跟 <code>Spring</code> 框架非常类似，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">            <span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> (RateLimiter) applicationContext.getBean(<span class="string">&quot;rateLimiter&quot;</span>);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="提供执行入口"><a href="#提供执行入口" class="headerlink" title="提供执行入口"></a>提供执行入口</h5><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，可以看出，执行入口主要包含两部分：<code>ApplicationContext</code> 和 <code>ClassPathXmlApplicationContext</code>。其中，<code>ApplicationContext</code> 是接口，<code>ClassPathXmlApplicationContext</code> 是接口的实现类。两个类具体实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  Object <span class="title function_">getBean</span><span class="params">(String beanId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> BeansFactory beansFactory;</span><br><span class="line">  <span class="keyword">private</span> BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.beansFactory = <span class="keyword">new</span> <span class="title class_">BeansFactory</span>();</span><br><span class="line">    <span class="built_in">this</span>.beanConfigParser = <span class="keyword">new</span> <span class="title class_">XmlBeanConfigParser</span>();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in = <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/&quot;</span> + configLocation);</span><br><span class="line">      <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log error</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们可以看出，<code>ClassPathXmlApplicationContext</code> 负责组装 <code>BeansFactory</code>和 <code>BeanConfigParser</code> 两个类，串联执行流程：从 <code>classpath</code> 中加载 <code>XML</code> 格式的配置文件，通过 <code>BeanConfigParser</code> 解析为统一的 <code>BeanDefinition</code> 格式，然后，<code>BeansFactory</code> 根据 <code>BeanDefinition</code> 来创建对象。</p>
<h5 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h5><p>配置文件解析主要包含 <code>BeanConfigParser</code> 接口和 <code>XmlBeanConfigParser</code> 实现类，负责将配置文件解析为 <code>BeanDefinition</code> 结构，以便 <code>BeansFactory</code> 根据这个结构来创建对象。配置文件的解析比较繁琐，不是重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。具体的代码框架如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line">  List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span>;</span><br><span class="line">  List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(String configContent)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanConfigParser</span> <span class="keyword">implements</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="keyword">return</span> parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(String configContent)</span> &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String className;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 省略必要的getter/setter/constructors</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorArg</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isRef;</span><br><span class="line">    <span class="keyword">private</span> Class type;</span><br><span class="line">    <span class="keyword">private</span> Object arg;</span><br><span class="line">    <span class="comment">// 省略必要的getter/setter/constructors</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心工厂类设计"><a href="#核心工厂类设计" class="headerlink" title="核心工厂类设计"></a>核心工厂类设计</h5><p>最后，我们来看，<code>BeansFactory</code> 是如何设计和实现的。这也是我们这个 <code>DI</code> 容器最核心的一个类了。它负责根据从配置文件解析得到的 <code>BeanDefinition</code> 来创建对象。</p>
<p>如果对象的 <code>scope</code> 属性是 <code>singleton</code>，那对象创建之后会缓存在 <code>singletonObjects</code> 这样一个 <code>map</code> 中，下次再请求此对象的时候，直接从 <code>map</code> 中取出返回，不需要重新创建。如果对象的 <code>scope</code> 属性是 <code>prototype</code>，那每次请求对象，<code>BeansFactory</code> 都会创建一个新的对象返回。</p>
<p>实际上，<code>BeansFactory</code> 创建对象用到的主要技术点就是 <code>Java</code> 中的反射语法：一种动态加载类和创建对象的机制。<code>JVM</code> 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 <code>JVM</code> 帮我们自动完成了，我们需要利用 <code>Java</code> 提供的反射语法自己去编写代码。</p>
<p>搞清楚了反射的原理，<code>BeansFactory</code> 的代码就不难看懂了。具体代码实现如下所示：</p>
<details class="note success"><summary><p>实现逻辑</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanDefinition.isLazyInit() == <span class="literal">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitions.get(beanId);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(<span class="string">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">      <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">        bean = beanClass.newInstance();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class[] argClasses = <span class="keyword">new</span> <span class="title class_">Class</span>[args.size()];</span><br><span class="line">        Object[] argObjects = <span class="keyword">new</span> <span class="title class_">Object</span>[args.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.<span class="type">ConstructorArg</span> <span class="variable">arg</span> <span class="operator">=</span> args.get(i);</span><br><span class="line">          <span class="keyword">if</span> (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] = arg.getType();</span><br><span class="line">            argObjects[i] = arg.getArg();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">refBeanDefinition</span> <span class="operator">=</span> beanDefinitions.get(arg.getArg());</span><br><span class="line">            <span class="keyword">if</span> (refBeanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(<span class="string">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationFailureException</span>(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h4 id="代理、桥接、装饰器、适配器-区别"><a href="#代理、桥接、装饰器、适配器-区别" class="headerlink" title="代理、桥接、装饰器、适配器 区别"></a>代理、桥接、装饰器、适配器 区别</h4><p>代理、桥接、装饰器、适配器，这 <code>4</code> 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 <code>Wrapper</code> 模式，也就是通过 <code>Wrapper</code> 类二次封装原始类。</p>
<p>尽管代码结构相似，但这 <code>4</code> 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p>
<p><strong>代理模式</strong>：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p>
<p><strong>桥接模式</strong>：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p>
<p><strong>装饰器模式</strong>：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p>
<p><strong>适配器模式</strong>：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p>
<h4 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h4><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>在享元模式的实现中，我们通过工厂类来缓存已经创建好的对象。这里的缓存实际上是存储的意思，跟我们平时所说的数据库缓存 <code>CPU</code> 缓存  <code>MemCache</code> 缓存是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p>
<h5 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h5><p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，像 <code>C++</code> 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p>
<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</p>
<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p>
<h4 id="回调-VS-模板模式"><a href="#回调-VS-模板模式" class="headerlink" title="回调 VS 模板模式"></a>回调 VS 模板模式</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>
<p>前面讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p>
<ol>
<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>
<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>
<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>
</ol>
<h4 id="中介模式-VS-观察者模式"><a href="#中介模式-VS-观察者模式" class="headerlink" title="中介模式 VS 观察者模式"></a>中介模式 VS 观察者模式</h4><p>之前讲到观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 <code>update()</code> 方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。</p>
<p>中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？</p>
<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p>
<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="https://refactoringguru.cn/design-patterns">设计模式</a></li>
<li><a href="https://time.geekbang.org/column/intro/100039001?tab=catalog">设计模式（极客时间）</a></li>
</ol>
]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【量化】网格交易策略详解</title>
    <url>/2023/07/17/Quantitative/grid-trading-strategy-explained/</url>
    <content><![CDATA[<h3 id="一、网格交易的原理"><a href="#一、网格交易的原理" class="headerlink" title="一、网格交易的原理"></a>一、网格交易的原理</h3><h3 id="二、最低价-最高价"><a href="#二、最低价-最高价" class="headerlink" title="二、最低价&amp;最高价"></a>二、最低价&amp;最高价</h3><h3 id="三、等差或等比"><a href="#三、等差或等比" class="headerlink" title="三、等差或等比"></a>三、等差或等比</h3><h3 id="四、网格数量"><a href="#四、网格数量" class="headerlink" title="四、网格数量"></a>四、网格数量</h3><h3 id="五、网格交易适合怎样的市场"><a href="#五、网格交易适合怎样的市场" class="headerlink" title="五、网格交易适合怎样的市场"></a>五、网格交易适合怎样的市场</h3><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3>]]></content>
      <categories>
        <category>Quantitative Trading</category>
      </categories>
      <tags>
        <tag>Quantitative Trading</tag>
        <tag>量化交易</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/baidu_verify_code-NR10G09zww.html</url>
    <content><![CDATA[350e6c308dc58aea67c07a622da60226]]></content>
  </entry>
  <entry>
    <title>算法</title>
    <url>/Algorithm/index.html</url>
    <content><![CDATA[<h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><ul>
<li><a href="/2022/05/27/Algorithm/two-sum-0001/">两数之和（<code>0001</code>）</a></li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><a href="/2022/05/30/Algorithm/two-number-add-0002/">两数相加（<code>0002</code>）</a></li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li><a href="/2022/05/30/Algorithm/longest-substring-without-repeating-characters-0003">无重复字符的最长子串 (<code>0003</code>)</a></li>
<li><a href="/2022/06/01/Algorithm/substring-with-concatenation-of-all-words-0030/">串联所有单词的子串 (<code>0030</code>)</a></li>
<li><a href="/2022/06/11/Algorithm/repeated-dna-sequences-0187/">重复的 <code>DNA</code> 序列 (<code>0187</code>)</a></li>
<li><a href="/2022/06/11/Algorithm/repeated-dna-sequences-0187/">长度最小的子数组 (<code>0209</code>)</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Programming C/C++</title>
    <url>/Programming-C++/index.html</url>
    <content><![CDATA[<h3 id="Programming-C-C"><a href="#Programming-C-C" class="headerlink" title="Programming C/C++"></a><code>Programming C/C++</code></h3>]]></content>
  </entry>
  <entry>
    <title>Programming Go</title>
    <url>/Programming-Go/index.html</url>
    <content><![CDATA[<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul>
<li><a href="https://books.halfrost.com/leetcode/"><code>LeetCode-Go</code></a></li>
<li><a href="https://github.com/chai2010/advanced-go-programming-book"><code>Go</code> 语言高级编程</a></li>
<li><a href="https://draveness.me/golang/"><code>Go</code> 语言设计与实现</a></li>
<li><a href="https://golang.design/under-the-hood/"><code>Go</code> 语言原本</a></li>
<li><a href="https://golang2.eddycjy.com/posts/ch6/06-gops/"><code>Go</code> 语言编程之旅</a></li>
</ul>
<h3 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h3><ul>
<li><a href="https://github.com/fatedier/frp"><code>frp</code></a>：快速的反向代理服务器，将本地的服务暴露到公网中；</li>
<li><a href="https://github.com/caddyserver/caddy"><code>caddy</code></a>：快速的多平台 <code>Web</code> 服务器；</li>
<li><a href="https://github.com/FiloSottile/mkcert"><code>mkcert</code></a>：简单的零配置工具创建本地开发证书；</li>
<li><a href="https://github.com/wagoodman/dive"><code>dive</code></a>：一个解析 <code>Docekr</code> 镜像的工具；</li>
<li><a href="https://github.com/inconshreveable/ngrok"><code>ngrok</code></a>：<code>Introspected tunnels to localhost</code>；</li>
<li><a href="https://github.com/ehang-io/nps"><code>nps</code></a>：内网穿透的代理服务器；</li>
<li><a href="https://github.com/spf13/viper"><code>viper</code></a>：配置解析；</li>
<li><a href="https://github.com/go-delve/delve"><code>delve</code></a>：<code>Go</code> 调试器；</li>
<li><a href="https://github.com/restic/restic"><code>restic</code></a>：快速、安全、高效的备份程序；</li>
<li><a href="https://github.com/containers/podman"><code>podman</code></a>：管理 <code>OCI</code> 容器和 <code>Pod</code> 的工具；</li>
<li><a href="https://github.com/ipfs/go-ipfs"><code>go-ipfs</code></a>：<code>IPFS</code> 的 <code>Go</code> 实现；</li>
<li><a href="https://github.com/qax-os/excelize"><code>excelize</code></a>：<code>Excel</code> 处理；</li>
<li><a href="https://github.com/goreleaser/goreleaser"><code>goreleaser</code></a>：帮助发布 <code>Go</code> 二进制程序的工具；</li>
<li><a href="https://github.com/google/wire"><code>wire</code></a>：<code>Go</code> 依赖注入的实现； </li>
<li><a href="https://github.com/harness/drone"><code>drone</code></a>：云原生持续发布平台；</li>
<li><a href="https://github.com/google/gops"><code>gops</code></a>：列出和诊断系统上当前运行的 <code>Go</code> 进程的工具；</li>
<li><a href="https://github.com/vektra/mockery"><code>mockery</code></a>：<code>Golang</code> 的 <code>Mock</code> 代码自动生成器；</li>
<li><a href="https://github.com/golang/mock"><code>mock</code></a>：<code>Go</code> 的 <code>Mock</code> 框架；</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Programming Rust</title>
    <url>/Programming-Rust/index.html</url>
    <content><![CDATA[<h3 id="Programming-Rust"><a href="#Programming-Rust" class="headerlink" title="Programming Rust"></a><code>Programming Rust</code></h3><p>这本书是 <code>O&#39;Reilly</code> 出版社的，对本书进行了学习和记录，内容大体上没有遗漏，只是对一些描述做了精简，<a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">出版社书籍链接</a>。</p>
<p><img data-src="/images/programing-rust-cover.png"></p>
<p>表述有误的地方请评论或者提 <code>pr</code> 指正。</p>
<ol>
<li><a href="/2022/06/28/%E3%80%90Rust%E3%80%91%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/">《第3章-Fundamental Types》</a></li>
<li><a href="/2022/04/12/%E3%80%90Rust%E3%80%91%E6%89%80%E6%9C%89%E6%9D%83/">《第4章-Ownership and Moves》</a></li>
<li><a href="/2022/04/17/%E3%80%90Rust%E3%80%91%E5%BC%95%E7%94%A8/">《第5章-References》</a></li>
<li><a href="/2022/04/20/%E3%80%90Rust%E3%80%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/">《第6章-Expressions》</a></li>
<li><a href="/2022/04/21/%E3%80%90Rust%E3%80%91%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">《第7章-Error Handling》</a></li>
<li><a href="/2022/04/22/%E3%80%90Rust%E3%80%91Crate-%E5%92%8C-Module/">《第8章-Crates and Modules》</a></li>
<li><a href="/2022/04/24/%E3%80%90Rust%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/">《第9章-Structs》</a></li>
<li><a href="/2022/04/25/%E3%80%90Rust%E3%80%91%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/">《第10章-Enums and Patterns》</a></li>
<li><a href="/2022/04/26/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/">《第11章-Traits and Generics》</a></li>
<li><a href="/2022/04/28/Rust/Rust-operator-overloading/">《第12章-Operator Overloading》</a></li>
<li><a href="/2022/04/29/%E3%80%90Rust%E3%80%91%E5%B8%B8%E7%94%A8-Trait/">《第13章-Utility Traits》</a></li>
<li><a href="/2022/04/30/%E3%80%90Rust%E3%80%91%E9%97%AD%E5%8C%85/">《第14章-Closures》</a></li>
<li><a href="/2022/04/30/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/">《第15章-Iterators》</a></li>
<li><a href="/2022/05/01/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/">《第16章-Collections》</a></li>
<li><a href="/2022/05/01/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/">《第17章-Strings and Text》</a></li>
<li><a href="/2022/05/02/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">《第18章-Input and Output》</a></li>
<li><a href="/2022/05/03/%E3%80%90Rust%E3%80%91%E5%B9%B6%E5%8F%91/">《第19章-Concurrency》</a></li>
<li><a href="/2022/05/03/%E3%80%90Rust%E3%80%91%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">《第20章-Asynchronous Programming》</a></li>
<li><a href="/2022/05/04/%E3%80%90Rust%E3%80%91%E5%AE%8F/">《第21章-Macros》</a></li>
<li><a href="/2022/05/05/%E3%80%90Rust%E3%80%91Unsafe-%E4%BB%A3%E7%A0%81/">《第22章-Unsafe Code》</a></li>
<li><a href="/2022/05/06/Rust/Rust-ffi/">《第23章-Foreign Functions》</a></li>
</ol>
<h4 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h4><ul>
<li><a href="/2021/07/06/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Rust 生命周期</a></li>
<li><a href="/2021/07/05/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/">Rust 学习笔记</a></li>
<li><a href="/2022/06/30/%E3%80%90Rust%E3%80%91Rustup%20%E4%BB%8B%E7%BB%8D/">Rustup 介绍</a></li>
<li><a href="/2022/06/29/%E3%80%90Rust%E3%80%91%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">Rust 交叉编译</a></li>
<li><a href="https://github.com/johnthagen/min-sized-rust">Rust 二进制文件体积减小</a></li>
<li><a href="/2022/05/01/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/#%E6%A0%BC%E5%BC%8F%E5%8C%96">Rust 格式化</a></li>
<li><a href="/2022/05/01/%E3%80%90Rust%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">Rust 正则表达式</a></li>
<li><a href="/2022/05/02/%E3%80%90Rust%E3%80%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95">文件和目录</a></li>
<li><a href="/2022/05/11/Rust/anyhow-and-thiserror/"><code>anyhow &amp; thiserror</code></a></li>
<li><a href="https://dtolnay.github.io/rust-quiz/18"><code>Rust</code> 在线题目测试</a></li>
<li><a href="https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf"><code>gdb</code> 速查手册</a></li>
<li><a href="https://lldb.llvm.org/use/map.html"><code>lldb</code> 使用帮助</a></li>
<li><a href="https://course.rs/test/ci.html">用 <code>GitHub Actions</code> 进行持续集成</a></li>
<li><a href="https://ectobit.com/blog/speed-up-github-actions-rust-pipelines/"><code>GitHub Action</code> 构建 <code>Rust</code> 程序加速</a></li>
<li><a href="https://tutorialedge.net/rust/rust-docker-tutorial/"><code>Rust Docker Tutorial</code></a></li>
<li><a href="https://mp.weixin.qq.com/s/SIgvfBKOIzTtG8x2metdKA">【<code>Rust</code>日报】关于 <code>pprof-rs</code> 内部工作原理的一些笔记</a></li>
</ul>
<h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a><code>WEB</code></h3><ul>
<li><a href="https://crates.io/crates/reqwest"><code>reqwest</code></a>：高级 <code>HTTP</code> 客户端；</li>
<li><a href="https://crates.io/crates/actix-web"><code>actix-web</code></a>：<code>Web</code> 框架；</li>
<li><a href="https://crates.io/crates/surf"><code>surf</code></a>：跨平台 <code>HTTP</code> 客户端，简单易用；</li>
<li><a href="https://rocket.rs/"><code>rocket</code></a>：<code>web</code> 框架；</li>
<li><a href="https://github.com/tokio-rs/axum"><code>axum</code></a>：使用 <code>Tokio</code>、<code>Tower</code> 和 <code>Hyper</code> 构建的符合人体工程学的模块化 <code>Web</code> 框架；</li>
<li><a href="https://diesel.rs/"><code>diesel</code></a>：<code>Rust</code> 的 <code>ORM</code> 框架；</li>
<li><a href="https://www.sea-ql.org/SeaORM/"><code>SeaORM</code></a>：<code>Rust</code> 的 <code>ORM</code> 框架；</li>
<li><a href="https://github.com/launchbadge/sqlx"><code>sqlx</code></a>：异步的纯 <code>Rust</code> 实现的 <code>Sql</code> 工具箱；</li>
<li><a href="https://yew.rs/zh-CN/"><code>yew</code></a>：<code>Yew</code> 是一个设计先进的 <code>Rust</code> 框架，目的是使用 <code>WebAssembly</code> 来创建多线程的前端 <code>web</code> 应用。</li>
<li><a href="https://github.com/seed-rs/seed"><code>seed</code></a>：创建 <code>Web</code> 前端应用的 <code>Rust</code> 框架；</li>
<li><a href="https://github.com/MoonZoon/MoonZoon"><code>MoonZoon</code></a>：<code>Rust</code> 全栈框架；</li>
<li><a href="https://docs.rs/comrak/latest/comrak/"><code>comrak</code></a>：<code>markdown</code> 解析；</li>
</ul>
<h3 id="FFI"><a href="#FFI" class="headerlink" title="FFI"></a><code>FFI</code></h3><ul>
<li><a href="https://github.com/PyO3/pyo3"><code>pyo3</code></a></li>
<li><a href="https://github.com/neon-bindings/neon"><code>neon</code></a></li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li><a href="https://github.com/johnthagen/min-sized-rust"><code>min-sized-rust</code></a>：减小 <code>Rust</code> 二进制文件体积；</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><a href="https://github.com/hyperium/hyper"><code>hyper</code></a>：快速的 <code>HTTP</code> 实现；</li>
<li><a href="https://github.com/hyperium/tonic"><code>tonic</code></a>：原生的 <code>grpc</code> 客户段和服务端，支持 <code>async/await</code>；</li>
<li><a href="https://github.com/tokio-rs/prost"><code>prost</code></a>：<code>Rust</code> 的 <code>protocol buffer</code> 实现；</li>
<li><a href="https://docs.rs/tungstenite/latest/tungstenite/"><code>tungstenite</code></a>：<code>websocket</code> 协议实现；</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><a href="https://docs.rs/headless_chrome/latest/headless_chrome/"><code>headless_chrome</code></a>：一个高级的控制无头浏览器或者 <code>Chromium</code> 的框架；</li>
<li><a href="https://docs.rs/thirtyfour/latest/thirtyfour/"><code>thirtyfour</code></a>：类似 <code>Selenium</code> 的自动化测试框架；</li>
<li><a href="https://docs.rs/fantoccini/latest/fantoccini/"><code>fantoccini</code></a>：通过 <code>WebDriver</code> 以编程方式与网页交互的高级 API；</li>
</ul>
<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a><code>GUI</code></h3><ul>
<li><a href="https://github.com/iced-rs/iced"><code>iced</code></a></li>
<li><a href="https://github.com/sixtyfpsui/sixtyfps"><code>sixtyfps</code></a></li>
<li><a href="https://linebender.org/druid/"><code>druid</code></a></li>
<li><a href="https://tauri.studio/"><code>tauri</code></a></li>
<li><a href="http://www.areweguiyet.com/#ecosystem"><code>areweguiyet</code></a></li>
<li><a href="https://github.com/rust-skia/rust-skia"><code>rust-skia</code></a></li>
<li><a href="https://github.com/RazrFalcon/tiny-skia"><code>tiny-skia</code></a></li>
</ul>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ul>
<li><a href="https://docs.rs/dialoguer/latest/dialoguer/"><code>dialoguer</code></a>：可以用于构建交互式命令行；</li>
<li><a href="https://docs.rs/indicatif/latest/indicatif/"><code>indicatif</code></a>：用于提供友好的进度条；</li>
<li><a href="https://github.com/clap-rs/clap"><code>clap</code></a></li>
<li><a href="https://github.com/fdehau/tui-rs"><code>tui</code></a>：<code>Rust</code> 终端 <code>UI</code>；</li>
</ul>
<h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><ul>
<li><a href="https://github.com/kube-rs/kube-rs"><code>kube-rs</code></a></li>
<li><a href="https://github.com/krator-rs/krator"><code>krator</code></a></li>
<li><a href="https://github.com/krustlet/krustlet"><code>krustlet</code></a></li>
</ul>
<h3 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h3><ul>
<li><a href="https://github.com/rust-embedded/wg/"><code>wg</code></a>：嵌入式设备工作组的协调存储库；</li>
<li><a href="https://github.com/rust-embedded/awesome-embedded-rust"><code>awesome-embedded-rust</code></a></li>
<li><a href="https://github.com/project-akri/akri"><code>akri</code></a>：一个管理嵌入式设备的云原生项目；</li>
</ul>
<h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><ul>
<li><a href="https://github.com/solana-labs/solana"><code>solana</code></a></li>
<li><a href="https://github.com/RustCrypto/password-hashes"><code>password-hashes</code></a></li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li><a href="https://bonsaidb.io/"><code>bonsaidb</code></a>：<code>Rust</code> 写的本地数据库；</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><a href="https://crates.io/crates/fnv"><code>fnv</code></a>：基于 <code>Fowler–Noll–Vo</code> 算法实现的 <code>HashMap</code>；</li>
<li><a href="https://crates.io/crates/dashmap"><code>dashmap</code></a>：<code>Rust</code> 中超快的并发 <code>map</code>；</li>
</ul>
<h3 id="静态网站"><a href="#静态网站" class="headerlink" title="静态网站"></a>静态网站</h3><ul>
<li><a href="https://www.getzola.org/"><code>getzola</code></a>：静态网站生成器；</li>
<li><a href="https://github.com/rust-lang/mdBook"><code>mdBook</code></a>：类似 <code>gitbook</code> 的 <code>Rust</code> 实现；</li>
</ul>
<h3 id="wasmtime"><a href="#wasmtime" class="headerlink" title="wasmtime"></a><code>wasmtime</code></h3><ul>
<li><a href="https://github.com/bytecodealliance/wasmtime"><code>wasmtime</code></a>：单独的 <code>wasm</code> 运行时；</li>
<li><a href="https://github.com/rustwasm"><code>rustwasm</code></a>：<code>rustwasm</code> 生态系统；</li>
<li><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a>：<code>wasm</code> 工作流工具；</li>
<li><a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a>：提供<code>Wasm</code> 模块和 <code>JavaScript</code> 之间级交互的高级 <code>API</code>。</li>
<li><a href="https://bytecodealliance.org/"><code>bytecodealliance</code></a></li>
<li><a href="https://github.com/wasmerio/wasmer"><code>wasmer</code></a>：<code>Wasmer</code> 提供基于 <code>WebAssembly</code> 的超轻量级容器，其可以在任何地方运行：从桌面到云、以及 <code>IoT</code> 设备，并且也能嵌入到 任何编程语言中；</li>
<li><a href="https://github.com/thedodd/trunk"><code>trunk</code></a>：构建、打包以及发布 <code>wasm</code> 应用；</li>
<li><a href="https://github.com/fermyon/spin"><code>spin</code></a>：<code>Spin</code> 用于使用 <code>WebAssembly</code> 构建和运行快速、安全和可组合的云微服务；</li>
<li><a href="https://github.com/WasmEdge/WasmEdge"><code>WasmEdge</code></a>：WasmEdge 是一个轻量级、高性能和可扩展的 WebAssembly 运行时，适用于云原生、边缘和去中心化应用程序。它为无服务器应用程序、嵌入式功能、微服务、智能合约和物联网设备提供支持；</li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li><a href="https://github.com/tensorflow/rust"><code>tensorflow</code></a></li>
<li><a href="https://github.com/LaurentMazare/tch-rs"><code>PyTorch</code></a></li>
<li><a href="https://github.com/rust-ml/linfa"><code>scikit-learn</code></a></li>
</ul>
<h3 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h3><ul>
<li><a href="https://github.com/tikv/rust-prometheus"><code>rust-prometheus</code></a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-rust"><code>opentelemetry-rust</code></a></li>
<li><a href="https://crates.io/crates/tracing"><code>tracing</code></a>：日志处理；</li>
</ul>
<h3 id="并发异步"><a href="#并发异步" class="headerlink" title="并发异步"></a>并发异步</h3><ul>
<li><a href="https://github.com/actix/actix"><code>actix</code></a>：<code>Rust</code> 的 <code>actor</code> 框架；</li>
<li><a href="https://github.com/bastion-rs/bastion"><code>bastion</code></a>：高可用分布式容错运行时；</li>
<li><a href="https://github.com/smol-rs/smol"><code>smol</code></a>：一个小而快的异步运行时；</li>
<li><a href="https://crates.io/crates/crossbeam"><code>crossbeam</code></a>：提供很多用于并发编程的工具，例如线程阻塞；</li>
<li><a href="https://crates.io/crates/waker-fn"><code>waker_fn</code></a>：转换闭包为 <code>waker</code>；</li>
<li><a href="https://crates.io/crates/rayon"><code>rayon</code></a>：计算密集型任务的任务分解；</li>
<li><a href="https://crates.io/crates/futures-lite"><code>futures-lite</code></a>：完全兼容 <a href="https://docs.rs/futures">futures</a>，提供了 <code>pin!</code>；</li>
<li><a href="https://docs.rs/tokio/latest/tokio/"><code>tokio</code></a>：<code>Tokio</code> 是一个事件驱动的非阻塞 <code>I/O</code> 平台，用于使用 <code>Rust</code> 编程语言编写异步应用程序。</li>
<li><a href="https://docs.rs/async-trait/latest/async_trait/"><code>async_trait</code></a>：提供了一个宏，可以在 <code>trait</code> 中包含异步的方法；</li>
</ul>
<h3 id="其他-crate"><a href="#其他-crate" class="headerlink" title="其他 crate"></a>其他 <code>crate</code></h3><ul>
<li><a href="https://crates.io/crates/thiserror"><code>thiserror</code></a>：自动派生标准库中的 <code>std::error::Error</code>；</li>
<li><a href="https://crates.io/crates/anyhow"><code>anyhow</code></a>：提供了 <code>anyhow::Result&lt;T&gt;</code> 用于任何可能失败返回错误的函数；</li>
<li><a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>：可以用于初始化全局可变静态变量；</li>
<li><a href="https://crates.io/crates/once_cell"><code>once_cell</code></a>：<code>once_cell</code>提供了<code>unsync::OnceCell</code>和<code>sync::OnceCell</code>这两种<code>Cell</code>，用来存储堆上的信息，并且具有最多只能赋值一次的特性；</li>
<li><a href="https://crates.io/crates/unicode-width"><code>unicode-width</code></a>：获取 <code>Unicode</code> 字符宽度；</li>
<li><a href="https://crates.io/crates/enum_primitive"><code>enum_primitive</code></a>：提供宏能自动从数字转换成枚举；</li>
<li><a href="https://crates.io/crates/serde_json"><code>serde_json</code></a>：<code>json</code> 序列化；</li>
<li><a href="https://crates.io/crates/argonautica"><code>argonautica</code></a>：使用 <a href="https://en.wikipedia.org/wiki/Argon2"><code>Argon2 hashing algorithm</code></a> 进行密码 <code>hash</code>；</li>
<li><a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a>：提供了比标准库更快的 <code>Mutex</code> 等；</li>
<li><a href="https://docs.rs/itertools/0.10.1/itertools/index.html"><code>itertools</code></a>：扩展了内置的 <code>Iterator</code>，提供了更多的迭代适配器方法；</li>
<li><a href="https://github.com/tokio-rs/bytes"><code>bytes</code></a>：处理二进制内容的库；</li>
<li><a href="https://crates.io/crates/colored"><code>colored</code></a>：在终端中添加颜色的最简单方法；</li>
<li><a href="https://github.com/zhiburt/tabled"><code>tabled</code></a>：以表格的形式输出结构体和枚举；</li>
<li><a href="https://github.com/chronotope/chrono"><code>chrono</code></a>：<code>Rust</code> 的日期和时间处理库；</li>
<li><a href="https://github.com/Geal/nom#example"><code>nom</code></a>：解析器组合库；</li>
<li><a href="https://docs.rs/rusoto_core/latest/rusoto_core/"><code>rusoto_core</code></a>：<code>Rust</code> 实现的 <code>AWS</code> <code>SDK</code>；</li>
<li><a href="https://github.com/pola-rs/polars"><code>polars</code></a>：用于 <code>Rust</code> 和 <code>Python</code> 快速的 <code>DataFrame</code> 库；</li>
<li><a href="https://github.com/tikv/pprof-rs"><code>pprof-rs</code></a>：借助 <code>backtrace-rs</code> 实现的 <code>Rust</code> <code>CPU</code> 分析器；</li>
</ul>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/"><code>Rust</code> 程序设计语言</a></li>
<li><a href="https://course.rs/about-book.html"><code>Rust</code> 语言圣经</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/index.html"><code>Rust</code> 秘典</a></li>
<li><a href="https://nomicon.purewhite.io/"><code>Rust</code> 秘典（中文）</a></li>
<li><a href="https://doc.rust-lang.org/edition-guide/index.html"><code>Rust</code> 版本指南</a></li>
<li><a href="https://rustwiki.org/zh-CN/rust-by-example/">通过例子学 <code>Rust</code></a></li>
<li><a href="https://danielkeep.github.io/tlborm/book/">《<code>Rust Macros</code>小书》</a></li>
<li><a href="https://doc.rust-lang.org/cargo/index.html"><code>Cargo</code> 手册</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html"><code>Rustdoc</code> 手册</a></li>
<li><a href="https://doc.rust-lang.org/rustc/index.html"><code>Rustc</code> 手册</a></li>
<li><a href="https://rust-cli.github.io/book/index.html">命令行手册</a></li>
<li><a href="https://doc.rust-lang.org/embedded-book">嵌入式手册</a></li>
<li><a href="https://rustwasm.github.io/docs/book/"><code>WEBASSEMBLY</code> 手册</a></li>
<li><a href="https://doc.rust-lang.org/reference/index.html"><code>Rust</code> 参数手册</a></li>
<li><a href="https://github.com/rust-lang/rustlings"><code>rustlings</code></a>：<code>Rust</code> 知识检测；</li>
<li><a href="https://github.com/dtolnay/rust-quiz"><code>rust-quiz</code></a>：<code>Rust</code> 知识检测；</li>
<li><a href="https://spec.ferrocene.dev/"><code>spec.ferrocene.dev</code></a></li>
</ul>
<h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><ul>
<li><a href="https://releases.rs/"><code>releases.rs</code></a></li>
<li><a href="https://replit.com/languages/rust"><code>Replit</code></a>：在线支持 <code>crate</code> 和 <code>cargo</code>；</li>
<li><a href="https://godbolt.org/"><code>Godbolt</code></a>：支持在线查看 <code>Rust</code> 汇编生成；</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>目录</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="一位开发人员"><a href="#一位开发人员" class="headerlink" title="一位开发人员"></a>一位开发人员</h1>]]></content>
  </entry>
</search>
