---
title: 深度学习(DL)(三) — 探析
date: 2024-09-08 12:15:11
tags:
  - AI
categories:
  - 人工智能
mathjax:
  tex:
    tags: 'ams'
  svg:
    exFactor: 0.03
---

#### 介绍

假设您要输入一个法语句子，如`Jane visite I'Afrique Septembre`，并且要将其翻译成英语句子，`Jane is visiting Africa in September`。我们使用{% mathjax %}x^{<1>},\ldots,x^{<5>}{% endmathjax %}来表示单词和输入序列，我们将使用{% mathjax %}y^{<1>},\ldots,y^{<6>}{% endmathjax %}来表示输出序列中的单词。您如何训练神经网络来输入序列{% mathjax %}x{% endmathjax %}并输出序列{% mathjax %}y{% endmathjax %}？首先，让我们建立一个网络，称之为**编码器网络**，将其构建`RNN`，这可能是`GRU`或`LSTM`，一次一个单词地输入法语单词。在获取输入序列后，`RNN`会输出一个表示输入句子的向量。之后，您可以构建一个**解码器网络**。**编码器网络**的编码输出作为输入，然后可以训练一次一个单词地输出翻译。最后，识别出序列的结尾和解码器停止的句子标记，这样它们在使用语言模型合成文本时保持在之前的序列中。深度学习最显著的成果之一是模型有效性。给定足够多的法语和英语句子对，如果你训练一个模型来输入法语句子并输出相应的英语翻译，这很有效。这个模型只使用一个**编码器网络**，找到输入法语句子的编码，然后使用一个**解码器网络**生成相应的英语翻译。
<!-- more -->

#### 序列->序列

机器翻译模型如下所示，我将使用两种不同的颜色，绿色和紫色，分别表示绿色的**编码器网络**和紫色的**解码器网络**。您会注意到，**解码器网络**看起来与上面的语言模型几乎完全相同。因此，机器翻译模型与语言模型非常相似，只是它不是从全零向量开始，而是有一个**编码器网络**，可以找出输入句子的一些表示，它获取该输入句子，并从输入句子的表示而不是全零的表示开始解码网络。所以，这就是将其称为条件语言模型的原因，它不是对任何句子的**概率**进行建模，而是对输出英语翻译的概率进行建模，条件是输入一些法语句子。例如，翻译为“`Jane is visite l'Afrique en septembre`”的概率是多少，但输入的法语句子的条件是“`Jane visite l'Afrique en septembre`”。这实际上是英语句子以输入的法语句子为条件的概率，这就是为什么它是一个条件语言模型。如果想应用此模型将句子从法语翻译成英语，给定这个输入的法语句子，该模型会告诉您相应的英语翻译存在差异的概率。{% mathjax %}x{% endmathjax %}是法语句子“`Jane visite l'Afrique en septembre`”。并且，不希望随机抽样输出。如果从这个分布中抽取单词，给定{% mathjax %}\mathbf{P}(\hat{y}^{<1>},\ldots,\hat{y}^{<T_y>}|x){% endmathjax %}，也许会得到一个相当不错的翻译，“`Jane is visite l'Afrique en septembre`”。但是，也许另一次你会得到不同的翻译，这听起来有点别扭，但不是一个糟糕的翻译，只是不是最好的。当使用这个模型进行机器翻译时，你并不是从这个分布中随机抽样。相反，你想要的是找到最大化条件概率的英语句子{% mathjax %}y{% endmathjax %}。在开发机器翻译系统时，你需要做的事情就是想出一个算法，可以真正找到最大化这个{% mathjax %}y{% endmathjax %}值。最常见的算法称为**定向搜索**，为什么不直接使用**贪婪搜索**呢？什么是贪婪搜索？**贪婪搜索**是一种计算机算法，它表示要生成第一个单词，只需根据条件语言模型选择最有可能的第一个单词即可。进入机器翻译模型，在选择第一个单词后，选择看起来最有可能的第二个单词，然后选择看起来最有可能的第三个单词。这种算法称为**贪婪搜索**。而你真正想要的是选择整个单词序列，{% mathjax %}y^{<1>},y^{<2>},\ldots,y^{<T_y>}{% endmathjax %}，这可以最大化整个单词的**联合概率**。贪婪方法并不奏效，即只选择最佳的第一个单词，然后在选择最佳的第一个单词后，尝试选择最佳的第二个单词，在此之后，尝试选择最佳的第三个单词。为了证明这一点，让我们考虑以下两个翻译。第一个翻译更好，所以希望在我们的机器翻译中翻译模型会说，对于第一个句子，{% mathjax %}\mathbf{P}(y){% endmathjax %}更高。这只是对法语输入的更好、更简洁的翻译。第二个翻译并不差，只是更冗长，有更多不必要的单词。但是，如果算法选择“`Jane is`”作为前两个单词，因为“`going`”是一个更常见的英语单词，那么在法语输入的情况下，“`Jane is going`”的概率实际上可能高于在法语句子的情况下“`Jane is visit`”的概率。如果最大化前三个单词的概率来选择第三个单词，那么最终可能会选择第二个选项。但是，这最终会导致句子不太理想，根据该模型对{% mathjax %}\mathbf{P}(y|x){% endmathjax %}的测量，句子不太好。如果你想找到单词序列{% mathjax %}y^{<1>},y^{<2>}{% endmathjax %}一直到最后一个单词，使概率最大化，那么一次只选择一个单词并不总是最佳选择。当然，英语句子中单词组合的总数要大得多。如果字典里只有`10,000`个单词，你正在考虑翻译长度不超过`10`个单词，那么就有{% mathjax %}10000^{10}{% endmathjax %}个可能的句子，长度为`10`个单词。从词汇量中挑选单词，字典大小为`10,000`个单词。这是一个巨大句子空间，不可能对它们全部进行评级，这就是为什么最常见的做法是使用**近似搜索算法**。**近似搜索算法**的作用是选择使条件概率最大化的句子{% mathjax %}y{% endmathjax %}。即使不能保证找到使这个值最大化的{% mathjax %}y{% endmathjax %}值，它通常也能做得很好。