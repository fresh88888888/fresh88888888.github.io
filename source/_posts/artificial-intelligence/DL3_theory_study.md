---
title: 深度学习(DL)(三) — 探析
date: 2024-09-08 12:15:11
tags:
  - AI
categories:
  - 人工智能
mathjax:
  tex:
    tags: 'ams'
  svg:
    exFactor: 0.03
---

#### 介绍

假设您要输入一个法语句子，如`Jane visite I'Afrique Septembre`，并且要将其翻译成英语句子，`Jane is visiting Africa in September`。我们使用{% mathjax %}x^{<1>},\ldots,x^{<5>}{% endmathjax %}来表示单词和输入序列，我们将使用{% mathjax %}y^{<1>},\ldots,y^{<6>}{% endmathjax %}来表示输出序列中的单词。您如何训练神经网络来输入序列{% mathjax %}x{% endmathjax %}并输出序列{% mathjax %}y{% endmathjax %}？首先，让我们建立一个网络，称之为**编码器网络**，将其构建`RNN`，这可能是`GRU`或`LSTM`，一次一个单词地输入法语单词。在获取输入序列后，`RNN`会输出一个表示输入句子的向量。之后，您可以构建一个**解码器网络**。**编码器网络**的编码输出作为输入，然后可以训练一次一个单词地输出翻译。最后，识别出序列的结尾和解码器停止的句子标记，这样它们在使用语言模型合成文本时保持在之前的序列中。深度学习最显著的成果之一是模型有效性。给定足够多的法语和英语句子对，如果你训练一个模型来输入法语句子并输出相应的英语翻译，这很有效。这个模型只使用一个**编码器网络**，找到输入法语句子的编码，然后使用一个**解码器网络**生成相应的英语翻译。
<!-- more -->

#### 序列->序列

机器翻译模型如下所示，我将使用两种不同的颜色，绿色和紫色，分别表示绿色的**编码器网络**和紫色的**解码器网络**。您会注意到，**解码器网络**看起来与上面的语言模型几乎完全相同。因此，机器翻译模型与语言模型非常相似，只是它不是从全零向量开始，而是有一个**编码器网络**，可以找出输入句子的一些表示，它获取该输入句子，并从输入句子的表示而不是全零的表示开始解码网络。所以，这就是将其称为条件语言模型的原因，它不是对任何句子的**概率**进行建模，而是对输出英语翻译的概率进行建模，条件是输入一些法语句子。例如，翻译为“`Jane is visite l'Afrique en septembre`”的概率是多少，但输入的法语句子的条件是“`Jane visite l'Afrique en septembre`”。这实际上是英语句子以输入的法语句子为条件的概率，这就是为什么它是一个条件语言模型。如果想应用此模型将句子从法语翻译成英语，给定这个输入的法语句子，该模型会告诉您相应的英语翻译存在差异的概率。{% mathjax %}x{% endmathjax %}是法语句子“`Jane visite l'Afrique en septembre`”。并且，不希望随机抽样输出。如果从这个分布中抽取单词，给定{% mathjax %}\mathbf{P}(\hat{y}^{<1>},\ldots,\hat{y}^{<T_y>}|x){% endmathjax %}，也许会得到一个相当不错的翻译，“`Jane is visite l'Afrique en septembre`”。但是，也许另一次你会得到不同的翻译，这听起来有点别扭，但不是一个糟糕的翻译，只是不是最好的。当使用这个模型进行机器翻译时，你并不是从这个分布中随机抽样。相反，你想要的是找到最大化条件概率的英语句子{% mathjax %}y{% endmathjax %}。在开发机器翻译系统时，你需要做的事情就是想出一个算法，可以真正找到最大化这个{% mathjax %}y{% endmathjax %}值。最常见的算法称为**定向搜索**，为什么不直接使用**贪婪搜索**呢？什么是贪婪搜索？**贪婪搜索**是一种计算机算法，它表示要生成第一个单词，只需根据条件语言模型选择最有可能的第一个单词即可。进入机器翻译模型，在选择第一个单词后，选择看起来最有可能的第二个单词，然后选择看起来最有可能的第三个单词。这种算法称为**贪婪搜索**。而你真正想要的是选择整个单词序列，{% mathjax %}y^{<1>},y^{<2>},\ldots,y^{<T_y>}{% endmathjax %}，这可以最大化整个单词的**联合概率**。贪婪方法并不奏效，即只选择最佳的第一个单词，然后在选择最佳的第一个单词后，尝试选择最佳的第二个单词，在此之后，尝试选择最佳的第三个单词。为了证明这一点，让我们考虑以下两个翻译。第一个翻译更好，所以希望在我们的机器翻译中翻译模型会说，对于第一个句子，{% mathjax %}\mathbf{P}(y){% endmathjax %}更高。这只是对法语输入的更好、更简洁的翻译。第二个翻译并不差，只是更冗长，有更多不必要的单词。但是，如果算法选择“`Jane is`”作为前两个单词，因为“`going`”是一个更常见的英语单词，那么在法语输入的情况下，“`Jane is going`”的概率实际上可能高于在法语句子的情况下“`Jane is visit`”的概率。如果最大化前三个单词的概率来选择第三个单词，那么最终可能会选择第二个选项。但是，这最终会导致句子不太理想，根据该模型对{% mathjax %}\mathbf{P}(y|x){% endmathjax %}的测量，句子不太好。如果你想找到单词序列{% mathjax %}y^{<1>},y^{<2>}{% endmathjax %}一直到最后一个单词，使概率最大化，那么一次只选择一个单词并不总是最佳选择。当然，英语句子中单词组合的总数要大得多。如果字典里只有`10,000`个单词，你正在考虑翻译长度不超过`10`个单词，那么就有{% mathjax %}10000^{10}{% endmathjax %}个可能的句子，长度为`10`个单词。从词汇量中挑选单词，字典大小为`10,000`个单词。这是一个巨大句子空间，不可能对它们全部进行评级，这就是为什么最常见的做法是使用**近似搜索算法**。**近似搜索算法**的作用是选择使条件概率最大化的句子{% mathjax %}y{% endmathjax %}。即使不能保证找到使这个值最大化的{% mathjax %}y{% endmathjax %}值，它通常也能做得很好。

##### 集束搜索

**集束搜索**(`Beam Search`)算法是一种**启发式搜索算法**，主要用于处理解空间较大的问题，尤其在自然语言处理(`NLP`)领域的序列生成任务中，如机器翻译、文本摘要和语音识别等。让我们使用法语句子“`Jane, visite l'Afrique en Septembre`”的运行示例尝试**集束搜索**。希望翻译成“`Jane, visits Africa in September`”。**集束搜索**要做的第一件事是选择英语翻译的第一个单词输出。这里列出了`10,000`个单词到词汇表中。为了简化问题，将忽略大写。把所有单词都用小写字母列出来。在**集束搜索**(`Beam Search`)的第一步中，使用这个网络片段，**编码器**用绿色表示，**解码器**用紫色表示，来评估第一个单词的概率。给定输入句子{% mathjax %}x{% endmathjax %}法语输入，第一个输出{% mathjax %}y{% endmathjax %}的概率是多少。**贪婪搜索**只会选择一个最有可能的单词继续前进，而**集束搜索**(`Beam Search`)则可以考虑多种替代方案。**集束搜索**(`Beam Search`)算法有一个参数称为{% mathjax %}B{% endmathjax %}，称为**波束宽度**，在这个例子中，{% mathjax %}B = 3{% endmathjax %}。**集束搜索**(`Beam Search`)会同时考虑三种可能性。假设对第一个单词的不同选择评估这个概率，发现`Jane`和`September`是英语输出中第一个单词最有可能的三种可能性。**集束搜索**(`Beam Search`)会尝试这三个单词的信息隐藏在计算机内存中，如果**集束宽度**参数的设置不同，{% mathjax %}B = 10{% endmathjax %}，那么跟踪第一个单词最有可能的`10`个选项，而不是`3`个。为了执行**集束搜索**(`Beam Search`)的第一步，需要做的是将输入的法语句子通过**编码器网络**运行，这是一个总共`10,000`种可能性的`softmax`输出。然后将获取这`10,000`个可能的输出，并将其中的前三个输出保存在内存中。**集束搜索**(`Beam Search`)的第二步。在选择了`in、Jane`和`September`作为第一个单词最有可能的三个选项之后，**集束搜索**(`Beam Search`)现在要做的是，针对这三个选项中的每一个，考虑第二个单词应该是什么，所以在“`in`”之后，第二个单词可能是“`a`”，可能是`September`，列表中有`visit`，然后一直到`z`，最后一个单词是`zulu`。为了评估第二个单词的概率，它将使用此神经网络片段，其中绿色的是`coder`，对于**解码器**部分，**解码器**首先输出{% mathjax %}\hat{y}^{<1>}{% endmathjax %}。把这个{% mathjax %}\hat{y}^{<1>}{% endmathjax %}设置为单词“`in`”。然后它将输出是{% mathjax %}\hat{y}^{<2>}{% endmathjax %}。通过{% mathjax %}\hat{y}{% endmathjax %}，这里的输入实际上是第一个单词“`in`”，这个网络片段可用于评估给定输入法语句子的第二个单词的概率，以及翻译的第一个单词是否是单词“`in`”。现在请注意，我们最终关心的是在这个第二步的**集束搜索**(`Beam Search`)中，找到最有可能的第一个单词和第二个单词的配对，而不仅仅是第二个单词，其中最有可能的是第一个单词和第二个单词的配对，而最有可能的是**条件概率规则**。这可以表示为{% mathjax %}\mathbf{P}(y^{<1>}|x^{<1>})\mathbf{P}(y^{<2>}|x^{<2>}){% endmathjax %}。这是从这个网络片段中获得的，如果对于选择的三个单词“`in`”、“`Jane`”和“`September`”，您保存了这个概率，那么您可以将它们乘以第二个概率以获得第一个单词和第二个单词的概率。所以现在你已经看到了如果第一个单词是“`in`”，你如何评估第二个单词的概率。一开始是“`Jane`”。句子可以是“`Jane a`”、“`Jane Aaron`”，等等，直到“`Jane is`”、“`Jane visits`”等等。你会在神经网络片段中使用它，在这里你会硬连线，{% mathjax %}\hat{y}^{<1>}{% endmathjax %}是`Jane`。所以第一个单词{% mathjax %}y{% endmathjax %}被硬连线为 `Jane`，那么网络片段就可以告诉您第二个单词的概率。假设第一个单词是“`Jane`”。与上述相同，{% mathjax %}\mathbf{P}(y^{<1>},y^{<2>}|x) = \mathbf{P}(y^{<1>}|x)\mathbf{P}(y^{<2>}|x,y^{<1>}){% endmathjax %}。最后对`September`执行相同的操作，从`a`到`Zulu`的所有单词，并使用这个网络片段。第一个单词是否是`September`。第二个单词最有可能的选项是什么。对于第二步的**集束搜索**(`Beam Search`)，继续使用{% mathjax %}B = 3{% endmathjax %}束宽度，词汇表中有`10,000`个单词，最终会考虑{% mathjax %}3\times 10000{% endmathjax %}种可能性，因为这里有{% mathjax %}10000\times 10000{% endmathjax %}个单词数，您要做的是根据可能的第一个和第二个单词评估这`30,000`个选项，然后选择前三个。因此，经过缩减，这`30,000`个可能性再次减少到`3`，**集束宽度**再次四舍五入，假设`30,000`个选项中最有可能的是`September`，如果**集束搜索**(`Beam Search`)确定最有可能的选择是第一个和第二个单词是`in September、Jane is`或`Jane visits`。那么它现在拒绝 `September`作为输出英语翻译的第一个单词的候选，现在只剩下两个单词的可能性，但仍然{% mathjax %}B = 3{% endmathjax %}，用于跟踪{% mathjax %}y^{<1>},y^{<2>}{% endmathjax %}对的三个选择，最后进入**集束搜索**(`Beam Search`)的第三步。由于{% mathjax %}B = 3{% endmathjax %}，每一步你都会实例化三个网络副本来评估这些部分句子片段和输出。正是因为{% mathjax %}B = 3{% endmathjax %}，才有三个网络副本，对于第一个单词有不同的选择，但这三个网络副本可以非常有效地用于评估第二个单词的所有`30,000`个选项。不要实例化`30,000`个网络副本或三个网络副本来快速地评估该`softmax`输出的`10,000`个可能的输出，假设前两个单词最有可能的选择是`in September、Jane is 和 Jane visits`，对于这些单词对，我们应该在计算机内存中保存{% mathjax %}By^{<1>}{% endmathjax %}和{% mathjax %}y^{<2>}{% endmathjax %}的概率，给定输入{% mathjax %}x{% endmathjax %}。现在要考虑第三个单词是什么。那么`in September a？In September Aaron？`一直到`in September Zulu`，为了评估第三个单词的可能选择，可以使用这个网络片段，其中将第一个单词硬连线为第二个单词`September`。因此，这个网络片段允许您评估第三个单词的概率，给定输入法语句子{% mathjax %}x{% endmathjax %}，给定前两个单词`in September`和英语输出。然后对第二个片段执行相同的操作。就像这样。对`Jane visits`执行相同的操作，**集束搜索**(`Beam Search`)将再次选择前三个可能，可能是`September`。`Jane`是可能的结果，或者`Jane is visiting`是可能的，或者`Jane visits Africa`是可能的，这是前三个词，然后进入第四步，即**定向搜索**，再加一个词，然后继续。这个过程的结果是，希望每次添加一个词，**定向搜索**将决定这一点。`Jane visits Africa in September`将在句子结尾符号处终止。对于三个**定向搜索**一次考虑三种可能性。注意，如果定向宽度等于`1`，那么本质上就变成了**贪婪搜索算法**，但同时考虑多种可能性，比如说三个、十个或其他数字，**定向搜索**通常会找到比**贪婪搜索**更好的输出句子。

**集束搜索**以最大化{% mathjax %}\text{arg}\;\underset{y}{\max}\prod_{t=1}^{T_y}\mathbf{P}(y^{<t>}|x,y^{<1>},\ldots,y^{<t-1>}){% endmathjax %}概率。这些概率都是小于`1`的数字，将许多小于`1`的数字相乘会得到一个很小的数字，对于计算机中浮点表示来说，这个数字太小，无法准确存储。在实践中，不会最大化这个乘积，而是取对数，如果你在那里插入一个对数，那么乘积的对数就变成了对数的总和，最大化这个对数概率的总和应该会在选择最可能的句子给你相同的结果({% mathjax %}\text{arg}\;\underset{y}{\max}\prod_{t=1}^{T_y}\log\mathbf{P}(y^{<t>}|x,y^{<1>},\ldots,y^{<t-1>}){% endmathjax %})。通过取对数，你最终会得到一个更稳定的算法，它不太容易出现数值舍入错误。因为对数函数是一个单调递增的函数，我们知道，给定{% mathjax %}\log\mathbf{P}(y|x){% endmathjax %}的结果，给定{% mathjax %}\mathbf{P}(y|x){% endmathjax %}，{% mathjax %}y{% endmathjax %}的值相同。跟踪概率对数的总和，而不是概率的乘积。这个目标函数还有另一个变化，使机器翻译算法工作得更好。如果参考上面的目标，如果有一个很长的句子，那么这个句子的概率会很低，因为这里乘以了很多项，很多小于`1`的数字来估计这个句子的概率。如果你将小于`1`的数字的对数相乘，你最终会得到一个较小的概率。这个**目标函数**有一个不良影响，它可能倾向于选择非常短的翻译输出，因为短句子的概率只是通过乘以这些数字中小于`1`的数，乘积不会那么小。同样的事情也适用于这种情况，概率的对数总是小于或等于`1`，对数的范围是这样的，所以加在一起的项越多，这个对数就越负。还有另一个改变算法的方法，那就是不要用这个作为最大化的目标。根据翻译中的单词数量进行**归一化**，这样就可以取每个单词概率对数的平均值，这确实可以显著降低输出较长翻译的惩罚。在实践中，作为一种启发式方法，而不是用{% mathjax %}T_y{% endmathjax %}除以输出句子中的单词数量，有时你会使用更温和的方法，我们有{% mathjax %}T_y^{\alpha}{% endmathjax %}，其中{% mathjax %}\alpha = 0.7{% endmathjax %}。如果{% mathjax %} \alpha = 1{% endmathjax %}，那么完全按长度**归一化**，如果{% mathjax %}\alpha = 0{% endmathjax %}，那么{% mathjax %}T_y^{0} = 1{% endmathjax %}，根本没有**归一化**，这介于完全归一化和无归一化之间。{% mathjax %}\alpha{% endmathjax %}是另一个超参数。以这种方式使用{% mathjax %}\alpha{% endmathjax %}，这是启发式方法还是一种破解方法？它没有很好的理论依据，但人们发现它效果很好，可以尝试不同的{% mathjax %}\alpha{% endmathjax %}值，看看哪一个能给你最好的结果。总结一下，如何进行**定向搜索**，当您运行**定向搜索**时，会看到很多句子的长度{% mathjax %}T_y =\{1,2,3,\ldots,30\}{% endmathjax %}。输出句子并根据这个分数对它们进行评分，这样你就可以选出最热门的句子，然后通过**集束搜索**计算这个**目标函数**。在你用这种方式评估的所有这些句子中，你选择一个在归一化低概率目标上达到最高值的句子，有时它被称为**归一化对数似然目标**，这将是输出的最终翻译。这就是实现**集束搜索**的方式。最后，您如何选择束宽度？如果束宽度非常大，往往会得到更好的结果。内存需求也会增加，计算速度也会更慢。而如果使用非常小的束宽度，那么会得到更糟糕的结果，因为只记住了更少的可能性，但会更快地得到结果，内存需求也会更低。

假设当你在学习到的`RNN`模型和翻译模型上运行**定向搜索**时，它最终会得到这样的翻译{% mathjax %}\hat{y}{% endmathjax %}，`Jane visits Africa in September`，这是法语的一个更糟糕的翻译。它改变了含义，所以这不是一个好的翻译。你的模型有两个主要组成部分。一个是**神经网络模型**，即**序列到序列模型**(`RNN`)。它实际上是一个**编码器**和一个**解码器**。你有**定向搜索算法**，定向宽度为{% mathjax %}b{% endmathjax %}。是`RNN`还是神经网络的问题，还是定向搜索算法的问题？但就像获得更多训练数据可能无法达到想要的性能水平一样。同样地，增加束宽可能无法让您达到想要的目标。但如何改进搜索算法？如何将问题分解并找出利用时间的方法。现在，`RNN`，神经网络，编码器和解码器。例如，对于一个句子，插入`Jane visits Africa in September`。现在最有用的事情就是使用这个模型计算{% mathjax %}\mathbf{P}(y|x) < \mathbf{P}(y){% endmathjax %}，使用`RNN`模型计算{% mathjax %}\mathbf{P}(\hat{y}|x){% endmathjax %}。然后看看这两个中哪个更大。所以左边可能比右边大。{% mathjax %}\mathbf{P}(y^{\ast}){% endmathjax %}，根据可以将这个特定的错误归咎于`RNN`或**集束搜索**算法中存在错误。计算{% mathjax %}\mathbf{P}(y^{\ast}|x){% endmathjax %}和{% mathjax %}\mathbf{P}(\hat{y}|x){% endmathjax %}，看看这两个中哪个更大。所以会有两种情况。在情况`1`中，`RNN`模型输出的{% mathjax %}\mathbf{P}(y^{\ast}|x) > \mathbf{P}(\hat{y}|x){% endmathjax %}。**定向搜索算法**选择了{% mathjax %}\hat{y}{% endmathjax %}，有一个计算 {% mathjax %}\mathbf{P}(y|x){% endmathjax %}的`RNN`。**定向搜索**的工作是找到一个使该参数最大的{% mathjax %}y{% endmathjax %}值。但在这种情况下，{% mathjax %}y^{\ast}{% endmathjax %}比 {% mathjax %}\hat{y}{% endmathjax %}获得了更高的{% mathjax %}\mathbf{P}(y|x){% endmathjax %}值。因此，**定向搜索**无法提供最大化{% mathjax %}\mathbf{P}(y|x){% endmathjax %}值，**定向搜索**的工作是找到这个非常大的{% mathjax %}y{% endmathjax %}值。{% mathjax %}y^{\ast}{% endmathjax %}获得了更大的值。可以得出结论，**定向搜索**有问题。在情况`2`中，{% mathjax %}\mathbf{P}(y^{\ast}|x) \leq \mathbf{P}(\hat{y}|x){% endmathjax %}。在例子中，{% mathjax %}y^{\ast}{% endmathjax %}比{% mathjax %}\hat{y}{% endmathjax %}翻译得更好。根据`RNN`，{% mathjax %}\mathbf{P}(y^{\ast}) \leq \mathbf{P}(\hat{y}){% endmathjax %}，因此说{% mathjax %}y^{\ast}{% endmathjax %}是比{% mathjax %}\hat{y}{% endmathjax %}输出的概率更低。

机器翻译面临的挑战是，给定一个法语句子，会有多个英语翻译与该法语句子表现的一样好。如果有多个一样好的翻译结果，如何评估机器翻译系统呢？这不同于图像识别，后者只有一个正确结果。你只需测量准确度。如果有多个一样好的结果，你如何测量准确度？传统方法是通过`BLEU`分数来完成的。假设有一个法语句子`Le chat est sur le tapis`。你获得了一个人工生成的翻译，`the cat is on the mat`。但是这个句子有多个不错的翻译。所以不同的人可能会把它翻译成：`there is a cat on the mat`。这两个都是对法语句子的完美翻译。`BLEU`分数的作用是，给定一个机器翻译，它允许您自动计算一个分数来衡量机器翻译的好坏。只要机器生翻译非常接近人类提供的参考，它就会得到一个很高的`BLEU`分数。`BLEU`代表双语评估。虽然可以让人类评估者评估机器翻译系统，但`BLEU`分数可以替代让人类评估机器翻译系统的每个输出。所以`BLEU`分数是`Kishore Papineni、Salim Roukos、Todd Ward`和`Wei-Jing Zhu`的功劳。这篇论文具有很高的影响力。查看机器生成的输出，看看它生成的单词类型是否出现在至少有一个人工生成的参考文献中。这些人工生成的参考文献将作为开发集或测试集的一部分被提供。现在，让我们看一个有点极端的例子。假设机器翻译系统简称**机器翻译**`MT`。因此，机器翻译输出是`the the the the the the the`。这显然是一个非常糟糕的翻译。衡量机器翻译输出好坏的一种方法是查看输出中的每个单词，看看它是否出现在参考文献中。这将被称为机器翻译输出的精度。在这种情况下，机器翻译输出中有`7`个单词都出现在参考文献`1`或参考文献`2`中，单词`the`出现在两个参考文献中。因此，其精度为`7/7`。看起来精度很高。因此，**精度测量**是机器翻译输出中有多少单词也出现在参考文献中。这不是一个特别有效的测量方法。接下来将使用一种经过修改的精度测量方法，我们将只给每个单词在参考句子中出现的最大次数的**信用**。在参考文献`1`中，单词`the`出现了`2`次。在参考文献`2`中，单词`the`只出现了`1`次。因此单词`the`最多获得两次**信用**。使用经过修改的精度，它在`7`个单词中得到`2`分。这里的分母是单词`the`在总共`7`个单词中出现的次数。分子是单词出现的次数`2`，即`2/7`。我们截取这个计数，取最大值，或者将这个计数截取为 `2`。这样我们就得到了修改后的精度测量。到目前为止，我们一直在孤立地查看单词。`BLEU`分数中，不想只查看孤立的单词。可能还想查看成对的单词。让我们根据二元组定义`BLEU`分数。二元组指成对出现的单词。让我们看看如何使用二元组来定义`BLEU`分数。`The cat the cat on the mat`。这仍然不是很好的翻译，但可能比上一个好。所以这里，可能的二元组是`cat`。然后是`cat the`，这是另一个二元组。然后`cat on`是下一个。然后是`on the`，以及`the mat`。这些是机器翻译输出中的二元组。让我们计算一下，每个二元组出现了多少次。`The cat`出现了`2`次，`cat the`出现了`1`次，其他的都只出现了`1`次。最后，定义剪裁计数即{% mathjax %}\text{count}_{\text{clip}}{% endmathjax %}。二元语法在参考文献`1`或参考文献`2`中出现的最大次数。`cat`在任一参考文献中最多出现`1`次。所以把这个剪裁计数为`1`。这些是剪裁后的计数。我们取所有计数并进行剪裁，将它们减少到不超过该二元语法在至少一个参考文献中出现的次数。最后，我们修改后的二元语法精度将是剪裁后的计数之和。所以这是`1、2、3、4`除以二元语法的总数。即`2、3、4、5、6`，因此`2/3`是二元组的修正精度。根据我们在单元组上所取得的成果，我们将计算单元组的修正精度定义为{% mathjax %}\mathbf{P}_1 = \frac{\sum_{\text{unigram}\in\hat{y}}\text{Count}_{\text{clip}}(\text{unigram})}{\sum_{\text{unigram}\in\hat{y}}\text{Count}(\text{ungram})}{% endmathjax %}。{% mathjax %}\mathbf{P}{% endmathjax %}代表精度，这里的下标`1`表示单元组。这表示对机器翻译输出中出现的单词的总和。这称该单元组的计数{% mathjax %}\hat{y}{% endmathjax %}。除以机器翻译输出中单元组的总和，即该单元组的计数数量？这里的`1`指的是单元组。如果机器翻译输出与参考文献`1`或参考文献`2`完全相同，那么所有这些值{% mathjax %}\mathbf{P}_1,\mathbf{P}_2{% endmathjax %}都将等于`1.0`。有时即使翻译输出与参考文献不完全相同，也可以实现这一点。最后，把它们放在一起形成最终的`BLEU`分数。{% mathjax %}\mathbf{P}_n = \frac{\sum_{\text{n-gram}\in\hat{y}}\text{Count}_{\text{clip}}(\text{n-gram})}{\sum_{\text{n-gram}\in\hat{y}}\text{Count}(\text{n-gram})}{% endmathjax %}是基于`n-gram`计算的`BLEU`分数。也是基于`n-gram`计算的修改后的精度。按照惯例，需要计算{% mathjax %}\mathbf{P}_1,\mathbf{P}_2,\mathbf{P}_3{% endmathjax %}和{% mathjax %}\mathbf{P}_4{% endmathjax %}，然后使用以下公式将它们组合在一起。它将是平均值，因此将{% mathjax %}\text{exp}(\frac{\sum_{n=1}^4\mathbf{P}_n}{4}){% endmathjax %}。取平均值。`BLEU`分数定义为，然后是指数和线性运算，指数是单调递增的运算，然后用`BP`惩罚来调整它。`BP`代表简洁性惩罚。如果你输出非常短的翻译，更容易获得高精度。因为你输出的大多数单词可能都出现在参考文献中。但我们不想要非常短的翻译。因此，`BP`是一个**调整因子**，它惩罚输出太短翻译的翻译系统。简洁性惩罚的公式如下图所示。如果机器翻译系统输出的内容比人工生成的参考文献更长，则它等于`1`。
{% asset_img dl_1.png %}

##### 注意力模型

**注意力思想**是深度学习中最具影响力的思想之一。拿一个的很长的法语句子。**编码器神经网络**读入整个句子，并记住整个句子将其存储在此处的激活中。**解码器网络**负责生成英语翻译。`Jane went to Africa last September and enjoyed the culture and met many wonderful people; she came back raving about how wonderful her trip was, and is tempting me to go too`。人类翻译这句话的方式不是先阅读整个法语句子，然后记住整个句子，最后从头开始翻译成英语句子。相反，人工翻译会阅读第一部分，可能生成部分翻译。查看第二部分，生成更多单词，查看更多单词，生成更多单词等等。你需要逐个处理句子，因为记住整个长句子真的很难。上面的**编码器-解码器架构**对短句非常有效，获得相对较高的`Bleu`分数，但对于非常长的句子，可能超过`30`或`40`个单词，性能就会下降。**注意力模型**是由`Dimitri、Bahdanau、Camcrun Cho`和`Yoshua Bengio`提出的，尽管它是为机器翻译而开发的，但它也扩展到了许多其他应用领域。这确实是一篇非常有影响力的论文，我认为是深度学习文献中非常具有开创性的论文。让我们用一个短句来说明这一点，尽管这些想法更多地是为长句而开发的，但用一个更简单的例子来说明这些想法会更容易。`Jane visite l'Afrique en Septembre`。假设使用双向`RNN`，为每个输入单词计算一些特征集，双向`RNN`的输出为{% mathjax %}y^{<1>},\ldots,y^{<5>}{% endmathjax %}。双向`RNN`计算句子中的单词以及每个位置周围的单词的特征集。我们将使用另一个`RNN`来生成英语翻译。这里不再使用{% mathjax %}A{% endmathjax %}来表示激活，为了避免与下面的激活混淆，我将使用不同的符号，我将使用{% mathjax %}S{% endmathjax %}来表示这里`RNN`中的隐藏状态，所以使用{% mathjax %}S_1{% endmathjax %}而不是{% mathjax %}A_1{% endmathjax %}，希望在这个模型中生成的第一个单词是`Jane`，如`Jane visits Africa in September`。当你试图生成这个第一个单词时，你应该关注输入法语句子的那一部分？似乎你应该主要关注第一个单词，还有其他几个附近的单词，但你不需要关注句子的末尾。**注意力模型**将计算一组**注意力权重**，使用{% mathjax %}\alpha_1{% endmathjax %}，`1`表示当你生成第一个单词时投入多少的**注意力**。称作**注意力权重**，第二步，它们一起会生成第二个单词，然后进入第三步，{% mathjax %}S_3{% endmathjax %}，这是一个输入，有一些新的上下文{% mathjax %}C{% endmathjax %}，它取决于{% mathjax %}\alpha_3{% endmathjax %}在多大程度上关注输入法语句子中的不同单词。

假设您有一个输入句子，使用双向`RNN`、双向`GRU`或双向`LSTM`来计算每个单词的特征。对前向传播的第一个时间步。激活**后向传播**。激活**前向传播**，第二个时间步。激活后向等等。**前向传播**第五个时间步和后向传播第五个时间步。我们在这里有一个0，我们也可以有一个后向传播第六个作为全零的向量，实际上这是一个全零的因子。为了简化每个时间步的符号，即使您拥有从双向`RNN`中的**前向传播**和**后向传播**计算出的特征。使用a^{<t>}来表示这两个连接在一起。{% mathjax %}a^{<t>}{% endmathjax %}将成为时间步{% mathjax %}t{% endmathjax %}的**特征向量**。使用{% mathjax %}t_{\text{prime}}{% endmathjax %}来索引法语句子中的单词。接下来，只有前向传播，所以它是一个单向`RNN`，具状态 {% mathjax %}s{% endmathjax %}来生成翻译。第一个时间步应该生成{% mathjax %}y^{<1>}{% endmathjax %}，并且将上下文`C`作为输入。如果您想用时间来索引它可以写一个{% mathjax %} C_1{% endmathjax %}，但有时只需写一个没有上标的{% mathjax %}C{% endmathjax %}。这取决于注意力参数，{% mathjax %}\alpha_{11},\alpha_{12}{% endmathjax %}表示注意力的程度。这些{% mathjax %}\alpha{% endmathjax %}参数对于上下文在多大程度上依赖于特征的激活。定义上下文的方式实际上对来自不同时间步骤的特征进行加权和，由**注意力权重**加权。注意力权重都是非负的，且它们的总和为`1`。我们将在时间步`1`处获得上下文，通常会删除上标，该上标将对{% mathjax %}t'{% endmathjax %}求和，即这些激活的加权对所有{% mathjax %}t'{% endmathjax %}值求和。{% mathjax %}\alpha^{<t'>}{% endmathjax %}是{% mathjax %}y^{<t>}{% endmathjax %}对{% mathjax %}t'{% endmathjax %}的关注量。在下一个时间步中，生成第二个输出，现在有一组新的**注意力权重**，找到一种新的求和方法。这会生成一个新的上下文。这也是输入，这允许你生成第二个单词。这种求和方式成为第二个时间步的上下文。使用这些上下文向量。这里的网络看起来像一个标准的`RNN`序列，上下文向量作为输出，我们可以一次生成一个单词的翻译。我们还定义了如何根据这些注意力权重和输入句子的那些特征来计算上下文向量。所以剩下要做的就是如何计算这些**注意力权重**。{% mathjax %}\alpha^{<t,t'>}{% endmathjax %}是生成输出翻译的第{% mathjax %}t{% endmathjax %}个单词时应该关注的量。写下公式{% mathjax %}\alpha^{<t,t'>} = \frac{\text{exp}(e^{<t,t'>})}{\sum_{t'=1}^{T_x}\text{exp}(e^{<t,t'>})}{% endmathjax %}，这个公式可以使用{% mathjax %}\alpha^{<t,t'>}{% endmathjax %}，它将计算这些项{% mathjax %}e^{<t,t'>}{% endmathjax %}，然后使用`softmax`方法来确保这些权重的总和为`1`。对于{% mathjax %}t{% endmathjax %}的值，如果对 {% mathjax %}t'{% endmathjax %}求和，这些值的总和为`1`。现在如何计算这些因子{% mathjax %}e{% endmathjax %}。一种方法是使用一个小的神经网络，如下所示。{% mathjax %}S^{<t-1>}{% endmathjax %}是来自前一个时间步骤的神经网络状态。如果生成{% mathjax %}y^{<t>}{% endmathjax %}，那么{% mathjax %}S^{<t-1>}{% endmathjax %}就是上一时间步的隐藏状态，它被输入到{% mathjax %}S^{<t>}{% endmathjax %}中，这是对非常小的神经网络的一个输入。通常，神经网络中只有一个隐藏层，因为你需要大量计算。然后{% mathjax %}a^{<t>}{% endmathjax %}是时间步的特征，{% mathjax %}t'{% endmathjax %}是其他输入。如果你想对{% mathjax %}t'{% endmathjax %}的激活投入多少注意力。应该依赖前一个时间步骤中的隐藏状态激活。看看这个`RNN`的隐藏状态，它会输出翻译，然后对于每个位置，每个单词查看它们的特征。{% mathjax %}\alpha^{<t,t'>}{% endmathjax %} 和 {% mathjax %}e(t,t_{\text{prime}}){% endmathjax %}依赖于这两个量。并且相信**反向传播**，相信**梯度下降**来学习正确的函数。如果你实现了整个模型并用**梯度下降**训练它，整个过程就会起作用。这个小型神经网络可以计算出{% mathjax %}y^{<t>}{% endmathjax %}应该对{% mathjax %}a^{<t>}{% endmathjax %}投入多少**注意力**，当一次生成一个单词时，这个神经网络会关注输入句子的正确部分，并使用**梯度下降**自动学习所有这些。这个算法的一个缺点是运行这个算法需要二次成本。如果输入中有{% mathjax %}t_x{% endmathjax %}个单词，输出中有{% mathjax %}t_y{% endmathjax %}个单词，那么这些注意力参数的总数将是{% mathjax %}t_xt_y{% endmathjax %}。虽然在机器翻译应用中，输入和输出句子通常都不会很长，二次成本是可以接受的。

#### 应用

##### 语音识别

**序列到序列模型**最令人兴奋的发展之一是语音识别精确度的提高。有一个音频片段{% mathjax %}x{% endmathjax %}，任务是自动找到文本记录{% mathjax %}y{% endmathjax %}。如下图所示，这里的横轴是时间，麦克风的作用是测量微小的气压变化，可能是由扬声器或耳机产生的。一些音频片段绘制了气压与时间的关系。如果这个音频片段是我说“敏捷的棕色狐狸”，那么希望语音识别算法可以输入该音频片段并输出记录。因为即使人耳也无法处理原始波形，但人耳具有测量不同频率强度的物理结构，因此，音频数据的一个常见预处理步骤是运行原始音频剪辑并生成频谱图。这些图的横轴是时间，纵轴是频率，不同颜色的强度表示能量的大小。那么，不同频率的声音有多大？不同时间的声音有多大？这些类型的频谱图，通常是在音频进入运行算法之前的预处理。人耳的计算与预处理步骤非常相似。语音识别系统是使用音素构建的，这是手工设计的基本细胞单位。所以，”敏捷的棕色狐狸“用音素表示。比如说，“`The`” 有“`de`”和“`e`”的发音，而`Quick`有“`ku`”和“`wu`”、“`ik`”、“`k`”的发音，语言学家过去常常忽略这些基本的声音单位，并试图将语言分解为这些基本的声音单位。但语言学家过去常常假设，用这些称为**音素**的基本声音单位来记录音频是进行语音识别的最佳方式。但随着端到端深度学习的发展，发现音素表示不再是必要的。相反，你可以构建一个系统，输入音频片段并直接输出转录，而无需使用像这样的手工设计的表示。实现这一点的因素之一是使用更大的数据集。因此，语音识别的学术数据集为`300`小时，在学术界，转录音频的`3000`小时数据集被认为是合理的大小，许多研究论文都基于数千小时的数据集。但是，现在最好的商业系统是使用超过`10,000`小时甚至有时超过`100,000`小时的音频进行训练。它正在转向更大的音频数据集，转录{% mathjax %}x{% endmathjax %}和{% mathjax %}y{% endmathjax %}的音频数据集，再加上深度学习算法，推动了语音识别的很大进步。那么，如何构建语音识别系统？可以做的一件事就是在横轴上获取音频输入的不同时间帧，然后使用**注意力模型**输出转录，例如“敏捷的棕色狐狸”。另一种似乎效果很好的方法是使用`CTC`进行语音识别。`CTC`代表连接时间分类，由`Alex Graves、Santiago Fernandes、Faustino Gomez`和`Jürgen Schmidhuber`提出。想法是这样的。假设音频片段是说“敏捷的棕色狐狸”。我们将使用这样结构的神经网络，其输入{% mathjax %}x{% endmathjax %}和输出{% mathjax %}y{% endmathjax %}的数量相等，为此绘制了 `RNN`的单向简单图，但在实践中，这通常是双向`LSTM`和双向`GRU`，通常是更深的模型。这里的时间步长数量非常大，在语音识别中，输入时间步长的数量通常比输出时间步长的数量大得多。例如，如果你有`10`秒的音频，并且特征频率为`100`赫兹，即每秒`100`个样本，那么`10`秒的音频片段最终将有`1000`个输入。但输出可能没有`1000`个字母。所以，你会怎么做？`CTC`成本函数允许`RNN`生成这样的输出，有一个特殊字符称为空白字符，我们将其写为下划线，`th_eee___q`，然后可能是空格，`CTC`成本函数的基本规则是折叠未被“空白”分隔的重复字符。使用这个下划线来表示特殊的空白字符，这与空格字符不同。通过折叠未被空格分隔的重复字符，它实际上将序列折叠为`t、h、e`，然后是空格和`q`。插入一堆空白字符，最终输出的文本记录仍然很短。这里的短语“`the quick brown fox`”包括空格有`19`个字符，较新的网络允许网络插入空格和重复字符而被强制超过一千个字符，并且仍然可以用这`1000`个{% mathjax %}y{% endmathjax %}值输出表示这`19`个字符的输出。`Alex Grace`的这篇论文使用了这个想法来构建有效的语音识别系统。

##### 触发词检测

随着语音识别的兴起，越来越多的设备可以通过语音唤醒，这些设备被称为**触发词检测系统**。那么让我们看看如何构建触发词系统。**触发词系统**的示例有`Amazon Echo`，它可以通过`Alexa`一词唤醒，百度`DuerOS`驱动的设备可以通过短语`xiaodunihao`唤醒，`Apple Siri`可以通过`hey，Siri`启动，`Google Home可`以通过`Okay，Google`唤醒。多亏了**触发词检测**，如果您的客厅里有`Amazon Echo`，您可以走进客厅，只需说`Alexa`，现在几点了？被`Alexa`一词触发并进行语音查询。**触发检测算法**的文献仍在发展，因此对于触发词检测的最佳算法尚未达成广泛共识。现在有`RNN`，获取一个音频片段，并计算频谱图特征。这会生成特征{% mathjax %}x^{<1>},x^{<2>},x^{<3>}{% endmathjax %}，然后将其传递给`RNN`。剩下要做的就是定义目标标签{% mathjax %}y{% endmathjax %}。某人刚刚说完触发词恰好是音频片段中的这一点，比如`Alexa`，那么在训练集中，您可以将该点之前的所有内容的目标标签设置为`0`，然后将该点的目标标签设置为`1`。稍后，触发词再次被说出来可以在此之后再次将目标标签设置为`1`。这种`RNN`标记方案可以发挥作用。这样做的一个小缺点是，它会创建一个非常不平衡的训练集，其中包含很多的 `0`而不是`1`。不是只设置一个时间步长输出`1`，你可以让它连续输出几个`1`，或者在固定的一段时间内输出几个`1`，然后再恢复为`0`。这样可以平衡`1`和`0`的比例。但如果这是在音频剪辑器中说出触发词时，那么紧接着，你可以将目标标签设置为`1`，如果这是再次说出的触发词，那么紧接着就是你想要`RNN`输出`1`的时候。

