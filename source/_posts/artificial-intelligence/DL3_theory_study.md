---
title: 深度学习(DL)(三) — 探析
date: 2024-09-08 12:15:11
tags:
  - AI
categories:
  - 人工智能
mathjax:
  tex:
    tags: 'ams'
  svg:
    exFactor: 0.03
---

#### 介绍

假设您要输入一个法语句子，如`Jane visite I'Afrique Septembre`，并且要将其翻译成英语句子，`Jane is visiting Africa in September`。我们使用{% mathjax %}x^{<1>},\ldots,x^{<5>}{% endmathjax %}来表示单词和输入序列，我们将使用{% mathjax %}y^{<1>},\ldots,y^{<6>}{% endmathjax %}来表示输出序列中的单词。您如何训练神经网络来输入序列{% mathjax %}x{% endmathjax %}并输出序列{% mathjax %}y{% endmathjax %}？首先，让我们建立一个网络，称之为**编码器网络**，将其构建`RNN`，这可能是`GRU`或`LSTM`，一次一个单词地输入法语单词。在获取输入序列后，`RNN`会输出一个表示输入句子的向量。之后，您可以构建一个**解码器网络**。**编码器网络**的编码输出作为输入，然后可以训练一次一个单词地输出翻译。最后，识别出序列的结尾和解码器停止的句子标记，这样它们在使用语言模型合成文本时保持在之前的序列中。深度学习最显著的成果之一是模型有效性。给定足够多的法语和英语句子对，如果你训练一个模型来输入法语句子并输出相应的英语翻译，这很有效。这个模型只使用一个**编码器网络**，找到输入法语句子的编码，然后使用一个**解码器网络**生成相应的英语翻译。
<!-- more -->

#### 序列->序列

机器翻译模型如下所示，我将使用两种不同的颜色，绿色和紫色，分别表示绿色的**编码器网络**和紫色的**解码器网络**。您会注意到，**解码器网络**看起来与上面的语言模型几乎完全相同。因此，机器翻译模型与语言模型非常相似，只是它不是从全零向量开始，而是有一个**编码器网络**，可以找出输入句子的一些表示，它获取该输入句子，并从输入句子的表示而不是全零的表示开始解码网络。所以，这就是将其称为条件语言模型的原因，它不是对任何句子的**概率**进行建模，而是对输出英语翻译的概率进行建模，条件是输入一些法语句子。例如，翻译为“`Jane is visite l'Afrique en septembre`”的概率是多少，但输入的法语句子的条件是“`Jane visite l'Afrique en septembre`”。这实际上是英语句子以输入的法语句子为条件的概率，这就是为什么它是一个条件语言模型。如果想应用此模型将句子从法语翻译成英语，给定这个输入的法语句子，该模型会告诉您相应的英语翻译存在差异的概率。{% mathjax %}x{% endmathjax %}是法语句子“`Jane visite l'Afrique en septembre`”。并且，不希望随机抽样输出。如果从这个分布中抽取单词，给定{% mathjax %}\mathbf{P}(\hat{y}^{<1>},\ldots,\hat{y}^{<T_y>}|x){% endmathjax %}，也许会得到一个相当不错的翻译，“`Jane is visite l'Afrique en septembre`”。但是，也许另一次你会得到不同的翻译，这听起来有点别扭，但不是一个糟糕的翻译，只是不是最好的。当使用这个模型进行机器翻译时，你并不是从这个分布中随机抽样。相反，你想要的是找到最大化条件概率的英语句子{% mathjax %}y{% endmathjax %}。在开发机器翻译系统时，你需要做的事情就是想出一个算法，可以真正找到最大化这个{% mathjax %}y{% endmathjax %}值。最常见的算法称为**定向搜索**，为什么不直接使用**贪婪搜索**呢？什么是贪婪搜索？**贪婪搜索**是一种计算机算法，它表示要生成第一个单词，只需根据条件语言模型选择最有可能的第一个单词即可。进入机器翻译模型，在选择第一个单词后，选择看起来最有可能的第二个单词，然后选择看起来最有可能的第三个单词。这种算法称为**贪婪搜索**。而你真正想要的是选择整个单词序列，{% mathjax %}y^{<1>},y^{<2>},\ldots,y^{<T_y>}{% endmathjax %}，这可以最大化整个单词的**联合概率**。贪婪方法并不奏效，即只选择最佳的第一个单词，然后在选择最佳的第一个单词后，尝试选择最佳的第二个单词，在此之后，尝试选择最佳的第三个单词。为了证明这一点，让我们考虑以下两个翻译。第一个翻译更好，所以希望在我们的机器翻译中翻译模型会说，对于第一个句子，{% mathjax %}\mathbf{P}(y){% endmathjax %}更高。这只是对法语输入的更好、更简洁的翻译。第二个翻译并不差，只是更冗长，有更多不必要的单词。但是，如果算法选择“`Jane is`”作为前两个单词，因为“`going`”是一个更常见的英语单词，那么在法语输入的情况下，“`Jane is going`”的概率实际上可能高于在法语句子的情况下“`Jane is visit`”的概率。如果最大化前三个单词的概率来选择第三个单词，那么最终可能会选择第二个选项。但是，这最终会导致句子不太理想，根据该模型对{% mathjax %}\mathbf{P}(y|x){% endmathjax %}的测量，句子不太好。如果你想找到单词序列{% mathjax %}y^{<1>},y^{<2>}{% endmathjax %}一直到最后一个单词，使概率最大化，那么一次只选择一个单词并不总是最佳选择。当然，英语句子中单词组合的总数要大得多。如果字典里只有`10,000`个单词，你正在考虑翻译长度不超过`10`个单词，那么就有{% mathjax %}10000^{10}{% endmathjax %}个可能的句子，长度为`10`个单词。从词汇量中挑选单词，字典大小为`10,000`个单词。这是一个巨大句子空间，不可能对它们全部进行评级，这就是为什么最常见的做法是使用**近似搜索算法**。**近似搜索算法**的作用是选择使条件概率最大化的句子{% mathjax %}y{% endmathjax %}。即使不能保证找到使这个值最大化的{% mathjax %}y{% endmathjax %}值，它通常也能做得很好。

**集束搜索**(`Beam Search`)算法是一种**启发式搜索算法**，主要用于处理解空间较大的问题，尤其在自然语言处理(`NLP`)领域的序列生成任务中，如机器翻译、文本摘要和语音识别等。让我们使用法语句子“`Jane, visite l'Afrique en Septembre`”的运行示例尝试**集束搜索**。希望翻译成“`Jane, visits Africa in September`”。**集束搜索**要做的第一件事是选择英语翻译的第一个单词输出。这里列出了`10,000`个单词到词汇表中。为了简化问题，将忽略大写。把所有单词都用小写字母列出来。在**集束搜索**(`Beam Search`)的第一步中，使用这个网络片段，**编码器**用绿色表示，**解码器**用紫色表示，来评估第一个单词的概率。给定输入句子{% mathjax %}x{% endmathjax %}法语输入，第一个输出{% mathjax %}y{% endmathjax %}的概率是多少。**贪婪搜索**只会选择一个最有可能的单词继续前进，而**集束搜索**(`Beam Search`)则可以考虑多种替代方案。**集束搜索**(`Beam Search`)算法有一个参数称为{% mathjax %}B{% endmathjax %}，称为**波束宽度**，在这个例子中，{% mathjax %}B = 3{% endmathjax %}。**集束搜索**(`Beam Search`)会同时考虑三种可能性。假设对第一个单词的不同选择评估这个概率，发现`Jane`和`September`是英语输出中第一个单词最有可能的三种可能性。**集束搜索**(`Beam Search`)会尝试这三个单词的信息隐藏在计算机内存中，如果**集束宽度**参数的设置不同，{% mathjax %}B = 10{% endmathjax %}，那么跟踪第一个单词最有可能的`10`个选项，而不是`3`个。为了执行**集束搜索**(`Beam Search`)的第一步，需要做的是将输入的法语句子通过**编码器网络**运行，这是一个总共`10,000`种可能性的`softmax`输出。然后将获取这`10,000`个可能的输出，并将其中的前三个输出保存在内存中。**集束搜索**(`Beam Search`)的第二步。在选择了`in、Jane`和`September`作为第一个单词最有可能的三个选项之后，**集束搜索**(`Beam Search`)现在要做的是，针对这三个选项中的每一个，考虑第二个单词应该是什么，所以在“`in`”之后，第二个单词可能是“`a`”，可能是`September`，列表中有`visit`，然后一直到`z`，最后一个单词是`zulu`。为了评估第二个单词的概率，它将使用此神经网络片段，其中绿色的是`coder`，对于解码器部分，解码器首先输出`y hat one`。把这个{% mathjax %}\hat{y}^{<1>}{% endmathjax %}设置为单词“`in`”。然后它将输出是{% mathjax %}\hat{y}^{<2>}{% endmathjax %}。通过{% mathjax %}\hat{y}{% endmathjax %}，这里的输入实际上是第一个单词“`in`”，这个网络片段可用于评估给定输入法语句子的第二个单词的概率，以及翻译的第一个单词是否是单词“`in`”。现在请注意，我们最终关心的是在这个第二步的**集束搜索**(`Beam Search`)中，找到最有可能的第一个单词和第二个单词的配对，而不仅仅是第二个单词，其中最有可能的是第一个单词和第二个单词的配对，而最有可能的是**条件概率规则**。这可以表示为{% mathjax %}\mathbf{P}(y^{<1>}|x^{<1>})\mathbf{P}(y^{<2>}|x^{<2>}){% endmathjax %}。这是从这个网络片段中获得的，如果对于选择的三个单词“`in`”、“`Jane`”和“`September`”，您保存了这个概率，那么您可以将它们乘以第二个概率以获得第一个单词和第二个单词的概率。所以现在你已经看到了如果第一个单词是“`in`”，你如何评估第二个单词的概率。一开始是“`Jane`”。句子可以是“`Jane a`”、“`Jane Aaron`”，等等，直到“`Jane is`”、“`Jane visits`”等等。你会在神经网络片段中使用它，在这里你会硬连线，{% mathjax %}\hat{y}^{<1>}{% endmathjax %}是`Jane`。所以第一个单词{% mathjax %}y{% endmathjax %}被硬连线为 `Jane`，那么网络片段就可以告诉您第二个单词的概率。假设第一个单词是“`Jane`”。与上述相同，您可以将Y1 与 P 相乘，以获得第二个单词的这10,000个不同可能选项中的每一个的 Y1 和 Y2 的概率。最后对`September`执行相同的操作，从`a`到`Zulu`的所有单词，并使用这个网络片段。第一个单词是否是`September`。第二个单词最有可能的选项是什么。对于第二步的**集束搜索**(`Beam Search`)，继续使用{% mathjax %}B = 3{% endmathjax %}束宽度，词汇表中有`10,000`个单词，最终会考虑{% mathjax %}3\times 10000{% endmathjax %}种可能性，因为这里有10,000个，10,000 个，10,000 是束宽度乘以词汇表中的单词数，您要做的是根据可能的第一个和第二个单词评估这`30,000`个选项，然后选择前三个。因此，经过缩减，这`30,000`个可能性再次减少到`3`，**集束宽度**再次四舍五入，假设`30,000`个选项中最有可能的是`September`，如果**集束搜索**(`Beam Search`)确定最有可能的选择是第一个和第二个单词是`in September、Jane is`或`Jane visits`。那么它现在拒绝 `September`作为输出英语翻译的第一个单词的候选，现在只剩下两个单词的可能性，但仍然{% mathjax %}B = 3{% endmathjax %}，用于跟踪{% mathjax %}y^{<1>},y^{<2>}{% endmathjax %}对的三个选择，最后进入**集束搜索**(`Beam Search`)的第三步。由于{% mathjax %}B = 3{% endmathjax %}，每一步你都会实例化三个网络副本来评估这些部分句子片段和输出。正是因为{% mathjax %}B = 3{% endmathjax %}，才有三个网络副本，对于第一个单词有不同的选择，但这三个网络副本可以非常有效地用于评估第二个单词的所有`30,000`个选项。不要实例化`30,000`个网络副本或三个网络副本来快速地评估该`softmax`输出的`10,000`个可能的输出，假设前两个单词最有可能的选择是`in September、Jane is 和 Jane visits`，对于这些单词对，我们应该在计算机内存中保存{% mathjax %}By^{<1>}{% endmathjax %}和{% mathjax %}y^{<2>}{% endmathjax %}的概率，给定输入{% mathjax %}x{% endmathjax %}。现在要考虑第三个单词是什么。那么`in September a？In September Aaron？`一直到`in September Zulu`，为了评估第三个单词的可能选择，可以使用这个网络片段，其中将第一个单词硬连线为第二个单词`September`。因此，这个网络片段允许您评估第三个单词的概率，给定输入法语句子{% mathjax %}x{% endmathjax %}，给定前两个单词`in September`和英语输出。然后对第二个片段执行相同的操作。就像这样。对`Jane visits`执行相同的操作，**集束搜索**(`Beam Search`)将再次选择前三个可能，可能是`September`。`Jane`是可能的结果，或者`Jane is visiting`是可能的，或者`Jane visits Africa`是可能的，这是前三个词，然后进入第四步，即**定向搜索**，再加一个词，然后继续。这个过程的结果是，希望每次添加一个词，**定向搜索**将决定这一点。`Jane visits Africa in September`将在句子结尾符号处终止。对于三个**定向搜索**一次考虑三种可能性。注意，如果定向宽度等于`1`，那么本质上就变成了**贪婪搜索算法**，但同时考虑多种可能性，比如说三个、十个或其他数字，**定向搜索**通常会找到比**贪婪搜索**更好的输出句子。