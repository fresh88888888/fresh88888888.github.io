---
title: 数据科学 — 数学(二)（机器学习）
date: 2024-08-09 17:35:11
tags:
  - AI
categories:
  - 人工智能
mathjax:
  tex:
    tags: 'ams'
  svg:
    exFactor: 0.03
---

#### 向量代数

##### 点积

用矩阵和向量表达线性方程组的非常简洁的方法，称为**点积**。点积是线性代数中非常重要的运算。
<!-- more -->

假设您有以下问题。您买了一些水果，比如说两个苹果、四根香蕉和一个樱桃。每个苹果售价`3`美元，每根香蕉售价`5`美元，每颗樱桃售价`2`美元。问题是，每样东西的总价是多少？这是一个简单的问题，但关键在于如何表达它。表达水果数量的方法是使用一个向量，它只是一列数字，`2、4、1`。这就是我们购买的每种水果的数量。价格也可以表示为一个包含`3、5、2`的向量。为了找到所有水果的总价，你可以单独找到每种水果的价格，即两个苹果乘以三，即每个苹果的总价，得到{% mathjax %}2\times 3 = 6{% endmathjax %}美元。这就是你在苹果上花费的金额。你可以对香蕉做同样的事情，得到{% mathjax %}4\times 5 = 20{% endmathjax %}，对樱桃做同样的事情，所以{% mathjax %}1\times 2 = 2{% endmathjax %}。`6`是你在苹果上花费的金额，`20`是香蕉，`2`是樱桃。水果的总价是：{% mathjax %}6 + 20 + 2 =28{% endmathjax %}。现在所做的就是**点积**，因为你可以像这样缩写：{% mathjax %}2\times 3 + 4\times 5 + 1\times 2 = 28{% endmathjax %}。我们实际上可以这样表达。更常见的是将第一个向量作为一行，将第二个向量作为一列，然后获取点积。向量`(2,4,1)`和`(3,5,2)`的点积是每个对应项对的总和。点积在线性代数中很常用，接下来您将看到它的一些用途。

**点积**和**范数**之间有很好的联系。让我们回到坐标为`(4,3)`的向量，其范数为5。注意一件事，{% mathjax %}\sqrt{4^2 + 3^2} = 5{% endmathjax %}实际上是向量与其自身的点积。`L2`范数始终是向量与其自身点积的平方根。有时您会看到它以这种符号写成，左边有一个尖括号，右边有一个尖括号。
{% asset_img m_1.png  %}

让我们回到我之前向您展示的将列向量转换为行向量的操作。这称为**转置**，它本质上是**将列转换为行**。用上标`T`表示该操作。结果会将此列向量转换为行向量。您也可以将转置应用于行向量，其工作方式完全相同，只是现在行向量已转换为列向量。您还可以**转置矩阵**。
{% asset_img m_2.png  %}

让我通过添加第二列向您展示如何操作。这现在是一个三乘二矩阵。要转置矩阵，只需转置每一列。首先，您将获得原始矩阵的第一列，然后对其进行转置以获得转置矩阵的第一行。然后对第二列执行相同的操作。同样，您将列转换为行。请注意，矩阵的维度互换。如果您从三乘二矩阵开始，其转置将是一个二乘三矩阵。
{% asset_img m_3.png  %}

让我们通过查看点积的正式定义来结束。从两个具有相同数量分量的向量{% mathjax %}x{% endmathjax %}和{% mathjax %}y{% endmathjax %}开始。那么点积就是{% mathjax %}x_1y_1 + x_2y_2{% endmathjax %}，然后将这些乘积添加到所有{% mathjax %}n{% endmathjax %}个分量上。
{% note warning%}
请注意，尖括号是点积的另一种表示法。在某些情况下，点积的左侧是行向量，右侧是列向量。在这些情况下，您可能会看到对其中一个向量使用转置，以使它们正确排列。
{% endnote %}
{% asset_img m_4.png  %}

##### 几何点积

首先，我们来看看这两个垂直的，也叫**正交向量**，它们的项是`(-1, 3)`和`(6, 2)`。现在取点积，注意点积是：{% mathjax %}6 \times -1 + 2 \times 3 = 0{% endmathjax %}。事实上，只要点积是`0`，那么这两个向量是正交的。
{% asset_img m_5.png  %}

**一个向量和它本身之间的点积恰好是范数的平方，或者向量长度的平方**。两个垂直或正交向量之间的点积始终为`0`。那么两个随机向量{% mathjax %}u{% endmathjax %}和{% mathjax %}v{% endmathjax %}之间的点积呢？有没有什么好的方法可以写出来？事实证明是有的。所以让我们从不同的角度来看待它。**向量本身的点积是范数的平方除以范数和它本身的乘积**。一个向量和一个同方向的长向量的点积非常相似，它只是两个范数的乘积，即{% mathjax %}u{% endmathjax %}范数乘以{% mathjax %}v{% endmathjax %}范数。那么，哪些向量之间有角度呢？它们几乎相同，只是你必须将一个向量垂直投影到另一个向量上，这恰好是一个向量在另一个向量上留下的形状。因此，如果这个向量是{% mathjax %}u{% endmathjax %}素数，那么{% mathjax %}u{% endmathjax %}和{% mathjax %}v{% endmathjax %}之间的点积就是{% mathjax %}u{% endmathjax %}素数的幅度与{% mathjax %}v{% endmathjax %}幅度的乘积。有趣的是，无论你将{% mathjax %}u{% endmathjax %}投影到{% mathjax %}v{% endmathjax %}上还是将{% mathjax %}v{% endmathjax %}投影到{% mathjax %}u{% endmathjax %}上，你仍然会得到相同的点积。一个更容易理解的方法是，如果向量之间的角度是{% mathjax %}\theta{% endmathjax %}，那么{% mathjax %}u{% endmathjax %}和{% mathjax %}v{% endmathjax %}的点积就是{% mathjax %}u{% endmathjax %}幅度乘以{% mathjax %}v{% endmathjax %}幅度乘以角度的余弦。
{% asset_img m_6.png  %}

利用你所了解的点积，你现在可以判断两个向量之间的点积是正数、负数还是`0`。例如，看一下向量`(6, 2)`。与其垂直的向量（例如`(-1, 3)`）与向量`(6, 2)`的点积为`0`。它右边的向量（例如`(2, 4)`）的点积为`20`，为正数。它左边的向量（例如`(-4, 1)`）的点积为`-22`，为负数。那么，为什么与`(2, 4)`的点积为正数？嗯，原因是这个向量在两个`(6, 2)`上的投影长度为正，而与`(-4, 1)`的点积为什么为负数？原因是向量`(6, 2)`上的投影是负的，因为你必须沿向量`(6, 2)`的反方向移动。因此，向量点积的正弦对应于垂直向量的一侧或另一侧。
{% asset_img m_7.png  %}

换句话说，这种情况很常见。如果向量是{% mathjax %}u{% endmathjax %}，那么与{% mathjax %}u{% endmathjax %}点积为`0`的向量都是垂直于{% mathjax %}u{% endmathjax %}的向量。与{% mathjax %}u{% endmathjax %}点积为正的向量都是这个区域内的向量，与{% mathjax %}u{% endmathjax %}点积为负的向量都是这个区域内的向量。
{% asset_img m_8.png  %}

##### 矩阵与向量相乘

**两个向量之间的点积是相应元素乘积的总和**。例如{% mathjax %}2a + 4b + c = 28{% endmathjax %}，可以写成行向量的乘积，行向量的元素为`2、4、1`。列向量的元素为未知数`a、b、c`。向量可以有变量。这表示一个方程，其中列向量中的未知数代表每种水果的价格，而行向量中的数字代表您购买的每种水果的数量。`28`美元表示两个向量的点积。现在，假设您有一个由三个方程组成的系统，其中有三个未知数。这些方程中的每一个都可以表示为点积。例如，第一个方程{% mathjax %}a + b + c = 10{% endmathjax %}可以表示为向量`(1、1、1)`（即{% mathjax %}a,b{% endmathjax %}和{% mathjax %}c{% endmathjax %}的系数）与向量{% mathjax %}a,b{% endmathjax %}和{% mathjax %}c{% endmathjax %}（变量）的点积，等于`10`。等式：{% mathjax %}a + 2b + c = 15{% endmathjax %}可以看作是`(1、2、1)`与`(a、b、c)`的乘积，等于`15`。最后，等式{% mathjax %}a + b = c{% endmathjax %}可以看作是向量`(1、1、2)`与向量`(a、b、c)`的乘积，等于 `12`。
{% asset_img m_9.png  %}

现在，用三个不同的点积来表示这个方程似乎很笨拙。有没有更好的方法？答案是有的。我们要做的第一件事就是把它们像这样放。在左边，我们有三个方程组和三个未知变量，在右边，我们有三个点积。
{% asset_img m_10.png  %}

请注意，列向量是相同的，因此我们可以简单地将三个向量合并并得到一个矩阵。现在我们得到了矩阵和向量的乘积。矩阵和向量的乘积只不过是三个点积堆叠在一起。如果你的系统中有更多的方程，那么你就有一个更大的矩阵。
{% asset_img m_11.png  %}

但从现在开始，我们将把方程组表示为矩阵乘以向量的乘积。请注意，这是一个{% mathjax %}3\times 3{% endmathjax %}矩阵，有三行三列，这个向量的长度为三。矩阵中的列数必须等于向量的长度。如果它们不匹配，你实际上是在尝试对具有不同长度的向量进行点积，这是未定义的。然而，有趣的是，只要这两个圆的尺寸匹配，矩阵就可以是矩形。例如，你可以添加第四个线性方程来创建一个{% mathjax %}4\times 3{% endmathjax %}矩阵，然后将其乘以包含三个分量{% mathjax %}a,b{% endmathjax %}和{% mathjax %}c{% endmathjax %}的向量。注意长度为四的向量的结果将与矩阵中的行数相匹配。
{% asset_img m_12.png  %}

#### 线性变换

**矩阵**还有另一种非常强大且非常有用的表示形式，那就是**线性变换**。**线性变换**是一种以非常结构化的方式将平面上的每个点发送到平面上的另一个点的方法。假设您有一个{% mathjax %}2\times 2{% endmathjax %}矩阵，其元素为{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}。首先考虑两个平面，其入口标记为{% mathjax %}a{% endmathjax %}和{% mathjax %}b{% endmathjax %}。变换将以下方式将左侧平面上的每个点移动到右侧平面上的一个点。任何点都有两个坐标。这两个坐标形成一个列向量。为了得到右边的向量，我们将第一个向量乘以矩阵，得到的任何向量都是右边的点。首先，让我们看一下原点。`(0,0)`变成向量`(0,0)`，我们将其乘以矩阵，得到向量`(0,0)`。这实际上总是发生在线性变换中。原点被移动到原点。现在让我们看看点`(1,0)`。因此矩阵乘以向量`(1 0)`得到向量`(3,1)`。现在让我们看看`(0,1)`。矩阵乘以`(0,1)`等于`(1,2)`。最后让我们看看`(1,1)`。矩阵乘以向量`(1,1)`得到向量`(4,3)`。实际上这定义了整个变换。让我们看看这四个点形成的小正方形。它变为这个平行四边形。左边的正方形称为**基**。右边的平行四边形也是如此。它们是线性代数中非常非常重要的概念。稍后你就会知道为什么它们被称为基，基的一个非常特殊的属性是它们覆盖整个平面。实际上，由于这个正方形实际上镶嵌了整个平面，平行四边形也镶嵌了整个平面。那么**线性变换就简单地定义为坐标的变化**。例如，如果我们想找到点`(-2,3)`的位置，那么左边的点`(-2,3)`可以从原点开始向左走两个坐标单位，向上走三个坐标单位。因此，为了找到该点在线性变换中的位置，我们只需从原点开始，在这些新坐标中向左走两个坐标单位，向上走三个坐标单位。我们得到了点`(-3,4)`。
{% asset_img m_13.png  %}

用买苹果和香蕉的语言来说。我喜欢以以下方式看待变换。假设你第一天去商店买了三个苹果和一个香蕉。第二天你买了一个苹果和两根香蕉。所以如果苹果的价格是{% mathjax %}a{% endmathjax %}，香蕉的价格是{% mathjax %}b{% endmathjax %}。那么第一天和第二天的价格就是向量的元素，该向量对应于这两个矩阵的乘积，元素为`(3、1、1、2)`。向量为{% mathjax %}ab{% endmathjax %}。线性变换将你从左边的点（访问苹果的价格和香蕉的价格）带到右边的点（访问第一天支付的金额和第二天支付的金额）。所以苹果是`1`美元，香蕉也是`1`美元。那么第一天你支付了`4`美元，第二天你支付了`3`美元，矩阵的线性变换将坐标为`(1,1)`的点移动到坐标为`(4,3)`的点。坐标的变化就是苹果和香蕉的价格变为第一天和第二天的支付金额。

假设我们有一个隐身矩阵，我们知道它将这个基本方格移动到这个矩阵中，目标是找到矩阵的元素。让我们看看它将每个点移动到哪里？点`(0,0)`被移动到`(0,0)`。点`(1,0)`被移动到`(3,-1)`，即右下角。点`(0,1)`被移动到`(2, 3)`，点`(1,1)`被移动到`(5,2)`。我们只需要这里的这两个点。使用箭头来表示这个点，因为向量往往从原点一直延伸到该点的箭头来表示。坐标为`(1,0)`的向量被移动到坐标为`(3,-1)`的向量，坐标为`(0,1)`的向量被移动到坐标为`(2,3)`的向量。将向量`(1,0)`和`(0,1)`移动到`(3,-1)`和`(2,3)`的矩阵恰恰是具有列`(3, -1)`和`(2, 3)`的矩阵。这就是将线性变换转换为对应矩阵的方法。你只需查看两个基本向量`(1,0)`和`(0,1)`的位置，它们就是矩阵的列。
{% asset_img m_14.png  %}

##### 矩阵乘法

假设你有一个矩阵{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}。让我们快速看一下这里的线性变换。向量`(1,0)`变为`(3,1)`。向量`(0,1)`变为向量`(1,2)`。但让我们从右侧的向量开始。让我们看看矩阵{% mathjax %}\begin{bmatrix} 2 & -1\\ 0 & 2 \end{bmatrix}{% endmathjax %}线性变换。如何作用于这两个向量，现在是向量`(3,1)`。`(3,1)`变为`(2,5)`。这个向量指向右侧的点`(2,5)`。另一个向量是`(1,2)`。此矩阵乘以`(1,2)`变为向量`(0,4)`，因此我们绘制`(0,4)`。然后左边的平行四边形变成右边的平行四边形。这是线性变换的一种方法。现在让我们把它们放在一起。我们有第一个线性变换矩阵{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}，第二个线性变换矩阵{% mathjax %}\begin{bmatrix} 2 & -1\\ 0 & 2 \end{bmatrix}{% endmathjax %}。如果我们忘记中间的那个，那么第一个和第三个之间就有一个线性变换，而这必定对应某个矩阵。问题是，什么矩阵对应那个线性变换？让我们简化一点，只看基向量。通过只看左边和右边，我们会看到左边的向量`(1,0)`被移动到右边的`(5,2)`。因此，正如我们之前看到的，矩阵的第一列是`(5,2)`。另一个基向量，向量`(0,1)`，被移动到向量`(0,4)`。因此，矩阵的第二列是`(0,4)`。
{% asset_img m_15.png  %}

两个线性变换的组合给出了与矩阵{% mathjax %}\begin{bmatrix} 5 & 0\\ 2 & 4 \end{bmatrix}{% endmathjax %}相对应的线性变换。现在，我们有没有办法从另外两个矩阵获得？答案是可以的。这就是矩阵乘法。这里的运算是左边的矩阵乘以右边的矩阵等于第三个矩阵。现在注意矩阵被翻转了。这对应于第一个线性变换，即左边的矩阵，而这对应于第二个线性变换。这是非常重要的一点。原因是线性变换作用于左边的向量，所以你要将矩阵乘以向量。因此，你首先将矩阵{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}相乘，然后将矩阵{% mathjax %}\begin{bmatrix} 2 & -1\\ 0 & 2 \end{bmatrix}{% endmathjax %}相乘，这样它们的方向就相反了。那么，有没有一种快速的方法可以查看矩阵乘法，而无需绘制线性变换？答案是肯定的，因为它有很多点积。基本上，将左侧矩阵视为两行，将右侧矩阵视为两列，然后取行和列之间点积的所有可能组合。例如，第一行和第一列位于左上角，而右侧第一行和第二列位于右上角。第一个是`5`，第二个是`0`，第三个是`2`，第四个是`4`。
{% asset_img m_16.png  %}

矩阵{% mathjax %}\begin{bmatrix} 5 & 0\\ 2 & 4 \end{bmatrix}{% endmathjax %}是这两个矩阵的乘积。总之，你可以将**矩阵积视为两个矩阵相乘**，但也可以将其视为将两个线性变换组合成第三个线性变换。此示例中的每个矩阵都是一个{% mathjax %}2\times 2{% endmathjax %}矩阵，但是当你的矩阵不像这样的方阵时，乘法也有定义。
{% asset_img m_17.png  %}

让我给你举个例子。这次我将一个{% mathjax %}2\times 3{% endmathjax %}矩阵和一个{% mathjax %}3\times 4{% endmathjax %}矩阵相乘。结果将是一个{% mathjax %}2\times 4{% endmathjax %}矩阵。请记住，要乘以矩阵，你需要从第一个矩阵中取出行，从第二个矩阵中取出列。第一个点积是`(3,1,4)`和`(3,1,-2)`的点积。结果是`2`。下一个点积是`(3,1,4)`和`(0,5,1)`，结果为`9`。完成矩阵的这一行将得到`21`和`-6`的点积。现在让我们检查矩阵的左下角单元格。按照这个模式，我将取第一个矩阵的第二行和第二个矩阵的第一列的点积。这是{% mathjax %}2\times 3-1\times 1+ ​​-2\times 2 = 1{% endmathjax %}。继续使用相同的模式，您可以求解矩阵的其余值。
{% asset_img m_18.png  %}

这些示例向您展示了即使矩阵都是矩形，也可以将它们相乘。首先，第一个矩阵的列数必须与第二个矩阵的行数匹配。换句话说，这里圈出的数字需要匹配。其次，结果矩阵从第一个矩阵中获取行数。换句话说，这里圈出的数字需要匹配。最后，结果从第二个矩阵中获取列数，因此这里圈出的数字需要匹配。您只需取第一个矩阵的行和第二个矩阵的列的点积来填充结果矩阵的每个单元格。

当我想到乘法时，我认为`1`是一个非常特殊的数字。`1`之所以特殊，是因为当你将任何数字乘以`1`时，你得到的数字与你开始时的数字相同。**单位矩阵**在矩阵中扮演着完全相同的角色。单位矩阵是与任何其他矩阵相乘时都会得到相同矩阵的矩阵，其相应的线性变换非常简单。它是使平面保持完整的矩阵。单位矩阵看起来非常简单。它在对角线上为`1`，其他地方为`0`。当你将它乘以任何向量，比如说，包含{% mathjax %}a,b,c,d,e{% endmathjax %}的向量时，你可以验证得到的向量包含{% mathjax %}a,b,c,d,e{% endmathjax %}的向量。
{% asset_img m_19.png  %}

##### 逆矩阵

矩阵可以有一个与之相关的非常特殊的矩阵，称为**逆矩阵**。当我想到矩阵的逆时，我会想到一个数字的逆，即当与它相乘时得到`1`的数字。例如，数字`2`的逆是数字`1/2`，而负`5`的逆是负`1/5`。**逆矩阵**正是矩阵乘积为**单位矩阵**的矩阵。在线性变换中，**逆矩阵**是撤销原始矩阵工作的矩阵，即将平面返回到其起始位置的矩阵。**逆矩阵**的工作原理如下。想象一下，您有一个线性变换，对应于具有元素{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}的普通矩阵，它将正方形变成这里的平行四边形。现在存在一些变换可以将这个平行四边形变回原始正方形。不用担心矩阵的元素，我们稍后会找到它们。只要知道有一个，那就意味着两个变换的组合就是对应于单位矩阵的那个，对平面没有任何影响。
{% asset_img m_20.png  %}

如果**逆矩阵**是具有元素{% mathjax %}\begin{bmatrix} a & b\\ c & d \end{bmatrix}{% endmathjax %}的矩阵，意味着当我们将原始矩阵乘以逆矩阵时，我们得到的是单位矩阵。现在就像数字一样，我们将原始矩阵的`-1`次方称为**逆矩阵**。就像你说{% mathjax %}2^{-1} = \frac{1}{2}{% endmathjax %}一样，那么这个矩阵的`-1`次方就是逆矩阵。而这个矩阵恰好有这些元素，你可以验证，如果你将原始矩阵乘以这个矩阵，你会得到单位矩阵。现在我们如何找到这个逆矩阵中的元素？答案是通过**解线性方程组**。所以请注意，如果我们将左边这个矩阵中的元素取为右边这个对应元素的元素，那么我们实际上有以下四个点积。这些点积中的每一个都会给我们一些线性方程。现在您有一个包含四个未知数的四个线性方程组，分别是{% mathjax %}a,b,c,d{% endmathjax %}。我们可以使用通常的消元法来求解它，得到{% mathjax %}a = \frac{2}{5}、b = -\frac{1}{5}、c = -\frac{1}{5}、c = \frac{3}{5}{% endmathjax %}。
{% asset_img m_21.png  %}

有些矩阵没有逆矩阵。那么矩阵有逆矩阵还是没有逆矩阵的规则是什么呢？矩阵的行为很像数字。你只需要意识到有些矩阵有**乘法逆**，就像有些数字有乘法逆一样。例如，五的逆是`1/5`。八的逆是`1/8`。但是，并非所有数字都有乘法逆。例如，零的逆是什么？零的逆没有定义，因为没有一个数字乘以零会得到`1`。有些矩阵有逆矩阵，有些矩阵没有。如下图所示，正如你之前看到的，前两个是非奇异的，第三个是奇异的。非奇异矩阵总是有逆矩阵，奇异矩阵永远没有逆矩阵。当你看行列式时，可逆矩阵的行列式非零，就像非零数有逆一样，不可逆矩阵的行列式为零，就像零没有乘法逆一样。我喜欢这样记住它。非零行列式矩阵有逆矩阵，零行列式意味着矩阵没有逆矩阵。

##### 神经网络和矩阵

**神经网络**是最成功、最强大的机器学习模型之一，应用范围广泛，它主要基于**矩阵**和**矩阵点积**。假设你有一个垃圾邮件的数据集，在这个垃圾邮件的数据集中，你已经确定了两个判定垃圾邮件的词，即`lottery`和`win`。这两个词更多地出现在垃圾邮件中，当然，出现并不能保证就是垃圾邮件。你已经计算了邮箱中垃圾邮件和非垃圾邮件出现的次数，并得到了这个表格。现在的目标是：“你想建立一个最好的垃圾邮件过滤器”。这被称为**分类器**，它会根据此表的内容尝试猜测电子邮件是否是垃圾邮件。这个特定的分类器将按以下方式工作。你给单词`lottery`和`win`分配一个**分数**，然后通过将重复单词的分数相加来计算句子的分数。例如，如果单词`lottery`和`win`的分数分别为`3`和`2`，那么句子`win, win the lottery`的总分为`7`分，每次出现`win`得`2`分，出现`lottery`得`3`分，单词`done`得`1`分。现在，猜测电子邮件是否为垃圾邮件的规则如下。如果句子的分数大于某个称为**阈值**的数值，则电子邮件被归类为垃圾邮件。否则，不是。注意。这并不意味着电子邮件是垃圾邮件，只是分类器认为它是垃圾邮件并将其发送到垃圾邮件箱。现在，测验的目标是找到最佳分类器。意味着尽可能符合表格结果的分类器。换句话说，你想找到单词`lottery`和`win`以及阈值的最佳分数，这样分类器的结果就尽可能接近表格中的垃圾邮件列。我给你一个提示，实际上可以找到三个数字，使分类器对表格中的每封电子邮件都做出正确的猜测。这是答案。实际上，许多答案都有效，但在测验的选项中，唯一有效的是这个。单词`lottery` 和`win`的分数都是`1`分，阈值是`1.5`分。请注意，当你计算句子的分数时，它们最终是每个单词出现次数的总和。当你检查数字是否大于等于阈值`1.5`时，答案列与记录电子邮件是否为垃圾邮件的列完全相同。这是该特定数据集的完美垃圾邮件过滤器。这意味着分类器在给定的数据集中表现相当不错。

现在这被称为**自然语言处理**，因为输入是语言，是单词，它使用这些单词进行预测。这个分类器也可以用下面的图形来表示。让我们在一个平面上绘制数据集，其中横轴是单词`lottery`出现的次数，纵轴是单词`win`出现的次数。数据集看起来像这样。请注意，一条线可以将垃圾邮件与非垃圾邮件分开。这条线恰好有一个由分数和阈值给出的方程，该阈值是一次`win`加上一次`lottery`，等于`1.5`。这条线还产生了两个区域，即**正区域**和**负区域**。正区域是句子中的分数大于阈值的区域，负区域是句子中的分数小于阈值的区域。这恰恰是一个**线性分类器**，它实际上是最简单的神经网络。
{% asset_img m_22.png  %}

它是一个只有一层的神经网络。还要注意，这个模型确实有意义。单词`lottery`和`win`出现的次数越多，句子中的分数就越高，电子邮件是垃圾邮件的可能性就越大。**一层神经网络可以看作是矩阵乘积，然后进行阈值检查**。就是这样。左边是数据集，中间是模型，这两个数字`(1,1)` 是单词`lottery`和`win`的分数。现在让我们看其中一行，比如第二行。这是一个句子，其中单词`lottery`出现了两次，单词`win`出现了一次。现在为了找到该句子的分数，只需将句子行和模型列的点积相乘即可得到{% mathjax %}2 + 1 = 3{% endmathjax %}。在点积之后，可以使用阈值进行检查。这个，如果结果大于`1.5`，则为是，否则为否。在这种情况下，{% mathjax %}3 > 1.5{% endmathjax %}，因此预测是垃圾邮件。
{% asset_img m_23.png  %}

让我们再做一次，比如说第五行。这个单词`win`只出现了一次，没有出现`lottery`。点积等于`1`，经过检查后，预测结果为 `no`，因为分类器不认为该电子邮件是垃圾邮件。现在请注意，如果您有更多的单词，您只需要在左侧有一个更宽的矩阵，在右侧有一个更长的模型向量，但这仍然有效。同时进行所有这些预测的一种更简单的方法是实际取矩阵和向量的乘积。如果我们取矩阵和这个向量的乘积，我们就会得到分数向量，我们所要做的就是将检查应用于这个向量中的所有元素以获得我们的预测。正如我之前提到的，如果你有很多单词，你只需要有一个更宽的矩阵和一个更长的模型向量，但这将完全一样。但现在，让我们回到两列的情况。这是另一种看待这个分类器的方式。检查垃圾邮件的公式是句子的分数大于阈值`1.5`。但这分数`-1.5`大于零是一样的。在这种情况下，这个`-1.5`称为**偏差**。将其包含在矩阵乘法中的方法是在数据表中添加一个带有数字`1`的整列，并在模型中添加一个带有偏差的角色，偏差为`-1.5`。现在，我们不必检查结果是否大于阈值 `1.5`，而只需检查修改后的分数是正数还是负数。这给了我们完全相同的分类器。有时你会看到带有偏差的分类器，有时带有阈值。
{% asset_img m_24.png  %}

对于更复杂的神经网络，偏差往往更常见。但不要太担心偏差，继续使用阈值，而是让我们看一个更简单的问题。这称为**结束运算符**。数据集实际上非常相似。它只是前一个数据集的四行，标签与之前相同，只不过现在它不再是垃圾邮件或非垃圾邮件问题。现在，如果`x`列和`y`列都包含一个，则结束列简单地表示“是”，否则表示否。这只是两个元素的结束运算符。现在我为什么要提到结束运算符？因为如果您将其视为一个小数据集，那么您可以使用神经网络对其进行建模。实际上，这与垃圾邮件检测器完全相同。当您将矩阵乘以这个模型向量时，您会得到这些结果。当您使用与之前相同的阈值进行检查时，您会得到与最终数据集完全相同的预测。最终数据集可以建模为**感知器**，即**单层神经网络**。从图形上看，这是分类器节点。它看起来与之前完全相同，它将点分开，只是现在只有点的子集。{% mathjax %}1\times x + 1\times y- 1.5 = 0{% endmathjax %}。
{% asset_img m_25.png  %}

下面是用图形的方式表示前一个感知器。输入是`x`和`y`，偏差是`-1.5`。如下图所示，节点内的数字乘以边缘的权重，然后将它们添加到下一个节点，然后应用激活函数。**激活准确地说是检查**。如果得到的结果是非负的，则返回`1`或“是”，如果得到的结果是负的，则返回`0`或“否”。输入是来自数据集的{% mathjax %}x{% endmathjax %}。模型的权重是{% mathjax %}W_s{% endmathjax %}，偏差是{% mathjax %}b{% endmathjax %}。在节点内部，出现一个与偏差相加的点积。然后，节点的输出通过激活函数，生成感知器的输出。
{% asset_img m_26.png  %}
