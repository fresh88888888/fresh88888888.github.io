---
title: 数据科学 — 数学(二)（机器学习）
date: 2024-08-09 17:35:11
tags:
  - AI
categories:
  - 人工智能
mathjax:
  tex:
    tags: 'ams'
  svg:
    exFactor: 0.03
---

#### 向量代数

##### 点积

用矩阵和向量表达线性方程组的非常简洁的方法，称为**点积**。点积是线性代数中非常重要的运算。
<!-- more -->

假设您有以下问题。您买了一些水果，比如说两个苹果、四根香蕉和一个樱桃。每个苹果售价`3`美元，每根香蕉售价`5`美元，每颗樱桃售价`2`美元。问题是，每样东西的总价是多少？这是一个简单的问题，但关键在于如何表达它。表达水果数量的方法是使用一个向量，它只是一列数字，`2、4、1`。这就是我们购买的每种水果的数量。价格也可以表示为一个包含`3、5、2`的向量。为了找到所有水果的总价，你可以单独找到每种水果的价格，即两个苹果乘以三，即每个苹果的总价，得到{% mathjax %}2\times 3 = 6{% endmathjax %}美元。这就是你在苹果上花费的金额。你可以对香蕉做同样的事情，得到{% mathjax %}4\times 5 = 20{% endmathjax %}，对樱桃做同样的事情，所以{% mathjax %}1\times 2 = 2{% endmathjax %}。`6`是你在苹果上花费的金额，`20`是香蕉，`2`是樱桃。水果的总价是：{% mathjax %}6 + 20 + 2 =28{% endmathjax %}。现在所做的就是**点积**，因为你可以像这样缩写：{% mathjax %}2\times 3 + 4\times 5 + 1\times 2 = 28{% endmathjax %}。我们实际上可以这样表达。更常见的是将第一个向量作为一行，将第二个向量作为一列，然后获取点积。向量`(2,4,1)`和`(3,5,2)`的点积是每个对应项对的总和。点积在线性代数中很常用，接下来您将看到它的一些用途。

**点积**和**范数**之间有很好的联系。让我们回到坐标为`(4,3)`的向量，其范数为5。注意一件事，{% mathjax %}\sqrt{4^2 + 3^2} = 5{% endmathjax %}实际上是向量与其自身的点积。`L2`范数始终是向量与其自身点积的平方根。有时您会看到它以这种符号写成，左边有一个尖括号，右边有一个尖括号。
{% asset_img m_1.png  %}

让我们回到我之前向您展示的将列向量转换为行向量的操作。这称为**转置**，它本质上是**将列转换为行**。用上标`T`表示该操作。结果会将此列向量转换为行向量。您也可以将转置应用于行向量，其工作方式完全相同，只是现在行向量已转换为列向量。您还可以**转置矩阵**。
{% asset_img m_2.png  %}

让我通过添加第二列向您展示如何操作。这现在是一个三乘二矩阵。要转置矩阵，只需转置每一列。首先，您将获得原始矩阵的第一列，然后对其进行转置以获得转置矩阵的第一行。然后对第二列执行相同的操作。同样，您将列转换为行。请注意，矩阵的维度互换。如果您从三乘二矩阵开始，其转置将是一个二乘三矩阵。
{% asset_img m_3.png  %}

让我们通过查看点积的正式定义来结束。从两个具有相同数量分量的向量{% mathjax %}x{% endmathjax %}和{% mathjax %}y{% endmathjax %}开始。那么点积就是{% mathjax %}x_1y_1 + x_2y_2{% endmathjax %}，然后将这些乘积添加到所有{% mathjax %}n{% endmathjax %}个分量上。
{% note warning%}
请注意，尖括号是点积的另一种表示法。在某些情况下，点积的左侧是行向量，右侧是列向量。在这些情况下，您可能会看到对其中一个向量使用转置，以使它们正确排列。
{% endnote %}
{% asset_img m_4.png  %}

##### 几何点积

首先，我们来看看这两个垂直的，也叫**正交向量**，它们的项是`(-1, 3)`和`(6, 2)`。现在取点积，注意点积是：{% mathjax %}6 \times -1 + 2 \times 3 = 0{% endmathjax %}。事实上，只要点积是`0`，那么这两个向量是正交的。
{% asset_img m_5.png  %}

**一个向量和它本身之间的点积恰好是范数的平方，或者向量长度的平方**。两个垂直或正交向量之间的点积始终为`0`。那么两个随机向量{% mathjax %}u{% endmathjax %}和{% mathjax %}v{% endmathjax %}之间的点积呢？有没有什么好的方法可以写出来？事实证明是有的。所以让我们从不同的角度来看待它。**向量本身的点积是范数的平方除以范数和它本身的乘积**。一个向量和一个同方向的长向量的点积非常相似，它只是两个范数的乘积，即{% mathjax %}u{% endmathjax %}范数乘以{% mathjax %}v{% endmathjax %}范数。那么，哪些向量之间有角度呢？它们几乎相同，只是你必须将一个向量垂直投影到另一个向量上，这恰好是一个向量在另一个向量上留下的形状。因此，如果这个向量是{% mathjax %}u{% endmathjax %}素数，那么{% mathjax %}u{% endmathjax %}和{% mathjax %}v{% endmathjax %}之间的点积就是{% mathjax %}u{% endmathjax %}素数的幅度与{% mathjax %}v{% endmathjax %}幅度的乘积。有趣的是，无论你将{% mathjax %}u{% endmathjax %}投影到{% mathjax %}v{% endmathjax %}上还是将{% mathjax %}v{% endmathjax %}投影到{% mathjax %}u{% endmathjax %}上，你仍然会得到相同的点积。一个更容易理解的方法是，如果向量之间的角度是{% mathjax %}\theta{% endmathjax %}，那么{% mathjax %}u{% endmathjax %}和{% mathjax %}v{% endmathjax %}的点积就是{% mathjax %}u{% endmathjax %}幅度乘以{% mathjax %}v{% endmathjax %}幅度乘以角度的余弦。
{% asset_img m_6.png  %}

利用你所了解的点积，你现在可以判断两个向量之间的点积是正数、负数还是`0`。例如，看一下向量`(6, 2)`。与其垂直的向量（例如`(-1, 3)`）与向量`(6, 2)`的点积为`0`。它右边的向量（例如`(2, 4)`）的点积为`20`，为正数。它左边的向量（例如`(-4, 1)`）的点积为`-22`，为负数。那么，为什么与`(2, 4)`的点积为正数？嗯，原因是这个向量在两个`(6, 2)`上的投影长度为正，而与`(-4, 1)`的点积为什么为负数？原因是向量`(6, 2)`上的投影是负的，因为你必须沿向量`(6, 2)`的反方向移动。因此，向量点积的正弦对应于垂直向量的一侧或另一侧。
{% asset_img m_7.png  %}

换句话说，这种情况很常见。如果向量是{% mathjax %}u{% endmathjax %}，那么与{% mathjax %}u{% endmathjax %}点积为`0`的向量都是垂直于{% mathjax %}u{% endmathjax %}的向量。与{% mathjax %}u{% endmathjax %}点积为正的向量都是这个区域内的向量，与{% mathjax %}u{% endmathjax %}点积为负的向量都是这个区域内的向量。
{% asset_img m_8.png  %}

##### 矩阵与向量相乘

**两个向量之间的点积是相应元素乘积的总和**。例如{% mathjax %}2a + 4b + c = 28{% endmathjax %}，可以写成行向量的乘积，行向量的元素为`2、4、1`。列向量的元素为未知数`a、b、c`。向量可以有变量。这表示一个方程，其中列向量中的未知数代表每种水果的价格，而行向量中的数字代表您购买的每种水果的数量。`28`美元表示两个向量的点积。现在，假设您有一个由三个方程组成的系统，其中有三个未知数。这些方程中的每一个都可以表示为点积。例如，第一个方程{% mathjax %}a + b + c = 10{% endmathjax %}可以表示为向量`(1、1、1)`（即{% mathjax %}a,b{% endmathjax %}和{% mathjax %}c{% endmathjax %}的系数）与向量{% mathjax %}a,b{% endmathjax %}和{% mathjax %}c{% endmathjax %}（变量）的点积，等于`10`。等式：{% mathjax %}a + 2b + c = 15{% endmathjax %}可以看作是`(1、2、1)`与`(a、b、c)`的乘积，等于`15`。最后，等式{% mathjax %}a + b = c{% endmathjax %}可以看作是向量`(1、1、2)`与向量`(a、b、c)`的乘积，等于 `12`。
{% asset_img m_9.png  %}

现在，用三个不同的点积来表示这个方程似乎很笨拙。有没有更好的方法？答案是有的。我们要做的第一件事就是把它们像这样放。在左边，我们有三个方程组和三个未知变量，在右边，我们有三个点积。
{% asset_img m_10.png  %}

请注意，列向量是相同的，因此我们可以简单地将三个向量合并并得到一个矩阵。现在我们得到了矩阵和向量的乘积。矩阵和向量的乘积只不过是三个点积堆叠在一起。如果你的系统中有更多的方程，那么你就有一个更大的矩阵。
{% asset_img m_11.png  %}

但从现在开始，我们将把方程组表示为矩阵乘以向量的乘积。请注意，这是一个{% mathjax %}3\times 3{% endmathjax %}矩阵，有三行三列，这个向量的长度为三。矩阵中的列数必须等于向量的长度。如果它们不匹配，你实际上是在尝试对具有不同长度的向量进行点积，这是未定义的。然而，有趣的是，只要这两个圆的尺寸匹配，矩阵就可以是矩形。例如，你可以添加第四个线性方程来创建一个{% mathjax %}4\times 3{% endmathjax %}矩阵，然后将其乘以包含三个分量{% mathjax %}a,b{% endmathjax %}和{% mathjax %}c{% endmathjax %}的向量。注意长度为四的向量的结果将与矩阵中的行数相匹配。
{% asset_img m_12.png  %}

#### 线性变换

**矩阵**还有另一种非常强大且非常有用的表示形式，那就是**线性变换**。**线性变换**是一种以非常结构化的方式将平面上的每个点发送到平面上的另一个点的方法。假设您有一个{% mathjax %}2\times 2{% endmathjax %}矩阵，其元素为{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}。首先考虑两个平面，其入口标记为{% mathjax %}a{% endmathjax %}和{% mathjax %}b{% endmathjax %}。变换将以下方式将左侧平面上的每个点移动到右侧平面上的一个点。任何点都有两个坐标。这两个坐标形成一个列向量。为了得到右边的向量，我们将第一个向量乘以矩阵，得到的任何向量都是右边的点。首先，让我们看一下原点。`(0,0)`变成向量`(0,0)`，我们将其乘以矩阵，得到向量`(0,0)`。这实际上总是发生在线性变换中。原点被移动到原点。现在让我们看看点`(1,0)`。因此矩阵乘以向量`(1 0)`得到向量`(3,1)`。现在让我们看看`(0,1)`。矩阵乘以`(0,1)`等于`(1,2)`。最后让我们看看`(1,1)`。矩阵乘以向量`(1,1)`得到向量`(4,3)`。实际上这定义了整个变换。让我们看看这四个点形成的小正方形。它变为这个平行四边形。左边的正方形称为**基**。右边的平行四边形也是如此。它们是线性代数中非常非常重要的概念。稍后你就会知道为什么它们被称为基，基的一个非常特殊的属性是它们覆盖整个平面。实际上，由于这个正方形实际上镶嵌了整个平面，平行四边形也镶嵌了整个平面。那么**线性变换就简单地定义为坐标的变化**。例如，如果我们想找到点`(-2,3)`的位置，那么左边的点`(-2,3)`可以从原点开始向左走两个坐标单位，向上走三个坐标单位。因此，为了找到该点在线性变换中的位置，我们只需从原点开始，在这些新坐标中向左走两个坐标单位，向上走三个坐标单位。我们得到了点`(-3,4)`。
{% asset_img m_13.png  %}

用买苹果和香蕉的语言来说。我喜欢以以下方式看待变换。假设你第一天去商店买了三个苹果和一个香蕉。第二天你买了一个苹果和两根香蕉。所以如果苹果的价格是{% mathjax %}a{% endmathjax %}，香蕉的价格是{% mathjax %}b{% endmathjax %}。那么第一天和第二天的价格就是向量的元素，该向量对应于这两个矩阵的乘积，元素为`(3、1、1、2)`。向量为{% mathjax %}ab{% endmathjax %}。线性变换将你从左边的点（访问苹果的价格和香蕉的价格）带到右边的点（访问第一天支付的金额和第二天支付的金额）。所以苹果是`1`美元，香蕉也是`1`美元。那么第一天你支付了`4`美元，第二天你支付了`3`美元，矩阵的线性变换将坐标为`(1,1)`的点移动到坐标为`(4,3)`的点。坐标的变化就是苹果和香蕉的价格变为第一天和第二天的支付金额。

假设我们有一个隐身矩阵，我们知道它将这个基本方格移动到这个矩阵中，目标是找到矩阵的元素。让我们看看它将每个点移动到哪里？点`(0,0)`被移动到`(0,0)`。点`(1,0)`被移动到`(3,-1)`，即右下角。点`(0,1)`被移动到`(2, 3)`，点`(1,1)`被移动到`(5,2)`。我们只需要这里的这两个点。使用箭头来表示这个点，因为向量往往从原点一直延伸到该点的箭头来表示。坐标为`(1,0)`的向量被移动到坐标为`(3,-1)`的向量，坐标为`(0,1)`的向量被移动到坐标为`(2,3)`的向量。将向量`(1,0)`和`(0,1)`移动到`(3,-1)`和`(2,3)`的矩阵恰恰是具有列`(3, -1)`和`(2, 3)`的矩阵。这就是将线性变换转换为对应矩阵的方法。你只需查看两个基本向量`(1,0)`和`(0,1)`的位置，它们就是矩阵的列。
{% asset_img m_14.png  %}

##### 矩阵乘法

假设你有一个矩阵{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}。让我们快速看一下这里的线性变换。向量`(1,0)`变为`(3,1)`。向量`(0,1)`变为向量`(1,2)`。但让我们从右侧的向量开始。让我们看看矩阵{% mathjax %}\begin{bmatrix} 2 & -1\\ 0 & 2 \end{bmatrix}{% endmathjax %}线性变换。如何作用于这两个向量，现在是向量`(3,1)`。`(3,1)`变为`(2,5)`。这个向量指向右侧的点`(2,5)`。另一个向量是`(1,2)`。此矩阵乘以`(1,2)`变为向量`(0,4)`，因此我们绘制`(0,4)`。然后左边的平行四边形变成右边的平行四边形。这是线性变换的一种方法。现在让我们把它们放在一起。我们有第一个线性变换矩阵{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}，第二个线性变换矩阵{% mathjax %}\begin{bmatrix} 2 & -1\\ 0 & 2 \end{bmatrix}{% endmathjax %}。如果我们忘记中间的那个，那么第一个和第三个之间就有一个线性变换，而这必定对应某个矩阵。问题是，什么矩阵对应那个线性变换？让我们简化一点，只看基向量。通过只看左边和右边，我们会看到左边的向量`(1,0)`被移动到右边的`(5,2)`。因此，正如我们之前看到的，矩阵的第一列是`(5,2)`。另一个基向量，向量`(0,1)`，被移动到向量`(0,4)`。因此，矩阵的第二列是`(0,4)`。
{% asset_img m_15.png  %}

两个线性变换的组合给出了与矩阵{% mathjax %}\begin{bmatrix} 5 & 0\\ 2 & 4 \end{bmatrix}{% endmathjax %}相对应的线性变换。现在，我们有没有办法从另外两个矩阵获得？答案是可以的。这就是矩阵乘法。这里的运算是左边的矩阵乘以右边的矩阵等于第三个矩阵。现在注意矩阵被翻转了。这对应于第一个线性变换，即左边的矩阵，而这对应于第二个线性变换。这是非常重要的一点。原因是线性变换作用于左边的向量，所以你要将矩阵乘以向量。因此，你首先将矩阵{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}相乘，然后将矩阵{% mathjax %}\begin{bmatrix} 2 & -1\\ 0 & 2 \end{bmatrix}{% endmathjax %}相乘，这样它们的方向就相反了。那么，有没有一种快速的方法可以查看矩阵乘法，而无需绘制线性变换？答案是肯定的，因为它有很多点积。基本上，将左侧矩阵视为两行，将右侧矩阵视为两列，然后取行和列之间点积的所有可能组合。例如，第一行和第一列位于左上角，而右侧第一行和第二列位于右上角。第一个是`5`，第二个是`0`，第三个是`2`，第四个是`4`。
{% asset_img m_16.png  %}

矩阵{% mathjax %}\begin{bmatrix} 5 & 0\\ 2 & 4 \end{bmatrix}{% endmathjax %}是这两个矩阵的乘积。总之，你可以将**矩阵积视为两个矩阵相乘**，但也可以将其视为将两个线性变换组合成第三个线性变换。此示例中的每个矩阵都是一个{% mathjax %}2\times 2{% endmathjax %}矩阵，但是当你的矩阵不像这样的方阵时，乘法也有定义。
{% asset_img m_17.png  %}

让我给你举个例子。这次我将一个{% mathjax %}2\times 3{% endmathjax %}矩阵和一个{% mathjax %}3\times 4{% endmathjax %}矩阵相乘。结果将是一个{% mathjax %}2\times 4{% endmathjax %}矩阵。请记住，要乘以矩阵，你需要从第一个矩阵中取出行，从第二个矩阵中取出列。第一个点积是`(3,1,4)`和`(3,1,-2)`的点积。结果是`2`。下一个点积是`(3,1,4)`和`(0,5,1)`，结果为`9`。完成矩阵的这一行将得到`21`和`-6`的点积。现在让我们检查矩阵的左下角单元格。按照这个模式，我将取第一个矩阵的第二行和第二个矩阵的第一列的点积。这是{% mathjax %}2\times 3-1\times 1+ ​​-2\times 2 = 1{% endmathjax %}。继续使用相同的模式，您可以求解矩阵的其余值。
{% asset_img m_18.png  %}

这些示例向您展示了即使矩阵都是矩形，也可以将它们相乘。首先，第一个矩阵的列数必须与第二个矩阵的行数匹配。换句话说，这里圈出的数字需要匹配。其次，结果矩阵从第一个矩阵中获取行数。换句话说，这里圈出的数字需要匹配。最后，结果从第二个矩阵中获取列数，因此这里圈出的数字需要匹配。您只需取第一个矩阵的行和第二个矩阵的列的点积来填充结果矩阵的每个单元格。

当我想到乘法时，我认为`1`是一个非常特殊的数字。`1`之所以特殊，是因为当你将任何数字乘以`1`时，你得到的数字与你开始时的数字相同。**单位矩阵**在矩阵中扮演着完全相同的角色。单位矩阵是与任何其他矩阵相乘时都会得到相同矩阵的矩阵，其相应的线性变换非常简单。它是使平面保持完整的矩阵。单位矩阵看起来非常简单。它在对角线上为`1`，其他地方为`0`。当你将它乘以任何向量，比如说，包含{% mathjax %}a,b,c,d,e{% endmathjax %}的向量时，你可以验证得到的向量包含{% mathjax %}a,b,c,d,e{% endmathjax %}的向量。
{% asset_img m_19.png  %}

##### 逆矩阵

矩阵可以有一个与之相关的非常特殊的矩阵，称为**逆矩阵**。当我想到矩阵的逆时，我会想到一个数字的逆，即当与它相乘时得到`1`的数字。例如，数字`2`的逆是数字`1/2`，而负`5`的逆是负`1/5`。**逆矩阵**正是矩阵乘积为**单位矩阵**的矩阵。在线性变换中，**逆矩阵**是撤销原始矩阵工作的矩阵，即将平面返回到其起始位置的矩阵。**逆矩阵**的工作原理如下。想象一下，您有一个线性变换，对应于具有元素{% mathjax %}\begin{bmatrix} 3 & 1\\ 1 & 2 \end{bmatrix}{% endmathjax %}的普通矩阵，它将正方形变成这里的平行四边形。现在存在一些变换可以将这个平行四边形变回原始正方形。不用担心矩阵的元素，我们稍后会找到它们。只要知道有一个，那就意味着两个变换的组合就是对应于单位矩阵的那个，对平面没有任何影响。
{% asset_img m_20.png  %}

如果**逆矩阵**是具有元素{% mathjax %}\begin{bmatrix} a & b\\ c & d \end{bmatrix}{% endmathjax %}的矩阵，意味着当我们将原始矩阵乘以逆矩阵时，我们得到的是单位矩阵。现在就像数字一样，我们将原始矩阵的`-1`次方称为**逆矩阵**。就像你说{% mathjax %}2^{-1} = \frac{1}{2}{% endmathjax %}一样，那么这个矩阵的`-1`次方就是逆矩阵。而这个矩阵恰好有这些元素，你可以验证，如果你将原始矩阵乘以这个矩阵，你会得到单位矩阵。现在我们如何找到这个逆矩阵中的元素？答案是通过**解线性方程组**。所以请注意，如果我们将左边这个矩阵中的元素取为右边这个对应元素的元素，那么我们实际上有以下四个点积。这些点积中的每一个都会给我们一些线性方程。现在您有一个包含四个未知数的四个线性方程组，分别是{% mathjax %}a,b,c,d{% endmathjax %}。我们可以使用通常的消元法来求解它，得到{% mathjax %}a = \frac{2}{5}、b = -\frac{1}{5}、c = -\frac{1}{5}、c = \frac{3}{5}{% endmathjax %}。
{% asset_img m_21.png  %}

