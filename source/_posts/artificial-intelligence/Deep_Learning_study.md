---
title: 深度学习（TensorFlow and Keras）
date: 2024-03-15 20:20:32
tags:
  - AI
categories:
  - 人工智能
---

#### 介绍

##### 什么是深度学习？

近年来，人工智能领域最令人印象深刻的一些进展出现在深度学习领域。自然语言翻译、图像识别和游戏都是深度学习模型已经接近甚至超过人类水平的表现。那么什么是深度学习呢？**深度学习**是一种以深度计算堆栈为特征的机器学习方法。这种计算深度使得深度学习模型能够理清最具挑战性的现实数据集中发现的各种复杂和分层模式。神经网络凭借其强大的功能和可扩展性，已成为深度学习的定义模型。神经网络由神经元组成，其中每个神经元单独执行简单的计算。神经网络的力量来自于这些神经元可以形成的连接的复杂性。
<!-- more -->
##### 线性单元

让我们从神经网络的基本组成部分开始：单个神经元。如图所示，具有一个输入的神经元（或单元）如下所示：
{% asset_img dl_1.png %}

输入是`x`。它与神经元的连接权重为`w`。每当一个值流经连接时，您就将该值乘以连接的权重。对于输入`x`，到达神经元的是`w * x`。神经网络通过修改其权重来“学习”。`b`是一种特殊的权重，我们称之为偏差。该偏差没有任何与之相关的输入数据；相反，我们在图中放入`1`，这样到达神经元的值就是`b`（因为`1 * b = b`）。偏差使神经元能够独立于其输入来修改输出。`y`是神经元最终输出的值。为了获得输出，神经元将通过其连接接收到的所有值相加。该神经元的激活为`y = w * x + b`，或作为公式`𝑦=𝑤𝑥+𝑏`。

##### 举例 - 线性单元作为模型

尽管单个神经元通常仅作为神经网络的一部分发挥作用，但从单个神经元模型作为基线开始通常很有用。单神经元模型是线性模型。让我们考虑一下这如何适用于`80 Cereals`这样的数据集。以“糖”（每份的糖克数）作为输入，以“卡路里”（每份的卡路里）作为输出来训练模型，我们可能会发现偏差为`b=90`，权重为`w=2.5`。 我们可以这样估算每份含`5`克糖的麦片的卡路里含量：
{% asset_img dl_2.png %}

检查我们的公式，`𝑐𝑎𝑙𝑜𝑟𝑖𝑒𝑠=2.5×5+90=102.5`, 就像我们期望的那样。

##### 多输入

`80 Cereals`数据集除了“糖”之外还有更多特征。如果我们想扩展我们的模型以包含纤维或蛋白质含量等内容该怎么办？这很容易。我们可以向神经元添加更多输入连接，每个附加功能对应一个输入连接。为了找到输出，我们将每个输入乘以其连接权重，然后将它们全部加在一起。
{% asset_img dl_3.png %}

该神经元的公式为`𝑦=𝑤0𝑥0+𝑤1𝑥1+𝑤2𝑥2+𝑏`。具有两个输入的线性单元将适合一个平面，而具有更多输入的单元将适合一个超平面。

##### Keras 中的线性单位

在`Keras`中创建模型的最简单方法是通过`keras.Sequential`，它将神经网络创建为层堆栈。我们可以使用密集层创建如上所述的模型。我们可以定义一个线性模型，接受三个输入特征（“糖”、“纤维”和“蛋白质”）并产生单个输出（“卡路里”），如下所示：
```python
from tensorflow import keras
from tensorflow.keras import layers

# Create a network with 1 linear unit
model = keras.Sequential([
    layers.Dense(units=1, input_shape=[3])
])
```
使用第一个参数，单位，我们定义我们想要的输出数量。在本例中，我们只是预测“卡路里”，因此我们将使用`units=1`。通过第二个参数`input_shape`，我们告诉`Keras`输入的维度。设置 `input_shape=[3]`确保模型接受三个特征作为输入（“糖”、“纤维”和“蛋白质”）。

{% note info %}
为什么`input_shape`是一个`Python`列表？我们将为数据集中的每个特征提供一个输入。这些特征按列排列，因此我们始终有`input_shape=[num_columns]`。`Keras`在这里使用列表的原因是允许使用更复杂的数据集。例如，图像数据可能需要三个维度：`[height, width, channels]`。
{% endnote %}

#### 深度神经网络

##### 介绍

这里的关键思想是模块化，从更简单的功能单元构建复杂的网络。我们已经了解了线性单元如何计算线性函数——现在我们将了解如何组合和修改这些单个单元以建模更复杂的关系。

##### 层

神经网络通常将其神经元组织成层。当我们将具有一组公共输入的线性单元收集在一起时，我们得到了一个密集层。
{% asset_img dl_4.png %}

您可以将神经网络中的每一层视为执行某种相对简单的转换。通过深层堆栈，神经网络可以以越来越复杂的方式转换其输入。在训练有素的神经网络中，每一层都是一次转换，让我们更接近解决方案。
{% note info %}
**多种层**:`Keras`中的“层”是一种非常通用的东西。本质上，层可以是任何类型的数据转换。许多层（例如卷积层和循环层）通过使用神经元来转换数据，并且主要区别在于它们形成的连接模式。其他人则用于特征工程或只是简单的算术。
{% endnote %}

##### 激活函数

然而事实证明，两个中间没有任何东西的致密层并不比单个致密层本身更好。密集的层次本身永远无法让我们脱离线和面的世界。我们需要的是非线性的东西。我们需要的是激活函数。
{% asset_img dl_5.png %}

激活函数只是我们应用于每个层的输出（其激活）的函数。最常见的是整流器函数：`𝑚𝑎𝑥(0,𝑥)`
{% asset_img dl_6.png %}

整流器函数有一个图形，该图形是一条线，其中负部分“整流”为零。将函数应用于神经元的输出将使数据弯曲，使我们远离简单的线条。当我们将整流器连接到线性单元时，我们得到一个整流线性单元或`ReLU`。（因此，通常将整流器函数称为“`ReLU`函数”。）将`ReLU`激活应用于线性单元意味着输出变为`max(0, w * x + b)`，我们可以将其绘制在如下图中:
{% asset_img dl_7.png %}

##### 堆叠密集层(Stacking Dense Layers)

现在我们已经有了一些非线性，让我们看看如何堆叠层来获得复杂的数据转换。
{% asset_img dl_8.png %}

输出层之前的层有时被称为隐藏层，因为我们永远不会直接看到它们的输出。现在，请注意最后（输出）层是线性单元（意味着没有激活函数）。这使得这个网络适合回归任务，我们试图预测一些任意数值。其他任务（例如分类）可能需要输出上的激活函数。

##### 构建序列模型

我们一直使用的顺序模型将按从第一个到最后一个的顺序将层列表连接在一起：第一层获取输入，最后一层产生输出。这将创建上图中的模型：
```python
import tensorflow as tf
import keras
from keras import layers

model = keras.Sequential([
    # the hidden ReLU layers
    layers.Dense(units=4, activation='relu', input_shape=[2]),
    layers.Dense(units=3, activation='relu'),
    # the linear output layer 
    layers.Dense(units=1),
])
```
确保将所有层一起传递到一个列表中，例如`[layer,layer,layer, ...]`，而不是作为单独的参数。要将激活函数添加到层，只需在激活参数中给出其名称即可。
