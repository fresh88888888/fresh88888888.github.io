---
title: 序列化建模：Mamba / S4（深度学习）
date: 2024-06-29 10:00:11
tags:
  - AI
categories:
  - 人工智能
mathjax:
  tex:
    tags: 'ams'
  svg:
    exFactor: 0.03
---

序列模型的目标是将输入序列映射到输出序列。我们可以将连续输入信号{% mathjax %}x(t){% endmathjax %}映射到输出信号{% mathjax %}y(t){% endmathjax %}，或者将离散输入序列映射到离散输出序列。
{% asset_img ms_1.png %}
<!-- more -->

例如连续信号可以是音频，离散信号可以是文本，实际上大多数时候我们都使用离散信号，即使在音频的情况下也是如此。当语言建模时，我们考虑的是离散输入，因为只有有限数量的`token`，将其映射到`token`的输出序列，我们可以选择许多模型的来进行序列建模。

第一个模型是**循环神经网络**(`RNN`)。在该网络中，我们有一个隐藏状态，按如下方式计算输出，例如我们输入的序列由{% mathjax %}x_1,x_2{% endmathjax %}和{% mathjax %}x_3{% endmathjax %}组成。初始化隐藏状态的隐藏序列使用`0`来进行初始化。我们将其插入到网络的第一个隐藏状态，因此与第一个输入组合为`0`，然后将产生第一个输出。上一步的输出将产生一个新的隐藏状态和新输入`token`，这将是{% mathjax %}y_2{% endmathjax %}，输出数为`2`。之前生成的隐藏状态与新的输入`token`，用于生成新的输出`token`，以及下一个新隐藏状态的`token`。输出的生成顺序不可以并行化，因为要生成`N`个`token`，我们需要`n-1`个节点。但是每个token的推理时间是不变的，从计算和内存的角度来看，输出中生成的`token`的是相同的。无论它是第一个`token`，还是第`100`个`token`。在这里操作和计算的数量级是一样的，理论上这个输出token拥有无限的上下文长度。但实际情况是不能的，因为它存在梯度消失和爆炸的问题。

另一个模型是**卷积神经网络**(`CNN`)。主要用于计算机视觉任务，它有一个有限的上下文窗口，并需要构建一个可运行的内核，通过输入来产生输出特征的内核，它可以并行化计算，因为每个输出都使用相同的内核。

最后一个模型是`Transformer`,在训练时可以进行并行化计算。拥有计算点积的自注意力机制，由于它是一个矩阵乘法，我们可以并行化该操作。该操作由序列、输入序列、注意力掩码定义的有限上下文窗口。对于这种模型的推理，每个`token`并不是恒定的。在`Transformer`模型中，我们生成第一个`token`输出。我使用`1`个点积来生成；如果我们生成第`10`个输出`token`，我们将需要10个点积来生成它；如果你要生成第`100`个输出`token`，我们将需要100个点积。因此生成第一个`token`的耗时与生成第`10`个`token`的耗时不同。这样不好，这会影响扩展。如果我们将序列长度加倍，则需要花费`4`倍的计算时间来训练该模型。但它可以并行化，我们像`Transformer`一样并行化训练。这样可以很好地利用`GPU`。并像`RNN`一样线性扩展到长序列。

#### 微分方程

让我们用一个非常简单的例子来讨论微分方程。假设你有一些兔子，兔子的数量以恒定速度增长，这意味着每只兔子都会生下{% mathjax %}\lambda{% endmathjax %}只小兔子。因此，我们可以说兔子数量的变化率如下：（特定时间步长{% mathjax %}t{% endmathjax %}出生的小兔子数量）= {% mathjax %}\lambda{% endmathjax %} ×（同一时间步长{% mathjax %}t{% endmathjax %}的兔子数量），则（相对于时间的变化率）= {% mathjax %}\lambda{% endmathjax %} ×（时间{% mathjax %}t{% endmathjax %}时的兔子数量）：
{% mathjax '{"conversion":{"em":14}}' %}
\frac{db}{dt} = \lambda b(t)
{% endmathjax %}
{% mathjax %}\frac{db}{dt}{% endmathjax %}表示兔子数量随时间的变化率。{% mathjax %}b(t){% endmathjax %}表示在时间{% mathjax %}t{% endmathjax %}时我们有多少只兔子。已知{% mathjax %}t = 0{% endmathjax %}时兔子的数量为`5`只，那么如何求出`t = 100`时的兔子数量？我们需要找到描述兔子数量随时间变化的{% mathjax %}b(t){% endmathjax %}。求解微分方程：就是找到一个函数{% mathjax %}b(t){% endmathjax %}，使上述公式对所有{% mathjax %}t{% endmathjax %}值都成立。我们可以验证解为{% mathjax %}b(t) = ke^{\lambda t}{% endmathjax %}，其中{% mathjax %}k = b(0) = 5{% endmathjax %}，即兔子的初始数量。通常，我们通过省略变量{% mathjax %}t{% endmathjax %}来简化微分方程，如下所示：{% mathjax %}\dot{b} = \lambda b{% endmathjax %}。我们通常使用微分方程来模拟系统随时间的变化状态，目的是找到一个函数，给定时间为`0`时系统的初始状态，给出任意时间步的系统状态。
