---
title: UML2.5 统一建模语言
date: 2022-05-05 12:34:32
tags:
  - UML
categories:
  - 设计原则
---


`UML` 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。

{% asset_img uml-language.png %}

<!-- more -->


### 类图

面向对象程序设计(Object-Oriented Programming， 缩写为 `OOP`) 是一种范式， 其基本理念是将数据块及与数据相关的行为封装成为特殊的、 名为对象的实体， 同时对象实体的生成工作则是基于程序员给出的一系列蓝图， 这些蓝图就是类，在UML中，类图专门是用来描述这种实体的。如下图所示：

{% asset_img class-cat.png 类图-猫 %}

类之间是有相互关系的，就像猫属于动物，动物和植物又属于生物体：

{% asset_img class-level.png 类之间的层次结构 %}

类之间的关系可以更细分的划分为这几种：依赖，关联，聚合，组合。

#### 依赖

依赖是类之间最基础的、也是最微弱的关系类型。 如果修改一个类的定义可能会造成另一个类的变化，那么这两个类之 间就存在依赖关系。当你在代码中使用具体类的名称时， 通 常意味着存在依赖关系。 例如在指定方法签名类型时， 或是通过调用构造函数对对象进行初始化时等。 通过让代码依赖接口或抽象类(而不是具体类)，你可以降低其依赖程度。

通常情况下，UML 图不会展示所有依赖——它们在真实代码中的数量太多了。 为了不让依赖关系破坏 UML 图， 你必须对其进行精心选择，仅展示那些对于沟通你的想法来说重要 的依赖关系。

在UML中，依赖关系用一个虚线的箭头表示，从依赖者到被依赖者，例如教授依赖课程资料：

{% asset_img class-depend.png 授依赖于课程资料%}

#### 关联

关联是一个对象使用另一对象或与另一对象进行交互的关系。 在 UML 图中， 关联关系用起始于一个对象并指向其所使用 的对象的简单箭头来表示。 顺带一提， 双向关联也是完全正常的， 这种情况就用双向箭头来表示。 关联可视为一种特殊类型的依赖，即一个对象总是拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。

一般来说， 你可以使用关联关系来表示类似于类成员变量的东西。这个关系将一直存在，因此你总能通过`订单`来获 取其`顾客`。 但是它并非一定是成员变量。如果你根据接口来创建类，它也可以表示为一个可返回`订单`的`顾客`的方法。

为了区分关联和依赖，举如下的例子，`Professor` 依赖 `Course` 提供的 `c.getKnowledge` 方法获取知识，将其传授给关联的 `Student`：

```
class Professor is
    field Student student //...
    method teach(Course c) is
    // ...
    this.student.remember(c.getKnowledge())
```

如果有人修改了 课程 类的 getKnowledge (获取知识)方法(修改方法名或添加一些 必须的参数等)，代码将会崩溃。这就是依赖关系。

让我们来看看名为 `student` (学生)的成员变量，以及如何在 `teach` 方法中使用该变量。我们可以肯定学生 (`Student`)类是教授类的依赖: 如果 `remember` 方法被修改， 教授的代码也将崩溃。但由于教授的所有方法总能访问 `student` 成员变量，所以学生类就不仅是依赖，而也是关联了。

UML图中，经常用一个单向的箭头表示关联关系：

{% asset_img class-association.png %}

#### 聚合

聚合是一种特殊类型的关联， 用于表示多个对象之间的`一对多`、`多对多`或`整体对部分`的关系 。 普通关联仅用于描述两个对象之间的关系。通常在聚合关系中， 一个对象`拥有` 一组其他对象， 并扮演着容器或集合的角色。组件可以独立于容器存在， 也可以同时连接多个容器。 在 UML 图中，聚合关系使用一端是空心菱形，另一端指向组件的箭头来表示。

{% asset_img class-juhe.png 院系包含教授 %}


#### 组合

组合是一种特殊类型的聚合， 其中一个对象由一个或多个其他对象实例构成。 组合与其他关系的区别在于组件仅能作为容器的一部分存在。 在 `UML` 图中，组合与聚合关系的符号相同，但箭头起始处的菱形是实心的。

{% asset_img class-zuhe.png 大学由院系构成 %}


### OOP

面向对象程序设计的四个基本概念使其区别于其他程序设计范式，他们分别是：抽象，多态，封装以及继承。

#### 抽象

当使用面向对象程序设计的理念开发一款程序时， 我们会将大部分时间用于根据真实世界对象来设计程序中的对象。但是，程序中的对象并不需要能够百分之百准确地反映其原型(极少情况下才需要做到这一点)。实际上，你的对象只需模拟真实对象的特定属性和行为即可，其他内容可以忽略。

例如， 飞行模拟器和航班预订程序中都可能会包含一个飞机 `Airplane` 类。 但是前者需包含与实际飞行相关的详细信息，而后者则只关心座位图和哪些座位可供预订。

{% asset_img class-airplane.png 同一个真实世界对象的不同模型 %}

抽象是一种反映真实世界对象或现象中特定内容的模型， 它 能高精度地反映所有与特定内容相关的详细信息， 同时忽略其他内容。


#### 封装

封装是指一个对象对其他对象隐藏其部分状态和行为， 而仅向程序其他部分暴露有限的接口的能力。

如果想要启动一辆车的发动机， 你只需转动钥匙或按下按钮即可， 无需打开引擎盖手动接线、转动曲轴和气缸并启动发动机的动力循环。 这些细节都隐藏在引擎盖下，你只会看到一些简单的接口: 启动开关、方向盘和一些踏板。 

对象的接口——它是对象的公有部分，能够同其他对象进行交互。

封装某个内容意味着使用关键字 `private` 来对其进行修饰， 这样仅有其所在类中的方法才能访问这些内容。 还有一种限制程度较小的关键字 `protected` 保护 ， 其所修饰的对象仅允许父类访问其类中的成员。

绝大部分编程语言的接口和抽象类(或方法)都基于抽象和 封装的概念。 在现代面向对象的编程语言中， 接口机制(通常使用 `interface` 或 `protocol` 关键字来声明)允许你定义对象之间的交互协议。这也是接口仅关心对象行为，以及你不能在接口中声明成员变量的原因之一。

假如航空运输 `FlyingTransport` 接口中有一个 `fly(origin, destination, passengers)` 方法 (即以起点、 终点以及乘客为参数的飞行方法)。 在设计航空运输模拟器时， 你可以对机场 `Airport` 做出限制， 使其仅与实现了航空运输接口的对象进行交互。此后，你可以确保 传递给机场对象的任何对象——无论是`飞机`、 `直升机`、还是可怕的`家养狮鹫` —— 都能到达或离开这种类型的机场。

{% asset_img class-inbox.png 多个类实现一个接口的 UML 图 %}

#### 继承

继承是指在根据已有类创建新类的能力。 继承最主要的好处是代码复用。如果你想要创建的类与已有的类差异不大， 那也没必要重复编写相同的代码。你只需扩展已有的类并将额外功能放入生成的子类(它会继承父类的成员变量和方法) 中即可。

使用继承后，子类将拥有与其父类相同的接口。如果父类中声明了某个方法，那么你将无法在子类中隐藏该方法。你还必须实现所有的抽象方法，即使它们对于你的子类而言没有意义。

{% asset_img class-jicheng.png 多个类实现一个接口的 UML 图 %}

在绝大多数编程语言中， 子类仅能对一个父类进行扩展。 另一方面， 任何类都可以同时实现多个接口。 但是正如我之前提到的那样， 如果父类实现了某个接口， 那么其所有子类都 必须实现该接口。

#### 多态

绝大部分动物 `Animals` 可以发出声音。 我们需要所有子类都重写基类的 `makeSound` 发出声音方法，让每个子类都发出正确的声音，因此我们可以马上将其声明为抽象。 这让我们得以忽略父类中该方法的所有默认实现，从而强制要求所有子类自行提供该方法的实现。

{% asset_img class-polymorphism.png %}

假如将几只猫和狗放入一个大袋子中。 然后，我们闭上眼睛，将动物一个一个地从袋中取出。 我们并不知道自己取出的是何种动物。 但如果我们好好地摸摸它们的话， 它就会根据自己的具体类发出特殊的欢快叫声。

```
bag = [new Cat(), new Dog()]; 
foreach (Animal a : bag)
    a.makeSound()

//喵喵!
//汪汪!
```

程序并不知道 `a` 变量中所包含的对象的具体类型，但幸亏有被称为多态的特殊机制， 程序可以追踪对象的子类并调用其方法，从而执行恰当的行为。

多态是指程序能够检测对象所属的实际类，并在当前上下文不知道其真实类型的情况下调用其实现的能力。


### UML

UML图经过各种大型工程的实践，被证明是一种极其有用的方式来描述可视化系统，数据可系统及其他软件系统，所有的软件开发人员都应该学习并掌握它。从种类上来说，它有以下几种类型：

{% asset_img UML图种类.png UML图种类 %}


#### 类图（Class Diagram）

`Class` 经常被用用来描述某个具体的或者抽象的对象，这个对象经常具有一些属性和方法，而且这些属性和方法都具有不同的访问限制规则，例如一个用来描述 `Dog` 的类图：

{% asset_img UML-Class-dog.png %}

可以看到的是在每个属性或者方法之前都有一个 `+` 或者 `-`，这个就是访问限制规则，一共有四种：

- `+`：Public，可公开访问
- `-`：Private
- `#`：Protected
- `~`：Package Local

而且对于方法而言，可以通过 `in`，`inout` 或者 `out` 标识参数的意义：

- `in`: 该参数仅作为输入参数，不应该被修改；
- `inout`: 该参数即可作为输入参数，也可以被内部修改；
- `out`: 该参数仅用于作为输出参数存储库，就像传入一个地址，然后内部可以对其进行赋值；

{% asset_img UML-Class-myclass.png %}

就像现实世界中不同对象之间有不同的关系一样，类图中也有描述不同类之间关系的方式，一般存在六种关系，分别是关联，继承，实现，依赖，聚合和组合。

例如，学生从老师那里学习知识，这种关系就可以表示位简单的关联关系，在表示的时候使用一个联系表示即可，也可以适当添加描述信息：

{% asset_img UML-Class-student-tutor.png %}

继承有时候也可以称为泛化，用一个空心箭头从子类指向父类，父类可能是抽象类或者具体类：

{% asset_img UML-Class-relation-inherit.png %}

实现一般是指具体类型和接口之间关系，用一个虚线实心箭头表示：

{% asset_img UML-Class-relationships-realization.png %}

当一个对象在其方法中使用另一个类的对象，并且未存储在任何字段中时，就表示存在依赖关系，例如，`Person` 有一个方法 `Read` 接收一个 `Book` 的实例 `book` 作为参数，调用 `Book` 的 `getknowledge` 方法获取知识：

{% asset_img UML-Class-relationships-dependency.png %}

聚合和组合比较相近，都表示一对多的关系，而聚合通常用来表示用类的聚合，而组合表示整体和部分的关系；例如学校有很多老师，这种表示聚合关系；而学校也有很多不同的学院，计算机学院，土木工程等，这种表示组合关系，不同类型；在表示上聚合使用空心菱形箭头，组合使用实心菱形箭头表示。

{% asset_img UML-Class-relationships-aggr-composition.png %}

类图是UML 结构图，它在类和 接口 级别显示设计系统的结构 ，显示它们的特性、 约束 和关系—— 关联、 泛化、 依赖等。常见的类图有：领域模型图、实现类图。

领域模型图:
{% asset_img class-diagram_1.png %}

实现类图:
{% asset_img class-diagram_2.png %}

##### 标准UML类的构造形态

|名称|描述|
|:--:|:--|
|`«Auxiliary»`|辅助类是支持核心或基础类的类，通常通过实现辅助逻辑或控制流来支持。 辅助支持的类可以使用焦点类显式定义，也可以通过依赖关系隐式定义。辅助类通常用于在设计阶段指定组件的辅助业务逻辑或控制流。|
|`«Focus»`|焦点是定义一个或多个支持类的核心逻辑或控制流的类。 支持类可以使用辅助类显式定义，也可以通过依赖关系隐式定义。焦点类通常用于在设计阶段指定组件的核心业务逻辑或控制流。|
|`«ImplementationClass»`|在某些编程语言（例如 `C++、Smalltalk、Java`）中类的实现，其中一个实例不能有多个类。这与 `UML` 类相反，在 `UML` 类中，一个实例可能同时具有多个类，并且随着时间的推移可能会获得或丢失类，而一个对象可能会动态地具有多个类。一个实现类可以实现多种不同的类型。 实现类的物理属性和关联不必与其实现的任何分类器的物理属性和关联相同，并且实现类可以根据其物理属性和关联为其操作提供方法。|
|`«Metaclass»`|其实例也是类。|
|`«Type»`|类型是指定对象域以及适用于对象的操作的类，但不定义这些对象的物理实现。类型可以具有属性和关联。 类型操作的行为规范可以使用例如活动图来表达。 一个对象最多可以有一个实现类，但是它可以符合多种不同的类型。|
|`«Utility»`|工具类是仅具有类范围的静态属性和操作的类。 因此，工具类通常没有实例。|

##### 类的模版

`UML` 类可以被模板化或绑定。下面的示例显示了具有两个形式模板参数的模板类 `Array`。 第一个模板参数 `T` 是不受约束的类模板参数。 第二模板参数`n`是整数表达式模板参数。绑定类 `Customers` 的模板绑定将无约束类 `T` 替换为类 `Customer`，边界 `n` 替换为整数值 `24`。因此，绑定类 `Customers` 是包含 `24` 个 `Customer` 类对象的数组。

{% asset_img class-diagram_3.png %}

##### 接口

接口是一个 分类器 ，声明一组连贯的公共功能和义务。接口指定契约。实现（实现）接口的任何分类器实例都必须履行该契约，从而提供契约所描述的服务。由于接口是声明，因此它们不可实例化。相反，接口规范是通过可实例化分类器的实例来实现的，这意味着可实例化分类器呈现出符合接口规范的公共外观。任何给定的分类器都可以实现多个接口。接口可以由许多不同的分类器来实现。接口可以使用矩形符号来显示，并且名称前面带有关键字`“interface”`。

{% asset_img class-diagram_4.png %}

##### 数据类型

**数据类型**是一个分类器(类似于类), 其实例“仅通过其值来标识”。数据类型的典型用途是表示业务领域的 值类型、编程语言的原始类型或结构化类型。例如，日期/时间、性别、货币、地址可以定义为数据类型。数据类型实例的所有副本以及具有相同值的该数据类型的任何实例都被视为相等实例。数据类型使用带有关键字`<<dataType>>`的矩形符号显示。数据类型可以包含 支持结构化数据类型 建模的属性 和操作。如果结构相同并且相应属性的值相等，则结构化数据类型的实例被认为是相等的。当数据类型被引用时，例如，作为类属性的类型，它简单地显示为数据类型的名称。

{% asset_img class-diagram_5.png %}

**原始数据类型**是表示原子数据值（即没有部分或结构的值）的数据类型。原始数据类型可以具有在 `UML` 外部定义的精确语义和操作，例如数学上的, 标准 `UML` 原始数据类型包括: `Boolean、Integer、UnlimitedNatural、String、Real`，原始数据类型的实例没有标识。如果两个实例具有相同的表示，那么它们是无法区分的。原始数据类型在原始数据类型名称上方或之前有关键字`<<primitive>>`。

**枚举**是一种数据类型，其值在模型中作为用户定义的枚举文字。可以使用带有关键字`«enumeration»` 的分类器符号（矩形）来显示枚举。枚举的名称位于上部隔间中。列出枚举属性的隔间放置在名称隔间下方。列出枚举操作的隔间放置在属性隔间下方。可以将枚举文字列表逐行放置在底部隔间中。属性和操作隔间可以被限制，并且通常如果它们是空的则被限制。

{% asset_img class-diagram_6.png %}

##### UML属性

属性是一种结构特征，属性表示分类器结构的某些命名部分。例如，`Patient` 类可以将 `id`、姓名、性别、出生日期等作为其属性。创建分类器的实例时，每个非静态属性都成为该实例状态的一部分，并通过将属性名称映射到构成实例状态的一个或多个特定值来实现。每个属性的值都有特定的类型，并分配在实例的槽中或与该实例关联。

属性的一般语法如下所示：

属性::= [可见性] ['/']   属性名称   [ ':'属性类型 ] [ '['多重性 ']' ] [ '='默认值] [属性修饰符]
可见性::= ' +' | '~'| '#'| '-'  
属性修饰符::= '{'属性修饰符   [ ','   属性修饰符] * '}'
属性修饰符::= 'id' | '只读' | '已订购' | ( 'seq' | '序列' ) | '独特'| '非独特' | '联盟' | “重新定义”   属性名称  | '子集'   属性名称  |  属性约束  

请注意，没有默认的可见性。此外，即使可见性在模型中具有某些值，也可能会抑制在图表上显示可见性。因此，如果图表上未显示可见性，则说明它未指定或被限制。正斜杠`“/”`表示该属性是 派生的。属性类型是由分类器名称表示，属性可以有多重性。多重界限，限制属性值集合的大小。默认情况下最大界限为 1。默认值 选项是属性的默认值或值的表达式。属性修饰符：

|修饰符|描述|
|:--:|:--|
|id|属性是拥有该属性的类的标识符的一部分。|
|readOnly|属性是只读的（isReadOnly = true）。|
|ordered|属性是有序的 (isOrdered = true)。|
|nonunique|多值属性没有重复值 (isUnique = true)。|
|nonunique|多值属性可能具有重复值 (isUnique = false)。|
|sequence (or seq)|属性是一个有序包（isUnique = false 且 isOrdered = true）。|
|union|属性是其子集的派生联合。|
|redefines property-name|Property 重新定义了名为property-name的继承属性。|
|subsets property-name|Property 是名为property-name的属性的子集。|
|property-constraint|适用于属性的约束|

分类器拥有的属性 表示分类器的属性。属性的上下文是所属分类器。允许使用关联表示法来显示属性:

{% asset_img class-diagram_7.png %}

关联的所有权结束于关联的 `Patient` 类，由小实心圆圈（也称为点）以图形方式表示。另请注意，连接到类的关联端没有修饰。当属性是关联端时，属性的一个或多个值与关联另一端的一个或多个实例相关。关联拥有的属性代表关联的属性，并命名为`member end`。在关联端上下文中是关联的另一端或两端的类型集。当关联端由分类器 拥有时，分类器 属性可以表示该关联端。关联分类器对关联端的所有权可以通过小实心圆（又名点） 以图形方式表示 。点绘制在直线与分类器相交的点处。它可以解释为表明该模型包含由点所触及的分类器表示的类型的属性。该属性由另一端的分类器拥有。

##### UML操作

操作是一种行为特征，可能由接口、 数据类型或类 拥有。操作也可以被 模板化 并用作模板参数。可以在其特征分类器的实例上直接调用操作。 该操作指定此类调用的 名称、类型、参数和约束。
`operation ::= [ visibility ]   signature   [ oper-properties ]`。 操作的可见性是可选的，如果存在，它应该是以下之一：`visibility ::= '+' | '-'| '#'| '~'` ，操作的签名具有可选的参数列表和返回规范。

`signature ::= operation-name  '('  [ parameter-list ]   ')'   [ ':' return-spec ]`

`operation-name`是操作的名称。参数列表是操作的参数列表，格式如下：

`parameter-list ::= parameter   [   ','   parameter   ]*`
`parameter ::= [ direction   ]   parm-name ':' type-expression   [   '[' multiplicity ']'   ]   [ '=' default ]   [ parm-properties ]`

`parm-name`是参数的名称。`type-expression`是指定参数类型的表达式。重数是参数的重数。`Default` 是一个表达式，定义参数默认值的值规范。

操作的属性是可选的，如果存在应遵循规则：

`oper-properties ::= '{' oper-property   [   ',' oper-property ]*   '}'`
`oper-property ::=   'redefines'   oper-name   |   'query'   |   'ordered'   |   'unique'   |   oper-constraint`

操作的属性一般定义为：
- `redefines oper-name` - 操作重新定义由操作名标识的继承操作；
- `query` - 操作不会改变系统的状态；
- `ordered` - 返回参数的值是有序的；
- `unique` - 参数返回的值没有重复项；
- `oper-constraint` - 是应用于操作的约束。

{% asset_img class-diagram_8.png %}

##### UML多重性和多重性元素

`UML`中的多重性允许指定某些元素集合的基数（即元素数量）。多重性元素 定义了一些元素的集合，并且包括多重性以及集合元素的顺序和唯一性的规范。多重性是某些元素集合的基数（即元素数量）的定义，通过提供非负整数的包含区间来指定所描述元素的允许实例数。重数区间有一些下限和上限。
```
multiplicity-range ::= [ lower-bound '..' ] upper-bound
lower-bound ::= natural-value-specification
upper-bound ::= natural-value-specification | '*'
```
下限和上限可以是自然常量或计算为自然（非负）数的常量表达式。上限也可以指定为星号“*”，表示元素数量不受限制。上限应大于或等于下限。

|多重性|选项|基数|
|:--:|:--|:--|
|0..0|0|集合必须为空|
|0..1||无实例或只有一个实例|
|1..1|1|	恰好有一个实例|
|0..*||零个或多个实例|
|1..*||至少一个实例|
|5..5|5|恰好 5 个实例|
|m..n||至少 m 但不超过 n 个实例|

如果多重性与符号为文本字符串（例如类属性） 的元素关联，则多重性范围将作为该文本字符串的一部分放在方括号内。
{% asset_img class-diagram_9.png %}

如果多重性与显示为符号（例如用例或类） 的元素关联 ，则显示多重性范围时不带方括号。

{% asset_img class-diagram_10.png %}

**多重性元素**定义了一些元素的集合，并且包括多重性 以及集合元素的顺序和唯一性的规范。多重性元素的一些子类是 结构特征、 操作、 参数、引脚。集合属性可以使用以下非规范语法规则来描述：
```
collection-type ::= multiplicity-range  [ '{' collection-options '}' ]
```
集合选项指定元素实例化中的值是否应该是唯一的和/或有序的：
```
collection-options ::= order-designator [ ','  uniqueness-designator ] |  uniqueness-designator [ ','  order-designator ]
order-designator ::= 'ordered' | 'unordered'
uniqueness-designator ::= 'unique' | 'nonunique'
```
{% asset_img class-diagram_11.png %}

如果多重性元素是多值的并且指定为有序的，则该元素的实例化中的值的集合是按顺序排序的。默认情况下，集合没有排序。如果多重性元素是多值的并且指定为`unique`，则该元素实例化中的值集合中的每个值都必须是唯一的。默认情况下，集合中的每个值都是唯一的。

{% asset_img class-diagram_12.png %}


#### 状态图（State Diagram）

`UML` 状态图是图表本身的名称，主要用于描述对象具有的各种状态、状态之间的转换过程以及触发状态转换的各种事件和条件。UML 状态图描述了一个状态机，可以被定义为一台机器，它定义了一个对象，这些状态控制外部或内部事件的不同状态，状态机由状态、转换、事件、活动和动作五部分组成。

- 状态：状态指的是对象在其生命周期中的一种状况，处于某个特定状态中的对象必然会满足某些条件、执行某些动作或者是等待某些事件。一个状态的生命周期是一个有限的时间阶段；
- 转换：转换指的是两个不同状态之间的一种关系，表明对象在第一个状态中执行一定的动作，并且在满足某个特定条件下由某个事件触发进入第二个状态；
- 事件：事件指的是发生在时间和空间上的对状态机来讲有意义的那些事情。事件通常会引起状态的变迁，促使状态机从一种状态切换到另一种状态，如信号、定时器，某个条件被处罚等；
- 活动：活动指的是状态机中进行的非原子操作；
- 动作：动作指的是状态机中可以执行的哪些原子操作。所谓原子操作，指的是他们在运行的过程中不能被其他消息中断，必须一直执行下去，以至最终导致状态的变更或者返回一个值；

一个状态图（Statechart Diagram）本质上就是一个状态机，或者是状态机的特殊情况，它基本上是一个状态机中元素的一个投影，这也就意味着状态图包括状态机的所有特征。

状态图描述了一个实体基于事件反映的动态行为，显示了该实体是如何根据当前所处的状态对不同的事件作出反应的。

在UML中，状态图由表示状态的节点和表示状态之间转换的带箭头的直线组成。状态的转换由事件触发，状态和状态之间由转换箭头连接。每一个状态图都有一个初始状态（实心圆），用来表示状态机的开始。还有一个中止状态（半实心圆），用来表示状态机的终止。状态图主要由元素状态、转换、初始状态、中止状态和判定等组成。

##### 状态

状态用于对实体在其生命周期中的各种状况进行建模，一个实体总是在有限的一段时间内保持一个状态。状态由一个带圆角的矩形表示，状态的描绘素应该包括名称、入口和出口动作、内部转换和嵌套状态。如下图，为一个简单状态：

{% asset_img uml-state-diagram-state.png %}

- 状态名指的是状态的名字，通常用字符串表示，其中每个单词的首字母大写。状态名可以包含任意数量的字母、数字和除了冒号“：”以外的一些字符，可以较长，甚至连续几行。但是一定要注意一个状态的名称在状态图所在的上下文中应该是唯一的，能够把该状态和其他状态区分开。
- 入口和出口动作一个状态可以具有或者没有入口和出口动作。入口和出口动作分别指的是进入和退出一个状态时所执行的“边界”动作。
- 内部转换指的是不导致状态改变的转换。内部转换中可以包含进入或者退出该状态应该执行的活动或动作。
- 嵌套状态状态分为简单状态（Simple State）和组成状态（Composite State）。简单状态是指在语义上不可分解的、对象保持一定属性值的状况，简单状态不包含其他状态：而组成状态是指内部嵌套有子状态的状态，在组成状态的嵌套状态图部分包含的就是此状态的子状态。

##### 转换

在UML的状态建模机制中，转换用带箭头的直线表示，一端连接源状态，箭头指向目标状态。转换还可以标注与此转换相关的选项，如事件、监护条件和动作等，如下图所示。注意：如果转换上没有标注触发转换的事件，则表示此转换自动进行。

{% asset_img uml-state-diagram-state-transmit.png %}

在状态转换机制中需要注意的五个概念如下：

- 状态源（Source State）：指的是激活转换之间对象处于的状态。如果一个一个状态处于源状态，当它接收到转换的触发事件或满足监护条件时，就激活了一个离开的转换。
- 目标状态（Event State）：指的是转换完成后对象所处的状态。
- 事件触发器（Event Trigger）：指的是引起源状态转换的事件。事件不是持续发生的，它只发生在时间的一点上，对象接收到事件，导致源状态发生变化，激活转换并使监护条件得到满足。
- 监护条件（Guard Condition）：是一个布尔表达式。当接收到触发事件要触发转换时，要对该表达式求值。如果表达式为真，则激活转换：如果表达式为假，则不激活转换，所接收到的触发事件丢失。
- 动作（Action）：是一个可执行的原子计算。

##### 初始状态

每个状态图都应该有一个初始状态，它代表状态图的起始位置。初始状态是一个伪状态（一个和普通状态有连接的假状态），对象不可能保持在初始状态，必须要有一个输出的无触发转换（没有事件触发器的转换）。通常初始状态上的转换是无监护条件的，并且初始状态只能作为转换的源，而不能作为转换的目标。在UML中，一个状态图只能有一个初始状态，用一个实心圆表示。

##### 终止状态

终止状态是一个状态图的终点，一个状态图可以拥有一个或者多个终止状态。对象可以保持在终止状态，但是终止状态不可能有任何形式的和触发转换，它的目的就是为了激发封装状态上的转换过程的结束。因此，终止状态只能作为转换的目标而不能作为转换的源，在UML中，终止状态用一个含有实心圆的空心圆表示。

##### 判定

活动图和状态图中都有需要根据给定条件进行判断，然后根据不同的判断结果进行不同转换的情况。实际就是工作流在此处按监护条件的取值发生分支，在UML中，判定用空心菱形表示。

{% asset_img UML-State.png 状态图 %}

#### 序列图（Sequence Diagram）

序列图也叫时序图，是交互图的一种，用于捕获系统运行中对象之间有时间顺序的交互，是由生命线和消息组成。时序图将交互关系表示为一个二维图。纵向是时间轴，时间沿竖线向下延伸。横向轴代表了在协作中各独立对象的类元角色。类元角色用生命线表示。当对象存在时，角色用一条虚线表示，当对象的过程处于激活状态时，生命线是一个双道线。消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。

- Actor（角色：代表某个由人或者设备扮演的角色，它不一定代表某个具体的实体，一般由一个小人代替；

- Lifetime（生命线）：在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。

- Activation（活动条/激活）：在生命线的徐线上可以用活动条表示某种行为的开始和结束，一般用小矩形来表示。

- 同步消息：意味着阻塞和等待。如：A向B 发送一个消息后，对象A 必须一直等到B执行完成后返回才能继续往下执行。这就是同步消息。用实心箭头表示

- 异步消息：就意味着是非阻塞。如：A向B发送消息后，直接可以执行下面代码，无需等待B的执行。

- 返回消息：在从A发送消息到达B之后，B的回复消息称之为返回消息。

{% asset_img uml-sequence-diagram-message.png %}

UML在2.0时在时序图中加入了交互框。交互框用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：

{% asset_img uml-2.0-interaction-1.png %}
{% asset_img uml-2.0-interaction-2.png %}

举几个示例：

{% asset_img UML-interaction-loop-alt-opt.png %}

### 参考资料

1. [UML Diagrams Full Course (Unified Modeling Language)](https://www.youtube.com/watch?v=WnMQ8HlmeXc)
2. [UML建模之状态图（Statechart Diagram）](https://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html)
3. [UML状态图](https://www.w3cschool.cn/uml_tutorial/uml_tutorial-jnf328y2.html)
4. [UML时序图/序列图](https://segmentfault.com/a/1190000040836364)